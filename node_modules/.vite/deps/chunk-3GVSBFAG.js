import {
  CheckOutlined_default,
  CloseCircleFilled_default,
  CloseOutlined_default,
  Context_default,
  DownOutlined_default,
  FastColor,
  LoadingOutlined_default,
  MinusOutlined_default,
  PlusOutlined_default,
  RightOutlined_default,
  SearchOutlined_default,
  UpOutlined_default,
  canUseDom,
  clsx,
  composeRef,
  generate,
  getNodeRef,
  getShadowRoot,
  isFragment,
  noteOnce,
  presetPalettes,
  presetPrimaryColors,
  removeCSS,
  supportRef,
  updateCSS,
  useComposeRef,
  useMemo,
  warning,
  warning_default
} from "./chunk-RLLPNQTR.js";
import {
  require_react_dom
} from "./chunk-OZA3KNTY.js";
import {
  __toESM,
  require_react
} from "./chunk-UV3U5RPD.js";

// node_modules/antd/es/color-picker/ColorPicker.js
var import_react91 = __toESM(require_react());

// node_modules/@rc-component/util/es/hooks/useEvent.js
var React = __toESM(require_react());
function useEvent(callback) {
  const fnRef = React.useRef(callback);
  fnRef.current = callback;
  const memoFn = React.useCallback((...args) => fnRef.current?.(...args), []);
  return memoFn;
}
var useEvent_default = useEvent;

// node_modules/@rc-component/util/es/hooks/useLayoutEffect.js
var React2 = __toESM(require_react());
var useInternalLayoutEffect = canUseDom() ? React2.useLayoutEffect : React2.useEffect;
var useLayoutEffect2 = (callback, deps) => {
  const firstMountRef = React2.useRef(true);
  useInternalLayoutEffect(() => {
    return callback(firstMountRef.current);
  }, deps);
  useInternalLayoutEffect(() => {
    firstMountRef.current = false;
    return () => {
      firstMountRef.current = true;
    };
  }, []);
};
var useLayoutUpdateEffect = (callback, deps) => {
  useLayoutEffect2((firstMount) => {
    if (!firstMount) {
      return callback();
    }
  }, deps);
};
var useLayoutEffect_default = useLayoutEffect2;

// node_modules/@rc-component/util/es/hooks/useState.js
var React3 = __toESM(require_react());
function useSafeState(defaultValue) {
  const destroyRef = React3.useRef(false);
  const [value, setValue] = React3.useState(defaultValue);
  React3.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}

// node_modules/@rc-component/util/es/hooks/useControlledState.js
var import_react = __toESM(require_react());
function useControlledState(defaultStateValue, value) {
  const [innerValue, setInnerValue] = (0, import_react.useState)(defaultStateValue);
  const mergedValue = value !== void 0 ? value : innerValue;
  useLayoutEffect_default((mount) => {
    if (!mount) {
      setInnerValue(value);
    }
  }, [value]);
  return [
    // Value
    mergedValue,
    // Update function
    setInnerValue
  ];
}

// node_modules/@rc-component/util/es/utils/get.js
function get(entity, path) {
  let current = entity;
  for (let i = 0; i < path.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path[i]];
  }
  return current;
}

// node_modules/@rc-component/util/es/utils/set.js
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  const [path, ...restPath] = paths;
  let clone;
  if (!entity && typeof path === "number") {
    clone = [];
  } else if (Array.isArray(entity)) {
    clone = [...entity];
  } else {
    clone = {
      ...entity
    };
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone[path][restPath[0]];
  } else {
    clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
  }
  return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
function mergeWith(sources, config = {}) {
  const {
    prepareArray
  } = config;
  const finalPrepareArray = prepareArray || (() => []);
  let clone = createEmpty(sources[0]);
  sources.forEach((src) => {
    function internalMerge(path, parentLoopSet) {
      const loopSet = new Set(parentLoopSet);
      const value = get(src, path);
      const isArr = Array.isArray(value);
      if (isArr || isObject(value)) {
        if (!loopSet.has(value)) {
          loopSet.add(value);
          const originValue = get(clone, path);
          if (isArr) {
            clone = set(clone, path, finalPrepareArray(originValue, value));
          } else if (!originValue || typeof originValue !== "object") {
            clone = set(clone, path, createEmpty(value));
          }
          keys(value).forEach((key) => {
            internalMerge([...path, key], loopSet);
          });
        }
      } else {
        clone = set(clone, path, value);
      }
    }
    internalMerge([]);
  });
  return clone;
}
function merge(...sources) {
  return mergeWith(sources);
}

// node_modules/@rc-component/util/es/omit.js
function omit(obj, fields) {
  const clone = Object.assign({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach((key) => {
      delete clone[key];
    });
  }
  return clone;
}

// node_modules/@rc-component/util/es/Children/toArray.js
var import_react2 = __toESM(require_react());
function toArray(children, option = {}) {
  let ret = [];
  import_react2.default.Children.forEach(children, (child) => {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if (isFragment(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}

// node_modules/antd/es/_util/ContextIsolator.js
var import_react33 = __toESM(require_react());

// node_modules/antd/es/form/context.js
var React15 = __toESM(require_react());

// node_modules/@rc-component/form/es/index.js
var React14 = __toESM(require_react());

// node_modules/@rc-component/util/es/isEqual.js
function isEqual(obj1, obj2, shallow = false) {
  const refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b, level = 1) {
    const circular = refSet.has(a);
    warning_default(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    const newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      const keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b).length) {
        return false;
      }
      return keys2.every((key) => deepEqual(a[key], b[key], newLevel));
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
var isEqual_default = isEqual;

// node_modules/@rc-component/form/es/Field.js
var React8 = __toESM(require_react());

// node_modules/@rc-component/form/es/FieldContext.js
var React5 = __toESM(require_react());
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = () => {
  warning_default(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context = React5.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: () => {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc,
      setBatchUpdate: warningFunc
    };
  }
});
var FieldContext_default = Context;

// node_modules/@rc-component/form/es/ListContext.js
var React6 = __toESM(require_react());
var ListContext = React6.createContext(null);
var ListContext_default = ListContext;

// node_modules/@rc-component/form/es/utils/typeUtil.js
function toArray2(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
  return form && !!form._init;
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// node_modules/@rc-component/async-validator/es/messages.js
function newMessages() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t) {
  var r = _isNativeReflectConstruct();
  return function() {
    var e, o = _getPrototypeOf(t);
    if (r) {
      var s = _getPrototypeOf(this).constructor;
      e = Reflect.construct(o, arguments, s);
    } else e = o.apply(this, arguments);
    return _possibleConstructorReturn(this, e);
  };
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}

// node_modules/@rc-component/async-validator/es/util.js
var formatRegExp = /%[sdj%]/g;
var warning2 = function warning3() {
};
if (typeof process !== "undefined" && process.env && true && typeof window !== "undefined" && typeof document !== "undefined") {
  warning2 = function warning5(type5, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type5, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type5) {
  return type5 === "string" || type5 === "url" || type5 === "hex" || type5 === "email" || type5 === "date" || type5 === "pattern";
}
function isEmptyValue(value, type5) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type5 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type5) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, _toConsumableArray(errors || []));
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index;
    index = index + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
  });
  return ret;
}
var AsyncValidationError = (function(_Error) {
  _inherits(AsyncValidationError2, _Error);
  var _super = _createSuper(AsyncValidationError2);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _classCallCheck(this, AsyncValidationError2);
    _this = _super.call(this, "Async Validation Error");
    _defineProperty(_assertThisInitialized(_this), "errors", void 0);
    _defineProperty(_assertThisInitialized(_this), "fields", void 0);
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return _createClass(AsyncValidationError2);
})(_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending.catch(function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending.catch(function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
  var v = value;
  for (var i = 0; i < path.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path[i]];
  }
  return v;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (_typeof(value) === "object" && _typeof(target[s]) === "object") {
          target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}

// node_modules/@rc-component/async-validator/es/rule/enum.js
var ENUM = "enum";
var enumerable = function enumerable2(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(", ")));
  }
};
var enum_default = enumerable;

// node_modules/@rc-component/async-validator/es/rule/pattern.js
var pattern = function pattern2(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var pattern_default = pattern;

// node_modules/@rc-component/async-validator/es/rule/range.js
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var range_default = range;

// node_modules/@rc-component/async-validator/es/rule/required.js
var required = function required2(rule, value, source, errors, options, type5) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type5 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var required_default = required;

// node_modules/@rc-component/async-validator/es/rule/url.js
var urlReg;
var url_default = (function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b = function b2(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6List = [
    "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ];
  var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
  var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
  var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
  var v4exact = new RegExp("^".concat(v4, "$"));
  var v6exact = new RegExp("^".concat(v6, "$"));
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path);
  urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
  return urlReg;
});

// node_modules/@rc-component/async-validator/es/rule/type.js
var pattern3 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  float: function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return _typeof(value) === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern3.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern3.hex);
  }
};
var type = function type2(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required_default(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && _typeof(value) !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var type_default = type;

// node_modules/@rc-component/async-validator/es/rule/whitespace.js
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var whitespace_default = whitespace;

// node_modules/@rc-component/async-validator/es/rule/index.js
var rule_default = {
  required: required_default,
  whitespace: whitespace_default,
  type: type_default,
  range: range_default,
  enum: enum_default,
  pattern: pattern_default
};

// node_modules/@rc-component/async-validator/es/validator/any.js
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var any_default = any;

// node_modules/@rc-component/async-validator/es/validator/array.js
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array_default = array2;

// node_modules/@rc-component/async-validator/es/validator/boolean.js
var boolean = function boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var boolean_default = boolean;

// node_modules/@rc-component/async-validator/es/validator/date.js
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rule_default.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rule_default.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var date_default = date2;

// node_modules/@rc-component/async-validator/es/validator/enum.js
var ENUM2 = "enum";
var enumerable3 = function enumerable4(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default[ENUM2](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var enum_default2 = enumerable3;

// node_modules/@rc-component/async-validator/es/validator/float.js
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var float_default = floatFn;

// node_modules/@rc-component/async-validator/es/validator/integer.js
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer_default = integer2;

// node_modules/@rc-component/async-validator/es/validator/method.js
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var method_default = method2;

// node_modules/@rc-component/async-validator/es/validator/number.js
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number_default = number2;

// node_modules/@rc-component/async-validator/es/validator/object.js
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object_default = object2;

// node_modules/@rc-component/async-validator/es/validator/pattern.js
var pattern4 = function pattern5(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rule_default.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern_default2 = pattern4;

// node_modules/@rc-component/async-validator/es/validator/regexp.js
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp_default = regexp2;

// node_modules/@rc-component/async-validator/es/validator/required.js
var required3 = function required4(rule, value, callback, source, options) {
  var errors = [];
  var type5 = Array.isArray(value) ? "array" : _typeof(value);
  rule_default.required(rule, value, source, errors, options, type5);
  callback(errors);
};
var required_default2 = required3;

// node_modules/@rc-component/async-validator/es/validator/string.js
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
      rule_default.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rule_default.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var string_default = string;

// node_modules/@rc-component/async-validator/es/validator/type.js
var type3 = function type4(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var type_default2 = type3;

// node_modules/@rc-component/async-validator/es/validator/index.js
var validator_default = {
  string: string_default,
  method: method_default,
  number: number_default,
  boolean: boolean_default,
  regexp: regexp_default,
  integer: integer_default,
  float: float_default,
  array: array_default,
  object: object_default,
  enum: enum_default2,
  pattern: pattern_default2,
  date: date_default,
  url: type_default2,
  hex: type_default2,
  email: type_default2,
  required: required_default2,
  any: any_default
};

// node_modules/@rc-component/async-validator/es/index.js
var Schema = (function() {
  function Schema2(descriptor) {
    _classCallCheck(this, Schema2);
    _defineProperty(this, "rules", null);
    _defineProperty(this, "_messages", messages);
    this.define(descriptor);
  }
  _createClass(Schema2, [{
    key: "define",
    value: function define(rules) {
      var _this = this;
      if (!rules) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (_typeof(rules) !== "object" || Array.isArray(rules)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules).forEach(function(name) {
        var item = rules[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    }
  }, {
    key: "messages",
    value: function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    }
  }, {
    key: "validate",
    value: function validate(source_) {
      var _this2 = this;
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      };
      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e) {
          if (Array.isArray(e)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e));
          } else {
            errors.push(e);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages2 = this.messages();
        if (messages2 === messages) {
          messages2 = newMessages();
        }
        deepMerge(messages2, options.messages);
        options.messages = messages2;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r) {
          var rule = r;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _objectSpread2({}, source);
            }
            value = source[z] = rule.transform(value);
            if (value !== void 0 && value !== null) {
              rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof(value));
            }
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _objectSpread2({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _objectSpread2(_objectSpread2({}, schema), {}, {
            fullField: "".concat(rule.fullField, ".").concat(key),
            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
          });
        }
        function cb() {
          var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var errorList = Array.isArray(e) ? e : [e];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            var _console$error, _console;
            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e) {
            return cb(e);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    }
  }, {
    key: "getType",
    value: function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validator_default.required;
      }
      return validator_default[this.getType(rule)] || void 0;
    }
  }]);
  return Schema2;
})();
_defineProperty(Schema, "register", function register(type5, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validator_default[type5] = validator;
});
_defineProperty(Schema, "warning", warning2);
_defineProperty(Schema, "messages", messages);
_defineProperty(Schema, "validators", validator_default);
var es_default = Schema;

// node_modules/@rc-component/form/es/utils/validateUtil.js
var React7 = __toESM(require_react());

// node_modules/@rc-component/form/es/utils/messages.js
var typeTemplate = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate,
    method: typeTemplate,
    array: typeTemplate,
    object: typeTemplate,
    number: typeTemplate,
    date: typeTemplate,
    boolean: typeTemplate,
    integer: typeTemplate,
    float: typeTemplate,
    regexp: typeTemplate,
    email: typeTemplate,
    url: typeTemplate,
    hex: typeTemplate
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};

// node_modules/@rc-component/form/es/utils/validateUtil.js
var AsyncValidator = es_default;
function replaceMessage(template, kv) {
  return template.replace(/\\?\$\{\w+\}/g, (str) => {
    if (str.startsWith("\\")) {
      return str.slice(1);
    }
    const key = str.slice(2, -1);
    return kv[key];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
async function validateRule(name, value, rule, options, messageVariables) {
  const cloneRule = {
    ...rule
  };
  delete cloneRule.ruleIndex;
  AsyncValidator.warning = () => void 0;
  if (cloneRule.validator) {
    const originValidator = cloneRule.validator;
    cloneRule.validator = (...args) => {
      try {
        return originValidator(...args);
      } catch (error) {
        console.error(error);
        return Promise.reject(CODE_LOGIC_ERROR);
      }
    };
  }
  let subRuleField = null;
  if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
    subRuleField = cloneRule.defaultField;
    delete cloneRule.defaultField;
  }
  const validator = new AsyncValidator({
    [name]: [cloneRule]
  });
  const messages2 = merge(defaultValidateMessages, options.validateMessages);
  validator.messages(messages2);
  let result = [];
  try {
    await Promise.resolve(validator.validate({
      [name]: value
    }, {
      ...options
    }));
  } catch (errObj) {
    if (errObj.errors) {
      result = errObj.errors.map(({
        message
      }, index) => {
        const mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
        return React7.isValidElement(mergedMessage) ? (
          // Wrap ReactNode with `key`
          React7.cloneElement(mergedMessage, {
            key: `error_${index}`
          })
        ) : mergedMessage;
      });
    }
  }
  if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {
    const subResults = await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)));
    return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
  }
  const kv = {
    ...rule,
    name,
    enum: (rule.enum || []).join(", "),
    ...messageVariables
  };
  const fillVariableResult = result.map((error) => {
    if (typeof error === "string") {
      return replaceMessage(error, kv);
    }
    return error;
  });
  return fillVariableResult;
}
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
  const name = namePath.join(".");
  const filledRules = rules.map((currentRule, ruleIndex) => {
    const originValidatorFunc = currentRule.validator;
    const cloneRule = {
      ...currentRule,
      ruleIndex
    };
    if (originValidatorFunc) {
      cloneRule.validator = (rule, val, callback) => {
        let hasPromise = false;
        const wrappedCallback = (...args) => {
          Promise.resolve().then(() => {
            warning_default(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback(...args);
            }
          });
        };
        const promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warning_default(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(() => {
            callback();
          }).catch((err) => {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(({
    warningOnly: w1,
    ruleIndex: i1
  }, {
    warningOnly: w2,
    ruleIndex: i2
  }) => {
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  let summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(async (resolve, reject) => {
      for (let i = 0; i < filledRules.length; i += 1) {
        const rule = filledRules[i];
        const errors = await validateRule(name, value, rule, options, messageVariables);
        if (errors.length) {
          reject([{
            errors,
            rule
          }]);
          return;
        }
      }
      resolve([]);
    });
  } else {
    const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
      errors,
      rule
    })));
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch((e) => e);
  return summaryPromise;
}
async function finishOnAllFailed(rulePromises) {
  return Promise.all(rulePromises).then((errorsList) => {
    const errors = [].concat(...errorsList);
    return errors;
  });
}
async function finishOnFirstFailed(rulePromises) {
  let count = 0;
  return new Promise((resolve) => {
    rulePromises.forEach((promise) => {
      promise.then((ruleError) => {
        if (ruleError.errors.length) {
          resolve([ruleError]);
        }
        count += 1;
        if (count === rulePromises.length) {
          resolve([]);
        }
      });
    });
  });
}

// node_modules/@rc-component/form/es/utils/valueUtil.js
function getNamePath(path) {
  return toArray2(path);
}
function cloneByNamePathList(store, namePathList) {
  let newStore = {};
  namePathList.forEach((namePath) => {
    const value = get(store, namePath);
    newStore = set(newStore, namePath, value);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath, partialMatch = false) {
  return namePathList && namePathList.some((path) => matchNamePath(namePath, path, partialMatch));
}
function matchNamePath(namePath, subNamePath, partialMatch = false) {
  if (!namePath || !subNamePath) {
    return false;
  }
  if (!partialMatch && namePath.length !== subNamePath.length) {
    return false;
  }
  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || typeof source !== "object" || typeof target !== "object") {
    return false;
  }
  const sourceKeys = Object.keys(source);
  const targetKeys = Object.keys(target);
  const keys2 = /* @__PURE__ */ new Set([...sourceKeys, ...targetKeys]);
  return [...keys2].every((key) => {
    const sourceValue = source[key];
    const targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName, ...args) {
  const event = args[0];
  if (event && event.target && typeof event.target === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  const {
    length: length2
  } = array4;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  const item = array4[moveIndex];
  const diff = moveIndex - toIndex;
  if (diff > 0) {
    return [...array4.slice(0, toIndex), item, ...array4.slice(toIndex, moveIndex), ...array4.slice(moveIndex + 1, length2)];
  }
  if (diff < 0) {
    return [...array4.slice(0, moveIndex), ...array4.slice(moveIndex + 1, toIndex + 1), item, ...array4.slice(toIndex + 1, length2)];
  }
  return array4;
}

// node_modules/@rc-component/form/es/Field.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var EMPTY_ERRORS = [];
var EMPTY_WARNINGS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev2, next2, "source" in info ? {
      source: info.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = class extends React8.Component {
  static contextType = FieldContext_default;
  state = {
    resetCount: 0
  };
  cancelRegisterFunc = null;
  mounted = false;
  /**
   * Follow state should not management in State since it will async update by React.
   * This makes first render of form can not get correct state value.
   */
  touched = false;
  /**
   * Mark when touched & validated. Currently only used for `dependencies`.
   * Note that we do not think field with `initialValue` is dirty
   * but this will be by `isFieldDirty` func.
   */
  dirty = false;
  validatePromise;
  prevValidating;
  errors = EMPTY_ERRORS;
  warnings = EMPTY_WARNINGS;
  // ============================== Subscriptions ==============================
  constructor(props) {
    super(props);
    if (props.fieldContext) {
      const {
        getInternalHooks
      } = props.fieldContext;
      const {
        initEntityValue
      } = getInternalHooks(HOOK_MARK);
      initEntityValue(this);
    }
  }
  componentDidMount() {
    const {
      shouldUpdate,
      fieldContext
    } = this.props;
    this.mounted = true;
    if (fieldContext) {
      const {
        getInternalHooks
      } = fieldContext;
      const {
        registerField
      } = getInternalHooks(HOOK_MARK);
      this.cancelRegisterFunc = registerField(this);
    }
    if (shouldUpdate === true) {
      this.reRender();
    }
  }
  componentWillUnmount() {
    this.cancelRegister();
    this.triggerMetaEvent(true);
    this.mounted = false;
  }
  cancelRegister = () => {
    const {
      preserve: preserve2,
      isListField,
      name
    } = this.props;
    if (this.cancelRegisterFunc) {
      this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
    }
    this.cancelRegisterFunc = null;
  };
  // ================================== Utils ==================================
  getNamePath = () => {
    const {
      name,
      fieldContext
    } = this.props;
    const {
      prefixName = []
    } = fieldContext;
    return name !== void 0 ? [...prefixName, ...name] : [];
  };
  getRules = () => {
    const {
      rules = [],
      fieldContext
    } = this.props;
    return rules.map((rule) => {
      if (typeof rule === "function") {
        return rule(fieldContext);
      }
      return rule;
    });
  };
  reRender() {
    if (!this.mounted) return;
    this.forceUpdate();
  }
  refresh = () => {
    if (!this.mounted) return;
    this.setState(({
      resetCount
    }) => ({
      resetCount: resetCount + 1
    }));
  };
  // Event should only trigger when meta changed
  metaCache = null;
  triggerMetaEvent = (destroy) => {
    const {
      onMetaChange
    } = this.props;
    if (onMetaChange) {
      const meta = {
        ...this.getMeta(),
        destroy
      };
      if (!isEqual_default(this.metaCache, meta)) {
        onMetaChange(meta);
      }
      this.metaCache = meta;
    } else {
      this.metaCache = null;
    }
  };
  // ========================= Field Entity Interfaces =========================
  // Trigger by store update. Check if need update the component
  onStoreChange = (prevStore, namePathList, info) => {
    const {
      shouldUpdate,
      dependencies = [],
      onReset
    } = this.props;
    const {
      store
    } = info;
    const namePath = this.getNamePath();
    const prevValue = this.getValue(prevStore);
    const curValue = this.getValue(store);
    const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
    if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
      this.touched = true;
      this.dirty = true;
      this.validatePromise = null;
      this.errors = EMPTY_ERRORS;
      this.warnings = EMPTY_WARNINGS;
      this.triggerMetaEvent();
    }
    switch (info.type) {
      case "reset":
        if (!namePathList || namePathMatch) {
          this.touched = false;
          this.dirty = false;
          this.validatePromise = void 0;
          this.errors = EMPTY_ERRORS;
          this.warnings = EMPTY_WARNINGS;
          this.triggerMetaEvent();
          onReset?.();
          this.refresh();
          return;
        }
        break;
      /**
       * In case field with `preserve = false` nest deps like:
       * - A = 1 => show B
       * - B = 1 => show C
       * - Reset A, need clean B, C
       */
      case "remove": {
        if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
          this.reRender();
          return;
        }
        break;
      }
      case "setField": {
        const {
          data
        } = info;
        if (namePathMatch) {
          if ("touched" in data) {
            this.touched = data.touched;
          }
          if ("validating" in data && !("originRCField" in data)) {
            this.validatePromise = data.validating ? Promise.resolve([]) : null;
          }
          if ("errors" in data) {
            this.errors = data.errors || EMPTY_ERRORS;
          }
          if ("warnings" in data) {
            this.warnings = data.warnings || EMPTY_WARNINGS;
          }
          this.dirty = true;
          this.triggerMetaEvent();
          this.reRender();
          return;
        } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
          this.reRender();
          return;
        }
        if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
          this.reRender();
          return;
        }
        break;
      }
      case "dependenciesUpdate": {
        const dependencyList = dependencies.map(getNamePath);
        if (dependencyList.some((dependency) => containsNamePath(info.relatedFields, dependency))) {
          this.reRender();
          return;
        }
        break;
      }
      default:
        if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
          this.reRender();
          return;
        }
        break;
    }
    if (shouldUpdate === true) {
      this.reRender();
    }
  };
  validateRules = (options) => {
    const namePath = this.getNamePath();
    const currentValue = this.getValue();
    const {
      triggerName,
      validateOnly = false
    } = options || {};
    const rootPromise = Promise.resolve().then(async () => {
      if (!this.mounted) {
        return [];
      }
      const {
        validateFirst = false,
        messageVariables,
        validateDebounce
      } = this.props;
      let filteredRules = this.getRules();
      if (triggerName) {
        filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
          const {
            validateTrigger
          } = rule;
          if (!validateTrigger) {
            return true;
          }
          const triggerList = toArray2(validateTrigger);
          return triggerList.includes(triggerName);
        });
      }
      if (validateDebounce && triggerName) {
        await new Promise((resolve) => {
          setTimeout(resolve, validateDebounce);
        });
        if (this.validatePromise !== rootPromise) {
          return [];
        }
      }
      const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
      promise.catch((e) => e).then((ruleErrors = EMPTY_ERRORS) => {
        if (this.validatePromise === rootPromise) {
          this.validatePromise = null;
          const nextErrors = [];
          const nextWarnings = [];
          ruleErrors.forEach?.(({
            rule: {
              warningOnly
            },
            errors = EMPTY_ERRORS
          }) => {
            if (warningOnly) {
              nextWarnings.push(...errors);
            } else {
              nextErrors.push(...errors);
            }
          });
          this.errors = nextErrors;
          this.warnings = nextWarnings;
          this.triggerMetaEvent();
          this.reRender();
        }
      });
      return promise;
    });
    if (validateOnly) {
      return rootPromise;
    }
    this.validatePromise = rootPromise;
    this.dirty = true;
    this.errors = EMPTY_ERRORS;
    this.warnings = EMPTY_WARNINGS;
    this.triggerMetaEvent();
    this.reRender();
    return rootPromise;
  };
  isFieldValidating = () => !!this.validatePromise;
  isFieldTouched = () => this.touched;
  isFieldDirty = () => {
    if (this.dirty || this.props.initialValue !== void 0) {
      return true;
    }
    const {
      fieldContext
    } = this.props;
    const {
      getInitialValue
    } = fieldContext.getInternalHooks(HOOK_MARK);
    if (getInitialValue(this.getNamePath()) !== void 0) {
      return true;
    }
    return false;
  };
  getErrors = () => this.errors;
  getWarnings = () => this.warnings;
  isListField = () => this.props.isListField;
  isList = () => this.props.isList;
  isPreserve = () => this.props.preserve;
  // ============================= Child Component =============================
  getMeta = () => {
    this.prevValidating = this.isFieldValidating();
    const meta = {
      touched: this.isFieldTouched(),
      validating: this.prevValidating,
      errors: this.errors,
      warnings: this.warnings,
      name: this.getNamePath(),
      validated: this.validatePromise === null
    };
    return meta;
  };
  // Only return validate child node. If invalidate, will do nothing about field.
  getOnlyChild = (children) => {
    if (typeof children === "function") {
      const meta = this.getMeta();
      return {
        ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
        isFunction: true
      };
    }
    const childList = toArray(children);
    if (childList.length !== 1 || !React8.isValidElement(childList[0])) {
      return {
        child: childList,
        isFunction: false
      };
    }
    return {
      child: childList[0],
      isFunction: false
    };
  };
  // ============================== Field Control ==============================
  getValue = (store) => {
    const {
      getFieldsValue
    } = this.props.fieldContext;
    const namePath = this.getNamePath();
    return get(store || getFieldsValue(true), namePath);
  };
  getControlled = (childProps = {}) => {
    const {
      name,
      trigger = "onChange",
      validateTrigger,
      getValueFromEvent,
      normalize: normalize2,
      valuePropName = "value",
      getValueProps,
      fieldContext
    } = this.props;
    const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
    const namePath = this.getNamePath();
    const {
      getInternalHooks,
      getFieldsValue
    } = fieldContext;
    const {
      dispatch
    } = getInternalHooks(HOOK_MARK);
    const value = this.getValue();
    const mergedGetValueProps = getValueProps || ((val) => ({
      [valuePropName]: val
    }));
    const originTriggerFunc = childProps[trigger];
    const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
    if (valueProps) {
      Object.keys(valueProps).forEach((key) => {
        warning_default(typeof valueProps[key] !== "function", `It's not recommended to generate dynamic function prop by \`getValueProps\`. Please pass it to child component directly (prop: ${key})`);
      });
    }
    const control = {
      ...childProps,
      ...valueProps
    };
    control[trigger] = (...args) => {
      this.touched = true;
      this.dirty = true;
      this.triggerMetaEvent();
      let newValue;
      if (getValueFromEvent) {
        newValue = getValueFromEvent(...args);
      } else {
        newValue = defaultGetValueFromEvent(valuePropName, ...args);
      }
      if (normalize2) {
        newValue = normalize2(newValue, value, getFieldsValue(true));
      }
      if (newValue !== value) {
        dispatch({
          type: "updateValue",
          namePath,
          value: newValue
        });
      }
      if (originTriggerFunc) {
        originTriggerFunc(...args);
      }
    };
    const validateTriggerList = toArray2(mergedValidateTrigger || []);
    validateTriggerList.forEach((triggerName) => {
      const originTrigger = control[triggerName];
      control[triggerName] = (...args) => {
        if (originTrigger) {
          originTrigger(...args);
        }
        const {
          rules
        } = this.props;
        if (rules && rules.length) {
          dispatch({
            type: "validateField",
            namePath,
            triggerName
          });
        }
      };
    });
    return control;
  };
  render() {
    const {
      resetCount
    } = this.state;
    const {
      children
    } = this.props;
    const {
      child,
      isFunction
    } = this.getOnlyChild(children);
    let returnChildNode;
    if (isFunction) {
      returnChildNode = child;
    } else if (React8.isValidElement(child)) {
      returnChildNode = React8.cloneElement(child, this.getControlled(child.props));
    } else {
      warning_default(!child, "`children` of Field is not validate ReactElement.");
      returnChildNode = child;
    }
    return React8.createElement(React8.Fragment, {
      key: resetCount
    }, returnChildNode);
  }
};
function WrapperField({
  name,
  ...restProps
}) {
  const fieldContext = React8.useContext(FieldContext_default);
  const listContext = React8.useContext(ListContext_default);
  const namePath = name !== void 0 ? getNamePath(name) : void 0;
  const isMergedListField = restProps.isListField ?? !!listContext;
  let key = "keep";
  if (!isMergedListField) {
    key = `_${(namePath || []).join("_")}`;
  }
  if (restProps.preserve === false && isMergedListField && namePath.length <= 1) {
    warning_default(false, "`preserve` should not apply on Form.List fields.");
  }
  return React8.createElement(Field, _extends({
    key,
    name: namePath,
    isListField: isMergedListField
  }, restProps, {
    fieldContext
  }));
}
var Field_default = WrapperField;

// node_modules/@rc-component/form/es/List.js
var React9 = __toESM(require_react());
function List({
  name,
  initialValue,
  children,
  rules,
  validateTrigger,
  isListField
}) {
  const context = React9.useContext(FieldContext_default);
  const wrapperListContext = React9.useContext(ListContext_default);
  const keyRef = React9.useRef({
    keys: [],
    id: 0
  });
  const keyManager = keyRef.current;
  const prefixName = React9.useMemo(() => {
    const parentPrefixName = getNamePath(context.prefixName) || [];
    return [...parentPrefixName, ...getNamePath(name)];
  }, [context.prefixName, name]);
  const fieldContext = React9.useMemo(() => ({
    ...context,
    prefixName
  }), [context, prefixName]);
  const listContext = React9.useMemo(() => ({
    getKey: (namePath) => {
      const len = prefixName.length;
      const pathName = namePath[len];
      return [keyManager.keys[pathName], namePath.slice(len + 1)];
    }
  }), [keyManager, prefixName]);
  if (typeof children !== "function") {
    warning_default(false, "Form.List only accepts function as children.");
    return null;
  }
  const shouldUpdate = (prevValue, nextValue, {
    source
  }) => {
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return React9.createElement(ListContext_default.Provider, {
    value: listContext
  }, React9.createElement(FieldContext_default.Provider, {
    value: fieldContext
  }, React9.createElement(Field_default, {
    name: [],
    shouldUpdate,
    rules,
    validateTrigger,
    initialValue,
    isList: true,
    isListField: isListField ?? !!wrapperListContext
  }, ({
    value = [],
    onChange
  }, meta) => {
    const {
      getFieldValue
    } = context;
    const getNewValue = () => {
      const values = getFieldValue(prefixName || []);
      return values || [];
    };
    const operations = {
      add: (defaultValue, index) => {
        const newValue = getNewValue();
        if (index >= 0 && index <= newValue.length) {
          keyManager.keys = [...keyManager.keys.slice(0, index), keyManager.id, ...keyManager.keys.slice(index)];
          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);
        } else {
          if (index < 0 || index > newValue.length) {
            warning_default(false, "The second parameter of the add function should be a valid positive number.");
          }
          keyManager.keys = [...keyManager.keys, keyManager.id];
          onChange([...newValue, defaultValue]);
        }
        keyManager.id += 1;
      },
      remove: (index) => {
        const newValue = getNewValue();
        const indexSet = new Set(Array.isArray(index) ? index : [index]);
        if (indexSet.size <= 0) {
          return;
        }
        keyManager.keys = keyManager.keys.filter((_, keysIndex) => !indexSet.has(keysIndex));
        onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));
      },
      move(from2, to) {
        if (from2 === to) {
          return;
        }
        const newValue = getNewValue();
        if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
          return;
        }
        keyManager.keys = move(keyManager.keys, from2, to);
        onChange(move(newValue, from2, to));
      }
    };
    let listValue = value || [];
    if (!Array.isArray(listValue)) {
      listValue = [];
      if (true) {
        warning_default(false, `Current value of '${prefixName.join(" > ")}' is not an array type.`);
      }
    }
    return children(listValue.map((__, index) => {
      let key = keyManager.keys[index];
      if (key === void 0) {
        keyManager.keys[index] = keyManager.id;
        key = keyManager.keys[index];
        keyManager.id += 1;
      }
      return {
        name: index,
        key,
        isListField: true
      };
    }), operations, meta);
  })));
}
var List_default = List;

// node_modules/@rc-component/form/es/useForm.js
var React10 = __toESM(require_react());

// node_modules/@rc-component/form/es/utils/asyncUtil.js
function allPromiseFinish(promiseList) {
  let hasError = false;
  let count = promiseList.length;
  const results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise((resolve, reject) => {
    promiseList.forEach((promise, index) => {
      promise.catch((e) => {
        hasError = true;
        return e;
      }).then((result) => {
        count -= 1;
        results[index] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}

// node_modules/@rc-component/form/es/utils/NameMap.js
var SPLIT = "__@field_split__";
function normalize(namePath) {
  return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT);
}
var NameMap = class {
  kvs = /* @__PURE__ */ new Map();
  set(key, value) {
    this.kvs.set(normalize(key), value);
  }
  get(key) {
    return this.kvs.get(normalize(key));
  }
  update(key, updater) {
    const origin = this.get(key);
    const next2 = updater(origin);
    if (!next2) {
      this.delete(key);
    } else {
      this.set(key, next2);
    }
  }
  delete(key) {
    this.kvs.delete(normalize(key));
  }
  // Since we only use this in test, let simply realize this
  map(callback) {
    return [...this.kvs.entries()].map(([key, value]) => {
      const cells = key.split(SPLIT);
      return callback({
        key: cells.map((cell) => {
          const [, type5, unit3] = cell.match(/^([^:]*):(.*)$/);
          return type5 === "number" ? Number(unit3) : unit3;
        }),
        value
      });
    });
  }
  toJSON() {
    const json = {};
    this.map(({
      key,
      value
    }) => {
      json[key.join(".")] = value;
      return null;
    });
    return json;
  }
};
var NameMap_default = NameMap;

// node_modules/@rc-component/form/es/useForm.js
var FormStore = class {
  formHooked = false;
  forceRootUpdate;
  subscribable = true;
  store = {};
  fieldEntities = [];
  initialValues = {};
  callbacks = {};
  validateMessages = null;
  preserve = null;
  lastValidatePromise = null;
  constructor(forceRootUpdate) {
    this.forceRootUpdate = forceRootUpdate;
  }
  getForm = () => ({
    getFieldValue: this.getFieldValue,
    getFieldsValue: this.getFieldsValue,
    getFieldError: this.getFieldError,
    getFieldWarning: this.getFieldWarning,
    getFieldsError: this.getFieldsError,
    isFieldsTouched: this.isFieldsTouched,
    isFieldTouched: this.isFieldTouched,
    isFieldValidating: this.isFieldValidating,
    isFieldsValidating: this.isFieldsValidating,
    resetFields: this.resetFields,
    setFields: this.setFields,
    setFieldValue: this.setFieldValue,
    setFieldsValue: this.setFieldsValue,
    validateFields: this.validateFields,
    submit: this.submit,
    _init: true,
    getInternalHooks: this.getInternalHooks
  });
  // ======================== Internal Hooks ========================
  getInternalHooks = (key) => {
    if (key === HOOK_MARK) {
      this.formHooked = true;
      return {
        dispatch: this.dispatch,
        initEntityValue: this.initEntityValue,
        registerField: this.registerField,
        useSubscribe: this.useSubscribe,
        setInitialValues: this.setInitialValues,
        destroyForm: this.destroyForm,
        setCallbacks: this.setCallbacks,
        setValidateMessages: this.setValidateMessages,
        getFields: this.getFields,
        setPreserve: this.setPreserve,
        getInitialValue: this.getInitialValue,
        registerWatch: this.registerWatch,
        setBatchUpdate: this.setBatchUpdate
      };
    }
    warning_default(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  useSubscribe = (subscribable) => {
    this.subscribable = subscribable;
  };
  /**
   * Record prev Form unmount fieldEntities which config preserve false.
   * This need to be refill with initialValues instead of store value.
   */
  prevWithoutPreserves = null;
  /**
   * First time `setInitialValues` should update store with initial value
   */
  setInitialValues = (initialValues, init) => {
    this.initialValues = initialValues || {};
    if (init) {
      let nextStore = merge(initialValues, this.store);
      this.prevWithoutPreserves?.map(({
        key: namePath
      }) => {
        nextStore = set(nextStore, namePath, get(initialValues, namePath));
      });
      this.prevWithoutPreserves = null;
      this.updateStore(nextStore);
    }
  };
  destroyForm = (clearOnDestroy) => {
    if (clearOnDestroy) {
      this.updateStore({});
    } else {
      const prevWithoutPreserves = new NameMap_default();
      this.getFieldEntities(true).forEach((entity) => {
        if (!this.isMergedPreserve(entity.isPreserve())) {
          prevWithoutPreserves.set(entity.getNamePath(), true);
        }
      });
      this.prevWithoutPreserves = prevWithoutPreserves;
    }
  };
  getInitialValue = (namePath) => {
    const initValue = get(this.initialValues, namePath);
    return namePath.length ? merge(initValue) : initValue;
  };
  setCallbacks = (callbacks) => {
    this.callbacks = callbacks;
  };
  setValidateMessages = (validateMessages) => {
    this.validateMessages = validateMessages;
  };
  setPreserve = (preserve2) => {
    this.preserve = preserve2;
  };
  // ============================= Watch ============================
  watchList = [];
  registerWatch = (callback) => {
    this.watchList.push(callback);
    return () => {
      this.watchList = this.watchList.filter((fn) => fn !== callback);
    };
  };
  notifyWatch = (namePath = []) => {
    if (this.watchList.length) {
      const values = this.getFieldsValue();
      const allValues = this.getFieldsValue(true);
      this.watchList.forEach((callback) => {
        callback(values, allValues, namePath);
      });
    }
  };
  notifyWatchNamePathList = [];
  batchNotifyWatch = (namePath) => {
    this.notifyWatchNamePathList.push(namePath);
    this.batch("notifyWatch", () => {
      this.notifyWatch(this.notifyWatchNamePathList);
      this.notifyWatchNamePathList = [];
    });
  };
  // ============================= Batch ============================
  batchUpdate;
  setBatchUpdate = (batchUpdate) => {
    this.batchUpdate = batchUpdate;
  };
  // Batch call the task, only last will be called
  batch = (key, callback) => {
    this.batchUpdate(key, callback);
  };
  // ========================== Dev Warning =========================
  timeoutId = null;
  warningUnhooked = () => {
    if (!this.timeoutId && typeof window !== "undefined") {
      this.timeoutId = setTimeout(() => {
        this.timeoutId = null;
        if (!this.formHooked) {
          warning_default(false, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
        }
      });
    }
  };
  // ============================ Store =============================
  updateStore = (nextStore) => {
    this.store = nextStore;
  };
  // ============================ Fields ============================
  /**
   * Get registered field entities.
   * @param pure Only return field which has a `name`. Default: false
   */
  getFieldEntities = (pure = false) => {
    if (!pure) {
      return this.fieldEntities;
    }
    return this.fieldEntities.filter((field) => field.getNamePath().length);
  };
  getFieldsMap = (pure = false) => {
    const cache = new NameMap_default();
    this.getFieldEntities(pure).forEach((field) => {
      const namePath = field.getNamePath();
      cache.set(namePath, field);
    });
    return cache;
  };
  getFieldEntitiesForNamePathList = (nameList) => {
    if (!nameList) {
      return this.getFieldEntities(true);
    }
    const cache = this.getFieldsMap(true);
    return nameList.map((name) => {
      const namePath = getNamePath(name);
      return cache.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath(name)
      };
    });
  };
  getFieldsValue = (nameList, filterFunc) => {
    this.warningUnhooked();
    let mergedNameList;
    let mergedFilterFunc;
    if (nameList === true || Array.isArray(nameList)) {
      mergedNameList = nameList;
      mergedFilterFunc = filterFunc;
    } else if (nameList && typeof nameList === "object") {
      mergedFilterFunc = nameList.filter;
    }
    if (mergedNameList === true && !mergedFilterFunc) {
      return this.store;
    }
    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
    const filteredNameList = [];
    const listNamePaths = [];
    fieldEntities.forEach((entity) => {
      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();
      if (entity.isList?.()) {
        listNamePaths.push(namePath);
        return;
      }
      if (!mergedFilterFunc) {
        filteredNameList.push(namePath);
      } else {
        const meta = "getMeta" in entity ? entity.getMeta() : null;
        if (mergedFilterFunc(meta)) {
          filteredNameList.push(namePath);
        }
      }
    });
    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));
    listNamePaths.forEach((namePath) => {
      if (!get(mergedValues, namePath)) {
        mergedValues = set(mergedValues, namePath, []);
      }
    });
    return mergedValues;
  };
  getFieldValue = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    return get(this.store, namePath);
  };
  getFieldsError = (nameList) => {
    this.warningUnhooked();
    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map((entity, index) => {
      if (entity && !entity.INVALIDATE_NAME_PATH) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath(nameList[index]),
        errors: [],
        warnings: []
      };
    });
  };
  getFieldError = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    const fieldError = this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  getFieldWarning = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    const fieldError = this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  isFieldsTouched = (...args) => {
    this.warningUnhooked();
    const [arg0, arg1] = args;
    let namePathList;
    let isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath);
      isAllFieldsTouched = arg1;
    }
    const fieldEntities = this.getFieldEntities(true);
    const isFieldTouched = (field) => field.isFieldTouched();
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
    }
    const map = new NameMap_default();
    namePathList.forEach((shortNamePath) => {
      map.set(shortNamePath, []);
    });
    fieldEntities.forEach((field) => {
      const fieldNamePath = field.getNamePath();
      namePathList.forEach((shortNamePath) => {
        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {
          map.update(shortNamePath, (list) => [...list, field]);
        }
      });
    });
    const isNamePathListTouched = (entities) => entities.some(isFieldTouched);
    const namePathListEntities = map.map(({
      value
    }) => value);
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  isFieldTouched = (name) => {
    this.warningUnhooked();
    return this.isFieldsTouched([name]);
  };
  isFieldsValidating = (nameList) => {
    this.warningUnhooked();
    const fieldEntities = this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some((testField) => testField.isFieldValidating());
    }
    const namePathList = nameList.map(getNamePath);
    return fieldEntities.some((testField) => {
      const fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  isFieldValidating = (name) => {
    this.warningUnhooked();
    return this.isFieldsValidating([name]);
  };
  /**
   * Reset Field with field `initialValue` prop.
   * Can pass `entities` or `namePathList` or just nothing.
   */
  resetWithFieldInitialValue = (info = {}) => {
    const cache = new NameMap_default();
    const fieldEntities = this.getFieldEntities(true);
    fieldEntities.forEach((field) => {
      const {
        initialValue
      } = field.props;
      const namePath = field.getNamePath();
      if (initialValue !== void 0) {
        const records = cache.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field,
          value: initialValue
        });
        cache.set(namePath, records);
      }
    });
    const resetWithFields = (entities) => {
      entities.forEach((field) => {
        const {
          initialValue
        } = field.props;
        if (initialValue !== void 0) {
          const namePath = field.getNamePath();
          const formInitialValue = this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warning_default(false, `Form already set 'initialValues' with path '${namePath.join(".")}'. Field can not overwrite it.`);
          } else {
            const records = cache.get(namePath);
            if (records && records.size > 1) {
              warning_default(false, `Multiple Field with path '${namePath.join(".")}' set 'initialValue'. Can not decide which one to pick.`);
            } else if (records) {
              const originValue = this.getFieldValue(namePath);
              const isListField = field.isListField();
              if (!isListField && (!info.skipExist || originValue === void 0)) {
                this.updateStore(set(this.store, namePath, [...records][0].value));
              }
            }
          }
        }
      });
    };
    let requiredFieldEntities;
    if (info.entities) {
      requiredFieldEntities = info.entities;
    } else if (info.namePathList) {
      requiredFieldEntities = [];
      info.namePathList.forEach((namePath) => {
        const records = cache.get(namePath);
        if (records) {
          requiredFieldEntities.push(...[...records].map((r) => r.entity));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  resetFields = (nameList) => {
    this.warningUnhooked();
    const prevStore = this.store;
    if (!nameList) {
      this.updateStore(merge(this.initialValues));
      this.resetWithFieldInitialValue();
      this.notifyObservers(prevStore, null, {
        type: "reset"
      });
      this.notifyWatch();
      return;
    }
    const namePathList = nameList.map(getNamePath);
    namePathList.forEach((namePath) => {
      const initialValue = this.getInitialValue(namePath);
      this.updateStore(set(this.store, namePath, initialValue));
    });
    this.resetWithFieldInitialValue({
      namePathList
    });
    this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    });
    this.notifyWatch(namePathList);
  };
  setFields = (fields) => {
    this.warningUnhooked();
    const prevStore = this.store;
    const namePathList = [];
    fields.forEach((fieldData) => {
      const {
        name,
        ...data
      } = fieldData;
      const namePath = getNamePath(name);
      namePathList.push(namePath);
      if ("value" in data) {
        this.updateStore(set(this.store, namePath, data.value));
      }
      this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    this.notifyWatch(namePathList);
  };
  getFields = () => {
    const entities = this.getFieldEntities(true);
    const fields = entities.map((field) => {
      const namePath = field.getNamePath();
      const meta = field.getMeta();
      const fieldData = {
        ...meta,
        name: namePath,
        value: this.getFieldValue(namePath)
      };
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  // =========================== Observer ===========================
  /**
   * This only trigger when a field is on constructor to avoid we get initialValue too late
   */
  initEntityValue = (entity) => {
    const {
      initialValue
    } = entity.props;
    if (initialValue !== void 0) {
      const namePath = entity.getNamePath();
      const prevValue = get(this.store, namePath);
      if (prevValue === void 0) {
        this.updateStore(set(this.store, namePath, initialValue));
      }
    }
  };
  isMergedPreserve = (fieldPreserve) => {
    const mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : this.preserve;
    return mergedPreserve ?? true;
  };
  registerField = (entity) => {
    this.fieldEntities.push(entity);
    const namePath = entity.getNamePath();
    this.batchNotifyWatch(namePath);
    if (entity.props.initialValue !== void 0) {
      const prevStore = this.store;
      this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: true
      });
      this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return (isListField, preserve2, subNamePath = []) => {
      this.fieldEntities = this.fieldEntities.filter((item) => item !== entity);
      if (!this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
        const defaultValue = isListField ? void 0 : this.getInitialValue(namePath);
        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every((field) => (
          // Only reset when no namePath exist
          !matchNamePath(field.getNamePath(), namePath)
        ))) {
          const prevStore = this.store;
          this.updateStore(set(prevStore, namePath, defaultValue, true));
          this.notifyObservers(prevStore, [namePath], {
            type: "remove"
          });
          this.triggerDependenciesUpdate(prevStore, namePath);
        }
      }
      this.batchNotifyWatch(namePath);
    };
  };
  dispatch = (action) => {
    switch (action.type) {
      case "updateValue": {
        const {
          namePath,
          value
        } = action;
        this.updateValue(namePath, value);
        break;
      }
      case "validateField": {
        const {
          namePath,
          triggerName
        } = action;
        this.validateFields([namePath], {
          triggerName
        });
        break;
      }
      default:
    }
  };
  notifyObservers = (prevStore, namePathList, info) => {
    if (this.subscribable) {
      const mergedInfo = {
        ...info,
        store: this.getFieldsValue(true)
      };
      this.getFieldEntities().forEach(({
        onStoreChange
      }) => {
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      this.forceRootUpdate();
    }
  };
  /**
   * Notify dependencies children with parent update
   * We need delay to trigger validate in case Field is under render props
   */
  triggerDependenciesUpdate = (prevStore, namePath) => {
    const childrenFields = this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      this.validateFields(childrenFields);
    }
    this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath, ...childrenFields]
    });
    return childrenFields;
  };
  updateValue = (name, value) => {
    const namePath = getNamePath(name);
    const prevStore = this.store;
    this.updateStore(set(this.store, namePath, value));
    this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    this.notifyWatch([namePath]);
    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);
    const {
      onValuesChange
    } = this.callbacks;
    if (onValuesChange) {
      const fieldEntity = this.getFieldsMap(true).get(namePath);
      const changedValues = cloneByNamePathList(this.store, [namePath]);
      const allValues = this.getFieldsValue();
      const mergedAllValues = mergeWith([allValues, changedValues], {
        // When value is array, it means trigger by Form.List which should replace directly
        prepareArray: (current) => fieldEntity?.isList() ? [] : [...current || []]
      });
      onValuesChange(changedValues, mergedAllValues);
    }
    this.triggerOnFieldsChange([namePath, ...childrenFields]);
  };
  // Let all child Field get update.
  setFieldsValue = (store) => {
    this.warningUnhooked();
    const prevStore = this.store;
    if (store) {
      const nextStore = merge(this.store, store);
      this.updateStore(nextStore);
    }
    this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    this.notifyWatch();
  };
  setFieldValue = (name, value) => {
    this.setFields([{
      name,
      value,
      errors: [],
      warnings: [],
      touched: true
    }]);
  };
  getDependencyChildrenFields = (rootNamePath) => {
    const children = /* @__PURE__ */ new Set();
    const childrenFields = [];
    const dependencies2fields = new NameMap_default();
    this.getFieldEntities().forEach((field) => {
      const {
        dependencies
      } = field.props;
      (dependencies || []).forEach((dependency) => {
        const dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, (fields = /* @__PURE__ */ new Set()) => {
          fields.add(field);
          return fields;
        });
      });
    });
    const fillChildren = (namePath) => {
      const fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach((field) => {
        if (!children.has(field)) {
          children.add(field);
          const fieldNamePath = field.getNamePath();
          if (field.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren(fieldNamePath);
          }
        }
      });
    };
    fillChildren(rootNamePath);
    return childrenFields;
  };
  triggerOnFieldsChange = (namePathList, filedErrors) => {
    const {
      onFieldsChange
    } = this.callbacks;
    if (onFieldsChange) {
      const fields = this.getFields();
      if (filedErrors) {
        const cache = new NameMap_default();
        filedErrors.forEach(({
          name,
          errors
        }) => {
          cache.set(name, errors);
        });
        fields.forEach((field) => {
          field.errors = cache.get(field.name) || field.errors;
        });
      }
      const changedFields = fields.filter(({
        name: fieldName
      }) => containsNamePath(namePathList, fieldName));
      if (changedFields.length) {
        onFieldsChange(changedFields, fields);
      }
    }
  };
  // =========================== Validate ===========================
  validateFields = (arg1, arg2) => {
    this.warningUnhooked();
    let nameList;
    let options;
    if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
      nameList = arg1;
      options = arg2;
    } else {
      options = arg1;
    }
    const provideNameList = !!nameList;
    const namePathList = provideNameList ? nameList.map(getNamePath) : [];
    const finalValueNamePathList = [...namePathList];
    const promiseList = [];
    const TMP_SPLIT = String(Date.now());
    const validateNamePathList = /* @__PURE__ */ new Set();
    const {
      recursive,
      dirty
    } = options || {};
    this.getFieldEntities(true).forEach((field) => {
      const fieldNamePath = field.getNamePath();
      if (!provideNameList) {
        if (
          // If is field, pass directly
          !field.isList() || // If is list, do not add if already exist sub field in the namePathList
          !namePathList.some((name) => matchNamePath(name, fieldNamePath, true))
        ) {
          finalValueNamePathList.push(fieldNamePath);
        }
        namePathList.push(fieldNamePath);
      }
      if (!field.props.rules || !field.props.rules.length) {
        return;
      }
      if (dirty && !field.isFieldDirty()) {
        return;
      }
      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
        const promise = field.validateRules({
          validateMessages: {
            ...defaultValidateMessages,
            ...this.validateMessages
          },
          ...options
        });
        promiseList.push(promise.then(() => ({
          name: fieldNamePath,
          errors: [],
          warnings: []
        })).catch((ruleErrors) => {
          const mergedErrors = [];
          const mergedWarnings = [];
          ruleErrors.forEach?.(({
            rule: {
              warningOnly
            },
            errors
          }) => {
            if (warningOnly) {
              mergedWarnings.push(...errors);
            } else {
              mergedErrors.push(...errors);
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: fieldNamePath,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    });
    const summaryPromise = allPromiseFinish(promiseList);
    this.lastValidatePromise = summaryPromise;
    summaryPromise.catch((results) => results).then((results) => {
      const resultNamePathList = results.map(({
        name
      }) => name);
      this.notifyObservers(this.store, resultNamePathList, {
        type: "validateFinish"
      });
      this.triggerOnFieldsChange(resultNamePathList, results);
    });
    const returnPromise = summaryPromise.then(() => {
      if (this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));
      }
      return Promise.reject([]);
    }).catch((results) => {
      const errorList = results.filter((result) => result && result.errors.length);
      const errorMessage = errorList[0]?.errors?.[0];
      return Promise.reject({
        message: errorMessage,
        values: this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch((e) => e);
    const triggerNamePathList = namePathList.filter((namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT)));
    this.triggerOnFieldsChange(triggerNamePathList);
    return returnPromise;
  };
  // ============================ Submit ============================
  submit = () => {
    this.warningUnhooked();
    this.validateFields().then((values) => {
      const {
        onFinish
      } = this.callbacks;
      if (onFinish) {
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch((e) => {
      const {
        onFinishFailed
      } = this.callbacks;
      if (onFinishFailed) {
        onFinishFailed(e);
      }
    });
  };
};
function useForm(form) {
  const formRef = React10.useRef(null);
  const [, forceUpdate] = React10.useState({});
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      const forceReRender = () => {
        forceUpdate({});
      };
      const formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var useForm_default = useForm;

// node_modules/@rc-component/form/es/Form.js
var React13 = __toESM(require_react());

// node_modules/@rc-component/form/es/FormContext.js
var React11 = __toESM(require_react());
var FormContext = React11.createContext({
  triggerFormChange: () => {
  },
  triggerFormFinish: () => {
  },
  registerForm: () => {
  },
  unregisterForm: () => {
  }
});
var FormProvider = ({
  validateMessages,
  onFormChange,
  onFormFinish,
  children
}) => {
  const formContext = React11.useContext(FormContext);
  const formsRef = React11.useRef({});
  return React11.createElement(FormContext.Provider, {
    value: {
      ...formContext,
      validateMessages: {
        ...formContext.validateMessages,
        ...validateMessages
      },
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: (name, changedFields) => {
        if (onFormChange) {
          onFormChange(name, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name, changedFields);
      },
      triggerFormFinish: (name, values) => {
        if (onFormFinish) {
          onFormFinish(name, {
            values,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name, values);
      },
      registerForm: (name, form) => {
        if (name) {
          formsRef.current = {
            ...formsRef.current,
            [name]: form
          };
        }
        formContext.registerForm(name, form);
      },
      unregisterForm: (name) => {
        const newForms = {
          ...formsRef.current
        };
        delete newForms[name];
        formsRef.current = newForms;
        formContext.unregisterForm(name);
      }
    }
  }, children);
};
var FormContext_default = FormContext;

// node_modules/@rc-component/form/es/BatchUpdate.js
var React12 = __toESM(require_react());
var BatchUpdate = React12.forwardRef((_, ref) => {
  const [batchInfo, setBatchInfo] = React12.useState({});
  React12.useLayoutEffect(() => {
    const keys2 = Object.keys(batchInfo);
    if (keys2.length) {
      keys2.forEach((key) => {
        batchInfo[key]?.();
      });
      setBatchInfo({});
    }
  }, [batchInfo]);
  React12.useImperativeHandle(ref, () => ({
    batch: (key, callback) => {
      setBatchInfo((ori) => ({
        ...ori,
        [key]: callback
      }));
    }
  }));
  return null;
});
var BatchUpdate_default = BatchUpdate;

// node_modules/@rc-component/form/es/Form.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var Form = ({
  name,
  initialValues,
  fields,
  form,
  preserve: preserve2,
  children,
  component: Component3 = "form",
  validateMessages,
  validateTrigger = "onChange",
  onValuesChange,
  onFieldsChange,
  onFinish,
  onFinishFailed,
  clearOnDestroy,
  ...restProps
}, ref) => {
  const nativeElementRef = React13.useRef(null);
  const formContext = React13.useContext(FormContext_default);
  const [formInstance] = useForm_default(form);
  const {
    useSubscribe,
    setInitialValues,
    setCallbacks,
    setValidateMessages,
    setPreserve,
    destroyForm,
    setBatchUpdate
  } = formInstance.getInternalHooks(HOOK_MARK);
  React13.useImperativeHandle(ref, () => ({
    ...formInstance,
    nativeElement: nativeElementRef.current
  }));
  React13.useEffect(() => {
    formContext.registerForm(name, formInstance);
    return () => {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]);
  setValidateMessages({
    ...formContext.validateMessages,
    ...validateMessages
  });
  setCallbacks({
    onValuesChange,
    onFieldsChange: (changedFields, ...rest) => {
      formContext.triggerFormChange(name, changedFields);
      if (onFieldsChange) {
        onFieldsChange(changedFields, ...rest);
      }
    },
    onFinish: (values) => {
      formContext.triggerFormFinish(name, values);
      if (onFinish) {
        onFinish(values);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve2);
  const mountRef = React13.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  const batchUpdateRef = React13.useRef(null);
  const batchUpdateTasksRef = React13.useRef([]);
  const tryFlushBatch = () => {
    if (batchUpdateRef.current) {
      batchUpdateTasksRef.current.forEach(([key, fn]) => {
        batchUpdateRef.current.batch(key, fn);
      });
      batchUpdateTasksRef.current = [];
    }
  };
  const setBatchUpdateRef = React13.useCallback((batchUpdate2) => {
    batchUpdateRef.current = batchUpdate2;
    tryFlushBatch();
  }, []);
  const batchUpdate = (key, callback) => {
    batchUpdateTasksRef.current.push([key, callback]);
    tryFlushBatch();
  };
  setBatchUpdate(batchUpdate);
  React13.useEffect(
    () => () => destroyForm(clearOnDestroy),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  let childrenNode;
  const childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    const values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  const prevFieldsRef = React13.useRef(null);
  React13.useEffect(() => {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  const formContextValue = React13.useMemo(() => ({
    ...formInstance,
    validateTrigger
  }), [formInstance, validateTrigger]);
  const wrapperNode = React13.createElement(ListContext_default.Provider, {
    value: null
  }, React13.createElement(FieldContext_default.Provider, {
    value: formContextValue
  }, childrenNode), React13.createElement(BatchUpdate_default, {
    ref: setBatchUpdateRef
  }));
  if (Component3 === false) {
    return wrapperNode;
  }
  return React13.createElement(Component3, _extends2({}, restProps, {
    ref: nativeElementRef,
    onSubmit: (event) => {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: (event) => {
      event.preventDefault();
      formInstance.resetFields();
      restProps.onReset?.(event);
    }
  }), wrapperNode);
};
var Form_default = Form;

// node_modules/@rc-component/form/es/useWatch.js
var import_react3 = __toESM(require_react());
function stringify(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Math.random();
  }
}
function useWatch(...args) {
  const [dependencies, _form = {}] = args;
  const options = isFormInstance(_form) ? {
    form: _form
  } : _form;
  const form = options.form;
  const [value, setValue] = (0, import_react3.useState)(() => typeof dependencies === "function" ? dependencies({}) : void 0);
  const valueStr = (0, import_react3.useMemo)(() => stringify(value), [value]);
  const valueStrRef = (0, import_react3.useRef)(valueStr);
  valueStrRef.current = valueStr;
  const fieldContext = (0, import_react3.useContext)(FieldContext_default);
  const formInstance = form || fieldContext;
  const isValidForm = formInstance && formInstance._init;
  if (true) {
    warning_default(args.length === 2 ? form ? isValidForm : true : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
  }
  const {
    getFieldsValue,
    getInternalHooks
  } = formInstance;
  const {
    registerWatch
  } = getInternalHooks(HOOK_MARK);
  const triggerUpdate = useEvent_default((values, allValues) => {
    const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();
    const nextValue = typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, getNamePath(dependencies));
    if (stringify(value) !== stringify(nextValue)) {
      setValue(nextValue);
    }
  });
  const flattenDeps = typeof dependencies === "function" ? dependencies : JSON.stringify(dependencies);
  (0, import_react3.useEffect)(() => {
    if (!isValidForm) {
      return;
    }
    triggerUpdate();
  }, [isValidForm, flattenDeps]);
  (0, import_react3.useEffect)(() => {
    if (!isValidForm) {
      return;
    }
    const cancelRegister = registerWatch((values, allValues) => {
      triggerUpdate(values, allValues);
    });
    return cancelRegister;
  }, [isValidForm]);
  return value;
}
var useWatch_default = useWatch;

// node_modules/@rc-component/form/es/index.js
var InternalForm = React14.forwardRef(Form_default);
var RefForm = InternalForm;
RefForm.FormProvider = FormProvider;
RefForm.Field = Field_default;
RefForm.List = List_default;
RefForm.useForm = useForm_default;
RefForm.useWatch = useWatch_default;
var es_default2 = RefForm;

// node_modules/antd/es/form/context.js
var FormContext2 = React15.createContext({
  labelAlign: "right",
  layout: "horizontal",
  itemRef: () => {
  }
});
var NoStyleItemContext = React15.createContext(null);
var FormProvider2 = (props) => {
  const providerProps = omit(props, ["prefixCls"]);
  return React15.createElement(FormProvider, {
    ...providerProps
  });
};
var FormItemPrefixContext = React15.createContext({
  prefixCls: ""
});
var FormItemInputContext = React15.createContext({});
if (true) {
  FormItemInputContext.displayName = "FormItemInputContext";
}
var NoFormStyle = ({
  children,
  status,
  override
}) => {
  const formItemInputContext = React15.useContext(FormItemInputContext);
  const newFormItemInputContext = React15.useMemo(() => {
    const newContext = {
      ...formItemInputContext
    };
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return React15.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
};
var VariantContext = React15.createContext(void 0);

// node_modules/antd/es/space/Compact.js
var React70 = __toESM(require_react());

// node_modules/antd/es/_util/hooks/useClosable.js
var import_react5 = __toESM(require_react());

// node_modules/@rc-component/util/es/pickAttrs.js
var attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
var eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
var propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs(props, ariaOnly = false) {
  let mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = {
      ...ariaOnly
    };
  }
  const attrs = {};
  Object.keys(props).forEach((key) => {
    if (
      // Aria
      mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
      mergedConfig.data && match(key, dataPrefix) || // Attr
      mergedConfig.attr && propList.includes(key)
    ) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}

// node_modules/antd/es/locale/index.js
var React18 = __toESM(require_react());

// node_modules/antd/es/_util/warning.js
var React16 = __toESM(require_react());
function noop() {
}
var {
  resetWarned: rcResetWarned
} = warning_default;
var deprecatedWarnList = null;
var _warning = noop;
if (true) {
  _warning = (valid, component, message) => {
    warning_default(valid, `[antd: ${component}] ${message}`);
    if (false) {
      resetWarned();
    }
  };
}
var warning4 = _warning;
var WarningContext = React16.createContext({});
var devUseWarning = true ? (component) => {
  const {
    strict
  } = React16.useContext(WarningContext);
  const typeWarning = (valid, type5, message) => {
    if (!valid) {
      if (strict === false && type5 === "deprecated") {
        const existWarning = deprecatedWarnList;
        if (!deprecatedWarnList) {
          deprecatedWarnList = {};
        }
        deprecatedWarnList[component] = deprecatedWarnList[component] || [];
        if (!deprecatedWarnList[component].includes(message || "")) {
          deprecatedWarnList[component].push(message || "");
        }
        if (!existWarning) {
          console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
        }
      } else {
        true ? warning4(valid, component, message) : void 0;
      }
    }
  };
  typeWarning.deprecated = (valid, oldProp, newProp, message = "") => {
    typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message ? ` ${message}` : ""}`);
  };
  return typeWarning;
} : () => {
  const noopWarning = () => {
  };
  noopWarning.deprecated = noop;
  return noopWarning;
};
var warning_default2 = warning4;

// node_modules/@rc-component/pagination/es/locale/en_US.js
var locale = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var en_US_default = locale;

// node_modules/@rc-component/picker/es/locale/common.js
var commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: true
};

// node_modules/@rc-component/picker/es/locale/en_US.js
function _typeof2(o) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof2(o);
}
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof2(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var locale2 = _objectSpread(_objectSpread({}, commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
var en_US_default2 = locale2;

// node_modules/antd/es/time-picker/locale/en_US.js
var locale3 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var en_US_default3 = locale3;

// node_modules/antd/es/date-picker/locale/en_US.js
var locale4 = {
  lang: {
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"],
    ...en_US_default2
  },
  timePickerLocale: {
    ...en_US_default3
  }
};
var en_US_default4 = locale4;

// node_modules/antd/es/calendar/locale/en_US.js
var en_US_default5 = en_US_default4;

// node_modules/antd/es/locale/en_US.js
var typeTemplate2 = "${label} is not a valid ${type}";
var localeValues = {
  locale: "en",
  Pagination: en_US_default,
  DatePicker: en_US_default4,
  TimePicker: en_US_default3,
  Calendar: en_US_default5,
  global: {
    placeholder: "Please select",
    close: "Close",
    sortable: "sortable"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckAll: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate2,
        method: typeTemplate2,
        array: typeTemplate2,
        object: typeTemplate2,
        number: typeTemplate2,
        date: typeTemplate2,
        boolean: typeTemplate2,
        integer: typeTemplate2,
        float: typeTemplate2,
        regexp: typeTemplate2,
        email: typeTemplate2,
        url: typeTemplate2,
        hex: typeTemplate2
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
var en_US_default6 = localeValues;

// node_modules/antd/es/modal/locale.js
var runtimeLocale = {
  ...en_US_default6.Modal
};
var localeList = [];
var generateLocale = () => localeList.reduce((merged, locale5) => ({
  ...merged,
  ...locale5
}), en_US_default6.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    const cloneLocale = {
      ...newLocale
    };
    localeList.push(cloneLocale);
    runtimeLocale = generateLocale();
    return () => {
      localeList = localeList.filter((locale5) => locale5 !== cloneLocale);
      runtimeLocale = generateLocale();
    };
  }
  runtimeLocale = {
    ...en_US_default6.Modal
  };
}
function getConfirmLocale() {
  return runtimeLocale;
}

// node_modules/antd/es/locale/context.js
var import_react4 = __toESM(require_react());
var LocaleContext = (0, import_react4.createContext)(void 0);
var context_default = LocaleContext;

// node_modules/antd/es/locale/useLocale.js
var React17 = __toESM(require_react());
var useLocale = (componentName, defaultLocale) => {
  const fullLocale = React17.useContext(context_default);
  const getLocale = React17.useMemo(() => {
    const locale5 = defaultLocale || en_US_default6[componentName];
    const localeFromContext = fullLocale?.[componentName] ?? {};
    return {
      ...typeof locale5 === "function" ? locale5() : locale5,
      ...localeFromContext || {}
    };
  }, [componentName, defaultLocale, fullLocale]);
  const getLocaleCode = React17.useMemo(() => {
    const localeCode = fullLocale?.locale;
    if (fullLocale?.exist && !localeCode) {
      return en_US_default6.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
};
var useLocale_default = useLocale;

// node_modules/antd/es/locale/index.js
var ANT_MARK = "internalMark";
var LocaleProvider = (props) => {
  const {
    locale: locale5 = {},
    children,
    _ANT_MARK__
  } = props;
  if (true) {
    const warning5 = devUseWarning("LocaleProvider");
    true ? warning5(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale") : void 0;
  }
  React18.useEffect(() => {
    const clearLocale = changeConfirmLocale(locale5?.Modal);
    return clearLocale;
  }, [locale5]);
  const getMemoizedContextValue = React18.useMemo(() => ({
    ...locale5,
    exist: true
  }), [locale5]);
  return React18.createElement(context_default.Provider, {
    value: getMemoizedContextValue
  }, children);
};
if (true) {
  LocaleProvider.displayName = "LocaleProvider";
}
var locale_default = LocaleProvider;

// node_modules/antd/es/_util/extendsObject.js
function mergeProps(...items) {
  const ret = {};
  items.forEach((item) => {
    if (item) {
      Object.keys(item).forEach((key) => {
        if (item[key] !== void 0) {
          ret[key] = item[key];
        }
      });
    }
  });
  return ret;
}
var extendsObject_default = mergeProps;

// node_modules/antd/es/_util/isNonNullable.js
var isNonNullable = (val) => {
  return val !== void 0 && val !== null;
};
var isNonNullable_default = isNonNullable;

// node_modules/antd/es/_util/hooks/useClosable.js
var pickClosable = (context) => {
  if (!context) {
    return void 0;
  }
  const {
    closable,
    closeIcon
  } = context;
  return {
    closable,
    closeIcon
  };
};
var EmptyFallbackCloseCollection = {};
var computeClosableConfig = (closable, closeIcon) => {
  if (!closable && (closable === false || closeIcon === false || closeIcon === null)) {
    return false;
  }
  if (closable === void 0 && closeIcon === void 0) {
    return null;
  }
  let closableConfig = {
    closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
  };
  if (closable && typeof closable === "object") {
    closableConfig = {
      ...closableConfig,
      ...closable
    };
  }
  return closableConfig;
};
var mergeClosableConfigs = (propConfig, contextConfig, fallbackConfig) => {
  if (propConfig === false) {
    return false;
  }
  if (propConfig) {
    return extendsObject_default(fallbackConfig, contextConfig, propConfig);
  }
  if (contextConfig === false) {
    return false;
  }
  if (contextConfig) {
    return extendsObject_default(fallbackConfig, contextConfig);
  }
  return fallbackConfig.closable ? fallbackConfig : false;
};
var computeCloseIcon = (mergedConfig, fallbackCloseCollection, closeLabel) => {
  const {
    closeIconRender
  } = fallbackCloseCollection;
  const {
    closeIcon,
    ...restConfig
  } = mergedConfig;
  let finalCloseIcon = closeIcon;
  const ariaOrDataProps = pickAttrs(restConfig, true);
  if (isNonNullable_default(finalCloseIcon)) {
    if (closeIconRender) {
      finalCloseIcon = closeIconRender(finalCloseIcon);
    }
    finalCloseIcon = import_react5.default.isValidElement(finalCloseIcon) ? import_react5.default.cloneElement(finalCloseIcon, {
      "aria-label": closeLabel,
      ...finalCloseIcon.props,
      ...ariaOrDataProps
    }) : import_react5.default.createElement("span", {
      "aria-label": closeLabel,
      ...ariaOrDataProps
    }, finalCloseIcon);
  }
  return [finalCloseIcon, ariaOrDataProps];
};
var computeClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection, closeLabel = "Close") => {
  const propConfig = computeClosableConfig(propCloseCollection?.closable, propCloseCollection?.closeIcon);
  const contextConfig = computeClosableConfig(contextCloseCollection?.closable, contextCloseCollection?.closeIcon);
  const mergedFallback = {
    closeIcon: import_react5.default.createElement(CloseOutlined_default, null),
    ...fallbackCloseCollection
  };
  const mergedConfig = mergeClosableConfigs(propConfig, contextConfig, mergedFallback);
  const closeBtnIsDisabled = typeof mergedConfig !== "boolean" ? !!mergedConfig?.disabled : false;
  if (mergedConfig === false) {
    return [false, null, closeBtnIsDisabled, {}];
  }
  const [closeIcon, ariaProps] = computeCloseIcon(mergedConfig, mergedFallback, closeLabel);
  return [true, closeIcon, closeBtnIsDisabled, ariaProps];
};
var useClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) => {
  const [contextLocale] = useLocale_default("global", en_US_default6.global);
  return import_react5.default.useMemo(() => {
    return computeClosable(propCloseCollection, contextCloseCollection, {
      closeIcon: import_react5.default.createElement(CloseOutlined_default, null),
      ...fallbackCloseCollection
    }, contextLocale.close);
  }, [propCloseCollection, contextCloseCollection, fallbackCloseCollection, contextLocale.close]);
};

// node_modules/antd/es/_util/hooks/useForceUpdate.js
var import_react6 = __toESM(require_react());
var useForceUpdate = () => {
  return import_react6.default.useReducer((ori) => ori + 1, 0);
};

// node_modules/antd/es/_util/hooks/useMergedMask.js
var import_react7 = __toESM(require_react());
var normalizeMaskConfig = (mask) => {
  if (mask && typeof mask === "object") {
    return mask;
  }
  if (typeof mask === "boolean") {
    return {
      enabled: mask,
      blur: mask
    };
  }
  return {};
};
var useMergedMask = (mask, contextMask, prefixCls) => {
  return (0, import_react7.useMemo)(() => {
    const maskConfig = normalizeMaskConfig(mask);
    const contextMaskConfig = normalizeMaskConfig(contextMask);
    const mergedConfig = {
      ...contextMaskConfig,
      ...maskConfig
    };
    const className = mergedConfig.blur !== false ? `${prefixCls}-mask-blur` : void 0;
    return [mergedConfig.enabled !== false, {
      mask: className
    }];
  }, [mask, contextMask, prefixCls]);
};

// node_modules/antd/es/_util/hooks/useMergeSemantic.js
var React21 = __toESM(require_react());
var mergeClassNames = (schema, ...classNames) => {
  const mergedSchema = schema || {};
  return classNames.filter(Boolean).reduce((acc, cur) => {
    Object.keys(cur || {}).forEach((key) => {
      const keySchema = mergedSchema[key];
      const curVal = cur[key];
      if (keySchema && typeof keySchema === "object") {
        if (curVal && typeof curVal === "object") {
          acc[key] = mergeClassNames(keySchema, acc[key], curVal);
        } else {
          const {
            _default: defaultField
          } = keySchema;
          if (defaultField) {
            acc[key] = acc[key] || {};
            acc[key][defaultField] = clsx(acc[key][defaultField], curVal);
          }
        }
      } else {
        acc[key] = clsx(acc[key], curVal);
      }
    });
    return acc;
  }, {});
};
var useSemanticClassNames = (schema, ...classNames) => {
  return React21.useMemo(() => mergeClassNames.apply(void 0, [schema].concat(classNames)), [schema].concat(classNames));
};
var mergeStyles = (...styles) => {
  return styles.filter(Boolean).reduce((acc, cur = {}) => {
    Object.keys(cur).forEach((key) => {
      acc[key] = {
        ...acc[key],
        ...cur[key]
      };
    });
    return acc;
  }, {});
};
var useSemanticStyles = (...styles) => {
  return React21.useMemo(() => mergeStyles.apply(void 0, styles), [].concat(styles));
};
var fillObjectBySchema = (obj, schema) => {
  const newObj = {
    ...obj
  };
  Object.keys(schema).forEach((key) => {
    if (key !== "_default") {
      const nestSchema = schema[key];
      const nextValue = newObj[key] || {};
      newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
    }
  });
  return newObj;
};
var resolveStyleOrClass = (value, info) => {
  return typeof value === "function" ? value(info) : value;
};
var useMergeSemantic = (classNamesList, stylesList, info, schema) => {
  const resolvedClassNamesList = classNamesList.map((classNames) => classNames ? resolveStyleOrClass(classNames, info) : void 0);
  const resolvedStylesList = stylesList.map((styles) => styles ? resolveStyleOrClass(styles, info) : void 0);
  const mergedClassNames = useSemanticClassNames.apply(void 0, [schema].concat(_toConsumableArray(resolvedClassNamesList)));
  const mergedStyles = useSemanticStyles.apply(void 0, _toConsumableArray(resolvedStylesList));
  return React21.useMemo(() => {
    if (!schema) {
      return [mergedClassNames, mergedStyles];
    }
    return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
  }, [mergedClassNames, mergedStyles, schema]);
};

// node_modules/antd/es/_util/hooks/useMultipleSelect.js
var import_react8 = __toESM(require_react());
var useMultipleSelect = (getKey2) => {
  const [prevSelectedIndex, setPrevSelectedIndex] = (0, import_react8.useState)(null);
  const multipleSelect = (0, import_react8.useCallback)((currentSelectedIndex, data, selectedKeys) => {
    const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex;
    const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
    const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
    const rangeKeys = data.slice(startIndex, endIndex + 1).map(getKey2);
    const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
    const changedKeys = [];
    rangeKeys.forEach((item) => {
      if (shouldSelected) {
        if (!selectedKeys.has(item)) {
          changedKeys.push(item);
        }
        selectedKeys.add(item);
      } else {
        selectedKeys.delete(item);
        changedKeys.push(item);
      }
    });
    setPrevSelectedIndex(shouldSelected ? endIndex : null);
    return changedKeys;
  }, [prevSelectedIndex]);
  return [multipleSelect, setPrevSelectedIndex];
};

// node_modules/antd/es/_util/hooks/useOrientation.js
var import_react9 = __toESM(require_react());
var isValidOrientation = (orientation) => {
  return orientation === "horizontal" || orientation === "vertical";
};
var useOrientation = (orientation, vertical, legacyDirection) => {
  return (0, import_react9.useMemo)(() => {
    const validOrientation = isValidOrientation(orientation);
    let mergedOrientation;
    if (validOrientation) {
      mergedOrientation = orientation;
    } else if (typeof vertical === "boolean") {
      mergedOrientation = vertical ? "vertical" : "horizontal";
    } else {
      const validLegacyDirection = isValidOrientation(legacyDirection);
      mergedOrientation = validLegacyDirection ? legacyDirection : "horizontal";
    }
    return [mergedOrientation, mergedOrientation === "vertical"];
  }, [legacyDirection, orientation, vertical]);
};

// node_modules/antd/es/_util/hooks/usePatchElement.js
var React22 = __toESM(require_react());
var usePatchElement = () => {
  const [elements, setElements] = React22.useState([]);
  const patchElement = React22.useCallback((element) => {
    setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
    return () => {
      setElements((originElements) => originElements.filter((ele) => ele !== element));
    };
  }, []);
  return [elements, patchElement];
};

// node_modules/antd/es/_util/hooks/useProxyImperativeHandle.js
var import_react10 = __toESM(require_react());
var fillProxy = (element, handler) => {
  element._antProxy = element._antProxy || {};
  Object.keys(handler).forEach((key) => {
    if (!(key in element._antProxy)) {
      const ori = element[key];
      element._antProxy[key] = ori;
      element[key] = handler[key];
    }
  });
  return element;
};
var useProxyImperativeHandle = (ref, init) => {
  return (0, import_react10.useImperativeHandle)(ref, () => {
    const refObj = init();
    const {
      nativeElement
    } = refObj;
    if (typeof Proxy !== "undefined") {
      return new Proxy(nativeElement, {
        get(obj, prop) {
          if (refObj[prop]) {
            return refObj[prop];
          }
          return Reflect.get(obj, prop);
        }
      });
    }
    return fillProxy(nativeElement, refObj);
  });
};

// node_modules/antd/es/_util/hooks/useSyncState.js
var React23 = __toESM(require_react());
var useSyncState = (initialValue) => {
  const ref = React23.useRef(initialValue);
  const [, forceUpdate] = useForceUpdate();
  return [() => ref.current, (newValue) => {
    ref.current = newValue;
    forceUpdate();
  }];
};

// node_modules/antd/es/_util/hooks/useZIndex.js
var import_react17 = __toESM(require_react());

// node_modules/antd/es/theme/useToken.js
var import_react15 = __toESM(require_react());

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

// node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var import_react12 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/StyleContext.js
var React24 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/Cache.js
var SPLIT2 = "%";
function pathKey(keys2) {
  return keys2.join(SPLIT2);
}
var updateId = 0;
var Entity = class {
  instanceId;
  constructor(instanceId) {
    this.instanceId = instanceId;
  }
  /** @private Internal cache map. Do not access this directly */
  cache = /* @__PURE__ */ new Map();
  /** @private Record update times for each key */
  updateTimes = /* @__PURE__ */ new Map();
  extracted = /* @__PURE__ */ new Set();
  get(keys2) {
    return this.opGet(pathKey(keys2));
  }
  /** A fast get cache with `get` concat. */
  opGet(keyPathStr) {
    return this.cache.get(keyPathStr) || null;
  }
  update(keys2, valueFn) {
    return this.opUpdate(pathKey(keys2), valueFn);
  }
  /** A fast get cache with `get` concat. */
  opUpdate(keyPathStr, valueFn) {
    const prevValue = this.cache.get(keyPathStr);
    const nextValue = valueFn(prevValue);
    if (nextValue === null) {
      this.cache.delete(keyPathStr);
      this.updateTimes.delete(keyPathStr);
    } else {
      this.cache.set(keyPathStr, nextValue);
      this.updateTimes.set(keyPathStr, updateId);
      updateId += 1;
    }
  }
};
var Cache_default = Entity;

// node_modules/@ant-design/cssinjs/es/StyleContext.js
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var ATTR_CACHE_PATH = "data-cache-path";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
  const cssinjsInstanceId = Math.random().toString(12).slice(2);
  if (typeof document !== "undefined" && document.head && document.body) {
    const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
    const {
      firstChild
    } = document.head;
    Array.from(styles).forEach((style2) => {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
      if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
        document.head.insertBefore(style2, firstChild);
      }
    });
    const styleHash = {};
    Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style2) => {
      const hash2 = style2.getAttribute(ATTR_MARK);
      if (styleHash[hash2]) {
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          style2.parentNode?.removeChild(style2);
        }
      } else {
        styleHash[hash2] = true;
      }
    });
  }
  return new Cache_default(cssinjsInstanceId);
}
var StyleContext = React24.createContext({
  hashPriority: "low",
  cache: createCache(),
  defaultCache: true,
  autoPrefix: false
});
var StyleContext_default = StyleContext;

// node_modules/@ant-design/cssinjs/es/theme/calc/CSSCalculator.js
var CALC_UNIT = "CALC_UNIT";
var regexp4 = new RegExp(CALC_UNIT, "g");

// node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (let i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) {
      return false;
    }
  }
  return true;
}
var ThemeCache = class _ThemeCache {
  static MAX_CACHE_SIZE = 20;
  static MAX_CACHE_OFFSET = 5;
  cache;
  keys;
  cacheCallTimes;
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(derivativeOption, updateCallTimes = false) {
    let cache = {
      map: this.cache
    };
    derivativeOption.forEach((derivative2) => {
      if (!cache) {
        cache = void 0;
      } else {
        cache = cache?.map?.get(derivative2);
      }
    });
    if (cache?.value && updateCallTimes) {
      cache.value[1] = this.cacheCallTimes++;
    }
    return cache?.value;
  }
  get(derivativeOption) {
    return this.internalGet(derivativeOption, true)?.[0];
  }
  has(derivativeOption) {
    return !!this.internalGet(derivativeOption);
  }
  set(derivativeOption, value) {
    if (!this.has(derivativeOption)) {
      if (this.size() + 1 > _ThemeCache.MAX_CACHE_SIZE + _ThemeCache.MAX_CACHE_OFFSET) {
        const [targetKey] = this.keys.reduce((result, key) => {
          const [, callTimes] = result;
          if (this.internalGet(key)[1] < callTimes) {
            return [key, this.internalGet(key)[1]];
          }
          return result;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(targetKey);
      }
      this.keys.push(derivativeOption);
    }
    let cache = this.cache;
    derivativeOption.forEach((derivative2, index) => {
      if (index === derivativeOption.length - 1) {
        cache.set(derivative2, {
          value: [value, this.cacheCallTimes++]
        });
      } else {
        const cacheValue = cache.get(derivative2);
        if (!cacheValue) {
          cache.set(derivative2, {
            map: /* @__PURE__ */ new Map()
          });
        } else if (!cacheValue.map) {
          cacheValue.map = /* @__PURE__ */ new Map();
        }
        cache = cache.get(derivative2).map;
      }
    });
  }
  deleteByPath(currentCache, derivatives) {
    const cache = currentCache.get(derivatives[0]);
    if (derivatives.length === 1) {
      if (!cache.map) {
        currentCache.delete(derivatives[0]);
      } else {
        currentCache.set(derivatives[0], {
          map: cache.map
        });
      }
      return cache.value?.[0];
    }
    const result = this.deleteByPath(cache.map, derivatives.slice(1));
    if ((!cache.map || cache.map.size === 0) && !cache.value) {
      currentCache.delete(derivatives[0]);
    }
    return result;
  }
  delete(derivativeOption) {
    if (this.has(derivativeOption)) {
      this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
      return this.deleteByPath(this.cache, derivativeOption);
    }
    return void 0;
  }
};

// node_modules/@ant-design/cssinjs/es/theme/Theme.js
var uuid = 0;
var Theme = class {
  derivatives;
  id;
  constructor(derivatives) {
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid;
    if (derivatives.length === 0) {
      warning(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function.");
    }
    uuid += 1;
  }
  getDerivativeToken(token2) {
    return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
  }
};

// node_modules/@ant-design/cssinjs/es/theme/createTheme.js
var cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}

// node_modules/@ant-design/cssinjs/es/util/index.js
var resultCache = /* @__PURE__ */ new WeakMap();
var RESULT_VALUE = {};
function memoResult(callback, deps) {
  let current = resultCache;
  for (let i = 0; i < deps.length; i += 1) {
    const dep = deps[i];
    if (!current.has(dep)) {
      current.set(dep, /* @__PURE__ */ new WeakMap());
    }
    current = current.get(dep);
  }
  if (!current.has(RESULT_VALUE)) {
    current.set(RESULT_VALUE, callback());
  }
  return current.get(RESULT_VALUE);
}
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
function flattenToken(token2) {
  let str = flattenTokenCache.get(token2) || "";
  if (!str) {
    Object.keys(token2).forEach((key) => {
      const value = token2[key];
      str += key;
      if (value instanceof Theme) {
        str += value.id;
      } else if (value && typeof value === "object") {
        str += flattenToken(value);
      } else {
        str += value;
      }
    });
    str = hash_browser_esm_default(str);
    flattenTokenCache.set(token2, str);
  }
  return str;
}
function token2key(token2, salt) {
  return hash_browser_esm_default(`${salt}_${flattenToken(token2)}`);
}
var randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
var isClientSide = canUseDom();
function unit(num) {
  if (typeof num === "number") {
    return `${num}px`;
  }
  return num;
}
function toStyleStr(style2, tokenKey, styleId, customizeAttrs = {}, plain = false) {
  if (plain) {
    return style2;
  }
  const attrs = {
    ...customizeAttrs,
    [ATTR_TOKEN]: tokenKey,
    [ATTR_MARK]: styleId
  };
  const attrStr = Object.keys(attrs).map((attr) => {
    const val = attrs[attr];
    return val ? `${attr}="${val}"` : null;
  }).filter((v) => v).join(" ");
  return `<style ${attrStr}>${style2}</style>`;
}
function where(options) {
  const {
    hashCls,
    hashPriority = "low"
  } = options || {};
  if (!hashCls) {
    return "";
  }
  const hashSelector = `.${hashCls}`;
  return hashPriority === "low" ? `:where(${hashSelector})` : hashSelector;
}

// node_modules/@ant-design/cssinjs/es/util/css-variables.js
var token2CSSVar = (token2, prefix2 = "") => {
  return `--${prefix2 ? `${prefix2}-` : ""}${token2}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
};
var serializeCSSVar = (cssVars, hashId, options) => {
  const {
    hashCls,
    hashPriority = "low"
  } = options || {};
  if (!Object.keys(cssVars).length) {
    return "";
  }
  return `${where({
    hashCls,
    hashPriority
  })}.${hashId}${options?.scope ? `.${options.scope}` : ""}{${Object.entries(cssVars).map(([key, value]) => `${key}:${value};`).join("")}}`;
};
var transformToken = (token2, themeKey, config) => {
  const {
    hashCls,
    hashPriority = "low",
    prefix: prefix2,
    unitless: unitless2,
    ignore: ignore2,
    preserve: preserve2
  } = config || {};
  const cssVars = {};
  const result = {};
  Object.entries(token2).forEach(([key, value]) => {
    if (preserve2?.[key]) {
      result[key] = value;
    } else if ((typeof value === "string" || typeof value === "number") && !ignore2?.[key]) {
      const cssVar = token2CSSVar(key, prefix2);
      cssVars[cssVar] = typeof value === "number" && !unitless2?.[key] ? `${value}px` : String(value);
      result[key] = `var(${cssVar})`;
    }
  });
  return [result, serializeCSSVar(cssVars, themeKey, {
    scope: config?.scope,
    hashCls,
    hashPriority
  })];
};

// node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
var React25 = __toESM(require_react());
var import_react11 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
var webpackHMR = false;
function useDevHMR() {
  return webpackHMR;
}
var useHMR_default = false ? useProdHMR : useDevHMR;
if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
  const win = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : null;
  if (win && typeof win.webpackHotUpdate === "function") {
    const originWebpackHotUpdate = win.webpackHotUpdate;
    win.webpackHotUpdate = (...args) => {
      webpackHMR = true;
      setTimeout(() => {
        webpackHMR = false;
      }, 0);
      return originWebpackHotUpdate(...args);
    };
  }
}

// node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
var effectMap = /* @__PURE__ */ new Map();
function useGlobalCache(prefix2, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
  const {
    cache: globalCache
  } = React25.useContext(StyleContext_default);
  const fullPath = [prefix2, ...keyPath];
  const fullPathStr = pathKey(fullPath);
  const HMRUpdate = useHMR_default();
  const buildCache = (updater) => {
    globalCache.opUpdate(fullPathStr, (prevCache) => {
      const [times = 0, cache] = prevCache || [void 0, void 0];
      let tmpCache = cache;
      if (cache && HMRUpdate) {
        onCacheRemove?.(tmpCache, HMRUpdate);
        tmpCache = null;
      }
      const mergedCache = tmpCache || cacheFn();
      const data = [times, mergedCache];
      return updater ? updater(data) : data;
    });
  };
  React25.useMemo(
    () => {
      buildCache();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [fullPathStr]
    /* eslint-enable */
  );
  let cacheEntity = globalCache.opGet(fullPathStr);
  if (!cacheEntity) {
    buildCache();
    cacheEntity = globalCache.opGet(fullPathStr);
  }
  const cacheContent = cacheEntity[1];
  (0, import_react11.useInsertionEffect)(() => {
    buildCache(([times, cache]) => [times + 1, cache]);
    if (!effectMap.has(fullPathStr)) {
      onCacheEffect?.(cacheContent);
      effectMap.set(fullPathStr, true);
      Promise.resolve().then(() => {
        effectMap.delete(fullPathStr);
      });
    }
    return () => {
      globalCache.opUpdate(fullPathStr, (prevCache) => {
        const [times = 0, cache] = prevCache || [];
        const nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove?.(cache, false);
          effectMap.delete(fullPathStr);
          return null;
        }
        return [times - 1, cache];
      });
    };
  }, [fullPathStr]);
  return cacheContent;
}

// node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var EMPTY_OVERRIDE = {};
var hashPrefix = true ? "css-dev-only-do-not-override" : "css";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
  if (typeof document !== "undefined") {
    const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
    styles.forEach((style2) => {
      if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
        style2.parentNode?.removeChild(style2);
      }
    });
  }
}
var TOKEN_THRESHOLD = -1;
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  const cleanableKeyList = /* @__PURE__ */ new Set();
  tokenKeys.forEach((value, key) => {
    if (value <= 0) cleanableKeyList.add(key);
  });
  if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) {
    cleanableKeyList.forEach((key) => {
      removeStyleTags(key, instanceId);
      tokenKeys.delete(key);
    });
  }
}
var getComputedToken = (originToken, overrideToken, theme, format2) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  let mergedDerivativeToken = {
    ...derivativeToken,
    ...overrideToken
  };
  if (format2) {
    mergedDerivativeToken = format2(mergedDerivativeToken);
  }
  return mergedDerivativeToken;
};
var TOKEN_PREFIX = "token";
function useCacheToken(theme, tokens, option) {
  const {
    cache: {
      instanceId
    },
    container,
    hashPriority
  } = (0, import_react12.useContext)(StyleContext_default);
  const {
    salt = "",
    override = EMPTY_OVERRIDE,
    formatToken: formatToken2,
    getComputedToken: compute,
    cssVar
  } = option;
  const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
  const tokenStr = flattenToken(mergedToken);
  const overrideTokenStr = flattenToken(override);
  const cssVarStr = flattenToken(cssVar);
  const cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], () => {
    const mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken2);
    const actualToken = {
      ...mergedDerivativeToken
    };
    const mergedSalt = `${salt}_${cssVar.prefix}`;
    const hashId = hash_browser_esm_default(mergedSalt);
    const hashCls = `${hashPrefix}-${hash_browser_esm_default(mergedSalt)}`;
    actualToken._tokenKey = token2key(actualToken, mergedSalt);
    const [tokenWithCssVar, cssVarsStr] = transformToken(mergedDerivativeToken, cssVar.key, {
      prefix: cssVar.prefix,
      ignore: cssVar.ignore,
      unitless: cssVar.unitless,
      preserve: cssVar.preserve,
      hashPriority,
      hashCls: cssVar.hashed ? hashCls : void 0
    });
    tokenWithCssVar._hashId = hashId;
    recordCleanToken(cssVar.key);
    return [tokenWithCssVar, hashCls, actualToken, cssVarsStr, cssVar.key];
  }, ([, , , , themeKey]) => {
    cleanTokenStyle(themeKey, instanceId);
  }, ([, , , cssVarsStr, themeKey]) => {
    if (!cssVarsStr) {
      return;
    }
    const style2 = updateCSS(cssVarsStr, hash_browser_esm_default(`css-var-${themeKey}`), {
      mark: ATTR_MARK,
      prepend: "queue",
      attachTo: container,
      priority: -999
    });
    style2[CSS_IN_JS_INSTANCE] = instanceId;
    style2.setAttribute(ATTR_TOKEN, themeKey);
  });
  return cachedToken;
}
var extract = (cache, effectStyles, options) => {
  const [, , realToken, styleStr, cssVarKey] = cache;
  const {
    plain
  } = options || {};
  if (!styleStr) {
    return null;
  }
  const styleId = realToken._tokenKey;
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};

// node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
var import_react13 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var React26 = __toESM(require_react());

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var NAMESPACE = "@namespace";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match2(value, pattern6) {
  return (value = pattern6.exec(value)) ? value[0] : value;
}
function replace(value, pattern6, replacement) {
  return value.replace(pattern6, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array4) {
  return array4.push(value), value;
}
function combine(array4, callback) {
  return array4.map(callback).join("");
}
function filter(array4, pattern6) {
  return array4.filter(function(value) {
    return !match2(value, pattern6);
  });
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type5, props, children, length2, siblings) {
  return { value, root, parent, type: type5, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type5) {
  switch (type5) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type5) {
  return trim(slice(position - 1, delimiter(type5 === 91 ? type5 + 2 : type5 === 40 ? type5 + 1 : type5)));
}
function whitespace3(type5) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type5) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type5) {
  while (next())
    switch (character) {
      // ] ) " '
      case type5:
        return position;
      // " '
      case 34:
      case 39:
        if (type5 !== 34 && type5 !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type5 === 41)
          delimiter(type5);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type5, index) {
  while (next())
    if (type5 + character === 47 + 10)
      break;
    else if (type5 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type5 === 47 ? type5 : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type5 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type5;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace3(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type5, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else {
                switch (atrule) {
                  // c(ontainer)
                  case 99:
                    if (charat(characters2, 3) === 110) break;
                  // l(ayer)
                  case 108:
                    if (charat(characters2, 2) === 97) break;
                  default:
                    offset = 0;
                  // d(ocument) m(edia) s(upports)
                  case 100:
                  case 109:
                  case 115:
                }
                if (offset) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type5, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                else parse(characters2, reference, reference, reference, [""], children, 0, points, children);
              }
        }
        index = offset = property = 0, variable = ampersand = 1, type5 = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type5 = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type5, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset === 0 ? RULESET : type5, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
      return WEBKIT + value + value;
    // mask-composite
    case 4855:
      return WEBKIT + value.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + value;
    // tab-size
    case 4789:
      return MOZ + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    // flex, flex-direction, scroll-snap-type, writing-mode
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match2(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /space-between/, "justify") + WEBKIT + value + value;
    // justify-self
    case 4200:
      if (!match2(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    // grid-template-(columns|rows)
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    // grid-(row|column)-start
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length2 = index, match2(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match2(children, /\d+/) : +match2(children, /\d+/) - +match2(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    // grid-(row|column)-end
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match2(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    // grid-(column|row)
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_, a, b, c, d, e, f) {
        return MS + a + ":" + b + f + (c ? MS + a + "-span:" + (d ? e : +e - +b) + f : "") + value;
      });
    // position: sticky
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    // display: (flex|inline-flex|grid|inline-grid)
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        // (inline-)?fle(x)
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        // (inline-)?gri(d)
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    // scroll-margin, scroll-margin-(top|right|bottom|left)
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify2(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case NAMESPACE:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}
function prefixer(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match2(value, callback = /(::plac\w+|:read-\w+)/)) {
                // :read-(only|write)
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                // :placeholder
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/@ant-design/cssinjs/es/linters/utils.js
function lintWarning(message, info) {
  const {
    path,
    parentSelectors
  } = info;
  warning_default(false, `[Ant Design CSS-in-JS] ${path ? `Error in ${path}: ` : ""}${message}${parentSelectors.length ? ` Selector: ${parentSelectors.join(" | ")}` : ""}`);
}

// node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js
var linter = (key, value, info) => {
  if (key === "content") {
    const contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    const contentValues = ["normal", "none", "initial", "inherit", "unset"];
    if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && !value.startsWith("var(") && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
      lintWarning(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${value}"'\`.`, info);
    }
  }
};
var contentQuotesLinter_default = linter;

// node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js
var linter2 = (key, value, info) => {
  if (key === "animation") {
    if (info.hashId && value !== "none") {
      lintWarning(`You seem to be using hashed animation '${value}', in which case 'animationName' with Keyframe as value is recommended.`, info);
    }
  }
};
var hashedAnimationLinter_default = linter2;

// node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js
var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
var CSS_FILE_STYLE = "_FILE_STYLE__";
var cachePathMap;
var fromCSSFile = true;
function prepare() {
  if (!cachePathMap) {
    cachePathMap = {};
    if (canUseDom()) {
      const div = document.createElement("div");
      div.className = ATTR_CACHE_MAP;
      div.style.position = "fixed";
      div.style.visibility = "hidden";
      div.style.top = "-9999px";
      document.body.appendChild(div);
      let content = getComputedStyle(div).content || "";
      content = content.replace(/^"/, "").replace(/"$/, "");
      content.split(";").forEach((item) => {
        const [path, hash2] = item.split(":");
        cachePathMap[path] = hash2;
      });
      const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
      if (inlineMapStyle) {
        fromCSSFile = false;
        inlineMapStyle.parentNode?.removeChild(inlineMapStyle);
      }
      document.body.removeChild(div);
    }
  }
}
function existPath(path) {
  prepare();
  return !!cachePathMap[path];
}
function getStyleAndHash(path) {
  const hash2 = cachePathMap[path];
  let styleStr = null;
  if (hash2 && canUseDom()) {
    if (fromCSSFile) {
      styleStr = CSS_FILE_STYLE;
    } else {
      const style2 = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
      if (style2) {
        styleStr = style2.innerHTML;
      } else {
        delete cachePathMap[path];
      }
    }
  }
  return [styleStr, hash2];
}

// node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var SKIP_CHECK = "_skip_check_";
var MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr, autoPrefix) {
  const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify2])) : serialize(compile(styleStr), stringify2);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
  return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  const hashClassName = `.${hashId}`;
  const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
  const keys2 = key.split(",").map((k) => {
    const fullPath = k.trim().split(/\s+/);
    let firstPath = fullPath[0] || "";
    const htmlElement = firstPath.match(/^\w+/)?.[0] || "";
    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
    return [firstPath, ...fullPath.slice(1)].join(" ");
  });
  return keys2.join(",");
}
var parseStyle = (interpolation, config = {}, {
  root,
  injectHash,
  parentSelectors
} = {
  root: true,
  parentSelectors: []
}) => {
  const {
    hashId,
    layer,
    path,
    hashPriority,
    transformers = [],
    linters = []
  } = config;
  let styleStr = "";
  let effectStyle = {};
  function parseKeyframes(keyframes) {
    const animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      const [parsedStr] = parseStyle(keyframes.style, config, {
        root: false,
        parentSelectors
      });
      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
    }
  }
  function flattenList(list, fullList = []) {
    list.forEach((item) => {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach((originStyle) => {
    const style2 = typeof originStyle === "string" && !root ? {} : originStyle;
    if (typeof style2 === "string") {
      styleStr += `${style2}
`;
    } else if (style2._keyframe) {
      parseKeyframes(style2);
    } else {
      const mergedStyle = transformers.reduce((prev2, trans) => trans?.visit?.(prev2) || prev2, style2);
      Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          let subInjectHash = false;
          let mergedKey = key.trim();
          let nextRoot = false;
          if ((root || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else if (mergedKey === "&") {
              mergedKey = injectSelectorHash("", hashId, hashPriority);
            } else {
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          const [parsedStr, childEffectStyle] = parseStyle(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [...parentSelectors, mergedKey]
          });
          effectStyle = {
            ...effectStyle,
            ...childEffectStyle
          };
          styleStr += `${mergedKey}${parsedStr}`;
        } else {
          let appendStyle = function(cssKey, cssValue) {
            if (typeof value !== "object" || !value?.[SKIP_CHECK]) {
              [contentQuotesLinter_default, hashedAnimationLinter_default, ...linters].forEach((linter3) => linter3(cssKey, cssValue, {
                path,
                hashId,
                parentSelectors
              }));
            }
            const styleName = cssKey.replace(/[A-Z]/g, (match3) => `-${match3.toLowerCase()}`);
            let formatValue = cssValue;
            if (!unitless_browser_esm_default[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
              formatValue = `${formatValue}px`;
            }
            if (cssKey === "animationName" && cssValue?._keyframe) {
              parseKeyframes(cssValue);
              formatValue = cssValue.getName(hashId);
            }
            styleStr += `${styleName}:${formatValue};`;
          };
          const actualValue = value?.value ?? value;
          if (typeof value === "object" && value?.[MULTI_VALUE] && Array.isArray(actualValue)) {
            actualValue.forEach((item) => {
              appendStyle(key, item);
            });
          } else {
            appendStyle(key, actualValue);
          }
        }
      });
    }
  });
  if (!root) {
    styleStr = `{${styleStr}}`;
  } else if (layer) {
    if (styleStr) {
      styleStr = `@layer ${layer.name} {${styleStr}}`;
    }
    if (layer.dependencies) {
      effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
    }
  }
  return [styleStr, effectStyle];
};
function uniqueHash(path, styleStr) {
  return hash_browser_esm_default(`${path.join("%")}${styleStr}`);
}
var STYLE_PREFIX = "style";
function useStyleRegister(info, styleFn) {
  const {
    path,
    hashId,
    layer,
    nonce,
    clientOnly,
    order = 0
  } = info;
  const {
    mock,
    hashPriority,
    container,
    transformers,
    linters,
    cache,
    layer: enableLayer,
    autoPrefix
  } = React26.useContext(StyleContext_default);
  const fullPath = [hashId || ""];
  if (enableLayer) {
    fullPath.push("layer");
  }
  fullPath.push(...path);
  let isMergedClientSide = isClientSide;
  if (mock !== void 0) {
    isMergedClientSide = mock === "client";
  }
  useGlobalCache(
    STYLE_PREFIX,
    fullPath,
    // Create cache if needed
    () => {
      const cachePath = fullPath.join("|");
      if (existPath(cachePath)) {
        const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
        if (inlineCacheStyleStr) {
          return [inlineCacheStyleStr, styleHash, {}, clientOnly, order];
        }
      }
      const styleObj = styleFn();
      const [parsedStyle, effectStyle] = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer: enableLayer ? layer : void 0,
        path: path.join("-"),
        transformers,
        linters
      });
      const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);
      const styleId = uniqueHash(fullPath, styleStr);
      return [styleStr, styleId, effectStyle, clientOnly, order];
    },
    // Remove cache if no need
    (cacheValue, fromHMR) => {
      const [, styleId] = cacheValue;
      if (fromHMR && isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK,
          attachTo: container
        });
      }
    },
    // Effect: Inject style here
    (cacheValue) => {
      const [styleStr, styleId, effectStyle, , priority] = cacheValue;
      if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
        const mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: enableLayer ? false : "queue",
          attachTo: container,
          priority
        };
        const nonceStr = typeof nonce === "function" ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = {
            nonce: nonceStr
          };
        }
        const effectLayerKeys = [];
        const effectRestKeys = [];
        Object.keys(effectStyle).forEach((key) => {
          if (key.startsWith("@layer")) {
            effectLayerKeys.push(key);
          } else {
            effectRestKeys.push(key);
          }
        });
        effectLayerKeys.forEach((effectKey) => {
          updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {
            ...mergedCSSConfig,
            prepend: true
          });
        });
        const style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
        style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
        if (true) {
          style2.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
        }
        effectRestKeys.forEach((effectKey) => {
          updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);
        });
      }
    }
  );
}
var extract2 = (cache, effectStyles, options) => {
  const [styleStr, styleId, effectStyle, clientOnly, order] = cache;
  const {
    plain,
    autoPrefix
  } = options || {};
  if (clientOnly) {
    return null;
  }
  let keyStyleText = styleStr;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  keyStyleText = toStyleStr(styleStr, void 0, styleId, sharedAttrs, plain);
  if (effectStyle) {
    Object.keys(effectStyle).forEach((effectKey) => {
      if (!effectStyles[effectKey]) {
        effectStyles[effectKey] = true;
        const effectStyleStr = normalizeStyle(effectStyle[effectKey], autoPrefix || false);
        const effectStyleHTML = toStyleStr(effectStyleStr, void 0, `_effect-${effectKey}`, sharedAttrs, plain);
        if (effectKey.startsWith("@layer")) {
          keyStyleText = effectStyleHTML + keyStyleText;
        } else {
          keyStyleText += effectStyleHTML;
        }
      }
    });
  }
  return [order, styleId, keyStyleText];
};

// node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
var CSS_VAR_PREFIX = "cssVar";
var useCSSVarRegister = (config, fn) => {
  const {
    key,
    prefix: prefix2,
    unitless: unitless2,
    ignore: ignore2,
    token: token2,
    hashId,
    scope = ""
  } = config;
  const {
    cache: {
      instanceId
    },
    container,
    hashPriority
  } = (0, import_react13.useContext)(StyleContext_default);
  const {
    _tokenKey: tokenKey
  } = token2;
  const stylePath = [...config.path, key, scope, tokenKey];
  const cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, () => {
    const originToken = fn();
    const [mergedToken, cssVarsStr] = transformToken(originToken, key, {
      prefix: prefix2,
      unitless: unitless2,
      ignore: ignore2,
      scope,
      hashPriority,
      hashCls: hashId
    });
    const styleId = uniqueHash(stylePath, cssVarsStr);
    return [mergedToken, cssVarsStr, styleId, key];
  }, ([, , styleId]) => {
    if (isClientSide) {
      removeCSS(styleId, {
        mark: ATTR_MARK,
        attachTo: container
      });
    }
  }, ([, cssVarsStr, styleId]) => {
    if (!cssVarsStr) {
      return;
    }
    const style2 = updateCSS(cssVarsStr, styleId, {
      mark: ATTR_MARK,
      prepend: "queue",
      attachTo: container,
      priority: -999
    });
    style2[CSS_IN_JS_INSTANCE] = instanceId;
    style2.setAttribute(ATTR_TOKEN, key);
  });
  return cache;
};
var extract3 = (cache, effectStyles, options) => {
  const [, styleStr, styleId, cssVarKey] = cache;
  const {
    plain
  } = options || {};
  if (!styleStr) {
    return null;
  }
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};
var useCSSVarRegister_default = useCSSVarRegister;

// node_modules/@ant-design/cssinjs/es/extractStyle.js
var ExtractStyleFns = {
  [STYLE_PREFIX]: extract2,
  [TOKEN_PREFIX]: extract,
  [CSS_VAR_PREFIX]: extract3
};

// node_modules/@ant-design/cssinjs/es/Keyframes.js
var Keyframe = class {
  name;
  style;
  constructor(name, style2) {
    this.name = name;
    this.style = style2;
  }
  getName(hashId = "") {
    return hashId ? `${hashId}-${this.name}` : this.name;
  }
  _keyframe = true;
};
var Keyframes_default = Keyframe;

// node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js
function noSplit(list) {
  list.notSplit = true;
  return list;
}
var keyMap = {
  // Inset
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  // Margin
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  // Padding
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  // Border
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  // Border width
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  // Border style
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  // Border color
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  // Border radius
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
};

// node_modules/antd/es/version/version.js
var version_default = "6.1.1";

// node_modules/antd/es/version/index.js
var version_default2 = version_default;

// node_modules/antd/es/theme/context.js
var import_react14 = __toESM(require_react());

// node_modules/antd/es/theme/themes/seed.js
var defaultPresetColors = {
  blue: "#1677FF",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  /**
   * @deprecated Use magenta instead
   */
  pink: "#EB2F96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
var seedToken = {
  // preset color palettes
  ...defaultPresetColors,
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: false,
  // Motion
  motion: true
};
var seed_default = seedToken;

// node_modules/antd/es/theme/themes/shared/genColorMapToken.js
function genColorMapToken(seed, {
  generateColorPalettes: generateColorPalettes2,
  generateNeutralColorPalettes: generateNeutralColorPalettes2
}) {
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed;
  const primaryColors = generateColorPalettes2(colorPrimaryBase);
  const successColors = generateColorPalettes2(colorSuccessBase);
  const warningColors = generateColorPalettes2(colorWarningBase);
  const errorColors = generateColorPalettes2(colorErrorBase);
  const infoColors = generateColorPalettes2(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
  const colorLink = seed.colorLink || seed.colorInfo;
  const linkColors = generateColorPalettes2(colorLink);
  const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
  return {
    ...neutralColors,
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBgFilledHover,
    colorErrorBgActive: errorColors[3],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorLinkHover: linkColors[4],
    colorLink: linkColors[6],
    colorLinkActive: linkColors[7],
    colorBgMask: new FastColor("#000").setA(0.45).toRgbString(),
    colorWhite: "#fff"
  };
}

// node_modules/antd/es/theme/themes/shared/genRadius.js
var genRadius = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
var genRadius_default = genRadius;

// node_modules/antd/es/theme/themes/shared/genCommonMapToken.js
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return {
    // motion
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    // line
    lineWidthBold: lineWidth + 1,
    // radius
    ...genRadius_default(borderRadius)
  };
}

// node_modules/antd/es/theme/themes/shared/genControlHeight.js
var genControlHeight = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
var genControlHeight_default = genControlHeight;

// node_modules/antd/es/theme/themes/shared/genFontSizes.js
function getLineHeight(fontSize) {
  return (fontSize + 8) / fontSize;
}
function getFontSizes(base) {
  const fontSizes = Array.from({
    length: 10
  }).map((_, index) => {
    const i = index - 1;
    const baseSize = base * Math.E ** (i / 5);
    const intSize = index > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base;
  return fontSizes.map((size) => ({
    size,
    lineHeight: getLineHeight(size)
  }));
}

// node_modules/antd/es/theme/themes/shared/genFontMapToken.js
var genFontMapToken = (fontSize) => {
  const fontSizePairs = getFontSizes(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  const fontSizeMD = fontSizes[1];
  const fontSizeSM = fontSizes[0];
  const fontSizeLG = fontSizes[2];
  const lineHeight = lineHeights[1];
  const lineHeightSM = lineHeights[0];
  const lineHeightLG = lineHeights[2];
  return {
    fontSizeSM,
    fontSize: fontSizeMD,
    fontSizeLG,
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight,
    lineHeightLG,
    lineHeightSM,
    fontHeight: Math.round(lineHeight * fontSizeMD),
    fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
    fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
var genFontMapToken_default = genFontMapToken;

// node_modules/antd/es/theme/themes/shared/genSizeMapToken.js
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    // 48
    sizeXL: sizeUnit * (sizeStep + 4),
    // 32
    sizeLG: sizeUnit * (sizeStep + 2),
    // 24
    sizeMD: sizeUnit * (sizeStep + 1),
    // 20
    sizeMS: sizeUnit * sizeStep,
    // 16
    size: sizeUnit * sizeStep,
    // 16
    sizeSM: sizeUnit * (sizeStep - 1),
    // 12
    sizeXS: sizeUnit * (sizeStep - 2),
    // 8
    sizeXXS: sizeUnit * (sizeStep - 3)
    // 4
  };
}

// node_modules/antd/es/theme/themes/default/colorAlgorithm.js
var getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
var getSolidColor = (baseColor, brightness) => {
  const instance = new FastColor(baseColor);
  return instance.darken(brightness).toHexString();
};

// node_modules/antd/es/theme/themes/default/colors.js
var generateColorPalettes = (baseColor) => {
  const colors = generate(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
  };
};
var generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.02),
    colorBgSolid: getAlphaColor(colorTextBase, 1),
    colorBgSolidHover: getAlphaColor(colorTextBase, 0.75),
    colorBgSolidActive: getAlphaColor(colorTextBase, 0.95),
    colorBgLayout: getSolidColor(colorBgBase, 4),
    colorBgContainer: getSolidColor(colorBgBase, 0),
    colorBgElevated: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor(colorTextBase, 0.85),
    colorBgBlur: "transparent",
    colorBorder: getSolidColor(colorBgBase, 15),
    colorBorderDisabled: getSolidColor(colorBgBase, 15),
    colorBorderSecondary: getSolidColor(colorBgBase, 6)
  };
};

// node_modules/antd/es/theme/themes/default/index.js
function derivative(token2) {
  presetPrimaryColors.pink = presetPrimaryColors.magenta;
  presetPalettes.pink = presetPalettes.magenta;
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate(token2[colorKey]);
    return Array.from({
      length: 10
    }, () => 1).reduce((prev2, _, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors[i];
      prev2[`${colorKey}${i + 1}`] = colors[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = {
      ...prev2,
      ...cur
    };
    return prev2;
  }, {});
  return {
    ...token2,
    ...colorPalettes,
    // Colors
    ...genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    }),
    // Font
    ...genFontMapToken_default(token2.fontSize),
    // Size
    ...genSizeMapToken(token2),
    // Height
    ...genControlHeight_default(token2),
    // Others
    ...genCommonMapToken(token2)
  };
}

// node_modules/antd/es/theme/themes/default/theme.js
var defaultTheme = createTheme(derivative);
var theme_default = defaultTheme;

// node_modules/antd/es/theme/context.js
var defaultConfig = {
  token: seed_default,
  override: {
    override: seed_default
  },
  hashed: true
};
var DesignTokenContext = import_react14.default.createContext(defaultConfig);

// node_modules/antd/es/theme/util/getAlphaColor.js
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
function getAlphaColor2(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new FastColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new FastColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r = Math.round((fR - bR * (1 - fA)) / fA);
    const g = Math.round((fG - bG * (1 - fA)) / fA);
    const b = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r) && isStableColor(g) && isStableColor(b)) {
      return new FastColor({
        r,
        g,
        b,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new FastColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var getAlphaColor_default = getAlphaColor2;

// node_modules/antd/es/theme/util/alias.js
function formatToken(derivativeToken) {
  const {
    override,
    ...restToken
  } = derivativeToken;
  const overrideTokens = {
    ...override
  };
  Object.keys(seed_default).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = {
    ...restToken,
    ...overrideTokens
  };
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  if (mergedToken.motion === false) {
    const fastDuration = "0s";
    mergedToken.motionDurationFast = fastDuration;
    mergedToken.motionDurationMid = fastDuration;
    mergedToken.motionDurationSlow = fastDuration;
  }
  const aliasToken = {
    ...mergedToken,
    // ============== Background ============== //
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    // Font
    fontSizeIcon: mergedToken.fontSizeSM,
    // Line
    lineWidthFocus: mergedToken.lineWidth * 3,
    // Control
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    // Override AliasToken
    ...overrideTokens
  };
  return aliasToken;
}

// node_modules/antd/es/theme/useToken.js
var unitless = {
  lineHeight: true,
  lineHeightSM: true,
  lineHeightLG: true,
  lineHeightHeading1: true,
  lineHeightHeading2: true,
  lineHeightHeading3: true,
  lineHeightHeading4: true,
  lineHeightHeading5: true,
  opacityLoading: true,
  fontWeightStrong: true,
  zIndexPopupBase: true,
  zIndexBase: true,
  opacityImage: true
};
var ignore = {
  motionBase: true,
  motionUnit: true
};
var preserve = {
  screenXS: true,
  screenXSMin: true,
  screenXSMax: true,
  screenSM: true,
  screenSMMin: true,
  screenSMMax: true,
  screenMD: true,
  screenMDMin: true,
  screenMDMax: true,
  screenLG: true,
  screenLGMin: true,
  screenLGMax: true,
  screenXL: true,
  screenXLMin: true,
  screenXLMax: true,
  screenXXL: true,
  screenXXLMin: true
};
var getComputedToken2 = (originToken, overrideToken, theme) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  const {
    override,
    ...components2
  } = overrideToken;
  let mergedDerivativeToken = {
    ...derivativeToken,
    override
  };
  mergedDerivativeToken = formatToken(mergedDerivativeToken);
  if (components2) {
    Object.entries(components2).forEach(([key, value]) => {
      const {
        theme: componentTheme,
        ...componentTokens
      } = value;
      let mergedComponentToken = componentTokens;
      if (componentTheme) {
        mergedComponentToken = getComputedToken2({
          ...mergedDerivativeToken,
          ...componentTokens
        }, {
          override: componentTokens
        }, componentTheme);
      }
      mergedDerivativeToken[key] = mergedComponentToken;
    });
  }
  return mergedDerivativeToken;
};
function useToken() {
  const {
    token: rootDesignToken,
    hashed,
    theme,
    override,
    cssVar: ctxCssVar,
    zeroRuntime
  } = import_react15.default.useContext(DesignTokenContext);
  const cssVar = {
    prefix: ctxCssVar?.prefix ?? "ant",
    key: ctxCssVar?.key ?? "css-var-root"
  };
  const salt = `${version_default2}-${hashed || ""}`;
  const mergedTheme = theme || theme_default;
  const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seed_default, rootDesignToken], {
    salt,
    override,
    getComputedToken: getComputedToken2,
    cssVar: {
      ...cssVar,
      unitless,
      ignore,
      preserve
    }
  });
  return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar, !!zeroRuntime];
}

// node_modules/antd/es/_util/zindexContext.js
var import_react16 = __toESM(require_react());
var zIndexContext = import_react16.default.createContext(void 0);
if (true) {
  zIndexContext.displayName = "zIndexContext";
}
var zindexContext_default = zIndexContext;

// node_modules/antd/es/_util/hooks/useZIndex.js
var CONTAINER_OFFSET = 100;
var CONTAINER_OFFSET_MAX_COUNT = 10;
var CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
var CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET;
var containerBaseZIndexOffset = {
  Modal: CONTAINER_OFFSET,
  Drawer: CONTAINER_OFFSET,
  Popover: CONTAINER_OFFSET,
  Popconfirm: CONTAINER_OFFSET,
  Tooltip: CONTAINER_OFFSET,
  Tour: CONTAINER_OFFSET,
  FloatButton: CONTAINER_OFFSET
};
var consumerBaseZIndexOffset = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
var isContainerType = (type5) => {
  return type5 in containerBaseZIndexOffset;
};
var useZIndex = (componentType, customZIndex) => {
  const [, token2] = useToken();
  const parentZIndex = import_react17.default.useContext(zindexContext_default);
  const isContainer = isContainerType(componentType);
  let result;
  if (customZIndex !== void 0) {
    result = [customZIndex, customZIndex];
  } else {
    let zIndex = parentZIndex ?? 0;
    if (isContainer) {
      zIndex += // Use preset token zIndex by default but not stack when has parent container
      (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
      containerBaseZIndexOffset[componentType];
    } else {
      zIndex += consumerBaseZIndexOffset[componentType];
    }
    result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
  }
  if (true) {
    const warning5 = devUseWarning(componentType);
    const maxZIndex = token2.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN;
    const currentZIndex = result[0] || 0;
    true ? warning5(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.") : void 0;
  }
  return result;
};

// node_modules/antd/es/config-provider/index.js
var React68 = __toESM(require_react());

// node_modules/antd/es/form/validateMessagesContext.js
var import_react18 = __toESM(require_react());
var validateMessagesContext_default = (0, import_react18.createContext)(void 0);

// node_modules/antd/es/tooltip/UniqueProvider/index.js
var import_react26 = __toESM(require_react());

// node_modules/@rc-component/portal/es/Portal.js
var React34 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@rc-component/portal/es/Context.js
var React31 = __toESM(require_react());
var OrderContext = React31.createContext(null);
var Context_default2 = OrderContext;

// node_modules/@rc-component/portal/es/mock.js
var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === "boolean") {
    inline = nextInline;
  }
  return inline;
}

// node_modules/@rc-component/portal/es/useDom.js
var React32 = __toESM(require_react());
var EMPTY_LIST = [];
function useDom(render, debug) {
  const [ele] = React32.useState(() => {
    if (!canUseDom()) {
      return null;
    }
    const defaultEle = document.createElement("div");
    if (debug) {
      defaultEle.setAttribute("data-debug", debug);
    }
    return defaultEle;
  });
  const appendedRef = React32.useRef(false);
  const queueCreate = React32.useContext(Context_default2);
  const [queue, setQueue] = React32.useState(EMPTY_LIST);
  const mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : (appendFn) => {
    setQueue((origin) => {
      const newQueue = [appendFn, ...origin];
      return newQueue;
    });
  });
  function append2() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  function cleanup2() {
    ele.parentElement?.removeChild(ele);
    appendedRef.current = false;
  }
  useLayoutEffect_default(() => {
    if (render) {
      if (queueCreate) {
        queueCreate(append2);
      } else {
        append2();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render]);
  useLayoutEffect_default(() => {
    if (queue.length) {
      queue.forEach((appendFn) => appendFn());
      setQueue(EMPTY_LIST);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}

// node_modules/@rc-component/portal/es/useScrollLocker.js
var React33 = __toESM(require_react());

// node_modules/@rc-component/util/es/getScrollBarSize.js
var cached;
function measureScrollbarSize(ele) {
  const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
  const measureEle = document.createElement("div");
  measureEle.id = randomId;
  const measureStyle = measureEle.style;
  measureStyle.position = "absolute";
  measureStyle.left = "0";
  measureStyle.top = "0";
  measureStyle.width = "100px";
  measureStyle.height = "100px";
  measureStyle.overflow = "scroll";
  let fallbackWidth;
  let fallbackHeight;
  if (ele) {
    const targetStyle = getComputedStyle(ele);
    measureStyle.scrollbarColor = targetStyle.scrollbarColor;
    measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
    const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
    const width = parseInt(webkitScrollbarStyle.width, 10);
    const height = parseInt(webkitScrollbarStyle.height, 10);
    try {
      const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : "";
      const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : "";
      updateCSS(`
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`, randomId);
    } catch (e) {
      console.error(e);
      fallbackWidth = width;
      fallbackHeight = height;
    }
  }
  document.body.appendChild(measureEle);
  const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
  const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
  document.body.removeChild(measureEle);
  removeCSS(randomId);
  return {
    width: scrollWidth,
    height: scrollHeight
  };
}
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    cached = measureScrollbarSize();
  }
  return cached.width;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  return measureScrollbarSize(target);
}

// node_modules/@rc-component/portal/es/util.js
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

// node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID = `rc-util-locker-${Date.now()}`;
var uuid2 = 0;
function useScrollLocker(lock) {
  const mergedLock = !!lock;
  const [id] = React33.useState(() => {
    uuid2 += 1;
    return `${UNIQUE_ID}_${uuid2}`;
  });
  useLayoutEffect_default(() => {
    if (mergedLock) {
      const scrollbarSize = getTargetScrollBarSize(document.body).width;
      const isOverflow = isBodyOverflowing();
      updateCSS(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
    } else {
      removeCSS(id);
    }
    return () => {
      removeCSS(id);
    };
  }, [mergedLock, id]);
}

// node_modules/@rc-component/portal/es/Portal.js
var getPortalContainer = (getContainer) => {
  if (getContainer === false) {
    return false;
  }
  if (!canUseDom() || !getContainer) {
    return null;
  }
  if (typeof getContainer === "string") {
    return document.querySelector(getContainer);
  }
  if (typeof getContainer === "function") {
    return getContainer();
  }
  return getContainer;
};
var Portal = React34.forwardRef((props, ref) => {
  const {
    open,
    autoLock,
    getContainer,
    debug,
    autoDestroy = true,
    children
  } = props;
  const [shouldRender, setShouldRender] = React34.useState(open);
  const mergedRender = shouldRender || open;
  if (true) {
    warning_default(canUseDom() || !open, `Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.`);
  }
  React34.useEffect(() => {
    if (autoDestroy || open) {
      setShouldRender(open);
    }
  }, [open, autoDestroy]);
  const [innerContainer, setInnerContainer] = React34.useState(() => getPortalContainer(getContainer));
  React34.useEffect(() => {
    const customizeContainer = getPortalContainer(getContainer);
    setInnerContainer(customizeContainer ?? null);
  });
  const [defaultContainer, queueCreate] = useDom(mergedRender && !innerContainer, debug);
  const mergedContainer = innerContainer ?? defaultContainer;
  useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
  let childRef = null;
  if (children && supportRef(children) && ref) {
    childRef = getNodeRef(children);
  }
  const mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0) {
    return null;
  }
  const renderInline = mergedContainer === false || inlineMock();
  let reffedChildren = children;
  if (ref) {
    reffedChildren = React34.cloneElement(children, {
      ref: mergedRef
    });
  }
  return React34.createElement(Context_default2.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : (0, import_react_dom.createPortal)(reffedChildren, mergedContainer));
});
if (true) {
  Portal.displayName = "Portal";
}
var Portal_default = Portal;

// node_modules/@rc-component/portal/es/index.js
var es_default3 = Portal_default;

// node_modules/@rc-component/resize-observer/es/index.js
var React37 = __toESM(require_react());

// node_modules/@rc-component/util/es/Dom/findDOMNode.js
function isDOM(node2) {
  return node2 instanceof HTMLElement || node2 instanceof SVGElement;
}
function getDOM(node2) {
  if (node2 && typeof node2 === "object" && isDOM(node2.nativeElement)) {
    return node2.nativeElement;
  }
  if (isDOM(node2)) {
    return node2;
  }
  return null;
}

// node_modules/@rc-component/resize-observer/es/SingleObserver/index.js
var React36 = __toESM(require_react());

// node_modules/@rc-component/resize-observer/es/Collection.js
var React35 = __toESM(require_react());
var CollectionContext = React35.createContext(null);
function Collection({
  children,
  onBatchResize
}) {
  const resizeIdRef = React35.useRef(0);
  const resizeInfosRef = React35.useRef([]);
  const onCollectionResize = React35.useContext(CollectionContext);
  const onResize2 = React35.useCallback((size, element, data) => {
    resizeIdRef.current += 1;
    const currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data
    });
    Promise.resolve().then(() => {
      if (currentId === resizeIdRef.current) {
        onBatchResize?.(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize?.(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return React35.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}

// node_modules/@rc-component/resize-observer/es/utils/observerUtil.js
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach((entity) => {
    const {
      target
    } = entity;
    elementListeners.get(target)?.forEach((listener) => listener(target));
  });
}
var observer;
function ensureResizeObserver() {
  if (!observer) {
    observer = new ResizeObserver(onResize);
  }
  return observer;
}
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    ensureResizeObserver().observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      ensureResizeObserver().unobserve(element);
      elementListeners.delete(element);
    }
  }
}

// node_modules/@rc-component/resize-observer/es/SingleObserver/index.js
function SingleObserver(props, ref) {
  const {
    children,
    disabled
  } = props;
  const elementRef = React36.useRef(null);
  const onCollectionResize = React36.useContext(CollectionContext);
  const isRenderProps = typeof children === "function";
  const mergedChildren = isRenderProps ? children(elementRef) : children;
  const sizeRef = React36.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  const canRef = !isRenderProps && React36.isValidElement(mergedChildren) && supportRef(mergedChildren);
  const originRef = canRef ? getNodeRef(mergedChildren) : null;
  const mergedRef = useComposeRef(originRef, elementRef);
  const getDomElement = () => {
    return getDOM(elementRef.current);
  };
  React36.useImperativeHandle(ref, () => getDomElement());
  const propsRef = React36.useRef(props);
  propsRef.current = props;
  const onInternalResize = React36.useCallback((target) => {
    const {
      onResize: onResize2,
      data
    } = propsRef.current;
    const {
      width,
      height
    } = target.getBoundingClientRect();
    const {
      offsetWidth,
      offsetHeight
    } = target;
    const fixedWidth = Math.floor(width);
    const fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      const size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      const sizeInfo = {
        ...size,
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      };
      onCollectionResize?.(sizeInfo, target, data);
      if (onResize2) {
        Promise.resolve().then(() => {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  React36.useEffect(() => {
    const currentElement = getDomElement();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return () => unobserve(currentElement, onInternalResize);
  }, [elementRef.current, disabled]);
  return canRef ? React36.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren;
}
var RefSingleObserver = React36.forwardRef(SingleObserver);
if (true) {
  RefSingleObserver.displayName = "SingleObserver";
}
var SingleObserver_default = RefSingleObserver;

// node_modules/@rc-component/resize-observer/es/index.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver2(props, ref) {
  const {
    children
  } = props;
  const childNodes = typeof children === "function" ? [children] : toArray(children);
  if (true) {
    if (childNodes.length > 1) {
      warning(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.");
    } else if (childNodes.length === 0) {
      warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
    }
  }
  return childNodes.map((child, index) => {
    const key = child?.key || `${INTERNAL_PREFIX_KEY}-${index}`;
    return React37.createElement(SingleObserver_default, _extends3({}, props, {
      key,
      ref: index === 0 ? ref : void 0
    }), child);
  });
}
var RefResizeObserver = React37.forwardRef(ResizeObserver2);
if (true) {
  RefResizeObserver.displayName = "ResizeObserver";
}
RefResizeObserver.Collection = Collection;
var es_default4 = RefResizeObserver;

// node_modules/@rc-component/util/es/hooks/useId.js
var React38 = __toESM(require_react());
function getUseId() {
  const fullClone = {
    ...React38
  };
  return fullClone.useId;
}
var uuid3 = 0;
var useOriginId = getUseId();
var useId_default = useOriginId ? (
  // Use React `useId`
  function useId(id) {
    const reactId = useOriginId();
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return reactId;
  }
) : (
  // Use compatible of `useId`
  function useCompatId(id) {
    const [innerId, setInnerId] = React38.useState("ssr-id");
    React38.useEffect(() => {
      const nextId = uuid3;
      uuid3 += 1;
      setInnerId(`rc_unique_${nextId}`);
    }, []);
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return innerId;
  }
);

// node_modules/@rc-component/trigger/es/index.js
var React59 = __toESM(require_react());

// node_modules/@rc-component/motion/es/CSSMotion.js
var React45 = __toESM(require_react());
var import_react22 = __toESM(require_react());

// node_modules/@rc-component/motion/es/context.js
var React39 = __toESM(require_react());
var Context2 = React39.createContext({});
function MotionProvider({
  children,
  ...props
}) {
  return React39.createElement(Context2.Provider, {
    value: props
  }, children);
}

// node_modules/@rc-component/util/es/hooks/useSyncState.js
var React40 = __toESM(require_react());
function useSyncState2(defaultValue) {
  const [, forceUpdate] = React40.useReducer((x) => x + 1, 0);
  const currentValueRef = React40.useRef(defaultValue);
  const getValue2 = useEvent_default(() => {
    return currentValueRef.current;
  });
  const setValue = useEvent_default((updater) => {
    currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
    forceUpdate();
  });
  return [getValue2, setValue];
}

// node_modules/@rc-component/motion/es/hooks/useStatus.js
var React44 = __toESM(require_react());
var import_react21 = __toESM(require_react());

// node_modules/@rc-component/motion/es/interface.js
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
var STEP_PREPARED = "prepared";

// node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js
var React41 = __toESM(require_react());
var import_react19 = __toESM(require_react());

// node_modules/@rc-component/motion/es/util/motion.js
function makePrefixMap(styleProp, eventName) {
  const prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
  prefixes[`Moz${styleProp}`] = `moz${eventName}`;
  prefixes[`ms${styleProp}`] = `MS${eventName}`;
  prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  const prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) {
  ({
    style
  } = document.createElement("div"));
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  const prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    const stylePropList = Object.keys(prefixMap);
    const len = stylePropList.length;
    for (let i = 0; i < len; i += 1) {
      const styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(transitionName, transitionType) {
  if (!transitionName) return null;
  if (typeof transitionName === "object") {
    const type5 = transitionType.replace(/-\w/g, (match3) => match3[1].toUpperCase());
    return transitionName[type5];
  }
  return `${transitionName}-${transitionType}`;
}

// node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js
var useDomMotionEvents_default = ((onInternalMotionEnd) => {
  const cacheElementRef = (0, import_react19.useRef)();
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  React41.useEffect(() => () => {
    removeMotionEvents(cacheElementRef.current);
    cacheElementRef.current = null;
  }, []);
  return [patchMotionEvents, removeMotionEvents];
});

// node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js
var import_react20 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDom() ? import_react20.useLayoutEffect : import_react20.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

// node_modules/@rc-component/motion/es/hooks/useStepQueue.js
var React43 = __toESM(require_react());

// node_modules/@rc-component/util/es/raf.js
var raf = (callback) => +setTimeout(callback, 16);
var caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = (callback) => window.requestAnimationFrame(callback);
  caf = (handle) => window.cancelAnimationFrame(handle);
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf = (callback, times = 1) => {
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(id);
  return caf(realId);
};
if (true) {
  wrapperRaf.ids = () => rafIds;
}
var raf_default = wrapperRaf;

// node_modules/@rc-component/motion/es/hooks/useNextFrame.js
var React42 = __toESM(require_react());
var useNextFrame_default = (() => {
  const nextFrameRef = React42.useRef(null);
  function cancelNextFrame() {
    raf_default.cancel(nextFrameRef.current);
  }
  function nextFrame(callback, delay = 2) {
    cancelNextFrame();
    const nextFrameId = raf_default(() => {
      if (delay <= 1) {
        callback({
          isCanceled: () => nextFrameId !== nextFrameRef.current
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  React42.useEffect(() => () => {
    cancelNextFrame();
  }, []);
  return [nextFrame, cancelNextFrame];
});

// node_modules/@rc-component/motion/es/hooks/useStepQueue.js
var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue_default = ((status, prepareOnly, callback) => {
  const [step, setStep] = useSafeState(STEP_NONE);
  const [nextFrame, cancelNextFrame] = useNextFrame_default();
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  useIsomorphicLayoutEffect_default(() => {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      const index = STEP_QUEUE.indexOf(step);
      const nextStep = STEP_QUEUE[index + 1];
      const result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else if (nextStep) {
        nextFrame((info) => {
          function doNext() {
            if (info.isCanceled()) return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  React43.useEffect(() => () => {
    cancelNextFrame();
  }, []);
  return [startQueue, step];
});

// node_modules/@rc-component/motion/es/hooks/useStatus.js
function useStatus(supportMotion, visible, getElement, {
  motionEnter = true,
  motionAppear = true,
  motionLeave = true,
  motionDeadline,
  motionLeaveImmediately,
  onAppearPrepare,
  onEnterPrepare,
  onLeavePrepare,
  onAppearStart,
  onEnterStart,
  onLeaveStart,
  onAppearActive,
  onEnterActive,
  onLeaveActive,
  onAppearEnd,
  onEnterEnd,
  onLeaveEnd,
  onVisibleChanged
}) {
  const [asyncVisible, setAsyncVisible] = useSafeState();
  const [getStatus, setStatus] = useSyncState2(STATUS_NONE);
  const [style2, setStyle] = useSafeState(null);
  const currentStatus = getStatus();
  const mountedRef = (0, import_react21.useRef)(false);
  const deadlineRef = (0, import_react21.useRef)(null);
  function getDomElement() {
    return getElement();
  }
  const activeRef = (0, import_react21.useRef)(false);
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE);
    setStyle(null, true);
  }
  const onInternalMotionEnd = useEvent_default((event) => {
    const status = getStatus();
    if (status === STATUS_NONE) {
      return;
    }
    const element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    const currentActive = activeRef.current;
    let canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd?.(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd?.(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd?.(element, event);
    }
    if (currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  });
  const [patchMotionEvents] = useDomMotionEvents_default(onInternalMotionEnd);
  const getEventHandlers = (targetStatus) => {
    switch (targetStatus) {
      case STATUS_APPEAR:
        return {
          [STEP_PREPARE]: onAppearPrepare,
          [STEP_START]: onAppearStart,
          [STEP_ACTIVE]: onAppearActive
        };
      case STATUS_ENTER:
        return {
          [STEP_PREPARE]: onEnterPrepare,
          [STEP_START]: onEnterStart,
          [STEP_ACTIVE]: onEnterActive
        };
      case STATUS_LEAVE:
        return {
          [STEP_PREPARE]: onLeavePrepare,
          [STEP_START]: onLeaveStart,
          [STEP_ACTIVE]: onLeaveActive
        };
      default:
        return {};
    }
  };
  const eventHandlers = React44.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);
  const [startStep, step] = useStepQueue_default(currentStatus, !supportMotion, (newStep) => {
    if (newStep === STEP_PREPARE) {
      const onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      setStyle(eventHandlers[step]?.(getDomElement(), null) || null);
    }
    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(() => {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    if (step === STEP_PREPARED) {
      updateMotionEndStatus();
    }
    return DoStep;
  });
  const active = isActive(step);
  activeRef.current = active;
  const visibleRef = (0, import_react21.useRef)(null);
  useIsomorphicLayoutEffect_default(() => {
    if (mountedRef.current && visibleRef.current === visible) {
      return;
    }
    setAsyncVisible(visible);
    const isMounted = mountedRef.current;
    mountedRef.current = true;
    let nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    const nextEventHandlers = getEventHandlers(nextStatus);
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      setStatus(STATUS_NONE);
    }
    visibleRef.current = visible;
  }, [visible]);
  (0, import_react21.useEffect)(() => {
    if (
      // Cancel appear
      currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter
      currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave
      currentStatus === STATUS_LEAVE && !motionLeave
    ) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  (0, import_react21.useEffect)(() => () => {
    mountedRef.current = false;
    clearTimeout(deadlineRef.current);
  }, []);
  const firstMountChangeRef = React44.useRef(false);
  (0, import_react21.useEffect)(() => {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged?.(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, currentStatus]);
  let mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = {
      transition: "none",
      ...mergedStyle
    };
  }
  return [getStatus, step, mergedStyle, asyncVisible ?? visible];
}

// node_modules/@rc-component/motion/es/CSSMotion.js
function genCSSMotion(config) {
  let transitionSupport = config;
  if (typeof config === "object") {
    ({
      transitionSupport
    } = config);
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  const CSSMotion = React45.forwardRef((props, ref) => {
    const {
      // Default config
      visible = true,
      removeOnLeave = true,
      forceRender,
      children,
      motionName,
      leavedClassName,
      eventProps
    } = props;
    const {
      motion: contextMotion
    } = React45.useContext(Context2);
    const supportMotion = isSupportTransition(props, contextMotion);
    const nodeRef = (0, import_react22.useRef)();
    function getDomElement() {
      return getDOM(nodeRef.current);
    }
    const [getStatus, statusStep, statusStyle, mergedVisible] = useStatus(supportMotion, visible, getDomElement, props);
    const status = getStatus();
    const renderedRef = React45.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    const refObj = React45.useMemo(() => {
      const obj = {};
      Object.defineProperties(obj, {
        nativeElement: {
          enumerable: true,
          get: getDomElement
        },
        inMotion: {
          enumerable: true,
          get: () => () => getStatus() !== STATUS_NONE
        },
        enableMotion: {
          enumerable: true,
          get: () => () => supportMotion
        }
      });
      return obj;
    }, []);
    React45.useImperativeHandle(ref, () => refObj, []);
    let motionChildren;
    const mergedProps = {
      ...eventProps,
      visible
    };
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      if (mergedVisible) {
        motionChildren = children({
          ...mergedProps
        }, nodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children({
          ...mergedProps,
          className: leavedClassName
        }, nodeRef);
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children({
          ...mergedProps,
          style: {
            display: "none"
          }
        }, nodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      let statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      const motionCls = getTransitionName(motionName, `${status}-${statusSuffix}`);
      motionChildren = children({
        ...mergedProps,
        className: clsx(getTransitionName(motionName, status), {
          [motionCls]: motionCls && statusSuffix,
          [motionName]: typeof motionName === "string"
        }),
        style: statusStyle
      }, nodeRef);
    }
    if (React45.isValidElement(motionChildren) && supportRef(motionChildren)) {
      const originNodeRef = getNodeRef(motionChildren);
      if (!originNodeRef) {
        motionChildren = React45.cloneElement(motionChildren, {
          ref: nodeRef
        });
      }
    }
    return motionChildren;
  });
  CSSMotion.displayName = "CSSMotion";
  return CSSMotion;
}
var CSSMotion_default = genCSSMotion(supportTransition);

// node_modules/@rc-component/motion/es/CSSMotionList.js
var React46 = __toESM(require_react());

// node_modules/@rc-component/motion/es/util/diff.js
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  let keyObj;
  if (key && typeof key === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = {
      key
    };
  }
  return {
    ...keyObj,
    key: String(keyObj.key)
  };
}
function parseKeys(keys2 = []) {
  return keys2.map(wrapKeyToObject);
}
function diffKeys(prevKeys = [], currentKeys = []) {
  let list = [];
  let currentIndex = 0;
  const currentLen = currentKeys.length;
  const prevKeyObjects = parseKeys(prevKeys);
  const currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach((keyObj) => {
    let hit = false;
    for (let i = currentIndex; i < currentLen; i += 1) {
      const currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map((obj) => ({
            ...obj,
            status: STATUS_ADD
          })));
          currentIndex = i;
        }
        list.push({
          ...currentKeyObj,
          status: STATUS_KEEP
        });
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push({
        ...keyObj,
        status: STATUS_REMOVE
      });
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map((obj) => ({
      ...obj,
      status: STATUS_ADD
    })));
  }
  const keys2 = {};
  list.forEach(({
    key
  }) => {
    keys2[key] = (keys2[key] || 0) + 1;
  });
  const duplicatedKeys = Object.keys(keys2).filter((key) => keys2[key] > 1);
  duplicatedKeys.forEach((matchKey) => {
    list = list.filter(({
      key,
      status
    }) => key !== matchKey || status !== STATUS_REMOVE);
    list.forEach((node2) => {
      if (node2.key === matchKey) {
        node2.status = STATUS_KEEP;
      }
    });
  });
  return list;
}

// node_modules/@rc-component/motion/es/CSSMotionList.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport, CSSMotion = CSSMotion_default) {
  class CSSMotionList extends React46.Component {
    static defaultProps = {
      component: "div"
    };
    state = {
      keyEntities: []
    };
    static getDerivedStateFromProps({
      keys: keys2
    }, {
      keyEntities
    }) {
      const parsedKeyObjects = parseKeys(keys2);
      const mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
      return {
        keyEntities: mixedKeyEntities.filter((entity) => {
          const prevEntity = keyEntities.find(({
            key
          }) => entity.key === key);
          if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
            return false;
          }
          return true;
        })
      };
    }
    // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
    removeKey = (removeKey) => {
      this.setState((prevState) => {
        const nextKeyEntities = prevState.keyEntities.map((entity) => {
          if (entity.key !== removeKey) return entity;
          return {
            ...entity,
            status: STATUS_REMOVED
          };
        });
        return {
          keyEntities: nextKeyEntities
        };
      }, () => {
        const {
          keyEntities
        } = this.state;
        const restKeysCount = keyEntities.filter(({
          status
        }) => status !== STATUS_REMOVED).length;
        if (restKeysCount === 0 && this.props.onAllRemoved) {
          this.props.onAllRemoved();
        }
      });
    };
    render() {
      const {
        keyEntities
      } = this.state;
      const {
        component,
        children,
        onVisibleChanged,
        onAllRemoved,
        ...restProps
      } = this.props;
      const Component3 = component || React46.Fragment;
      const motionProps = {};
      MOTION_PROP_NAMES.forEach((prop) => {
        motionProps[prop] = restProps[prop];
        delete restProps[prop];
      });
      delete restProps.keys;
      return React46.createElement(Component3, restProps, keyEntities.map(({
        status,
        ...eventProps
      }, index) => {
        const visible = status === STATUS_ADD || status === STATUS_KEEP;
        return React46.createElement(CSSMotion, _extends4({}, motionProps, {
          key: eventProps.key,
          visible,
          eventProps,
          onVisibleChanged: (changedVisible) => {
            onVisibleChanged?.(changedVisible, {
              key: eventProps.key
            });
            if (!changedVisible) {
              this.removeKey(eventProps.key);
            }
          }
        }), (props, ref) => children({
          ...props,
          index
        }, ref));
      }));
    }
  }
  return CSSMotionList;
}
var CSSMotionList_default = genCSSMotionList(supportTransition);

// node_modules/@rc-component/motion/es/index.js
var es_default5 = CSSMotion_default;

// node_modules/@rc-component/trigger/es/Popup/index.js
var React50 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/Popup/Arrow.js
var React47 = __toESM(require_react());
function Arrow(props) {
  const {
    prefixCls,
    align,
    arrow,
    arrowPos
  } = props;
  const {
    className,
    content,
    style: style2
  } = arrow || {};
  const {
    x = 0,
    y = 0
  } = arrowPos;
  const arrowRef = React47.useRef(null);
  if (!align || !align.points) {
    return null;
  }
  const alignStyle = {
    position: "absolute"
  };
  if (align.autoArrow !== false) {
    const popupPoints = align.points[0];
    const targetPoints = align.points[1];
    const popupTB = popupPoints[0];
    const popupLR = popupPoints[1];
    const targetTB = targetPoints[0];
    const targetLR = targetPoints[1];
    if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
      alignStyle.top = y;
    } else if (popupTB === "t") {
      alignStyle.top = 0;
    } else {
      alignStyle.bottom = 0;
    }
    if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
      alignStyle.left = x;
    } else if (popupLR === "l") {
      alignStyle.left = 0;
    } else {
      alignStyle.right = 0;
    }
  }
  return React47.createElement("div", {
    ref: arrowRef,
    className: clsx(`${prefixCls}-arrow`, className),
    style: {
      ...alignStyle,
      ...style2
    }
  }, content);
}

// node_modules/@rc-component/trigger/es/Popup/Mask.js
var React48 = __toESM(require_react());
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function Mask(props) {
  const {
    prefixCls,
    open,
    zIndex,
    mask,
    motion,
    mobile
  } = props;
  if (!mask) {
    return null;
  }
  return React48.createElement(es_default5, _extends5({}, motion, {
    motionAppear: true,
    visible: open,
    removeOnLeave: true
  }), ({
    className
  }) => React48.createElement("div", {
    style: {
      zIndex
    },
    className: clsx(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
  }));
}

// node_modules/@rc-component/trigger/es/Popup/PopupContent.js
var React49 = __toESM(require_react());
var PopupContent = React49.memo(({
  children
}) => children, (_, next2) => next2.cache);
if (true) {
  PopupContent.displayName = "PopupContent";
}
var PopupContent_default = PopupContent;

// node_modules/@rc-component/trigger/es/hooks/useOffsetStyle.js
function useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY) {
  const AUTO = "auto";
  const offsetStyle = isMobile ? {} : {
    left: "-1000vw",
    top: "-1000vh",
    right: AUTO,
    bottom: AUTO
  };
  if (!isMobile && (ready || !open)) {
    const {
      points
    } = align;
    const dynamicInset = align.dynamicInset || align._experimental?.dynamicInset;
    const alignRight = dynamicInset && points[0][1] === "r";
    const alignBottom = dynamicInset && points[0][0] === "b";
    if (alignRight) {
      offsetStyle.right = offsetR;
      offsetStyle.left = AUTO;
    } else {
      offsetStyle.left = offsetX;
      offsetStyle.right = AUTO;
    }
    if (alignBottom) {
      offsetStyle.bottom = offsetB;
      offsetStyle.top = AUTO;
    } else {
      offsetStyle.top = offsetY;
      offsetStyle.bottom = AUTO;
    }
  }
  return offsetStyle;
}

// node_modules/@rc-component/trigger/es/Popup/index.js
function _extends6() {
  _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
var Popup = React50.forwardRef((props, ref) => {
  const {
    popup,
    className,
    prefixCls,
    style: style2,
    target,
    onVisibleChanged,
    // Open
    open,
    keepDom,
    fresh,
    // Click
    onClick,
    // Mask
    mask,
    // Arrow
    arrow,
    arrowPos,
    align,
    // Motion
    motion,
    maskMotion,
    // Mobile
    mobile,
    // Portal
    forceRender,
    getPopupContainer,
    autoDestroy,
    portal: Portal2,
    children,
    zIndex,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    onPointerDownCapture,
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    onAlign,
    onPrepare,
    // Resize
    onResize: onResize2,
    stretch,
    targetWidth,
    targetHeight
  } = props;
  const popupContent = typeof popup === "function" ? popup() : popup;
  const isNodeVisible = open || keepDom;
  const isMobile = !!mobile;
  const [mergedMask, mergedMaskMotion, mergedPopupMotion] = React50.useMemo(() => {
    if (mobile) {
      return [mobile.mask, mobile.maskMotion, mobile.motion];
    }
    return [mask, maskMotion, motion];
  }, [mobile, mask, maskMotion, motion]);
  const getPopupContainerNeedParams = getPopupContainer?.length > 0;
  const [show, setShow] = React50.useState(!getPopupContainer || !getPopupContainerNeedParams);
  useLayoutEffect_default(() => {
    if (!show && getPopupContainerNeedParams && target) {
      setShow(true);
    }
  }, [show, getPopupContainerNeedParams, target]);
  const onInternalResize = useEvent_default((size, ele) => {
    onResize2?.(size, ele);
    onAlign();
  });
  const offsetStyle = useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY);
  if (!show) {
    return null;
  }
  const miscStyle = {};
  if (stretch) {
    if (stretch.includes("height") && targetHeight) {
      miscStyle.height = targetHeight;
    } else if (stretch.includes("minHeight") && targetHeight) {
      miscStyle.minHeight = targetHeight;
    }
    if (stretch.includes("width") && targetWidth) {
      miscStyle.width = targetWidth;
    } else if (stretch.includes("minWidth") && targetWidth) {
      miscStyle.minWidth = targetWidth;
    }
  }
  if (!open) {
    miscStyle.pointerEvents = "none";
  }
  return React50.createElement(Portal2, {
    open: forceRender || isNodeVisible,
    getContainer: getPopupContainer && (() => getPopupContainer(target)),
    autoDestroy
  }, React50.createElement(Mask, {
    prefixCls,
    open,
    zIndex,
    mask: mergedMask,
    motion: mergedMaskMotion,
    mobile: isMobile
  }), React50.createElement(es_default4, {
    onResize: onInternalResize,
    disabled: !open
  }, (resizeObserverRef) => {
    return React50.createElement(es_default5, _extends6({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      forceRender,
      leavedClassName: `${prefixCls}-hidden`
    }, mergedPopupMotion, {
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      visible: open,
      onVisibleChanged: (nextVisible) => {
        motion?.onVisibleChanged?.(nextVisible);
        onVisibleChanged(nextVisible);
      }
    }), ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => {
      const cls = clsx(prefixCls, motionClassName, className, {
        [`${prefixCls}-mobile`]: isMobile
      });
      return React50.createElement("div", {
        ref: composeRef(resizeObserverRef, ref, motionRef),
        className: cls,
        style: {
          "--arrow-x": `${arrowPos.x || 0}px`,
          "--arrow-y": `${arrowPos.y || 0}px`,
          ...offsetStyle,
          ...miscStyle,
          ...motionStyle,
          boxSizing: "border-box",
          zIndex,
          ...style2
        },
        onMouseEnter,
        onMouseLeave,
        onPointerEnter,
        onClick,
        onPointerDownCapture
      }, arrow && React50.createElement(Arrow, {
        prefixCls,
        arrow,
        arrowPos,
        align
      }), React50.createElement(PopupContent_default, {
        cache: !open && !fresh
      }, popupContent));
    });
  }), children);
});
if (true) {
  Popup.displayName = "Popup";
}
var Popup_default = Popup;

// node_modules/@rc-component/trigger/es/context.js
var React51 = __toESM(require_react());
var TriggerContext = React51.createContext(null);
var context_default2 = TriggerContext;
var UniqueContext = React51.createContext(null);

// node_modules/@rc-component/trigger/es/hooks/useAction.js
var React52 = __toESM(require_react());
function toArray3(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(action, showAction, hideAction) {
  return React52.useMemo(() => {
    const mergedShowAction = toArray3(showAction ?? action);
    const mergedHideAction = toArray3(hideAction ?? action);
    const showActionSet = new Set(mergedShowAction);
    const hideActionSet = new Set(mergedHideAction);
    if (showActionSet.has("hover") && !showActionSet.has("click")) {
      showActionSet.add("touch");
    }
    if (hideActionSet.has("hover") && !hideActionSet.has("click")) {
      hideActionSet.add("touch");
    }
    return [showActionSet, hideActionSet];
  }, [action, showAction, hideAction]);
}

// node_modules/@rc-component/util/es/Dom/isVisible.js
var isVisible_default = ((element) => {
  if (!element) {
    return false;
  }
  if (element instanceof Element) {
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      const {
        width,
        height
      } = element.getBBox();
      if (width || height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      if (width || height) {
        return true;
      }
    }
  }
  return false;
});

// node_modules/@rc-component/trigger/es/hooks/useAlign.js
var React53 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/util.js
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
  const getVal = (a, index) => a[index] || "";
  if (isAlignPoint) {
    return getVal(a1, 0) === getVal(a2, 0);
  }
  return getVal(a1, 0) === getVal(a2, 0) && getVal(a1, 1) === getVal(a2, 1);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  const {
    points
  } = align;
  const placements2 = Object.keys(builtinPlacements);
  for (let i = 0; i < placements2.length; i += 1) {
    const placement = placements2[i];
    if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {
      return `${prefixCls}-placement-${placement}`;
    }
  }
  return "";
}
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}
function collectScroller(ele) {
  const scrollerList = [];
  let current = ele?.parentElement;
  const scrollStyle = ["hidden", "scroll", "clip", "auto"];
  while (current) {
    const {
      overflowX,
      overflowY,
      overflow
    } = getWin(current).getComputedStyle(current);
    if ([overflowX, overflowY, overflow].some((o) => scrollStyle.includes(o))) {
      scrollerList.push(current);
    }
    current = current.parentElement;
  }
  return scrollerList;
}
function toNum(num, defaultValue = 1) {
  return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
  return toNum(parseFloat(val), 0);
}
function getVisibleArea(initArea, scrollerList) {
  const visibleArea = {
    ...initArea
  };
  (scrollerList || []).forEach((ele) => {
    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
      return;
    }
    const {
      overflow,
      overflowClipMargin,
      borderTopWidth,
      borderBottomWidth,
      borderLeftWidth,
      borderRightWidth
    } = getWin(ele).getComputedStyle(ele);
    const eleRect = ele.getBoundingClientRect();
    const {
      offsetHeight: eleOutHeight,
      clientHeight: eleInnerHeight,
      offsetWidth: eleOutWidth,
      clientWidth: eleInnerWidth
    } = ele;
    const borderTopNum = getPxValue(borderTopWidth);
    const borderBottomNum = getPxValue(borderBottomWidth);
    const borderLeftNum = getPxValue(borderLeftWidth);
    const borderRightNum = getPxValue(borderRightWidth);
    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
    const scaledBorderTopWidth = borderTopNum * scaleY;
    const scaledBorderBottomWidth = borderBottomNum * scaleY;
    const scaledBorderLeftWidth = borderLeftNum * scaleX;
    const scaledBorderRightWidth = borderRightNum * scaleX;
    let clipMarginWidth = 0;
    let clipMarginHeight = 0;
    if (overflow === "clip") {
      const clipNum = getPxValue(overflowClipMargin);
      clipMarginWidth = clipNum * scaleX;
      clipMarginHeight = clipNum * scaleY;
    }
    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
    visibleArea.left = Math.max(visibleArea.left, eleLeft);
    visibleArea.top = Math.max(visibleArea.top, eleTop);
    visibleArea.right = Math.min(visibleArea.right, eleRight);
    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
  });
  return visibleArea;
}

// node_modules/@rc-component/trigger/es/hooks/useAlign.js
function getUnitOffset(size, offset = 0) {
  const offsetStr = `${offset}`;
  const cells = offsetStr.match(/^(.*)\%$/);
  if (cells) {
    return size * (parseFloat(cells[1]) / 100);
  }
  return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset) {
  const [offsetX, offsetY] = offset || [];
  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints(points = "") {
  return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
  const topBottom = points[0];
  const leftRight = points[1];
  let x;
  let y;
  if (topBottom === "t") {
    y = rect.y;
  } else if (topBottom === "b") {
    y = rect.y + rect.height;
  } else {
    y = rect.y + rect.height / 2;
  }
  if (leftRight === "l") {
    x = rect.x;
  } else if (leftRight === "r") {
    x = rect.x + rect.width;
  } else {
    x = rect.x + rect.width / 2;
  }
  return {
    x,
    y
  };
}
function reversePoints(points, index) {
  const reverseMap = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  const clone = [...points];
  clone[index] = reverseMap[points[index]] || "c";
  return clone;
}
function flatPoints(points) {
  return points.join("");
}
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
  const [offsetInfo, setOffsetInfo] = React53.useState({
    ready: false,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: builtinPlacements[placement] || {}
  });
  const alignCountRef = React53.useRef(0);
  const scrollerList = React53.useMemo(() => {
    if (!popupEle || mobile) {
      return [];
    }
    return collectScroller(popupEle);
  }, [popupEle]);
  const prevFlipRef = React53.useRef({});
  const resetFlipCache = () => {
    prevFlipRef.current = {};
  };
  if (!open) {
    resetFlipCache();
  }
  const onAlign = useEvent_default(() => {
    if (popupEle && target && open && !mobile) {
      let getIntersectionVisibleArea = function(offsetX, offsetY, area = visibleArea) {
        const l = popupRect.x + offsetX;
        const t = popupRect.y + offsetY;
        const r = l + popupWidth;
        const b = t + popupHeight;
        const visibleL = Math.max(l, area.left);
        const visibleT = Math.max(t, area.top);
        const visibleR = Math.min(r, area.right);
        const visibleB = Math.min(b, area.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }, syncNextPopupPosition = function() {
        nextPopupY = popupRect.y + nextOffsetY;
        nextPopupBottom = nextPopupY + popupHeight;
        nextPopupX = popupRect.x + nextOffsetX;
        nextPopupRight = nextPopupX + popupWidth;
      };
      const popupElement = popupEle;
      const doc = popupElement.ownerDocument;
      const win = getWin(popupElement);
      const {
        position: popupPosition
      } = win.getComputedStyle(popupElement);
      const originLeft = popupElement.style.left;
      const originTop = popupElement.style.top;
      const originRight = popupElement.style.right;
      const originBottom = popupElement.style.bottom;
      const originOverflow = popupElement.style.overflow;
      const placementInfo = {
        ...builtinPlacements[placement],
        ...popupAlign
      };
      const placeholderElement = doc.createElement("div");
      popupElement.parentElement?.appendChild(placeholderElement);
      placeholderElement.style.left = `${popupElement.offsetLeft}px`;
      placeholderElement.style.top = `${popupElement.offsetTop}px`;
      placeholderElement.style.position = popupPosition;
      placeholderElement.style.height = `${popupElement.offsetHeight}px`;
      placeholderElement.style.width = `${popupElement.offsetWidth}px`;
      popupElement.style.left = "0";
      popupElement.style.top = "0";
      popupElement.style.right = "auto";
      popupElement.style.bottom = "auto";
      popupElement.style.overflow = "hidden";
      let targetRect;
      if (Array.isArray(target)) {
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      } else {
        const rect = target.getBoundingClientRect();
        rect.x = rect.x ?? rect.left;
        rect.y = rect.y ?? rect.top;
        targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      const popupRect = popupElement.getBoundingClientRect();
      const {
        height,
        width
      } = win.getComputedStyle(popupElement);
      popupRect.x = popupRect.x ?? popupRect.left;
      popupRect.y = popupRect.y ?? popupRect.top;
      const {
        clientWidth,
        clientHeight,
        scrollWidth,
        scrollHeight,
        scrollTop,
        scrollLeft
      } = doc.documentElement;
      const popupHeight = popupRect.height;
      const popupWidth = popupRect.width;
      const targetHeight = targetRect.height;
      const targetWidth = targetRect.width;
      const visibleRegion = {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      };
      const scrollRegion = {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      };
      let {
        htmlRegion
      } = placementInfo;
      const VISIBLE = "visible";
      const VISIBLE_FIRST = "visibleFirst";
      if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
        htmlRegion = VISIBLE;
      }
      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
      popupElement.style.left = "auto";
      popupElement.style.top = "auto";
      popupElement.style.right = "0";
      popupElement.style.bottom = "0";
      const popupMirrorRect = popupElement.getBoundingClientRect();
      popupElement.style.left = originLeft;
      popupElement.style.top = originTop;
      popupElement.style.right = originRight;
      popupElement.style.bottom = originBottom;
      popupElement.style.overflow = originOverflow;
      popupElement.parentElement?.removeChild(placeholderElement);
      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible_default(target)) {
        return;
      }
      const {
        offset,
        targetOffset: targetOffset2
      } = placementInfo;
      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);
      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset2);
      targetRect.x -= targetOffsetX;
      targetRect.y -= targetOffsetY;
      const [popupPoint, targetPoint] = placementInfo.points || [];
      const targetPoints = splitPoints(targetPoint);
      const popupPoints = splitPoints(popupPoint);
      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
      const nextAlignInfo = {
        ...placementInfo
      };
      let nextPoints = [popupPoints, targetPoints];
      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
      const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
      const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
      const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
      const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
      const overflow = placementInfo.overflow || {};
      const {
        adjustX,
        adjustY,
        shiftX,
        shiftY
      } = overflow;
      const supportAdjust = (val) => {
        if (typeof val === "boolean") {
          return val;
        }
        return val >= 0;
      };
      let nextPopupY;
      let nextPopupBottom;
      let nextPopupX;
      let nextPopupRight;
      syncNextPopupPosition();
      const needAdjustY = supportAdjust(adjustY);
      const sameTB = popupPoints[0] === targetPoints[0];
      if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY -= popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.bt = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
        } else {
          prevFlipRef.current.bt = false;
        }
      }
      if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY += popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.tb = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
        } else {
          prevFlipRef.current.tb = false;
        }
      }
      const needAdjustX = supportAdjust(adjustX);
      const sameLR = popupPoints[1] === targetPoints[1];
      if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX -= popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.rl = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
        } else {
          prevFlipRef.current.rl = false;
        }
      }
      if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX += popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.lr = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
        } else {
          prevFlipRef.current.lr = false;
        }
      }
      nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];
      syncNextPopupPosition();
      const numShiftX = shiftX === true ? 0 : shiftX;
      if (typeof numShiftX === "number") {
        if (nextPopupX < visibleRegionArea.left) {
          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
          }
        }
        if (nextPopupRight > visibleRegionArea.right) {
          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
          if (targetRect.x > visibleRegionArea.right - numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
          }
        }
      }
      const numShiftY = shiftY === true ? 0 : shiftY;
      if (typeof numShiftY === "number") {
        if (nextPopupY < visibleRegionArea.top) {
          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
          }
        }
        if (nextPopupBottom > visibleRegionArea.bottom) {
          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
          }
        }
      }
      const popupLeft = popupRect.x + nextOffsetX;
      const popupRight = popupLeft + popupWidth;
      const popupTop = popupRect.y + nextOffsetY;
      const popupBottom = popupTop + popupHeight;
      const targetLeft = targetRect.x;
      const targetRight = targetLeft + targetWidth;
      const targetTop = targetRect.y;
      const targetBottom = targetTop + targetHeight;
      const maxLeft = Math.max(popupLeft, targetLeft);
      const minRight = Math.min(popupRight, targetRight);
      const xCenter = (maxLeft + minRight) / 2;
      const nextArrowX = xCenter - popupLeft;
      const maxTop = Math.max(popupTop, targetTop);
      const minBottom = Math.min(popupBottom, targetBottom);
      const yCenter = (maxTop + minBottom) / 2;
      const nextArrowY = yCenter - popupTop;
      onPopupAlign?.(popupEle, nextAlignInfo);
      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
      if (scaleX === 1) {
        nextOffsetX = Math.round(nextOffsetX);
        offsetX4Right = Math.round(offsetX4Right);
      }
      if (scaleY === 1) {
        nextOffsetY = Math.round(nextOffsetY);
        offsetY4Bottom = Math.round(offsetY4Bottom);
      }
      const nextOffsetInfo = {
        ready: true,
        offsetX: nextOffsetX / scaleX,
        offsetY: nextOffsetY / scaleY,
        offsetR: offsetX4Right / scaleX,
        offsetB: offsetY4Bottom / scaleY,
        arrowX: nextArrowX / scaleX,
        arrowY: nextArrowY / scaleY,
        scaleX,
        scaleY,
        align: nextAlignInfo
      };
      setOffsetInfo(nextOffsetInfo);
    }
  });
  const triggerAlign = () => {
    alignCountRef.current += 1;
    const id = alignCountRef.current;
    Promise.resolve().then(() => {
      if (alignCountRef.current === id) {
        onAlign();
      }
    });
  };
  const resetReady = () => {
    setOffsetInfo((ori) => ({
      ...ori,
      ready: false
    }));
  };
  useLayoutEffect_default(resetReady, [placement]);
  useLayoutEffect_default(() => {
    if (!open) {
      resetReady();
    }
  }, [open]);
  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
}

// node_modules/@rc-component/trigger/es/hooks/useDelay.js
var React54 = __toESM(require_react());
function useDelay() {
  const delayRef = React54.useRef(null);
  const clearDelay = () => {
    if (delayRef.current) {
      clearTimeout(delayRef.current);
      delayRef.current = null;
    }
  };
  const delayInvoke = (callback, delay) => {
    clearDelay();
    if (delay === 0) {
      callback();
    } else {
      delayRef.current = setTimeout(() => {
        callback();
      }, delay * 1e3);
    }
  };
  React54.useEffect(() => {
    return () => {
      clearDelay();
    };
  }, []);
  return delayInvoke;
}

// node_modules/@rc-component/trigger/es/hooks/useWatch.js
function useWatch2(open, target, popup, onAlign, onScroll) {
  useLayoutEffect_default(() => {
    if (open && target && popup) {
      let notifyScroll = function() {
        onAlign();
        onScroll();
      };
      const targetElement = target;
      const popupElement = popup;
      const targetScrollList = collectScroller(targetElement);
      const popupScrollList = collectScroller(popupElement);
      const win = getWin(popupElement);
      const mergedList = /* @__PURE__ */ new Set([win, ...targetScrollList, ...popupScrollList]);
      mergedList.forEach((scroller) => {
        scroller.addEventListener("scroll", notifyScroll, {
          passive: true
        });
      });
      win.addEventListener("resize", notifyScroll, {
        passive: true
      });
      onAlign();
      return () => {
        mergedList.forEach((scroller) => {
          scroller.removeEventListener("scroll", notifyScroll);
          win.removeEventListener("resize", notifyScroll);
        });
      };
    }
  }, [open, target, popup]);
}

// node_modules/@rc-component/trigger/es/hooks/useWinClick.js
var React55 = __toESM(require_react());
function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
  const openRef = React55.useRef(open);
  openRef.current = open;
  const popupPointerDownRef = React55.useRef(false);
  React55.useEffect(() => {
    if (clickToHide && popupEle && (!mask || maskClosable)) {
      const onPointerDown = () => {
        popupPointerDownRef.current = false;
      };
      const onTriggerClose = (e) => {
        if (openRef.current && !inPopupOrChild(e.composedPath?.()?.[0] || e.target) && !popupPointerDownRef.current) {
          triggerOpen(false);
        }
      };
      const win = getWin(popupEle);
      win.addEventListener("pointerdown", onPointerDown, true);
      win.addEventListener("mousedown", onTriggerClose, true);
      win.addEventListener("contextmenu", onTriggerClose, true);
      const targetShadowRoot = getShadowRoot(targetEle);
      if (targetShadowRoot) {
        targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
        targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
      }
      if (targetEle) {
        const targetRoot = targetEle.getRootNode?.();
        const popupRoot = popupEle.getRootNode?.();
        warning(targetRoot === popupRoot, `trigger element and popup element should in same shadow root.`);
      }
      return () => {
        win.removeEventListener("pointerdown", onPointerDown, true);
        win.removeEventListener("mousedown", onTriggerClose, true);
        win.removeEventListener("contextmenu", onTriggerClose, true);
        if (targetShadowRoot) {
          targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
          targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
        }
      };
    }
  }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
  function onPopupPointerDown() {
    popupPointerDownRef.current = true;
  }
  return onPopupPointerDown;
}

// node_modules/@rc-component/trigger/es/UniqueProvider/index.js
var React58 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/UniqueProvider/useTargetState.js
var import_react23 = __toESM(require_react());
function useTargetState() {
  const [options, setOptions] = import_react23.default.useState(null);
  const [open, setOpen] = import_react23.default.useState(false);
  const [isAnimating, setIsAnimating] = import_react23.default.useState(false);
  const pendingOptionsRef = import_react23.default.useRef(null);
  const trigger = useEvent_default((nextOptions) => {
    if (nextOptions === false) {
      pendingOptionsRef.current = null;
      setOpen(false);
    } else {
      if (isAnimating && open) {
        pendingOptionsRef.current = nextOptions;
      } else {
        setOpen(true);
        setOptions(nextOptions);
        pendingOptionsRef.current = null;
        if (!open) {
          setIsAnimating(true);
        }
      }
    }
  });
  const onVisibleChanged = useEvent_default((visible) => {
    if (visible) {
      setIsAnimating(false);
      if (pendingOptionsRef.current) {
        setOptions(pendingOptionsRef.current);
        pendingOptionsRef.current = null;
      }
    } else {
      setIsAnimating(false);
      pendingOptionsRef.current = null;
    }
  });
  return [trigger, open, options, onVisibleChanged];
}

// node_modules/@rc-component/trigger/es/UniqueProvider/UniqueContainer.js
var import_react24 = __toESM(require_react());
function _extends7() {
  _extends7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
var UniqueContainer = (props) => {
  const {
    prefixCls,
    isMobile,
    ready,
    open,
    align,
    offsetR,
    offsetB,
    offsetX,
    offsetY,
    arrowPos,
    popupSize,
    motion,
    uniqueContainerClassName,
    uniqueContainerStyle
  } = props;
  const containerCls = `${prefixCls}-unique-container`;
  const [motionVisible, setMotionVisible] = import_react24.default.useState(false);
  const offsetStyle = useOffsetStyle(isMobile, ready, open, align, offsetR, offsetB, offsetX, offsetY);
  const cachedOffsetStyleRef = import_react24.default.useRef(offsetStyle);
  if (ready) {
    cachedOffsetStyleRef.current = offsetStyle;
  }
  const sizeStyle = {};
  if (popupSize) {
    sizeStyle.width = popupSize.width;
    sizeStyle.height = popupSize.height;
  }
  return import_react24.default.createElement(es_default5, _extends7({
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    removeOnLeave: false,
    leavedClassName: `${containerCls}-hidden`
  }, motion, {
    visible: open,
    onVisibleChanged: (nextVisible) => {
      setMotionVisible(nextVisible);
    }
  }), ({
    className: motionClassName,
    style: motionStyle
  }) => {
    const cls = clsx(containerCls, motionClassName, uniqueContainerClassName, {
      [`${containerCls}-visible`]: motionVisible
    });
    return import_react24.default.createElement("div", {
      className: cls,
      style: {
        "--arrow-x": `${arrowPos?.x || 0}px`,
        "--arrow-y": `${arrowPos?.y || 0}px`,
        ...cachedOffsetStyleRef.current,
        ...sizeStyle,
        ...motionStyle,
        ...uniqueContainerStyle
      }
    });
  });
};
var UniqueContainer_default = UniqueContainer;

// node_modules/@rc-component/trigger/es/UniqueProvider/index.js
var UniqueProvider = ({
  children,
  postTriggerProps
}) => {
  const [trigger, open, options, onTargetVisibleChanged] = useTargetState();
  const mergedOptions = React58.useMemo(() => {
    if (!options || !postTriggerProps) {
      return options;
    }
    return postTriggerProps(options);
  }, [options, postTriggerProps]);
  const [popupEle, setPopupEle] = React58.useState(null);
  const [popupSize, setPopupSize] = React58.useState(null);
  const externalPopupRef = React58.useRef(null);
  const setPopupRef = useEvent_default((node2) => {
    externalPopupRef.current = node2;
    if (isDOM(node2) && popupEle !== node2) {
      setPopupEle(node2);
    }
  });
  const isOpenRef = React58.useRef(null);
  const delayInvoke = useDelay();
  const show = useEvent_default((showOptions, isOpen) => {
    isOpenRef.current = isOpen;
    delayInvoke(() => {
      trigger(showOptions);
    }, showOptions.delay);
  });
  const hide = (delay) => {
    delayInvoke(() => {
      if (isOpenRef.current?.()) {
        return;
      }
      trigger(false);
    }, delay);
  };
  const onVisibleChanged = useEvent_default((visible) => {
    onTargetVisibleChanged(visible);
  });
  const [
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    arrowX,
    arrowY,
    // scaleX - not used in UniqueProvider
    ,
    ,
    // scaleY - not used in UniqueProvider
    alignInfo,
    onAlign
  ] = useAlign(
    open,
    popupEle,
    mergedOptions?.target,
    mergedOptions?.popupPlacement,
    mergedOptions?.builtinPlacements || {},
    mergedOptions?.popupAlign,
    void 0,
    // onPopupAlign
    false
    // isMobile
  );
  const alignedClassName = React58.useMemo(() => {
    if (!mergedOptions) {
      return "";
    }
    const baseClassName = getAlignPopupClassName(
      mergedOptions.builtinPlacements || {},
      mergedOptions.prefixCls || "",
      alignInfo,
      false
      // alignPoint is false for UniqueProvider
    );
    return clsx(baseClassName, mergedOptions.getPopupClassNameFromAlign?.(alignInfo));
  }, [alignInfo, mergedOptions?.getPopupClassNameFromAlign, mergedOptions?.builtinPlacements, mergedOptions?.prefixCls]);
  const contextValue = React58.useMemo(() => ({
    show,
    hide
  }), []);
  React58.useEffect(() => {
    onAlign();
  }, [mergedOptions?.target]);
  const onPrepare = useEvent_default(() => {
    onAlign();
    return Promise.resolve();
  });
  const subPopupElements = React58.useRef({});
  const parentContext = React58.useContext(context_default2);
  const triggerContextValue = React58.useMemo(() => ({
    registerSubPopup: (id, subPopupEle) => {
      subPopupElements.current[id] = subPopupEle;
      parentContext?.registerSubPopup(id, subPopupEle);
    }
  }), [parentContext]);
  const prefixCls = mergedOptions?.prefixCls;
  return React58.createElement(UniqueContext.Provider, {
    value: contextValue
  }, children, mergedOptions && React58.createElement(context_default2.Provider, {
    value: triggerContextValue
  }, React58.createElement(Popup_default, {
    ref: setPopupRef,
    portal: es_default3,
    prefixCls,
    popup: mergedOptions.popup,
    className: clsx(mergedOptions.popupClassName, alignedClassName, `${prefixCls}-unique-controlled`),
    style: mergedOptions.popupStyle,
    target: mergedOptions.target,
    open,
    keepDom: true,
    fresh: true,
    autoDestroy: false,
    onVisibleChanged,
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    onAlign,
    onPrepare,
    onResize: (size) => setPopupSize({
      width: size.offsetWidth,
      height: size.offsetHeight
    }),
    arrowPos: {
      x: arrowX,
      y: arrowY
    },
    align: alignInfo,
    zIndex: mergedOptions.zIndex,
    mask: mergedOptions.mask,
    arrow: mergedOptions.arrow,
    motion: mergedOptions.popupMotion,
    maskMotion: mergedOptions.maskMotion,
    getPopupContainer: mergedOptions.getPopupContainer
  }, React58.createElement(UniqueContainer_default, {
    prefixCls,
    isMobile: false,
    ready,
    open,
    align: alignInfo,
    offsetR,
    offsetB,
    offsetX,
    offsetY,
    arrowPos: {
      x: arrowX,
      y: arrowY
    },
    popupSize,
    motion: mergedOptions.popupMotion,
    uniqueContainerClassName: clsx(mergedOptions.uniqueContainerClassName, alignedClassName),
    uniqueContainerStyle: mergedOptions.uniqueContainerStyle
  }))));
};
var UniqueProvider_default = UniqueProvider;

// node_modules/@rc-component/trigger/es/index.js
function generateTrigger(PortalComponent = es_default3) {
  const Trigger = React59.forwardRef((props, ref) => {
    const {
      prefixCls = "rc-trigger-popup",
      children,
      // Action
      action = "hover",
      showAction,
      hideAction,
      // Open
      popupVisible,
      defaultPopupVisible,
      onOpenChange,
      afterOpenChange,
      onPopupVisibleChange,
      afterPopupVisibleChange,
      // Delay
      mouseEnterDelay,
      mouseLeaveDelay = 0.1,
      focusDelay,
      blurDelay,
      // Mask
      mask,
      maskClosable = true,
      // Portal
      getPopupContainer,
      forceRender,
      autoDestroy,
      // Popup
      popup,
      popupClassName,
      uniqueContainerClassName,
      uniqueContainerStyle,
      popupStyle,
      popupPlacement,
      builtinPlacements = {},
      popupAlign,
      zIndex,
      stretch,
      getPopupClassNameFromAlign,
      fresh,
      unique,
      alignPoint,
      onPopupClick,
      onPopupAlign,
      // Arrow
      arrow,
      // Motion
      popupMotion,
      maskMotion,
      // Private
      mobile,
      ...restProps
    } = props;
    const mergedAutoDestroy = autoDestroy || false;
    const openUncontrolled = popupVisible === void 0;
    const isMobile = !!mobile;
    const subPopupElements = React59.useRef({});
    const parentContext = React59.useContext(context_default2);
    const context = React59.useMemo(() => {
      return {
        registerSubPopup: (id2, subPopupEle) => {
          subPopupElements.current[id2] = subPopupEle;
          parentContext?.registerSubPopup(id2, subPopupEle);
        }
      };
    }, [parentContext]);
    const uniqueContext = React59.useContext(UniqueContext);
    const id = useId_default();
    const [popupEle, setPopupEle] = React59.useState(null);
    const externalPopupRef = React59.useRef(null);
    const setPopupRef = useEvent_default((node2) => {
      externalPopupRef.current = node2;
      if (isDOM(node2) && popupEle !== node2) {
        setPopupEle(node2);
      }
      parentContext?.registerSubPopup(id, node2);
    });
    const [targetEle, setTargetEle] = React59.useState(null);
    const externalForwardRef = React59.useRef(null);
    const setTargetRef = useEvent_default((node2) => {
      if (isDOM(node2) && targetEle !== node2) {
        setTargetEle(node2);
        externalForwardRef.current = node2;
      }
    });
    const cloneProps = {};
    const inPopupOrChild = useEvent_default((ele) => {
      const childDOM = targetEle;
      return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle) => subPopupEle?.contains(ele) || ele === subPopupEle);
    });
    const innerArrow = arrow ? {
      // true and Object likely
      ...arrow !== true ? arrow : {}
    } : null;
    const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);
    const mergedOpen = internalOpen || false;
    const child = React59.useMemo(() => {
      const nextChild = typeof children === "function" ? children({
        open: mergedOpen
      }) : children;
      return React59.Children.only(nextChild);
    }, [children, mergedOpen]);
    const originChildProps = child?.props || {};
    const isOpen = useEvent_default(() => mergedOpen);
    const getUniqueOptions = useEvent_default((delay = 0) => ({
      popup,
      target: targetEle,
      delay,
      prefixCls,
      popupClassName,
      uniqueContainerClassName,
      uniqueContainerStyle,
      popupStyle,
      popupPlacement,
      builtinPlacements,
      popupAlign,
      zIndex,
      mask,
      maskClosable,
      popupMotion,
      maskMotion,
      arrow: innerArrow,
      getPopupContainer,
      getPopupClassNameFromAlign,
      id
    }));
    useLayoutEffect_default(() => {
      if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {
        if (mergedOpen) {
          uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);
        } else {
          uniqueContext.hide(mouseLeaveDelay);
        }
      }
    }, [mergedOpen, targetEle]);
    const openRef = React59.useRef(mergedOpen);
    openRef.current = mergedOpen;
    const lastTriggerRef = React59.useRef([]);
    lastTriggerRef.current = [];
    const internalTriggerOpen = useEvent_default((nextOpen) => {
      setInternalOpen(nextOpen);
      if ((lastTriggerRef.current[lastTriggerRef.current.length - 1] ?? mergedOpen) !== nextOpen) {
        lastTriggerRef.current.push(nextOpen);
        onOpenChange?.(nextOpen);
        onPopupVisibleChange?.(nextOpen);
      }
    });
    const delayInvoke = useDelay();
    const triggerOpen = (nextOpen, delay = 0) => {
      if (popupVisible !== void 0) {
        delayInvoke(() => {
          internalTriggerOpen(nextOpen);
        }, delay);
        return;
      }
      if (uniqueContext && unique && openUncontrolled && !parentContext) {
        if (nextOpen) {
          uniqueContext.show(getUniqueOptions(delay), isOpen);
        } else {
          uniqueContext.hide(delay);
        }
        return;
      }
      delayInvoke(() => {
        internalTriggerOpen(nextOpen);
      }, delay);
    };
    const [inMotion, setInMotion] = React59.useState(false);
    useLayoutEffect_default((firstMount) => {
      if (!firstMount || mergedOpen) {
        setInMotion(true);
      }
    }, [mergedOpen]);
    const [motionPrepareResolve, setMotionPrepareResolve] = React59.useState(null);
    const [mousePos, setMousePos] = React59.useState(null);
    const setMousePosByEvent = (event) => {
      setMousePos([event.clientX, event.clientY]);
    };
    const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile);
    const [showActions, hideActions] = useAction(action, showAction, hideAction);
    const clickToShow = showActions.has("click");
    const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
    const triggerAlign = useEvent_default(() => {
      if (!inMotion) {
        onAlign();
      }
    });
    const onScroll = () => {
      if (openRef.current && alignPoint && clickToHide) {
        triggerOpen(false);
      }
    };
    useWatch2(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
    useLayoutEffect_default(() => {
      triggerAlign();
    }, [mousePos, popupPlacement]);
    useLayoutEffect_default(() => {
      if (mergedOpen && !builtinPlacements?.[popupPlacement]) {
        triggerAlign();
      }
    }, [JSON.stringify(popupAlign)]);
    const alignedClassName = React59.useMemo(() => {
      const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
      return clsx(baseClassName, getPopupClassNameFromAlign?.(alignInfo));
    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
    React59.useImperativeHandle(ref, () => ({
      nativeElement: externalForwardRef.current,
      popupElement: externalPopupRef.current,
      forceAlign: triggerAlign
    }));
    const [targetWidth, setTargetWidth] = React59.useState(0);
    const [targetHeight, setTargetHeight] = React59.useState(0);
    const syncTargetSize = () => {
      if (stretch && targetEle) {
        const rect = targetEle.getBoundingClientRect();
        setTargetWidth(rect.width);
        setTargetHeight(rect.height);
      }
    };
    const onTargetResize = () => {
      syncTargetSize();
      triggerAlign();
    };
    const onVisibleChanged = (visible) => {
      setInMotion(false);
      onAlign();
      afterOpenChange?.(visible);
      afterPopupVisibleChange?.(visible);
    };
    const onPrepare = () => new Promise((resolve) => {
      syncTargetSize();
      setMotionPrepareResolve(() => resolve);
    });
    useLayoutEffect_default(() => {
      if (motionPrepareResolve) {
        onAlign();
        motionPrepareResolve();
        setMotionPrepareResolve(null);
      }
    }, [motionPrepareResolve]);
    function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {
      cloneProps[eventName] = (event, ...args) => {
        if (!ignoreCheck || !ignoreCheck()) {
          callback?.(event);
          triggerOpen(nextOpen, delay);
        }
        originChildProps[eventName]?.(event, ...args);
      };
    }
    const touchToShow = showActions.has("touch");
    const touchToHide = hideActions.has("touch");
    const touchedRef = React59.useRef(false);
    if (touchToShow || touchToHide) {
      cloneProps.onTouchStart = (...args) => {
        touchedRef.current = true;
        if (openRef.current && touchToHide) {
          triggerOpen(false);
        } else if (!openRef.current && touchToShow) {
          triggerOpen(true);
        }
        originChildProps.onTouchStart?.(...args);
      };
    }
    if (clickToShow || clickToHide) {
      cloneProps.onClick = (event, ...args) => {
        if (openRef.current && clickToHide) {
          triggerOpen(false);
        } else if (!openRef.current && clickToShow) {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        originChildProps.onClick?.(event, ...args);
        touchedRef.current = false;
      };
    }
    const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
    const hoverToShow = showActions.has("hover");
    const hoverToHide = hideActions.has("hover");
    let onPopupMouseEnter;
    let onPopupMouseLeave;
    const ignoreMouseTrigger = () => {
      return touchedRef.current;
    };
    if (hoverToShow) {
      const onMouseEnterCallback = (event) => {
        setMousePosByEvent(event);
      };
      wrapperAction("onMouseEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
      wrapperAction("onPointerEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
      onPopupMouseEnter = (event) => {
        if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {
          triggerOpen(true, mouseEnterDelay);
        }
      };
      if (alignPoint) {
        cloneProps.onMouseMove = (event) => {
          originChildProps.onMouseMove?.(event);
        };
      }
    }
    if (hoverToHide) {
      wrapperAction("onMouseLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
      wrapperAction("onPointerLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
      onPopupMouseLeave = () => {
        triggerOpen(false, mouseLeaveDelay);
      };
    }
    if (showActions.has("focus")) {
      wrapperAction("onFocus", true, focusDelay);
    }
    if (hideActions.has("focus")) {
      wrapperAction("onBlur", false, blurDelay);
    }
    if (showActions.has("contextMenu")) {
      cloneProps.onContextMenu = (event, ...args) => {
        if (openRef.current && hideActions.has("contextMenu")) {
          triggerOpen(false);
        } else {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        event.preventDefault();
        originChildProps.onContextMenu?.(event, ...args);
      };
    }
    const rendedRef = React59.useRef(false);
    rendedRef.current ||= forceRender || mergedOpen || inMotion;
    const mergedChildrenProps = {
      ...originChildProps,
      ...cloneProps
    };
    const passedProps = {};
    const passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    passedEventList.forEach((eventName) => {
      if (restProps[eventName]) {
        passedProps[eventName] = (...args) => {
          mergedChildrenProps[eventName]?.(...args);
          restProps[eventName](...args);
        };
      }
    });
    const arrowPos = {
      x: arrowX,
      y: arrowY
    };
    const triggerNode = React59.cloneElement(child, {
      ...mergedChildrenProps,
      ...passedProps
    });
    return React59.createElement(React59.Fragment, null, React59.createElement(es_default4, {
      disabled: !mergedOpen,
      ref: setTargetRef,
      onResize: onTargetResize
    }, triggerNode), rendedRef.current && (!uniqueContext || !unique) && React59.createElement(context_default2.Provider, {
      value: context
    }, React59.createElement(Popup_default, {
      portal: PortalComponent,
      ref: setPopupRef,
      prefixCls,
      popup,
      className: clsx(popupClassName, !isMobile && alignedClassName),
      style: popupStyle,
      target: targetEle,
      onMouseEnter: onPopupMouseEnter,
      onMouseLeave: onPopupMouseLeave,
      onPointerEnter: onPopupMouseEnter,
      zIndex,
      open: mergedOpen,
      keepDom: inMotion,
      fresh,
      onClick: onPopupClick,
      onPointerDownCapture: onPopupPointerDown,
      mask,
      motion: popupMotion,
      maskMotion,
      onVisibleChanged,
      onPrepare,
      forceRender,
      autoDestroy: mergedAutoDestroy,
      getPopupContainer,
      align: alignInfo,
      arrow: innerArrow,
      arrowPos,
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      onAlign: triggerAlign,
      stretch,
      targetWidth: targetWidth / scaleX,
      targetHeight: targetHeight / scaleY,
      mobile
    })));
  });
  if (true) {
    Trigger.displayName = "Trigger";
  }
  return Trigger;
}
var es_default6 = generateTrigger(es_default3);

// node_modules/antd/es/tooltip/UniqueProvider/MotionContent.js
var import_react25 = __toESM(require_react());

// node_modules/antd/es/config-provider/context.js
var React60 = __toESM(require_react());
var defaultPrefixCls = "ant";
var defaultIconPrefixCls = "anticon";
var Variants = ["outlined", "borderless", "filled", "underlined"];
var defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
  if (customizePrefixCls) {
    return customizePrefixCls;
  }
  return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
};
var ConfigContext = React60.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
});
var {
  Consumer: ConfigConsumer
} = ConfigContext;
var EMPTY_OBJECT = {};
function useComponentConfig(propName) {
  const context = React60.useContext(ConfigContext);
  const {
    getPrefixCls,
    direction,
    getPopupContainer,
    renderEmpty
  } = context;
  const propValue = context[propName];
  return {
    classNames: EMPTY_OBJECT,
    styles: EMPTY_OBJECT,
    ...propValue,
    getPrefixCls,
    direction,
    getPopupContainer,
    renderEmpty
  };
}

// node_modules/antd/es/tooltip/UniqueProvider/MotionContent.js
var MotionContent = ({
  children
}) => {
  const {
    getPrefixCls
  } = import_react25.default.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  if (!import_react25.default.isValidElement(children)) {
    return children;
  }
  return import_react25.default.createElement(es_default5, {
    visible: true,
    motionName: `${rootPrefixCls}-fade`,
    motionAppear: true,
    motionEnter: true,
    motionLeave: false,
    removeOnLeave: false
  }, ({
    style: motionStyle,
    className: motionClassName
  }) => {
    const {
      className,
      style: style2
    } = children.props;
    const mergedStyles = {
      ...style2,
      ...motionStyle
    };
    return import_react25.default.cloneElement(children, {
      className: clsx(className, motionClassName),
      style: mergedStyles
    });
  });
};
var MotionContent_default = MotionContent;

// node_modules/antd/es/tooltip/UniqueProvider/index.js
var cachedPlacements = [null, null];
function uniqueBuiltinPlacements(ori) {
  if (cachedPlacements[0] !== ori) {
    const target = {};
    Object.keys(ori).forEach((placement) => {
      target[placement] = {
        ...ori[placement],
        dynamicInset: false
      };
    });
    cachedPlacements[0] = ori;
    cachedPlacements[1] = target;
  }
  return cachedPlacements[1];
}
var UniqueProvider2 = ({
  children
}) => {
  const renderPopup = (options) => {
    const popupEle = typeof options.popup === "function" ? options.popup() : options.popup;
    const {
      id,
      builtinPlacements
    } = options;
    const parsedPlacements = uniqueBuiltinPlacements(builtinPlacements);
    return {
      ...options,
      getPopupContainer: null,
      arrow: false,
      popup: import_react26.default.createElement(MotionContent_default, {
        key: id
      }, popupEle),
      builtinPlacements: parsedPlacements
    };
  };
  return import_react26.default.createElement(UniqueProvider_default, {
    postTriggerProps: renderPopup
  }, children);
};
var UniqueProvider_default2 = UniqueProvider2;

// node_modules/antd/es/config-provider/DisabledContext.js
var React63 = __toESM(require_react());
var DisabledContext = React63.createContext(false);
var DisabledContextProvider = ({
  children,
  disabled
}) => {
  const originDisabled = React63.useContext(DisabledContext);
  return React63.createElement(DisabledContext.Provider, {
    value: disabled ?? originDisabled
  }, children);
};
var DisabledContext_default = DisabledContext;

// node_modules/antd/es/config-provider/hooks/useConfig.js
var import_react27 = __toESM(require_react());

// node_modules/antd/es/config-provider/SizeContext.js
var React64 = __toESM(require_react());
var SizeContext = React64.createContext(void 0);
var SizeContextProvider = ({
  children,
  size
}) => {
  const originSize = React64.useContext(SizeContext);
  return React64.createElement(SizeContext.Provider, {
    value: size || originSize
  }, children);
};
var SizeContext_default = SizeContext;

// node_modules/antd/es/config-provider/hooks/useConfig.js
function useConfig() {
  const componentDisabled = (0, import_react27.useContext)(DisabledContext_default);
  const componentSize = (0, import_react27.useContext)(SizeContext_default);
  return {
    componentDisabled,
    componentSize
  };
}
var useConfig_default = useConfig;

// node_modules/antd/es/config-provider/hooks/useTheme.js
var import_react31 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

// node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
var import_react29 = __toESM(require_react());

// node_modules/@ant-design/cssinjs-utils/es/util/calc/calculator.js
var AbstractCalculator = _createClass(function AbstractCalculator2() {
  _classCallCheck(this, AbstractCalculator2);
});
var calculator_default2 = AbstractCalculator;

// node_modules/@ant-design/cssinjs-utils/es/util/calc/CSSCalculator.js
var CALC_UNIT2 = "CALC_UNIT";
var regexp5 = new RegExp(CALC_UNIT2, "g");
function unit2(value) {
  if (typeof value === "number") {
    return "".concat(value).concat(CALC_UNIT2);
  }
  return value;
}
var CSSCalculator2 = (function(_AbstractCalculator) {
  _inherits(CSSCalculator3, _AbstractCalculator);
  var _super = _createSuper(CSSCalculator3);
  function CSSCalculator3(num, unitlessCssVar) {
    var _this;
    _classCallCheck(this, CSSCalculator3);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "result", "");
    _defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
    _defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
    var numType = _typeof(num);
    _this.unitlessCssVar = unitlessCssVar;
    if (num instanceof CSSCalculator3) {
      _this.result = "(".concat(num.result, ")");
    } else if (numType === "number") {
      _this.result = unit2(num);
    } else if (numType === "string") {
      _this.result = num;
    }
    return _this;
  }
  _createClass(CSSCalculator3, [{
    key: "add",
    value: function add(num) {
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " + ").concat(num.getResult());
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " + ").concat(unit2(num));
      }
      this.lowPriority = true;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(num) {
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " - ").concat(num.getResult());
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " - ").concat(unit2(num));
      }
      this.lowPriority = true;
      return this;
    }
  }, {
    key: "mul",
    value: function mul(num) {
      if (this.lowPriority) {
        this.result = "(".concat(this.result, ")");
      }
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " * ").concat(num.getResult(true));
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " * ").concat(num);
      }
      this.lowPriority = false;
      return this;
    }
  }, {
    key: "div",
    value: function div(num) {
      if (this.lowPriority) {
        this.result = "(".concat(this.result, ")");
      }
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " / ").concat(num.getResult(true));
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " / ").concat(num);
      }
      this.lowPriority = false;
      return this;
    }
  }, {
    key: "getResult",
    value: function getResult(force) {
      return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function equal(options) {
      var _this2 = this;
      var _ref = options || {}, cssUnit = _ref.unit;
      var mergedUnit = true;
      if (typeof cssUnit === "boolean") {
        mergedUnit = cssUnit;
      } else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
        return _this2.result.includes(cssVar);
      })) {
        mergedUnit = false;
      }
      this.result = this.result.replace(regexp5, mergedUnit ? "px" : "");
      if (typeof this.lowPriority !== "undefined") {
        return "calc(".concat(this.result, ")");
      }
      return this.result;
    }
  }]);
  return CSSCalculator3;
})(calculator_default2);

// node_modules/@ant-design/cssinjs-utils/es/util/calc/NumCalculator.js
var NumCalculator2 = (function(_AbstractCalculator) {
  _inherits(NumCalculator3, _AbstractCalculator);
  var _super = _createSuper(NumCalculator3);
  function NumCalculator3(num) {
    var _this;
    _classCallCheck(this, NumCalculator3);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "result", 0);
    if (num instanceof NumCalculator3) {
      _this.result = num.result;
    } else if (typeof num === "number") {
      _this.result = num;
    }
    return _this;
  }
  _createClass(NumCalculator3, [{
    key: "add",
    value: function add(num) {
      if (num instanceof NumCalculator3) {
        this.result += num.result;
      } else if (typeof num === "number") {
        this.result += num;
      }
      return this;
    }
  }, {
    key: "sub",
    value: function sub(num) {
      if (num instanceof NumCalculator3) {
        this.result -= num.result;
      } else if (typeof num === "number") {
        this.result -= num;
      }
      return this;
    }
  }, {
    key: "mul",
    value: function mul(num) {
      if (num instanceof NumCalculator3) {
        this.result *= num.result;
      } else if (typeof num === "number") {
        this.result *= num;
      }
      return this;
    }
  }, {
    key: "div",
    value: function div(num) {
      if (num instanceof NumCalculator3) {
        this.result /= num.result;
      } else if (typeof num === "number") {
        this.result /= num;
      }
      return this;
    }
  }, {
    key: "equal",
    value: function equal() {
      return this.result;
    }
  }]);
  return NumCalculator3;
})(calculator_default2);
var NumCalculator_default = NumCalculator2;

// node_modules/@ant-design/cssinjs-utils/es/util/calc/index.js
var genCalc = function genCalc2(type5, unitlessCssVar) {
  var Calculator = type5 === "css" ? CSSCalculator2 : NumCalculator_default;
  return function(num) {
    return new Calculator(num, unitlessCssVar);
  };
};
var calc_default2 = genCalc;

// node_modules/@ant-design/cssinjs-utils/es/util/getCompVarPrefix.js
var getCompVarPrefix = function getCompVarPrefix2(component, prefix2) {
  return "".concat([prefix2, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
var getCompVarPrefix_default = getCompVarPrefix;

// node_modules/@ant-design/cssinjs-utils/es/util/getComponentToken.js
function getComponentToken(component, token2, defaultToken, options) {
  var customToken = _objectSpread2({}, token2[component]);
  if (options !== null && options !== void 0 && options.deprecatedTokens) {
    var deprecatedTokens = options.deprecatedTokens;
    deprecatedTokens.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
      if (true) {
        warning_default(!(customToken !== null && customToken !== void 0 && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead."));
      }
      if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
        var _customToken$newToken;
        (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
      }
    });
  }
  var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
  Object.keys(mergedToken).forEach(function(key) {
    if (mergedToken[key] === token2[key]) {
      delete mergedToken[key];
    }
  });
  return mergedToken;
}
var getComponentToken_default = getComponentToken;

// node_modules/@ant-design/cssinjs-utils/es/util/statistic.js
var enableStatistic = true;
var recording = true;
function merge2() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic) {
    return Object.assign.apply(Object, [{}].concat(objs));
  }
  recording = false;
  var ret = {};
  objs.forEach(function(obj) {
    if (_typeof(obj) !== "object") {
      return;
    }
    var keys2 = Object.keys(obj);
    keys2.forEach(function(key) {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: function get2() {
          return obj[key];
        }
      });
    });
  });
  recording = true;
  return ret;
}
var statistic = {};
function noop2() {
}
var statisticToken = function statisticToken2(token2) {
  var tokenKeys2;
  var proxy = token2;
  var flush = noop2;
  if (enableStatistic && typeof Proxy !== "undefined") {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get: function get2(obj, prop) {
        if (recording) {
          var _tokenKeys;
          (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
        }
        return obj[prop];
      }
    });
    flush = function flush2(componentName, componentToken) {
      var _statistic$componentN;
      statistic[componentName] = {
        global: Array.from(tokenKeys2),
        component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
      };
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
};
var statistic_default = statisticToken;

// node_modules/@ant-design/cssinjs-utils/es/util/getDefaultComponentToken.js
function getDefaultComponentToken(component, token2, getDefaultToken) {
  if (typeof getDefaultToken === "function") {
    var _token$component;
    return getDefaultToken(merge2(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
  }
  return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
}
var getDefaultComponentToken_default = getDefaultComponentToken;

// node_modules/@ant-design/cssinjs-utils/es/util/maxmin.js
function genMaxMin(type5) {
  if (type5 === "js") {
    return {
      max: Math.max,
      min: Math.min
    };
  }
  return {
    max: function max() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return "max(".concat(args.map(function(value) {
        return unit(value);
      }).join(","), ")");
    },
    min: function min() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return "min(".concat(args.map(function(value) {
        return unit(value);
      }).join(","), ")");
    }
  };
}
var maxmin_default = genMaxMin;

// node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js
var import_react28 = __toESM(require_react());
var BEAT_LIMIT = 1e3 * 60 * 10;
var ArrayKeyMap = (function() {
  function ArrayKeyMap2() {
    _classCallCheck(this, ArrayKeyMap2);
    _defineProperty(this, "map", /* @__PURE__ */ new Map());
    _defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
    _defineProperty(this, "nextID", 0);
    _defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
    _defineProperty(this, "accessBeat", 0);
  }
  _createClass(ArrayKeyMap2, [{
    key: "set",
    value: function set2(keys2, value) {
      this.clear();
      var compositeKey = this.getCompositeKey(keys2);
      this.map.set(compositeKey, value);
      this.lastAccessBeat.set(compositeKey, Date.now());
    }
  }, {
    key: "get",
    value: function get2(keys2) {
      var compositeKey = this.getCompositeKey(keys2);
      var cache = this.map.get(compositeKey);
      this.lastAccessBeat.set(compositeKey, Date.now());
      this.accessBeat += 1;
      return cache;
    }
  }, {
    key: "getCompositeKey",
    value: function getCompositeKey(keys2) {
      var _this = this;
      var ids = keys2.map(function(key) {
        if (key && _typeof(key) === "object") {
          return "obj_".concat(_this.getObjectID(key));
        }
        return "".concat(_typeof(key), "_").concat(key);
      });
      return ids.join("|");
    }
  }, {
    key: "getObjectID",
    value: function getObjectID(obj) {
      if (this.objectIDMap.has(obj)) {
        return this.objectIDMap.get(obj);
      }
      var id = this.nextID;
      this.objectIDMap.set(obj, id);
      this.nextID += 1;
      return id;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this2 = this;
      if (this.accessBeat > 1e4) {
        var now = Date.now();
        this.lastAccessBeat.forEach(function(beat, key) {
          if (now - beat > BEAT_LIMIT) {
            _this2.map.delete(key);
            _this2.lastAccessBeat.delete(key);
          }
        });
        this.accessBeat = 0;
      }
    }
  }]);
  return ArrayKeyMap2;
})();
var uniqueMap = new ArrayKeyMap();
function useUniqueMemo(memoFn, deps) {
  return import_react28.default.useMemo(function() {
    var cachedValue = uniqueMap.get(deps);
    if (cachedValue) {
      return cachedValue;
    }
    var newValue = memoFn();
    uniqueMap.set(deps, newValue);
    return newValue;
  }, deps);
}
var useUniqueMemo_default = useUniqueMemo;

// node_modules/@ant-design/cssinjs-utils/es/hooks/useCSP.js
var useDefaultCSP = function useDefaultCSP2() {
  return {};
};
var useCSP_default = useDefaultCSP;

// node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
function genStyleUtils(config) {
  var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useCSP_default : _config$useCSP, useToken2 = config.useToken, usePrefix = config.usePrefix, getResetStyles = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
  function genStyleHooks2(component, styleFn, getDefaultToken, options) {
    var componentName = Array.isArray(component) ? component[0] : component;
    function prefixToken(key) {
      return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
    }
    var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
    var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
    var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
    Object.keys(originUnitless).forEach(function(key) {
      compUnitless[prefixToken(key)] = originUnitless[key];
    });
    var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
      unitless: compUnitless,
      prefixToken
    });
    var useStyle = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions);
    var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      var hashId = useStyle(prefixCls, rootCls);
      var cssVarCls = useCSSVar(rootCls);
      return [hashId, cssVarCls];
    };
  }
  function genCSSVarRegister(component, getDefaultToken, options) {
    var compUnitless = options.unitless, prefixToken = options.prefixToken, ignore2 = options.ignore;
    return function(rootCls) {
      var _useToken = useToken2(), cssVar = _useToken.cssVar, realToken = _useToken.realToken;
      useCSSVarRegister_default({
        path: [component],
        prefix: cssVar.prefix,
        key: cssVar.key,
        unitless: compUnitless,
        ignore: ignore2,
        token: realToken,
        scope: rootCls
      }, function() {
        var defaultToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
        var componentToken = getComponentToken_default(component, realToken, defaultToken, {
          deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
        });
        if (defaultToken) {
          Object.keys(defaultToken).forEach(function(key) {
            componentToken[prefixToken(key)] = componentToken[key];
            delete componentToken[key];
          });
        }
        return componentToken;
      });
      return cssVar === null || cssVar === void 0 ? void 0 : cssVar.key;
    };
  }
  function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
    var _cells = _slicedToArray(cells, 1), component = _cells[0];
    var concatComponent = cells.join("-");
    var mergedLayer = config.layer || {
      name: "antd"
    };
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      var _useToken2 = useToken2(), theme = _useToken2.theme, realToken = _useToken2.realToken, hashId = _useToken2.hashId, token2 = _useToken2.token, cssVar = _useToken2.cssVar, zeroRuntime = _useToken2.zeroRuntime;
      var memoizedZeroRuntime = (0, import_react29.useMemo)(function() {
        return zeroRuntime;
      }, []);
      if (memoizedZeroRuntime) {
        return hashId;
      }
      var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
      var csp = useCSP();
      var type5 = "css";
      var calc = useUniqueMemo_default(function() {
        var unitlessCssVar = /* @__PURE__ */ new Set();
        Object.keys(options.unitless || {}).forEach(function(key) {
          unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
          unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)));
        });
        return calc_default2(type5, unitlessCssVar);
      }, [type5, component, cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix]);
      var _genMaxMin = maxmin_default(type5), max = _genMaxMin.max, min = _genMaxMin.min;
      var sharedConfig = {
        theme,
        token: token2,
        hashId,
        nonce: function nonce() {
          return csp.nonce;
        },
        clientOnly: options.clientOnly,
        layer: mergedLayer,
        // antd is always at top of styles
        order: options.order || -999
      };
      if (typeof getResetStyles === "function") {
        useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
          clientOnly: false,
          path: ["Shared", rootPrefixCls]
        }), function() {
          return getResetStyles(token2, {
            prefix: {
              rootPrefixCls,
              iconPrefixCls
            },
            csp
          });
        });
      }
      useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
        path: [concatComponent, prefixCls, iconPrefixCls]
      }), function() {
        if (options.injectStyle === false) {
          return [];
        }
        var _statisticToken = statistic_default(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
        var defaultComponentToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
        var componentCls = ".".concat(prefixCls);
        var componentToken = getComponentToken_default(component, realToken, defaultComponentToken, {
          deprecatedTokens: options.deprecatedTokens
        });
        if (defaultComponentToken && _typeof(defaultComponentToken) === "object") {
          Object.keys(defaultComponentToken).forEach(function(key) {
            defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)), ")");
          });
        }
        var mergedToken = merge2(proxyToken, {
          componentCls,
          prefixCls,
          iconCls: ".".concat(iconPrefixCls),
          antCls: ".".concat(rootPrefixCls),
          calc,
          max,
          min
        }, defaultComponentToken);
        var styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls
        });
        flush(component, componentToken);
        var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
        return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
      });
      return hashId;
    };
  }
  function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var useStyle = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2({
      resetStyle: false,
      // Sub Style should default after root one
      order: -998
    }, options));
    var StyledComponent = function StyledComponent2(_ref) {
      var prefixCls = _ref.prefixCls, _ref$rootCls = _ref.rootCls, rootCls = _ref$rootCls === void 0 ? prefixCls : _ref$rootCls;
      useStyle(prefixCls, rootCls);
      return null;
    };
    if (true) {
      StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName));
    }
    return StyledComponent;
  }
  return {
    genStyleHooks: genStyleHooks2,
    genSubStyleComponent: genSubStyleComponent2,
    genComponentStyleHook: genComponentStyleHook2
  };
}
var genStyleUtils_default = genStyleUtils;

// node_modules/antd/es/theme/interface/presetColors.js
var PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];

// node_modules/antd/es/theme/util/genStyleUtils.js
var import_react30 = __toESM(require_react());

// node_modules/antd/es/style/index.js
var textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
var resetComponent = (token2, needInheritFontFamily = false) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: token2.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
});
var resetIcon = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
});
var clearFix = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
});
var genLinkStyle = (token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
});
var genCommonStyle = (token2, componentPrefixCls, rootCls, resetFont) => {
  const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
  const resetStyle = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let resetFontStyle = {};
  if (resetFont !== false) {
    resetFontStyle = {
      fontFamily: token2.fontFamily,
      fontSize: token2.fontSize
    };
  }
  return {
    [rootPrefixSelector]: {
      ...resetFontStyle,
      ...resetStyle,
      [prefixSelector]: resetStyle
    }
  };
};
var genFocusOutline = (token2, offset) => ({
  outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
  outlineOffset: offset ?? 1,
  transition: "outline-offset 0s, outline 0s"
});
var genFocusStyle = (token2, offset) => ({
  "&:focus-visible": genFocusOutline(token2, offset)
});
var genIconStyle = (iconPrefixCls) => ({
  [`.${iconPrefixCls}`]: {
    ...resetIcon(),
    [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
      display: "block"
    }
  }
});
var operationUnit = (token2) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: token2.colorLink,
  textDecoration: token2.linkDecoration,
  outline: "none",
  cursor: "pointer",
  transition: `all ${token2.motionDurationSlow}`,
  border: 0,
  padding: 0,
  background: "none",
  userSelect: "none",
  ...genFocusStyle(token2),
  "&:hover": {
    color: token2.colorLinkHover,
    textDecoration: token2.linkHoverDecoration
  },
  "&:focus": {
    color: token2.colorLinkHover,
    textDecoration: token2.linkFocusDecoration
  },
  "&:active": {
    color: token2.colorLinkActive,
    textDecoration: token2.linkHoverDecoration
  }
});

// node_modules/antd/es/theme/util/genStyleUtils.js
var {
  genStyleHooks,
  genComponentStyleHook,
  genSubStyleComponent
} = genStyleUtils_default({
  usePrefix: () => {
    const {
      getPrefixCls,
      iconPrefixCls
    } = (0, import_react30.useContext)(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    return {
      rootPrefixCls,
      iconPrefixCls
    };
  },
  useToken: () => {
    const [theme, realToken, hashId, token2, cssVar, zeroRuntime] = useToken();
    return {
      theme,
      realToken,
      hashId,
      token: token2,
      cssVar,
      zeroRuntime
    };
  },
  useCSP: () => {
    const {
      csp
    } = (0, import_react30.useContext)(ConfigContext);
    return csp ?? {};
  },
  getResetStyles: (token2, config) => {
    const linkStyle = genLinkStyle(token2);
    return [linkStyle, {
      "&": linkStyle
    }, genIconStyle(config?.prefix.iconPrefixCls ?? defaultIconPrefixCls)];
  },
  getCommonStyle: genCommonStyle,
  getCompUnitless: () => unitless
});
var genCssVar = (antCls, componentAbbr) => {
  const cssPrefix = `--${antCls.replace(".", "")}-${componentAbbr}-`;
  return (name, withVar = false) => {
    const raw = `${cssPrefix}${name}`;
    return withVar ? `var(${raw})` : raw;
  };
};

// node_modules/antd/es/theme/util/genPresetColor.js
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`];
    const lightBorderColor = token2[`${colorKey}3`];
    const darkColor = token2[`${colorKey}6`];
    const textColor = token2[`${colorKey}7`];
    return {
      ...prev2,
      ...genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      })
    };
  }, {});
}

// node_modules/antd/es/theme/util/useResetIconStyle.js
var useResetIconStyle = (iconPrefixCls, csp) => {
  const [theme, token2] = useToken();
  return useStyleRegister({
    theme,
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls],
    nonce: () => csp?.nonce,
    layer: {
      name: "antd"
    }
  }, () => genIconStyle(iconPrefixCls));
};
var useResetIconStyle_default = useResetIconStyle;

// node_modules/antd/es/config-provider/hooks/useTheme.js
function useTheme(theme, parentTheme, config) {
  const warning5 = devUseWarning("ConfigProvider");
  const themeConfig = theme || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
    ...defaultConfig,
    hashed: parentTheme?.hashed ?? defaultConfig.hashed,
    cssVar: parentTheme?.cssVar
  } : parentTheme;
  const themeKey = (0, import_react31.useId)();
  if (true) {
    const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
    const validKey = !!(typeof themeConfig.cssVar === "object" && themeConfig.cssVar?.key || themeKey);
    true ? warning5(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.") : void 0;
  }
  return useMemo(() => {
    if (!theme) {
      return parentTheme;
    }
    const mergedComponents = {
      ...parentThemeConfig.components
    };
    Object.keys(theme.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = {
        ...mergedComponents[componentName],
        ...theme.components[componentName]
      };
    });
    const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
    const mergedCssVar = {
      prefix: config?.prefixCls,
      // Same as prefixCls by default
      ...parentThemeConfig.cssVar,
      ...themeConfig.cssVar,
      key: themeConfig.cssVar?.key || cssVarKey
    };
    return {
      ...parentThemeConfig,
      ...themeConfig,
      token: {
        ...parentThemeConfig.token,
        ...themeConfig.token
      },
      components: mergedComponents,
      cssVar: mergedCssVar
    };
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index) => {
    const nextTheme = next2[index];
    return !isEqual_default(prevTheme, nextTheme, true);
  }));
}

// node_modules/antd/es/config-provider/MotionWrapper.js
var React66 = __toESM(require_react());
var MotionCacheContext = React66.createContext(true);
if (true) {
  MotionCacheContext.displayName = "MotionCacheContext";
}
function MotionWrapper(props) {
  const parentMotion = React66.useContext(MotionCacheContext);
  const {
    children
  } = props;
  const [, token2] = useToken();
  const {
    motion
  } = token2;
  const needWrapMotionProviderRef = React66.useRef(false);
  needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion);
  if (needWrapMotionProviderRef.current) {
    return React66.createElement(MotionCacheContext.Provider, {
      value: motion
    }, React66.createElement(MotionProvider, {
      motion
    }, children));
  }
  return children;
}

// node_modules/antd/es/config-provider/PropWarning.js
var React67 = __toESM(require_react());
var PropWarning = React67.memo(({
  dropdownMatchSelectWidth
}) => {
  const warning5 = devUseWarning("ConfigProvider");
  warning5.deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth");
  return null;
});
if (true) {
  PropWarning.displayName = "PropWarning";
}
var PropWarning_default = true ? PropWarning : () => null;

// node_modules/antd/es/config-provider/index.js
var existThemeConfig = false;
var warnContext = true ? (componentName) => {
  true ? warning_default2(!existThemeConfig, componentName, `Static function can not consume context like dynamic theme. Please use 'App' component instead.`) : void 0;
} : (
  /* istanbul ignore next */
  null
);
var PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
var globalPrefixCls;
var globalIconPrefixCls;
var globalTheme;
var globalHolderRender;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
var setGlobalConfig = (props) => {
  const {
    prefixCls,
    iconPrefixCls,
    theme,
    holderRender
  } = props;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if ("holderRender" in props) {
    globalHolderRender = holderRender;
  }
  if (theme) {
    globalTheme = theme;
  }
};
var globalConfig = () => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalPrefixCls) {
      return globalPrefixCls;
    }
    return getGlobalPrefixCls();
  },
  getTheme: () => globalTheme,
  holderRender: globalHolderRender
});
var ProviderChildren = (props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    alert,
    affix,
    anchor,
    form,
    locale: locale5,
    componentSize,
    direction,
    space,
    splitter,
    virtual,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    popupOverflow,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme,
    componentDisabled,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    masonry,
    menu,
    pagination,
    input,
    textArea,
    otp,
    empty,
    badge,
    radio,
    rate,
    ribbon,
    switch: SWITCH,
    transfer,
    avatar,
    message,
    tag,
    table,
    card,
    cardMeta,
    tabs,
    timeline,
    timePicker,
    upload,
    notification,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    tooltip,
    popover,
    popconfirm,
    qrcode,
    floatButton,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect,
    watermark
  } = props;
  const getPrefixCls = React68.useCallback((suffixCls, customizePrefixCls) => {
    const {
      prefixCls
    } = props;
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
  const csp = customCsp || parentContext.csp;
  useResetIconStyle_default(iconPrefixCls, csp);
  const mergedTheme = useTheme(theme, parentContext.theme, {
    prefixCls: getPrefixCls("")
  });
  if (true) {
    existThemeConfig = existThemeConfig || !!mergedTheme;
  }
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    alert,
    affix,
    anchor,
    locale: locale5 || legacyLocale,
    direction,
    space,
    splitter,
    virtual,
    popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
    popupOverflow,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    input,
    textArea,
    otp,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    masonry,
    menu,
    pagination,
    empty,
    badge,
    radio,
    rate,
    ribbon,
    switch: SWITCH,
    transfer,
    avatar,
    message,
    tag,
    table,
    card,
    cardMeta,
    tabs,
    timeline,
    timePicker,
    upload,
    notification,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    tooltip,
    popover,
    popconfirm,
    qrcode,
    floatButton,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect,
    watermark
  };
  if (true) {
    const warningFn = devUseWarning("ConfigProvider");
    warningFn(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  }
  const config = {
    ...parentContext
  };
  Object.keys(baseConfig).forEach((key) => {
    if (baseConfig[key] !== void 0) {
      config[key] = baseConfig[key];
    }
  });
  PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  if (typeof autoInsertSpaceInButton !== "undefined") {
    config.button = {
      autoInsertSpace: autoInsertSpaceInButton,
      ...config.button
    };
  }
  const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
    const prevKeys = Object.keys(prevConfig);
    const currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
  });
  const {
    layer
  } = React68.useContext(StyleContext_default);
  const memoIconContextValue = React68.useMemo(() => ({
    prefixCls: iconPrefixCls,
    csp,
    layer: layer ? "antd" : void 0
  }), [iconPrefixCls, csp, layer]);
  let childNode = React68.createElement(React68.Fragment, null, React68.createElement(PropWarning_default, {
    dropdownMatchSelectWidth
  }), children);
  const validateMessages = React68.useMemo(() => merge(en_US_default6.Form?.defaultValidateMessages || {}, memoedConfig.locale?.Form?.defaultValidateMessages || {}, memoedConfig.form?.validateMessages || {}, form?.validateMessages || {}), [memoedConfig, form?.validateMessages]);
  if (Object.keys(validateMessages).length > 0) {
    childNode = React68.createElement(validateMessagesContext_default.Provider, {
      value: validateMessages
    }, childNode);
  }
  if (locale5) {
    childNode = React68.createElement(locale_default, {
      locale: locale5,
      _ANT_MARK__: ANT_MARK
    }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = React68.createElement(Context_default.Provider, {
      value: memoIconContextValue
    }, childNode);
  }
  if (componentSize) {
    childNode = React68.createElement(SizeContextProvider, {
      size: componentSize
    }, childNode);
  }
  childNode = React68.createElement(MotionWrapper, null, childNode);
  if (tooltip?.unique) {
    childNode = React68.createElement(UniqueProvider_default2, null, childNode);
  }
  const memoTheme = React68.useMemo(() => {
    const {
      algorithm,
      token: token2,
      components: components2,
      cssVar,
      ...rest
    } = mergedTheme || {};
    const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : theme_default;
    const parsedComponents = {};
    Object.entries(components2 || {}).forEach(([componentName, componentToken]) => {
      const parsedToken = {
        ...componentToken
      };
      if ("algorithm" in parsedToken) {
        if (parsedToken.algorithm === true) {
          parsedToken.theme = themeObj;
        } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
          parsedToken.theme = createTheme(parsedToken.algorithm);
        }
        delete parsedToken.algorithm;
      }
      parsedComponents[componentName] = parsedToken;
    });
    const mergedToken = {
      ...seed_default,
      ...token2
    };
    return {
      ...rest,
      theme: themeObj,
      token: mergedToken,
      components: parsedComponents,
      override: {
        override: mergedToken,
        ...parsedComponents
      },
      cssVar
    };
  }, [mergedTheme]);
  if (theme) {
    childNode = React68.createElement(DesignTokenContext.Provider, {
      value: memoTheme
    }, childNode);
  }
  if (memoedConfig.warning) {
    childNode = React68.createElement(WarningContext.Provider, {
      value: memoedConfig.warning
    }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = React68.createElement(DisabledContextProvider, {
      disabled: componentDisabled
    }, childNode);
  }
  return React68.createElement(ConfigContext.Provider, {
    value: memoedConfig
  }, childNode);
};
var ConfigProvider = (props) => {
  const context = React68.useContext(ConfigContext);
  const antLocale = React68.useContext(context_default);
  return React68.createElement(ProviderChildren, {
    parentContext: context,
    legacyLocale: antLocale,
    ...props
  });
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext_default;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig_default;
Object.defineProperty(ConfigProvider, "SizeContext", {
  get: () => {
    true ? warning_default2(false, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead.") : void 0;
    return SizeContext_default;
  }
});
if (true) {
  ConfigProvider.displayName = "ConfigProvider";
}
var config_provider_default = ConfigProvider;

// node_modules/antd/es/config-provider/hooks/useSize.js
var import_react32 = __toESM(require_react());
var useSize = (customSize) => {
  const size = import_react32.default.useContext(SizeContext_default);
  const mergedSize = import_react32.default.useMemo(() => {
    if (!customSize) {
      return size;
    }
    if (typeof customSize === "string") {
      return customSize ?? size;
    }
    if (typeof customSize === "function") {
      return customSize(size);
    }
    return size;
  }, [customSize, size]);
  return mergedSize;
};
var useSize_default = useSize;

// node_modules/antd/es/space/style/compact.js
var genSpaceCompactStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var compact_default = genStyleHooks(["Space", "Compact"], (token2) => [genSpaceCompactStyle(token2)], () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: false
});

// node_modules/antd/es/space/Compact.js
var SpaceCompactItemContext = React70.createContext(null);
var useCompactItemContext = (prefixCls, direction) => {
  const compactItemContext = React70.useContext(SpaceCompactItemContext);
  const compactItemClassnames = React70.useMemo(() => {
    if (!compactItemContext) {
      return "";
    }
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return clsx(`${prefixCls}-compact${separator}item`, {
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext?.compactSize,
    compactDirection: compactItemContext?.compactDirection,
    compactItemClassnames
  };
};
var NoCompactStyle = (props) => {
  const {
    children
  } = props;
  return React70.createElement(SpaceCompactItemContext.Provider, {
    value: null
  }, children);
};
var CompactItem = (props) => {
  const {
    children,
    ...others
  } = props;
  return React70.createElement(SpaceCompactItemContext.Provider, {
    value: React70.useMemo(() => others, [others])
  }, children);
};
var Compact = (props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = React70.useContext(ConfigContext);
  const {
    size,
    direction,
    orientation,
    block,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    vertical,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Space.Compact");
    warning5.deprecated(!direction, "direction", "orientation");
  }
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
  const mergedSize = useSize_default((ctx) => size ?? ctx);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [hashId] = compact_default(prefixCls);
  const clx = clsx(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-vertical`]: mergedVertical
  }, className, rootClassName);
  const compactItemContext = React70.useContext(SpaceCompactItemContext);
  const childNodes = toArray(children);
  const nodes = React70.useMemo(() => childNodes.map((child, i) => {
    const key = child?.key || `${prefixCls}-item-${i}`;
    return React70.createElement(CompactItem, {
      key,
      compactSize: mergedSize,
      compactDirection: mergedOrientation,
      isFirstItem: i === 0 && (!compactItemContext || compactItemContext?.isFirstItem),
      isLastItem: i === childNodes.length - 1 && (!compactItemContext || compactItemContext?.isLastItem)
    }, child);
  }), [childNodes, compactItemContext, mergedOrientation, mergedSize, prefixCls]);
  if (childNodes.length === 0) {
    return null;
  }
  return React70.createElement("div", {
    className: clx,
    ...restProps
  }, nodes);
};
var Compact_default = Compact;

// node_modules/antd/es/_util/ContextIsolator.js
var ContextIsolator = (props) => {
  const {
    space,
    form,
    children
  } = props;
  if (!isNonNullable_default(children)) {
    return null;
  }
  let result = children;
  if (form) {
    result = import_react33.default.createElement(NoFormStyle, {
      override: true,
      status: true
    }, result);
  }
  if (space) {
    result = import_react33.default.createElement(NoCompactStyle, null, result);
  }
  return result;
};
var ContextIsolator_default = ContextIsolator;

// node_modules/antd/es/_util/PurePanel.js
var React72 = __toESM(require_react());
function withPureRenderTheme(Component3) {
  return (props) => React72.createElement(config_provider_default, {
    theme: {
      token: {
        motion: false,
        zIndexPopupBase: 0
      }
    }
  }, React72.createElement(Component3, {
    ...props
  }));
}
var genPurePanel = (Component3, alignPropName, postProps, defaultPrefixCls2, getDropdownCls) => {
  const PurePanel5 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2
    } = props;
    const holderRef = React72.useRef(null);
    const [popupHeight, setPopupHeight] = React72.useState(0);
    const [popupWidth, setPopupWidth] = React72.useState(0);
    const [open, setOpen] = useControlledState(false, props.open);
    const {
      getPrefixCls
    } = React72.useContext(ConfigContext);
    const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
    React72.useEffect(() => {
      setOpen(true);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver = new ResizeObserver((entries) => {
          const element = entries[0].target;
          setPopupHeight(element.offsetHeight + 8);
          setPopupWidth(element.offsetWidth);
        });
        const interval = setInterval(() => {
          const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
          const popup = holderRef.current?.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver.observe(popup);
          }
        }, 10);
        return () => {
          clearInterval(interval);
          resizeObserver.disconnect();
        };
      }
    }, [prefixCls]);
    let mergedProps = {
      ...props,
      style: {
        ...style2,
        margin: 0
      },
      open,
      getPopupContainer: () => holderRef.current
    };
    if (postProps) {
      mergedProps = postProps(mergedProps);
    }
    if (alignPropName) {
      Object.assign(mergedProps, {
        [alignPropName]: {
          overflow: {
            adjustX: false,
            adjustY: false
          }
        }
      });
    }
    const mergedStyle = {
      paddingBottom: popupHeight,
      position: "relative",
      minWidth: popupWidth
    };
    return React72.createElement("div", {
      ref: holderRef,
      style: mergedStyle
    }, React72.createElement(Component3, {
      ...mergedProps
    }));
  };
  return withPureRenderTheme(PurePanel5);
};
var PurePanel_default = genPurePanel;

// node_modules/antd/es/_util/statusUtils.js
var getStatusClassNames = (prefixCls, status, hasFeedback) => {
  return clsx({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
};
var getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

// node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = (prefixCls) => `${prefixCls}-css-var`;
var useCSSVarCls_default = useCSSVarCls;

// node_modules/antd/es/popover/index.js
var React89 = __toESM(require_react());
var import_react47 = __toESM(require_react());

// node_modules/@rc-component/util/es/KeyCode.js
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    const {
      keyCode
    } = e;
    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var KeyCode_default = KeyCode;

// node_modules/antd/es/_util/getRenderPropValue.js
var getRenderPropValue = (propValue) => {
  if (!propValue) {
    return null;
  }
  return typeof propValue === "function" ? propValue() : propValue;
};

// node_modules/antd/es/_util/motion.js
var getCollapsedHeight = () => ({
  height: 0,
  opacity: 0
});
var getRealHeight = (node2) => {
  const {
    scrollHeight
  } = node2;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = (node2) => ({
  height: node2 ? node2.offsetHeight : 0
});
var skipOpacityTransition = (_, event) => event?.deadline === true || event.propertyName === "height";
var initCollapseMotion = (rootCls = defaultPrefixCls) => ({
  motionName: `${rootCls}-motion-collapse`,
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
});
var getTransitionName2 = (rootPrefixCls, motion, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion}`;
};
var motion_default = initCollapseMotion;

// node_modules/antd/es/_util/reactNode.js
var import_react34 = __toESM(require_react());
function isFragment2(child) {
  return child && import_react34.default.isValidElement(child) && child.type === import_react34.default.Fragment;
}
var replaceElement = (element, replacement, props) => {
  if (!import_react34.default.isValidElement(element)) {
    return replacement;
  }
  return import_react34.default.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
};
function cloneElement7(element, props) {
  return replaceElement(element, element, props);
}

// node_modules/antd/es/tooltip/index.js
var React87 = __toESM(require_react());

// node_modules/@rc-component/tooltip/es/Popup.js
var React74 = __toESM(require_react());
var Popup2 = (props) => {
  const {
    children,
    prefixCls,
    id,
    classNames,
    styles,
    className,
    style: style2
  } = props;
  return React74.createElement("div", {
    id,
    className: clsx(`${prefixCls}-container`, classNames?.container, className),
    style: {
      ...styles?.container,
      ...style2
    },
    role: "tooltip"
  }, typeof children === "function" ? children() : children);
};
var Popup_default2 = Popup2;

// node_modules/@rc-component/tooltip/es/Tooltip.js
var React75 = __toESM(require_react());
var import_react35 = __toESM(require_react());

// node_modules/@rc-component/tooltip/es/placements.js
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
};
var autoAdjustOverflowLeftRight = {
  adjustX: 1,
  shiftY: true
};
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  }
};

// node_modules/@rc-component/tooltip/es/Tooltip.js
function _extends8() {
  _extends8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
var Tooltip = React75.forwardRef((props, ref) => {
  const {
    trigger = ["hover"],
    mouseEnterDelay = 0,
    mouseLeaveDelay = 0.1,
    prefixCls = "rc-tooltip",
    children,
    onVisibleChange,
    afterVisibleChange,
    motion,
    placement = "right",
    align = {},
    destroyOnHidden = false,
    defaultVisible,
    getTooltipContainer,
    arrowContent,
    overlay,
    id,
    showArrow = true,
    classNames,
    styles,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const triggerRef = (0, import_react35.useRef)(null);
  (0, import_react35.useImperativeHandle)(ref, () => triggerRef.current);
  const extraProps = {
    ...restProps
  };
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  const mergedArrow = React75.useMemo(() => {
    if (!showArrow) {
      return false;
    }
    const arrowConfig = showArrow === true ? {} : showArrow;
    return {
      ...arrowConfig,
      className: clsx(arrowConfig.className, classNames?.arrow),
      style: {
        ...arrowConfig.style,
        ...styles?.arrow
      },
      content: arrowConfig.content ?? arrowContent
    };
  }, [showArrow, classNames?.arrow, styles?.arrow, arrowContent]);
  const getChildren = ({
    open
  }) => {
    const child = React75.Children.only(children);
    const ariaProps = {
      "aria-describedby": overlay && open ? mergedId : void 0
    };
    return React75.cloneElement(child, ariaProps);
  };
  return React75.createElement(es_default6, _extends8({
    popupClassName: classNames?.root,
    prefixCls,
    popup: React75.createElement(Popup_default2, {
      key: "content",
      prefixCls,
      id: mergedId,
      classNames,
      styles
    }, overlay),
    action: trigger,
    builtinPlacements: placements,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onOpenChange: onVisibleChange,
    afterOpenChange: afterVisibleChange,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyOnHidden,
    mouseLeaveDelay,
    popupStyle: styles?.root,
    mouseEnterDelay,
    arrow: mergedArrow,
    uniqueContainerClassName: classNames?.uniqueContainer,
    uniqueContainerStyle: styles?.uniqueContainer
  }, extraProps), getChildren);
});
var Tooltip_default = Tooltip;

// node_modules/@rc-component/tooltip/es/index.js
var es_default7 = Tooltip_default;

// node_modules/antd/es/style/roundedArrow.js
function getArrowToken(token2) {
  const {
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter
  } = token2;
  const unitWidth = sizePopupArrow / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = borderRadiusOuter * 1 / Math.sqrt(2);
  const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
  const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
  const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
  const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
  const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
  return {
    arrowShadowWidth: shadowWidth,
    arrowPath,
    arrowPolygon
  };
}
var genRoundedArrow = (token2, bgColor, boxShadow) => {
  const {
    sizePopupArrow,
    arrowPolygon,
    arrowPath,
    arrowShadowWidth,
    borderRadiusXS,
    calc
  } = token2;
  return {
    pointerEvents: "none",
    width: sizePopupArrow,
    height: sizePopupArrow,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: sizePopupArrow,
      height: calc(sizePopupArrow).div(2).equal(),
      background: bgColor,
      clipPath: {
        _multi_value_: true,
        value: [arrowPolygon, arrowPath]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: arrowShadowWidth,
      height: arrowShadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${unit(borderRadiusXS)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
};

// node_modules/antd/es/style/placementArrow.js
var MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
  const {
    contentRadius,
    limitVerticalRadius
  } = options;
  const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
  return {
    arrowOffsetHorizontal: arrowOffset,
    arrowOffsetVertical
  };
}
function isInject(valid, code) {
  if (!valid) {
    return {};
  }
  return code;
}
function getArrowStyle(token2, colorBg, options) {
  const {
    componentCls,
    boxShadowPopoverArrow,
    arrowOffsetVertical,
    arrowOffsetHorizontal
  } = token2;
  const {
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options || {};
  return {
    [componentCls]: {
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [{
        position: "absolute",
        zIndex: 1,
        // lift it up so the menu wouldn't cask shadow on it
        display: "block",
        ...genRoundedArrow(token2, colorBg, boxShadowPopoverArrow),
        "&:before": {
          background: colorBg
        }
      }],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      ...isInject(!!arrowPlacement.top, {
        [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        "&-placement-topLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-topRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      }),
      // >>>>> Bottom
      ...isInject(!!arrowPlacement.bottom, {
        [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        "&-placement-bottomLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-bottomRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      }),
      // >>>>> Left
      ...isInject(!!arrowPlacement.left, {
        [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-leftBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      }),
      // >>>>> Right
      ...isInject(!!arrowPlacement.right, {
        [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-rightBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      })
    }
  };
}

// node_modules/antd/es/_util/placements.js
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
  if (autoAdjustOverflow === false) {
    return {
      adjustX: false,
      adjustY: false
    };
  }
  const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === "object" ? autoAdjustOverflow : {};
  const baseOverflow = {};
  switch (placement) {
    case "top":
    case "bottom":
      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
      baseOverflow.shiftY = true;
      baseOverflow.adjustY = true;
      break;
    case "left":
    case "right":
      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
      baseOverflow.shiftX = true;
      baseOverflow.adjustX = true;
      break;
  }
  const mergedOverflow = {
    ...baseOverflow,
    ...overflow
  };
  if (!mergedOverflow.shiftX) {
    mergedOverflow.adjustX = true;
  }
  if (!mergedOverflow.shiftY) {
    mergedOverflow.adjustY = true;
  }
  return mergedOverflow;
}
var PlacementAlignMap = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
};
var ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
};
var DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function getPlacements(config) {
  const {
    arrowWidth,
    autoAdjustOverflow,
    arrowPointAtCenter,
    offset,
    borderRadius,
    visibleFirst
  } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {};
  const arrowOffset = getArrowOffsetToken({
    contentRadius: borderRadius,
    limitVerticalRadius: true
  });
  Object.keys(PlacementAlignMap).forEach((key) => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
    const placementInfo = {
      ...template,
      offset: [0, 0],
      dynamicInset: true
    };
    placementMap[key] = placementInfo;
    if (DisableAutoArrowList.has(key)) {
      placementInfo.autoArrow = false;
    }
    switch (key) {
      case "top":
      case "topLeft":
      case "topRight":
        placementInfo.offset[1] = -halfArrowWidth - offset;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        placementInfo.offset[1] = halfArrowWidth + offset;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        placementInfo.offset[0] = -halfArrowWidth - offset;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        placementInfo.offset[0] = halfArrowWidth + offset;
        break;
    }
    if (arrowPointAtCenter) {
      switch (key) {
        case "topLeft":
        case "bottomLeft":
          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case "topRight":
        case "bottomRight":
          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
        case "leftTop":
        case "rightTop":
          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
          break;
        case "leftBottom":
        case "rightBottom":
          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
          break;
      }
    }
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow);
    if (visibleFirst) {
      placementInfo.htmlRegion = "visibleFirst";
    }
  });
  return placementMap;
}

// node_modules/antd/es/tooltip/hook/useMergedArrow.js
var import_react36 = __toESM(require_react());
var useMergedArrow = (providedArrow, providedContextArrow) => {
  const toConfig = (arrow) => typeof arrow === "boolean" ? {
    show: arrow
  } : arrow || {};
  return import_react36.default.useMemo(() => {
    const arrowConfig = toConfig(providedArrow);
    const contextArrowConfig = toConfig(providedContextArrow);
    return {
      ...contextArrowConfig,
      ...arrowConfig,
      show: arrowConfig.show ?? contextArrowConfig.show ?? true
    };
  }, [providedArrow, providedContextArrow]);
};
var useMergedArrow_default = useMergedArrow;

// node_modules/antd/es/tooltip/PurePanel.js
var React86 = __toESM(require_react());

// node_modules/antd/es/style/motion/collapse.js
var genCollapseMotion = (token2) => ({
  [token2.componentCls]: {
    // For common/openAnimation
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
});
var collapse_default = genCollapseMotion;

// node_modules/antd/es/style/motion/motion.js
var initMotionCommon = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
var initMotionCommonLeave = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
var initMotion = (motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: {
      ...initMotionCommon(duration),
      animationPlayState: "paused"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      ...initMotionCommonLeave(duration),
      animationPlayState: "paused"
    },
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
};

// node_modules/antd/es/style/motion/fade.js
var fadeIn = new Keyframes_default("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var fadeOut = new Keyframes_default("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
var initFadeMotion = (token2, sameLevel = false) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
};

// node_modules/antd/es/style/motion/move.js
var moveDownIn = new Keyframes_default("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveDownOut = new Keyframes_default("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveLeftIn = new Keyframes_default("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveLeftOut = new Keyframes_default("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveRightIn = new Keyframes_default("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveRightOut = new Keyframes_default("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveUpIn = new Keyframes_default("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveUpOut = new Keyframes_default("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
var initMoveMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};

// node_modules/antd/es/style/motion/slide.js
var slideUpIn = new Keyframes_default("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideUpOut = new Keyframes_default("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideDownIn = new Keyframes_default("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
var slideDownOut = new Keyframes_default("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
var slideLeftIn = new Keyframes_default("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideLeftOut = new Keyframes_default("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideRightIn = new Keyframes_default("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
var slideRightOut = new Keyframes_default("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
var slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
var initSlideMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
};

// node_modules/antd/es/style/motion/zoom.js
var zoomIn = new Keyframes_default("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomOut = new Keyframes_default("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
var zoomBigIn = new Keyframes_default("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomBigOut = new Keyframes_default("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
var zoomUpIn = new Keyframes_default("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
var zoomUpOut = new Keyframes_default("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
var zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
var zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
var zoomRightIn = new Keyframes_default("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
var zoomRightOut = new Keyframes_default("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
var zoomDownIn = new Keyframes_default("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
var zoomDownOut = new Keyframes_default("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
var zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
var initZoomMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};

// node_modules/antd/es/tooltip/style/index.js
var genTooltipStyle = (token2) => {
  const {
    calc,
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    arrowOffsetHorizontal,
    sizePopupArrow
  } = token2;
  const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
  const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
  const sharedBodyStyle = {
    minWidth: centerAlignMinWidth,
    minHeight: controlHeight,
    padding: `${unit(token2.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
    color: `var(--ant-tooltip-color, ${tooltipColor})`,
    textAlign: "start",
    textDecoration: "none",
    wordWrap: "break-word",
    backgroundColor: tooltipBg,
    borderRadius: tooltipBorderRadius,
    boxShadow: boxShadowSecondary,
    boxSizing: "border-box"
  };
  const sharedTransformOrigin = {
    // When use `autoArrow`, origin will follow the arrow position
    "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
    transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" ")
  };
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        width: "max-content",
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        ...sharedTransformOrigin,
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        // Wrapper for the tooltip content
        [`${componentCls}-container`]: [sharedBodyStyle, initFadeMotion(token2, true)],
        [`&:has(~ ${componentCls}-unique-container)`]: {
          [`${componentCls}-container`]: {
            border: "none",
            background: "transparent",
            boxShadow: "none"
          }
        },
        // Align placement should have another min width
        [[`&-placement-topLeft`, `&-placement-topRight`, `&-placement-bottomLeft`, `&-placement-bottomRight`].join(",")]: {
          minWidth: edgeAlignMinWidth
        },
        // Limit left and right placement radius
        [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        // generator for preset color
        ...genPresetColor(token2, (colorKey, {
          darkColor
        }) => ({
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-container`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        })),
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow
      }
    },
    // Unique Body
    {
      [`${componentCls}-unique-container`]: {
        ...sharedBodyStyle,
        ...sharedTransformOrigin,
        position: "absolute",
        zIndex: calc(zIndexPopup).sub(1).equal(),
        "&-hidden": {
          display: "none"
        },
        "&-visible": {
          transition: `all ${token2.motionDurationSlow}`
        }
      }
    }
  ];
};
var prepareComponentToken = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 70,
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadius,
    limitVerticalRadius: true
  }),
  ...getArrowToken(merge2(token2, {
    borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
  }))
});
var style_default = (prefixCls, rootCls, injectStyle = true) => {
  const useStyle = genStyleHooks("Tooltip", (token2) => {
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgSpotlight
    } = token2;
    const TooltipToken = merge2(token2, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgSpotlight
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, prepareComponentToken, {
    resetStyle: false,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle
  });
  return useStyle(prefixCls, rootCls);
};

// node_modules/antd/es/_util/colors.js
var inverseColors = PresetColors.map((color) => `${color}-inverse`);
var PresetStatusColors = ["success", "processing", "error", "default", "warning"];
function isPresetColor(color, includeInverse = true) {
  if (includeInverse) {
    return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
  }
  return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
  return PresetStatusColors.includes(color);
}

// node_modules/@rc-component/color-picker/es/ColorPicker.js
var import_react46 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/color.js
var getRoundNumber = (value) => Math.round(Number(value || 0));
var convertHsb2Hsv = (color) => {
  if (color instanceof FastColor) {
    return color;
  }
  if (color && typeof color === "object" && "h" in color && "b" in color) {
    const {
      b,
      ...resets
    } = color;
    return {
      ...resets,
      v: b
    };
  }
  if (typeof color === "string" && /hsb/.test(color)) {
    return color.replace(/hsb/, "hsv");
  }
  return color;
};
var Color = class extends FastColor {
  constructor(color) {
    super(convertHsb2Hsv(color));
  }
  toHsbString() {
    const hsb = this.toHsb();
    const saturation = getRoundNumber(hsb.s * 100);
    const lightness = getRoundNumber(hsb.b * 100);
    const hue = getRoundNumber(hsb.h);
    const alpha = hsb.a;
    const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
    const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha.toFixed(alpha === 0 ? 0 : 2)})`;
    return alpha === 1 ? hsbString : hsbaString;
  }
  toHsb() {
    const {
      v,
      ...resets
    } = this.toHsv();
    return {
      ...resets,
      b: v,
      a: this.a
    };
  }
};

// node_modules/@rc-component/color-picker/es/util.js
var ColorPickerPrefixCls = "rc-color-picker";
var generateColor = (color) => {
  if (color instanceof Color) {
    return color;
  }
  return new Color(color);
};
var defaultColor = generateColor("#1677ff");
var calculateColor = (props) => {
  const {
    offset,
    targetRef,
    containerRef,
    color,
    type: type5
  } = props;
  const {
    width,
    height
  } = containerRef.current.getBoundingClientRect();
  const {
    width: targetWidth,
    height: targetHeight
  } = targetRef.current.getBoundingClientRect();
  const centerOffsetX = targetWidth / 2;
  const centerOffsetY = targetHeight / 2;
  const saturation = (offset.x + centerOffsetX) / width;
  const bright = 1 - (offset.y + centerOffsetY) / height;
  const hsb = color.toHsb();
  const alphaOffset = saturation;
  const hueOffset = (offset.x + centerOffsetX) / width * 360;
  if (type5) {
    switch (type5) {
      case "hue":
        return generateColor({
          ...hsb,
          h: hueOffset <= 0 ? 0 : hueOffset
        });
      case "alpha":
        return generateColor({
          ...hsb,
          a: alphaOffset <= 0 ? 0 : alphaOffset
        });
    }
  }
  return generateColor({
    h: hsb.h,
    s: saturation <= 0 ? 0 : saturation,
    b: bright >= 1 ? 1 : bright,
    a: hsb.a
  });
};
var calcOffset = (color, type5) => {
  const hsb = color.toHsb();
  switch (type5) {
    case "hue":
      return {
        x: hsb.h / 360 * 100,
        y: 50
      };
    case "alpha":
      return {
        x: color.a * 100,
        y: 50
      };
    // Picker panel
    default:
      return {
        x: hsb.s * 100,
        y: (1 - hsb.b) * 100
      };
  }
};

// node_modules/@rc-component/color-picker/es/components/ColorBlock.js
var import_react37 = __toESM(require_react());
var ColorBlock = ({
  color,
  prefixCls,
  className,
  style: style2,
  onClick
}) => {
  const colorBlockCls = `${prefixCls}-color-block`;
  return import_react37.default.createElement("div", {
    className: clsx(colorBlockCls, className),
    style: style2,
    onClick
  }, import_react37.default.createElement("div", {
    className: `${colorBlockCls}-inner`,
    style: {
      background: color
    }
  }));
};
var ColorBlock_default = ColorBlock;

// node_modules/@rc-component/color-picker/es/components/Picker.js
var import_react42 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js
var import_react38 = __toESM(require_react());
function getPosition(e) {
  const obj = "touches" in e ? e.touches[0] : e;
  const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
  const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
  return {
    pageX: obj.pageX - scrollXOffset,
    pageY: obj.pageY - scrollYOffset
  };
}
function useColorDrag(props) {
  const {
    targetRef,
    containerRef,
    direction,
    onDragChange,
    onDragChangeComplete,
    calculate,
    color,
    disabledDrag
  } = props;
  const [offsetValue, setOffsetValue] = (0, import_react38.useState)({
    x: 0,
    y: 0
  });
  const mouseMoveRef = (0, import_react38.useRef)(null);
  const mouseUpRef = (0, import_react38.useRef)(null);
  (0, import_react38.useEffect)(() => {
    setOffsetValue(calculate());
  }, [color]);
  (0, import_react38.useEffect)(() => () => {
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    document.removeEventListener("touchmove", mouseMoveRef.current);
    document.removeEventListener("touchend", mouseUpRef.current);
    mouseMoveRef.current = null;
    mouseUpRef.current = null;
  }, []);
  const updateOffset = (e) => {
    const {
      pageX,
      pageY
    } = getPosition(e);
    const {
      x: rectX,
      y: rectY,
      width,
      height
    } = containerRef.current.getBoundingClientRect();
    const {
      width: targetWidth,
      height: targetHeight
    } = targetRef.current.getBoundingClientRect();
    const centerOffsetX = targetWidth / 2;
    const centerOffsetY = targetHeight / 2;
    const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
    const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
    const calcOffset2 = {
      x: offsetX,
      y: direction === "x" ? offsetValue.y : offsetY
    };
    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
      return false;
    }
    onDragChange?.(calcOffset2);
  };
  const onDragMove = (e) => {
    e.preventDefault();
    updateOffset(e);
  };
  const onDragStop = (e) => {
    e.preventDefault();
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    document.removeEventListener("touchmove", mouseMoveRef.current);
    document.removeEventListener("touchend", mouseUpRef.current);
    mouseMoveRef.current = null;
    mouseUpRef.current = null;
    onDragChangeComplete?.();
  };
  const onDragStart = (e) => {
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    if (disabledDrag) {
      return;
    }
    updateOffset(e);
    document.addEventListener("mousemove", onDragMove);
    document.addEventListener("mouseup", onDragStop);
    document.addEventListener("touchmove", onDragMove);
    document.addEventListener("touchend", onDragStop);
    mouseMoveRef.current = onDragMove;
    mouseUpRef.current = onDragStop;
  };
  return [offsetValue, onDragStart];
}
var useColorDrag_default = useColorDrag;

// node_modules/@rc-component/color-picker/es/components/Handler.js
var import_react39 = __toESM(require_react());
var Handler = ({
  size = "default",
  color,
  prefixCls
}) => {
  return import_react39.default.createElement("div", {
    className: clsx(`${prefixCls}-handler`, {
      [`${prefixCls}-handler-sm`]: size === "small"
    }),
    style: {
      backgroundColor: color
    }
  });
};
var Handler_default = Handler;

// node_modules/@rc-component/color-picker/es/components/Palette.js
var import_react40 = __toESM(require_react());
var Palette = ({
  children,
  style: style2,
  prefixCls
}) => {
  return import_react40.default.createElement("div", {
    className: `${prefixCls}-palette`,
    style: {
      position: "relative",
      ...style2
    }
  }, children);
};
var Palette_default = Palette;

// node_modules/@rc-component/color-picker/es/components/Transform.js
var import_react41 = __toESM(require_react());
var Transform = (0, import_react41.forwardRef)((props, ref) => {
  const {
    children,
    x,
    y
  } = props;
  return import_react41.default.createElement("div", {
    ref,
    style: {
      position: "absolute",
      left: `${x}%`,
      top: `${y}%`,
      zIndex: 1,
      transform: "translate(-50%, -50%)"
    }
  }, children);
});
var Transform_default = Transform;

// node_modules/@rc-component/color-picker/es/components/Picker.js
var Picker = ({
  color,
  onChange,
  prefixCls,
  onChangeComplete,
  disabled
}) => {
  const pickerRef = (0, import_react42.useRef)();
  const transformRef = (0, import_react42.useRef)();
  const colorRef = (0, import_react42.useRef)(color);
  const onDragChange = useEvent_default((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: pickerRef,
      color
    });
    colorRef.current = calcColor;
    onChange(calcColor);
  });
  const [offset, dragStartHandle] = useColorDrag_default({
    color,
    containerRef: pickerRef,
    targetRef: transformRef,
    calculate: () => calcOffset(color),
    onDragChange,
    onDragChangeComplete: () => onChangeComplete?.(colorRef.current),
    disabledDrag: disabled
  });
  return import_react42.default.createElement("div", {
    ref: pickerRef,
    className: `${prefixCls}-select`,
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, import_react42.default.createElement(Palette_default, {
    prefixCls
  }, import_react42.default.createElement(Transform_default, {
    x: offset.x,
    y: offset.y,
    ref: transformRef
  }, import_react42.default.createElement(Handler_default, {
    color: color.toRgbString(),
    prefixCls
  })), import_react42.default.createElement("div", {
    className: `${prefixCls}-saturation`,
    style: {
      backgroundColor: `hsl(${color.toHsb().h},100%, 50%)`,
      backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
    }
  })));
};
var Picker_default = Picker;

// node_modules/@rc-component/color-picker/es/hooks/useColorState.js
var import_react43 = __toESM(require_react());
var useColorState = (defaultValue, value) => {
  const [mergedValue, setValue] = useControlledState(defaultValue, value);
  const color = (0, import_react43.useMemo)(() => generateColor(mergedValue), [mergedValue]);
  return [color, setValue];
};
var useColorState_default = useColorState;

// node_modules/@rc-component/color-picker/es/hooks/useComponent.js
var React84 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/components/Slider.js
var import_react45 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/components/Gradient.js
var import_react44 = __toESM(require_react());
var Gradient = ({
  colors,
  children,
  direction = "to right",
  type: type5,
  prefixCls
}) => {
  const gradientColors = (0, import_react44.useMemo)(() => colors.map((color, idx) => {
    let result = generateColor(color);
    if (type5 === "alpha" && idx === colors.length - 1) {
      result = new Color(result.setA(1));
    }
    return result.toRgbString();
  }).join(","), [colors, type5]);
  return import_react44.default.createElement("div", {
    className: `${prefixCls}-gradient`,
    style: {
      position: "absolute",
      inset: 0,
      background: `linear-gradient(${direction}, ${gradientColors})`
    }
  }, children);
};
var Gradient_default = Gradient;

// node_modules/@rc-component/color-picker/es/components/Slider.js
var Slider = (props) => {
  const {
    prefixCls,
    colors,
    disabled,
    onChange,
    onChangeComplete,
    color,
    type: type5
  } = props;
  const sliderRef = (0, import_react45.useRef)(null);
  const transformRef = (0, import_react45.useRef)(null);
  const colorRef = (0, import_react45.useRef)(color);
  const getValue2 = (c) => {
    return type5 === "hue" ? c.getHue() : c.a * 100;
  };
  const onDragChange = useEvent_default((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: sliderRef,
      color,
      type: type5
    });
    colorRef.current = calcColor;
    onChange(getValue2(calcColor));
  });
  const [offset, dragStartHandle] = useColorDrag_default({
    color,
    targetRef: transformRef,
    containerRef: sliderRef,
    calculate: () => calcOffset(color, type5),
    onDragChange,
    onDragChangeComplete() {
      onChangeComplete(getValue2(colorRef.current));
    },
    direction: "x",
    disabledDrag: disabled
  });
  const handleColor = import_react45.default.useMemo(() => {
    if (type5 === "hue") {
      const hsb = color.toHsb();
      hsb.s = 1;
      hsb.b = 1;
      hsb.a = 1;
      const lightColor = new Color(hsb);
      return lightColor;
    }
    return color;
  }, [color, type5]);
  const gradientList = import_react45.default.useMemo(() => colors.map((info) => `${info.color} ${info.percent}%`), [colors]);
  return import_react45.default.createElement("div", {
    ref: sliderRef,
    className: clsx(`${prefixCls}-slider`, `${prefixCls}-slider-${type5}`),
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, import_react45.default.createElement(Palette_default, {
    prefixCls
  }, import_react45.default.createElement(Transform_default, {
    x: offset.x,
    y: offset.y,
    ref: transformRef
  }, import_react45.default.createElement(Handler_default, {
    size: "small",
    color: handleColor.toHexString(),
    prefixCls
  })), import_react45.default.createElement(Gradient_default, {
    colors: gradientList,
    type: type5,
    prefixCls
  })));
};
var Slider_default = Slider;

// node_modules/@rc-component/color-picker/es/hooks/useComponent.js
function useComponent(components2) {
  return React84.useMemo(() => {
    const {
      slider
    } = components2 || {};
    return [slider || Slider_default];
  }, [components2]);
}

// node_modules/@rc-component/color-picker/es/ColorPicker.js
function _extends9() {
  _extends9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
var HUE_COLORS = [{
  color: "rgb(255, 0, 0)",
  percent: 0
}, {
  color: "rgb(255, 255, 0)",
  percent: 17
}, {
  color: "rgb(0, 255, 0)",
  percent: 33
}, {
  color: "rgb(0, 255, 255)",
  percent: 50
}, {
  color: "rgb(0, 0, 255)",
  percent: 67
}, {
  color: "rgb(255, 0, 255)",
  percent: 83
}, {
  color: "rgb(255, 0, 0)",
  percent: 100
}];
var ColorPicker = (0, import_react46.forwardRef)((props, ref) => {
  const {
    value,
    defaultValue,
    prefixCls = ColorPickerPrefixCls,
    onChange,
    onChangeComplete,
    className,
    style: style2,
    panelRender,
    disabledAlpha = false,
    disabled = false,
    components: components2
  } = props;
  const [Slider4] = useComponent(components2);
  const [colorValue, setColorValue] = useColorState_default(defaultValue || defaultColor, value);
  const alphaColor = (0, import_react46.useMemo)(() => colorValue.setA(1).toRgbString(), [colorValue]);
  const handleChange = (data, type5) => {
    if (!value) {
      setColorValue(data);
    }
    onChange?.(data, type5);
  };
  const getHueColor = (hue) => new Color(colorValue.setHue(hue));
  const getAlphaColor3 = (alpha) => new Color(colorValue.setA(alpha / 100));
  const onHueChange = (hue) => {
    handleChange(getHueColor(hue), {
      type: "hue",
      value: hue
    });
  };
  const onAlphaChange = (alpha) => {
    handleChange(getAlphaColor3(alpha), {
      type: "alpha",
      value: alpha
    });
  };
  const onHueChangeComplete = (hue) => {
    if (onChangeComplete) {
      onChangeComplete(getHueColor(hue));
    }
  };
  const onAlphaChangeComplete = (alpha) => {
    if (onChangeComplete) {
      onChangeComplete(getAlphaColor3(alpha));
    }
  };
  const mergeCls = clsx(`${prefixCls}-panel`, className, {
    [`${prefixCls}-panel-disabled`]: disabled
  });
  const sharedSliderProps = {
    prefixCls,
    disabled,
    color: colorValue
  };
  const defaultPanel = import_react46.default.createElement(import_react46.default.Fragment, null, import_react46.default.createElement(Picker_default, _extends9({
    onChange: handleChange
  }, sharedSliderProps, {
    onChangeComplete
  })), import_react46.default.createElement("div", {
    className: `${prefixCls}-slider-container`
  }, import_react46.default.createElement("div", {
    className: clsx(`${prefixCls}-slider-group`, {
      [`${prefixCls}-slider-group-disabled-alpha`]: disabledAlpha
    })
  }, import_react46.default.createElement(Slider4, _extends9({}, sharedSliderProps, {
    type: "hue",
    colors: HUE_COLORS,
    min: 0,
    max: 359,
    value: colorValue.getHue(),
    onChange: onHueChange,
    onChangeComplete: onHueChangeComplete
  })), !disabledAlpha && import_react46.default.createElement(Slider4, _extends9({}, sharedSliderProps, {
    type: "alpha",
    colors: [{
      percent: 0,
      color: "rgba(255, 0, 4, 0)"
    }, {
      percent: 100,
      color: alphaColor
    }],
    min: 0,
    max: 100,
    value: colorValue.a * 100,
    onChange: onAlphaChange,
    onChangeComplete: onAlphaChangeComplete
  }))), import_react46.default.createElement(ColorBlock_default, {
    color: colorValue.toRgbString(),
    prefixCls
  })));
  return import_react46.default.createElement("div", {
    className: mergeCls,
    style: style2,
    ref
  }, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
});
if (true) {
  ColorPicker.displayName = "ColorPicker";
}
var ColorPicker_default = ColorPicker;

// node_modules/@rc-component/color-picker/es/index.js
var es_default8 = ColorPicker_default;

// node_modules/antd/es/color-picker/color.js
var toHexFormat = (value, alpha) => value?.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6) || "";
var getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
var AggregationColor = (function() {
  function AggregationColor2(color) {
    _classCallCheck(this, AggregationColor2);
    this.cleared = false;
    if (color instanceof AggregationColor2) {
      this.metaColor = color.metaColor.clone();
      this.colors = color.colors?.map((info) => ({
        color: new AggregationColor2(info.color),
        percent: info.percent
      }));
      this.cleared = color.cleared;
      return;
    }
    const isArray = Array.isArray(color);
    if (isArray && color.length) {
      this.colors = color.map(({
        color: c,
        percent
      }) => ({
        color: new AggregationColor2(c),
        percent
      }));
      this.metaColor = new Color(this.colors[0].color.metaColor);
    } else {
      this.metaColor = new Color(isArray ? "" : color);
    }
    if (!color || isArray && !this.colors) {
      this.metaColor = this.metaColor.setA(0);
      this.cleared = true;
    }
  }
  return _createClass(AggregationColor2, [{
    key: "toHsb",
    value: function toHsb() {
      return this.metaColor.toHsb();
    }
  }, {
    key: "toHsbString",
    value: function toHsbString() {
      return this.metaColor.toHsbString();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return getHex(this.toHexString(), this.metaColor.a < 1);
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      return this.metaColor.toHexString();
    }
  }, {
    key: "toRgb",
    value: function toRgb() {
      return this.metaColor.toRgb();
    }
  }, {
    key: "toRgbString",
    value: function toRgbString() {
      return this.metaColor.toRgbString();
    }
  }, {
    key: "isGradient",
    value: function isGradient() {
      return !!this.colors && !this.cleared;
    }
  }, {
    key: "getColors",
    value: function getColors() {
      return this.colors || [{
        color: this,
        percent: 0
      }];
    }
  }, {
    key: "toCssString",
    value: function toCssString() {
      const {
        colors
      } = this;
      if (colors) {
        const colorsStr = colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ");
        return `linear-gradient(90deg, ${colorsStr})`;
      }
      return this.metaColor.toRgbString();
    }
  }, {
    key: "equals",
    value: function equals(color) {
      if (!color || this.isGradient() !== color.isGradient()) {
        return false;
      }
      if (!this.isGradient()) {
        return this.toHexString() === color.toHexString();
      }
      return this.colors.length === color.colors.length && this.colors.every((c, i) => {
        const target = color.colors[i];
        return c.percent === target.percent && c.color.equals(target.color);
      });
    }
  }]);
})();

// node_modules/antd/es/color-picker/util.js
var generateColor2 = (color) => {
  if (color instanceof AggregationColor) {
    return color;
  }
  return new AggregationColor(color);
};
var getRoundNumber2 = (value) => Math.round(Number(value || 0));
var getColorAlpha = (color) => getRoundNumber2(color.toHsb().a * 100);
var genAlphaColor = (color, alpha) => {
  const rgba = color.toRgb();
  if (!rgba.r && !rgba.g && !rgba.b) {
    const hsba = color.toHsb();
    hsba.a = alpha || 1;
    return generateColor2(hsba);
  }
  rgba.a = alpha || 1;
  return generateColor2(rgba);
};
var getGradientPercentColor = (colors, percent) => {
  const filledColors = [{
    percent: 0,
    color: colors[0].color
  }].concat(_toConsumableArray(colors), [{
    percent: 100,
    color: colors[colors.length - 1].color
  }]);
  for (let i = 0; i < filledColors.length - 1; i += 1) {
    const startPtg = filledColors[i].percent;
    const endPtg = filledColors[i + 1].percent;
    const startColor = filledColors[i].color;
    const endColor = filledColors[i + 1].color;
    if (startPtg <= percent && percent <= endPtg) {
      const dist = endPtg - startPtg;
      if (dist === 0) {
        return startColor;
      }
      const ratio = (percent - startPtg) / dist * 100;
      const startRcColor = new Color(startColor);
      const endRcColor = new Color(endColor);
      return startRcColor.mix(endRcColor, ratio).toRgbString();
    }
  }
  return "";
};

// node_modules/antd/es/tooltip/util.js
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = clsx({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  const rgb = generateColor2(color).toRgb();
  const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
  const textColor = luminance < 0.5 ? "#FFF" : "#000";
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    overlayStyle["--ant-tooltip-color"] = textColor;
    arrowStyle["--antd-arrow-background-color"] = color;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}

// node_modules/antd/es/tooltip/PurePanel.js
var PurePanel = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title,
    color,
    overlayInnerStyle,
    classNames,
    styles
  } = props;
  const {
    getPrefixCls
  } = React86.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default(prefixCls, rootCls);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const innerStyles = React86.useMemo(() => {
    const mergedStyle = {
      ...overlayInnerStyle,
      ...colorInfo.overlayStyle
    };
    return {
      container: mergedStyle
    };
  }, [overlayInnerStyle, colorInfo.overlayStyle]);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [innerStyles, styles], {
    props: mergedProps
  });
  const rootClassName = clsx(rootCls, hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
  return React86.createElement("div", {
    className: rootClassName,
    style: arrowContentStyle
  }, React86.createElement("div", {
    className: `${prefixCls}-arrow`
  }), React86.createElement(Popup_default2, {
    ...props,
    className: hashId,
    prefixCls,
    classNames: mergedClassNames,
    styles: mergedStyles
  }, title));
};
var PurePanel_default2 = PurePanel;

// node_modules/antd/es/tooltip/index.js
var InternalTooltip = React87.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    color,
    children,
    afterOpenChange,
    arrow: tooltipArrow,
    destroyTooltipOnHide,
    destroyOnHidden,
    title,
    overlay,
    trigger,
    builtinPlacements,
    autoAdjustOverflow = true,
    motion,
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    rootClassName,
    styles,
    classNames,
    onOpenChange,
    // Legacy
    overlayInnerStyle,
    overlayStyle,
    overlayClassName,
    ...restProps
  } = props;
  const [, token2] = useToken();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("tooltip");
  const mergedArrow = useMergedArrow_default(tooltipArrow, contextArrow);
  const mergedShowArrow = mergedArrow.show;
  const mergedTrigger = trigger || contextTrigger || "hover";
  const warning5 = devUseWarning("Tooltip");
  const tooltipRef = React87.useRef(null);
  const forceAlign = () => {
    tooltipRef.current?.forceAlign();
  };
  React87.useImperativeHandle(ref, () => ({
    forceAlign,
    nativeElement: tooltipRef.current?.nativeElement,
    popupElement: tooltipRef.current?.popupElement
  }));
  if (true) {
    [["overlayStyle", "styles.root"], ["overlayInnerStyle", "styles.container"], ["overlayClassName", "classNames.root"], ["destroyTooltipOnHide", "destroyOnHidden"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    true ? warning5(!destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly.") : void 0;
  }
  const [open, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const noTitle = !title && !overlay && title !== 0;
  const onInternalOpenChange = (vis) => {
    setOpen(noTitle ? false : vis);
    if (!noTitle && onOpenChange) {
      onOpenChange(vis);
    }
  };
  const tooltipPlacements = React87.useMemo(() => {
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrow?.pointAtCenter ?? false,
      autoAdjustOverflow,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius,
      offset: token2.marginXXS,
      visibleFirst: true
    });
  }, [mergedArrow, builtinPlacements, token2, mergedShowArrow, autoAdjustOverflow]);
  const memoOverlay = React87.useMemo(() => {
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  }, [overlay, title]);
  const memoOverlayWrapper = React87.createElement(ContextIsolator_default, {
    space: true
  }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
  const mergedProps = {
    ...props,
    trigger: mergedTrigger,
    color,
    placement,
    builtinPlacements,
    openClassName,
    arrow: tooltipArrow,
    autoAdjustOverflow,
    getPopupContainer,
    children,
    destroyTooltipOnHide,
    destroyOnHidden
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props["data-popover-inject"];
  let tempOpen = open;
  if (!("open" in props) && noTitle) {
    tempOpen = false;
  }
  const child = React87.isValidElement(children) && !isFragment2(children) ? children : React87.createElement("span", null, children);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === "string" ? clsx(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default(prefixCls, rootCls, !injectFromPopover);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const themeCls = clsx(rootCls, hashId, cssVarCls);
  const rootClassNames = clsx(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, colorInfo.className, rootClassName, themeCls, contextClassName, mergedClassNames.root);
  const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
  const containerStyle = {
    ...mergedStyles.container,
    ...overlayInnerStyle,
    ...colorInfo.overlayStyle
  };
  const content = React87.createElement(es_default7, {
    unique: true,
    ...restProps,
    trigger: mergedTrigger,
    zIndex,
    showArrow: mergedShowArrow,
    placement,
    mouseEnterDelay,
    mouseLeaveDelay,
    prefixCls,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow,
      uniqueContainer: clsx(themeCls, mergedClassNames.container)
    },
    styles: {
      root: {
        ...arrowContentStyle,
        ...mergedStyles.root,
        ...contextStyle,
        ...overlayStyle
      },
      container: containerStyle,
      uniqueContainer: containerStyle,
      arrow: mergedStyles.arrow
    },
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: tooltipRef,
    builtinPlacements: tooltipPlacements,
    overlay: memoOverlayWrapper,
    visible: tempOpen,
    onVisibleChange: onInternalOpenChange,
    afterVisibleChange: afterOpenChange,
    arrowContent: React87.createElement("span", {
      className: `${prefixCls}-arrow-content`
    }),
    motion: {
      motionName: getTransitionName2(rootPrefixCls, "zoom-big-fast", typeof motion?.motionName === "string" ? motion?.motionName : void 0),
      motionDeadline: 1e3
    },
    destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
  }, tempOpen ? cloneElement7(child, {
    className: childCls
  }) : child);
  return React87.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, content);
});
var Tooltip2 = InternalTooltip;
if (true) {
  Tooltip2.displayName = "Tooltip";
}
Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default2;
Tooltip2.UniqueProvider = UniqueProvider_default2;
var tooltip_default = Tooltip2;

// node_modules/antd/es/popover/PurePanel.js
var React88 = __toESM(require_react());

// node_modules/antd/es/popover/style/index.js
var genBaseStyle = (token2) => {
  const {
    componentCls,
    popoverColor,
    titleMinWidth,
    fontWeightStrong,
    innerPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG,
    zIndexPopup,
    titleMarginBottom,
    colorBgElevated,
    popoverBg,
    titleBorderBottom,
    innerContentPadding,
    titlePadding
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        // When use `autoArrow`, origin will follow the arrow position
        "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
        transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
        "--antd-arrow-background-color": colorBgElevated,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-container`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          padding: innerPadding
        },
        [`${componentCls}-title`]: {
          minWidth: titleMinWidth,
          marginBottom: titleMarginBottom,
          color: colorTextHeading,
          fontWeight: fontWeightStrong,
          borderBottom: titleBorderBottom,
          padding: titlePadding
        },
        [`${componentCls}-content`]: {
          color: popoverColor,
          padding: innerContentPadding
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow,
        display: "inline-block"
      }
    }
  ];
};
var genColorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
};
var prepareComponentToken2 = (token2) => {
  const {
    lineWidth,
    controlHeight,
    fontHeight,
    padding,
    wireframe,
    zIndexPopupBase,
    borderRadiusLG,
    marginXS,
    lineType,
    colorSplit,
    paddingSM
  } = token2;
  const titlePaddingBlockDist = controlHeight - fontHeight;
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    titleMinWidth: 177,
    zIndexPopup: zIndexPopupBase + 30,
    ...getArrowToken(token2),
    ...getArrowOffsetToken({
      contentRadius: borderRadiusLG,
      limitVerticalRadius: true
    }),
    // internal
    innerPadding: wireframe ? 0 : 12,
    titleMarginBottom: wireframe ? 0 : marginXS,
    titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
    titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
    innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
  };
};
var style_default2 = genStyleHooks("Popover", (token2) => {
  const {
    colorBgElevated,
    colorText
  } = token2;
  const popoverToken = merge2(token2, {
    popoverBg: colorBgElevated,
    popoverColor: colorText
  });
  return [genBaseStyle(popoverToken), genColorStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, prepareComponentToken2, {
  resetStyle: false,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});

// node_modules/antd/es/popover/PurePanel.js
var Overlay = (props) => {
  const {
    title,
    content,
    prefixCls,
    classNames,
    styles
  } = props;
  if (!title && !content) {
    return null;
  }
  return React88.createElement(React88.Fragment, null, title && React88.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames?.title),
    style: styles?.title
  }, title), content && React88.createElement("div", {
    className: clsx(`${prefixCls}-content`, classNames?.content),
    style: styles?.content
  }, content));
};
var RawPurePanel = (props) => {
  const {
    hashId,
    prefixCls,
    className,
    style: style2,
    placement = "top",
    title,
    content,
    children,
    classNames,
    styles
  } = props;
  const titleNode = getRenderPropValue(title);
  const contentNode = getRenderPropValue(content);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], {
    props: mergedProps
  });
  const rootClassName = clsx(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
  return React88.createElement("div", {
    className: rootClassName,
    style: style2
  }, React88.createElement("div", {
    className: `${prefixCls}-arrow`
  }), React88.createElement(Popup_default2, {
    ...props,
    className: hashId,
    prefixCls,
    classNames: mergedClassNames,
    styles: mergedStyles
  }, children || React88.createElement(Overlay, {
    prefixCls,
    title: titleNode,
    content: contentNode,
    classNames: mergedClassNames,
    styles: mergedStyles
  })));
};
var PurePanel2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React88.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [hashId, cssVarCls] = style_default2(prefixCls);
  return React88.createElement(RawPurePanel, {
    ...restProps,
    prefixCls,
    hashId,
    className: clsx(className, cssVarCls)
  });
};
var PurePanel_default3 = PurePanel2;

// node_modules/antd/es/popover/index.js
var InternalPopover = React89.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    content,
    overlayClassName,
    placement = "top",
    trigger,
    children,
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    onOpenChange,
    overlayStyle = {},
    styles,
    classNames,
    motion,
    arrow: popoverArrow,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("popover");
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [hashId, cssVarCls] = style_default2(prefixCls);
  const rootPrefixCls = getPrefixCls();
  const mergedArrow = useMergedArrow_default(popoverArrow, contextArrow);
  const mergedTrigger = trigger || contextTrigger || "hover";
  const mergedProps = {
    ...props,
    placement,
    trigger: mergedTrigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayStyle,
    styles,
    classNames
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(overlayClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root);
  const [open, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const settingOpen = (value, e) => {
    setOpen(value);
    onOpenChange?.(value, e);
  };
  const onKeyDown = (e) => {
    if (e.keyCode === KeyCode_default.ESC) {
      settingOpen(false, e);
    }
  };
  const onInternalOpenChange = (value) => {
    settingOpen(value);
  };
  const titleNode = getRenderPropValue(title);
  const contentNode = getRenderPropValue(content);
  return React89.createElement(tooltip_default, {
    unique: false,
    arrow: mergedArrow,
    placement,
    trigger: mergedTrigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    ...restProps,
    prefixCls,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow
    },
    styles: {
      root: {
        ...mergedStyles.root,
        ...contextStyle,
        ...overlayStyle
      },
      container: mergedStyles.container,
      arrow: mergedStyles.arrow
    },
    ref,
    open,
    onOpenChange: onInternalOpenChange,
    overlay: titleNode || contentNode ? React89.createElement(Overlay, {
      prefixCls,
      title: titleNode,
      content: contentNode,
      classNames: mergedClassNames,
      styles: mergedStyles
    }) : null,
    motion: {
      motionName: getTransitionName2(rootPrefixCls, "zoom-big", typeof motion?.motionName === "string" ? motion?.motionName : void 0)
    },
    "data-popover-inject": true
  }, cloneElement7(children, {
    onKeyDown: (e) => {
      if ((0, import_react47.isValidElement)(children)) {
        children?.props.onKeyDown?.(e);
      }
      onKeyDown(e);
    }
  }));
});
var Popover = InternalPopover;
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default3;
if (true) {
  Popover.displayName = "Popover";
}
var popover_default = Popover;

// node_modules/antd/es/color-picker/ColorPickerPanel.js
var import_react89 = __toESM(require_react());

// node_modules/antd/es/divider/index.js
var React90 = __toESM(require_react());

// node_modules/antd/es/divider/style/index.js
var genSizeDividerStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-horizontal": {
        [`&${componentCls}`]: {
          "&-sm": {
            marginBlock: token2.marginXS
          },
          "&-md": {
            marginBlock: token2.margin
          }
        }
      }
    }
  };
};
var genSharedDividerStyle = (token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth,
    textPaddingInline,
    orientationMargin,
    verticalMarginInline
  } = token2;
  const railCls = `${componentCls}-rail`;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`,
      [railCls]: {
        borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`
      },
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: verticalMarginInline,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${unit(lineWidth)} solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${unit(token2.marginLG)} 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${unit(token2.dividerHorizontalWithTextGutterMargin)} 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        [`${railCls}-start, ${railCls}-end`]: {
          width: "50%",
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-start`]: {
        [`${railCls}-start`]: {
          width: `calc(${orientationMargin} * 100%)`
        },
        [`${railCls}-end`]: {
          width: `calc(100% - ${orientationMargin} * 100%)`
        }
      },
      [`&-horizontal${componentCls}-with-text-end`]: {
        [`${railCls}-start`]: {
          width: `calc(100% - ${orientationMargin} * 100%)`
        },
        [`${railCls}-end`]: {
          width: `calc(${orientationMargin} * 100%)`
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: textPaddingInline
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${unit(lineWidth)} 0 0`,
        [railCls]: {
          borderBlockStart: `${unit(lineWidth)} dashed ${colorSplit}`
        }
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        [`${railCls}-start, ${railCls}-end`]: {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      "&-dotted": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dotted",
        borderWidth: `${unit(lineWidth)} 0 0`,
        [railCls]: {
          borderBlockStart: `${unit(lineWidth)} dotted ${colorSplit}`
        }
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: {
        "&::before, &::after": {
          borderStyle: "dotted none none"
        }
      },
      [`&-vertical${componentCls}-dotted`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
        [`${railCls}-start`]: {
          width: 0
        },
        [`${railCls}-end`]: {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
        [`${railCls}-start`]: {
          width: "100%"
        },
        [`${railCls}-end`]: {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    }
  };
};
var prepareComponentToken3 = (token2) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: token2.marginXS
});
var style_default3 = genStyleHooks("Divider", (token2) => {
  const dividerToken = merge2(token2, {
    dividerHorizontalWithTextGutterMargin: token2.margin,
    sizePaddingEdgeHorizontal: 0
  });
  return [genSharedDividerStyle(dividerToken), genSizeDividerStyle(dividerToken)];
}, prepareComponentToken3, {
  unitless: {
    orientationMargin: true
  }
});

// node_modules/antd/es/divider/index.js
var titlePlacementList = ["left", "right", "center", "start", "end"];
var sizeClassNameMap = {
  small: "sm",
  middle: "md"
};
var Divider = (props) => {
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("divider");
  const {
    prefixCls: customizePrefixCls,
    type: type5,
    orientation,
    vertical,
    titlePlacement,
    orientationMargin,
    className,
    rootClassName,
    children,
    dashed,
    variant = "solid",
    plain,
    style: style2,
    size: customSize,
    classNames,
    styles,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("divider", customizePrefixCls);
  const railCls = `${prefixCls}-rail`;
  const [hashId, cssVarCls] = style_default3(prefixCls);
  const sizeFullName = useSize_default(customSize);
  const sizeCls = sizeClassNameMap[sizeFullName];
  const hasChildren = !!children;
  const validTitlePlacement = titlePlacementList.includes(orientation || "");
  const mergedTitlePlacement = React90.useMemo(() => {
    const placement = titlePlacement ?? (validTitlePlacement ? orientation : "center");
    if (placement === "left") {
      return direction === "rtl" ? "end" : "start";
    }
    if (placement === "right") {
      return direction === "rtl" ? "start" : "end";
    }
    return placement;
  }, [direction, orientation, titlePlacement, validTitlePlacement]);
  const hasMarginStart = mergedTitlePlacement === "start" && orientationMargin != null;
  const hasMarginEnd = mergedTitlePlacement === "end" && orientationMargin != null;
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, type5);
  const mergedProps = {
    ...props,
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    size: sizeFullName
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const classString = clsx(prefixCls, contextClassName, hashId, cssVarCls, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-with-text`]: hasChildren,
    [`${prefixCls}-with-text-${mergedTitlePlacement}`]: hasChildren,
    [`${prefixCls}-dashed`]: !!dashed,
    [`${prefixCls}-${variant}`]: variant !== "solid",
    [`${prefixCls}-plain`]: !!plain,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
    [`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd,
    [`${prefixCls}-${sizeCls}`]: !!sizeCls,
    [railCls]: !children,
    [mergedClassNames.rail]: mergedClassNames.rail && !children
  }, className, rootClassName, mergedClassNames.root);
  const memoizedPlacementMargin = React90.useMemo(() => {
    if (typeof orientationMargin === "number") {
      return orientationMargin;
    }
    if (/^\d+$/.test(orientationMargin)) {
      return Number(orientationMargin);
    }
    return orientationMargin;
  }, [orientationMargin]);
  const innerStyle = {
    marginInlineStart: hasMarginStart ? memoizedPlacementMargin : void 0,
    marginInlineEnd: hasMarginEnd ? memoizedPlacementMargin : void 0
  };
  if (true) {
    const warning5 = devUseWarning("Divider");
    true ? warning5(!children || !mergedVertical, "usage", "`children` not working in `vertical` mode.") : void 0;
    true ? warning5(!validTitlePlacement, "usage", "`orientation` is used for direction, please use `titlePlacement` replace this") : void 0;
    [["type", "orientation"], ["orientationMargin", "styles.content.margin"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return React90.createElement("div", {
    className: classString,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...children ? {} : mergedStyles.rail,
      ...style2
    },
    ...restProps,
    role: "separator"
  }, children && !mergedVertical && React90.createElement(React90.Fragment, null, React90.createElement("div", {
    className: clsx(railCls, `${railCls}-start`, mergedClassNames.rail),
    style: mergedStyles.rail
  }), React90.createElement("span", {
    className: clsx(`${prefixCls}-inner-text`, mergedClassNames.content),
    style: {
      ...innerStyle,
      ...mergedStyles.content
    }
  }, children), React90.createElement("div", {
    className: clsx(railCls, `${railCls}-end`, mergedClassNames.rail),
    style: mergedStyles.rail
  })));
};
if (true) {
  Divider.displayName = "Divider";
}
var divider_default = Divider;

// node_modules/antd/es/color-picker/components/PanelPicker/index.js
var import_react82 = __toESM(require_react());

// node_modules/antd/es/segmented/index.js
var React93 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends10() {
  return _extends10 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends10.apply(null, arguments);
}

// node_modules/@rc-component/segmented/es/index.js
var React92 = __toESM(require_react());

// node_modules/@rc-component/segmented/es/MotionThumb.js
var React91 = __toESM(require_react());
var calcThumbStyle = (targetElement, vertical) => {
  if (!targetElement) return null;
  const style2 = {
    left: targetElement.offsetLeft,
    right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
    width: targetElement.clientWidth,
    top: targetElement.offsetTop,
    bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
    height: targetElement.clientHeight
  };
  if (vertical) {
    return {
      left: 0,
      right: 0,
      width: 0,
      top: style2.top,
      bottom: style2.bottom,
      height: style2.height
    };
  }
  return {
    left: style2.left,
    right: style2.right,
    width: style2.width,
    top: 0,
    bottom: 0,
    height: 0
  };
};
var toPX = (value) => value !== void 0 ? `${value}px` : void 0;
function MotionThumb(props) {
  const {
    prefixCls,
    containerRef,
    value,
    getValueIndex,
    motionName,
    onMotionStart,
    onMotionEnd,
    direction,
    vertical = false
  } = props;
  const thumbRef = React91.useRef(null);
  const [prevValue, setPrevValue] = React91.useState(value);
  const findValueElement = (val) => {
    const index = getValueIndex(val);
    const ele = containerRef.current?.querySelectorAll(`.${prefixCls}-item`)[index];
    return ele?.offsetParent && ele;
  };
  const [prevStyle, setPrevStyle] = React91.useState(null);
  const [nextStyle, setNextStyle] = React91.useState(null);
  useLayoutEffect_default(() => {
    if (prevValue !== value) {
      const prev2 = findValueElement(prevValue);
      const next2 = findValueElement(value);
      const calcPrevStyle = calcThumbStyle(prev2, vertical);
      const calcNextStyle = calcThumbStyle(next2, vertical);
      setPrevValue(value);
      setPrevStyle(calcPrevStyle);
      setNextStyle(calcNextStyle);
      if (prev2 && next2) {
        onMotionStart();
      } else {
        onMotionEnd();
      }
    }
  }, [value]);
  const thumbStart = React91.useMemo(() => {
    if (vertical) {
      return toPX(prevStyle?.top ?? 0);
    }
    if (direction === "rtl") {
      return toPX(-prevStyle?.right);
    }
    return toPX(prevStyle?.left);
  }, [vertical, direction, prevStyle]);
  const thumbActive = React91.useMemo(() => {
    if (vertical) {
      return toPX(nextStyle?.top ?? 0);
    }
    if (direction === "rtl") {
      return toPX(-nextStyle?.right);
    }
    return toPX(nextStyle?.left);
  }, [vertical, direction, nextStyle]);
  const onAppearStart = () => {
    if (vertical) {
      return {
        transform: "translateY(var(--thumb-start-top))",
        height: "var(--thumb-start-height)"
      };
    }
    return {
      transform: "translateX(var(--thumb-start-left))",
      width: "var(--thumb-start-width)"
    };
  };
  const onAppearActive = () => {
    if (vertical) {
      return {
        transform: "translateY(var(--thumb-active-top))",
        height: "var(--thumb-active-height)"
      };
    }
    return {
      transform: "translateX(var(--thumb-active-left))",
      width: "var(--thumb-active-width)"
    };
  };
  const onVisibleChanged = () => {
    setPrevStyle(null);
    setNextStyle(null);
    onMotionEnd();
  };
  if (!prevStyle || !nextStyle) {
    return null;
  }
  return React91.createElement(es_default5, {
    visible: true,
    motionName,
    motionAppear: true,
    onAppearStart,
    onAppearActive,
    onVisibleChanged
  }, ({
    className: motionClassName,
    style: motionStyle
  }, ref) => {
    const mergedStyle = {
      ...motionStyle,
      "--thumb-start-left": thumbStart,
      "--thumb-start-width": toPX(prevStyle?.width),
      "--thumb-active-left": thumbActive,
      "--thumb-active-width": toPX(nextStyle?.width),
      "--thumb-start-top": thumbStart,
      "--thumb-start-height": toPX(prevStyle?.height),
      "--thumb-active-top": thumbActive,
      "--thumb-active-height": toPX(nextStyle?.height)
    };
    const motionProps = {
      ref: composeRef(thumbRef, ref),
      style: mergedStyle,
      className: clsx(`${prefixCls}-thumb`, motionClassName)
    };
    if (false) {
      motionProps["data-test-style"] = JSON.stringify(mergedStyle);
    }
    return React91.createElement("div", motionProps);
  });
}

// node_modules/@rc-component/segmented/es/index.js
function getValidTitle(option) {
  if (typeof option.title !== "undefined") {
    return option.title;
  }
  if (typeof option.label !== "object") {
    return option.label?.toString();
  }
}
function normalizeOptions(options) {
  return options.map((option) => {
    if (typeof option === "object" && option !== null) {
      const validTitle = getValidTitle(option);
      return {
        ...option,
        title: validTitle
      };
    }
    return {
      label: option?.toString(),
      title: option?.toString(),
      value: option
    };
  });
}
var InternalSegmentedOption = ({
  prefixCls,
  className,
  style: style2,
  styles,
  classNames: segmentedClassNames,
  data,
  disabled,
  checked,
  label,
  title,
  value,
  name,
  onChange,
  onFocus,
  onBlur,
  onKeyDown,
  onKeyUp,
  onMouseDown,
  itemRender = (node2) => node2
}) => {
  const handleChange = (event) => {
    if (disabled) {
      return;
    }
    onChange(event, value);
  };
  const itemContent = React92.createElement("label", {
    className: clsx(className, {
      [`${prefixCls}-item-disabled`]: disabled
    }),
    style: style2,
    onMouseDown
  }, React92.createElement("input", {
    name,
    className: `${prefixCls}-item-input`,
    type: "radio",
    disabled,
    checked,
    onChange: handleChange,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyUp
  }), React92.createElement("div", {
    className: clsx(`${prefixCls}-item-label`, segmentedClassNames?.label),
    title,
    role: "radio",
    "aria-checked": checked,
    style: styles?.label
  }, label));
  return itemRender(itemContent, {
    item: data
  });
};
var Segmented = React92.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-segmented",
    direction,
    vertical,
    options = [],
    disabled,
    defaultValue,
    value,
    name,
    onChange,
    className = "",
    style: style2,
    styles,
    classNames: segmentedClassNames,
    motionName = "thumb-motion",
    itemRender,
    ...restProps
  } = props;
  const containerRef = React92.useRef(null);
  const mergedRef = React92.useMemo(() => composeRef(containerRef, ref), [containerRef, ref]);
  const segmentedOptions = React92.useMemo(() => {
    return normalizeOptions(options);
  }, [options]);
  const [rawValue, setRawValue] = useControlledState(defaultValue ?? segmentedOptions[0]?.value, value);
  const [thumbShow, setThumbShow] = React92.useState(false);
  const handleChange = (event, val) => {
    setRawValue(val);
    onChange?.(val);
  };
  const divProps = omit(restProps, ["children"]);
  const [isKeyboard, setIsKeyboard] = React92.useState(false);
  const [isFocused, setIsFocused] = React92.useState(false);
  const handleFocus = () => {
    setIsFocused(true);
  };
  const handleBlur = () => {
    setIsFocused(false);
  };
  const handleMouseDown = () => {
    setIsKeyboard(false);
  };
  const handleKeyUp = (event) => {
    if (event.key === "Tab") {
      setIsKeyboard(true);
    }
  };
  const onOffset = (offset) => {
    const currentIndex = segmentedOptions.findIndex((option) => option.value === rawValue);
    const total = segmentedOptions.length;
    const nextIndex = (currentIndex + offset + total) % total;
    const nextOption = segmentedOptions[nextIndex];
    if (nextOption) {
      setRawValue(nextOption.value);
      onChange?.(nextOption.value);
    }
  };
  const handleKeyDown = (event) => {
    switch (event.key) {
      case "ArrowLeft":
      case "ArrowUp":
        onOffset(-1);
        break;
      case "ArrowRight":
      case "ArrowDown":
        onOffset(1);
        break;
    }
  };
  const renderOption = (segmentedOption) => {
    const {
      value: optionValue,
      disabled: optionDisabled
    } = segmentedOption;
    return React92.createElement(InternalSegmentedOption, _extends10({}, segmentedOption, {
      name,
      data: segmentedOption,
      itemRender,
      key: optionValue,
      prefixCls,
      className: clsx(segmentedOption.className, `${prefixCls}-item`, segmentedClassNames?.item, {
        [`${prefixCls}-item-selected`]: optionValue === rawValue && !thumbShow,
        [`${prefixCls}-item-focused`]: isFocused && isKeyboard && optionValue === rawValue
      }),
      style: styles?.item,
      classNames: segmentedClassNames,
      styles,
      checked: optionValue === rawValue,
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      disabled: !!disabled || !!optionDisabled
    }));
  };
  return React92.createElement("div", _extends10({
    role: "radiogroup",
    "aria-label": "segmented control",
    tabIndex: disabled ? void 0 : 0,
    style: style2
  }, divProps, {
    className: clsx(prefixCls, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-vertical`]: vertical
    }, className),
    ref: mergedRef
  }), React92.createElement("div", {
    className: `${prefixCls}-group`
  }, React92.createElement(MotionThumb, {
    vertical,
    prefixCls,
    value: rawValue,
    containerRef,
    motionName: `${prefixCls}-${motionName}`,
    direction,
    getValueIndex: (val) => segmentedOptions.findIndex((n) => n.value === val),
    onMotionStart: () => {
      setThumbShow(true);
    },
    onMotionEnd: () => {
      setThumbShow(false);
    }
  }), segmentedOptions.map(renderOption)));
});
if (true) {
  Segmented.displayName = "Segmented";
}
var TypedSegmented = Segmented;
var es_default9 = TypedSegmented;

// node_modules/antd/es/segmented/style/index.js
function getItemDisabledStyle(cls, token2) {
  return {
    [`${cls}, ${cls}:hover, ${cls}:focus`]: {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
function getItemSelectedStyle(token2) {
  return {
    background: token2.itemSelectedBg,
    boxShadow: token2.boxShadowTertiary
  };
}
var segmentedTextEllipsisCss = {
  overflow: "hidden",
  // handle text ellipsis
  ...textEllipsis
};
var genSegmentedStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const labelHeight = token2.calc(token2.controlHeight).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightLG = token2.calc(token2.controlHeightLG).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightSM = token2.calc(token2.controlHeightSM).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      padding: token2.trackPadding,
      color: token2.itemColor,
      background: token2.trackBg,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`,
      ...genFocusStyle(token2),
      [`${componentCls}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        flexDirection: "row",
        width: "100%"
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${componentCls}-vertical`]: {
        [`${componentCls}-group`]: {
          flexDirection: "column"
        },
        [`${componentCls}-thumb`]: {
          width: "100%",
          height: 0,
          padding: `0 ${unit(token2.paddingXXS)}`
        }
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: "flex"
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${token2.motionDurationMid}`,
        borderRadius: token2.borderRadiusSM,
        // Fix Safari render bug
        // https://github.com/ant-design/ant-design/issues/45250
        transform: "translateZ(0)",
        "&-selected": {
          ...getItemSelectedStyle(token2),
          color: token2.itemSelectedColor
        },
        "&-focused": genFocusOutline(token2),
        "&::after": {
          content: '""',
          position: "absolute",
          zIndex: -1,
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          opacity: 0,
          transition: `opacity ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          // This is mandatory to make it not clickable or hoverable
          // Ref: https://github.com/ant-design/ant-design/issues/40888
          pointerEvents: "none"
        },
        [`&:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          "&:hover, &:active": {
            color: token2.itemHoverColor
          },
          "&:hover::after": {
            opacity: 1,
            backgroundColor: token2.itemHoverBg
          },
          "&:active::after": {
            opacity: 1,
            backgroundColor: token2.itemActiveBg
          }
        },
        "&-label": {
          minHeight: labelHeight,
          lineHeight: unit(labelHeight),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          ...segmentedTextEllipsisCss
        },
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: token2.calc(token2.marginSM).div(2).equal()
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: {
        ...getItemSelectedStyle(token2),
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${unit(token2.paddingXXS)} 0`,
        borderRadius: token2.borderRadiusSM,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      },
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token2.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightLG,
          lineHeight: unit(labelHeightLG),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          fontSize: token2.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token2.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightSM,
          lineHeight: unit(labelHeightSM),
          padding: `0 ${unit(token2.segmentedPaddingHorizontalSM)}`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadiusXS
        }
      },
      // disabled styles
      ...getItemDisabledStyle(`&-disabled ${componentCls}-item`, token2),
      ...getItemDisabledStyle(`${componentCls}-item-disabled`, token2),
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOut}, width ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        willChange: "transform, width"
      },
      [`&${componentCls}-shape-round`]: {
        borderRadius: 9999,
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: 9999
        }
      }
    }
  };
};
var prepareComponentToken4 = (token2) => {
  const {
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgElevated,
    colorFill,
    lineWidthBold,
    colorBgLayout
  } = token2;
  return {
    trackPadding: lineWidthBold,
    trackBg: colorBgLayout,
    itemColor: colorTextLabel,
    itemHoverColor: colorText,
    itemHoverBg: colorFillSecondary,
    itemSelectedBg: colorBgElevated,
    itemActiveBg: colorFill,
    itemSelectedColor: colorText
  };
};
var style_default4 = genStyleHooks("Segmented", (token2) => {
  const {
    lineWidth,
    calc
  } = token2;
  const segmentedToken = merge2(token2, {
    segmentedPaddingHorizontal: calc(token2.controlPaddingHorizontal).sub(lineWidth).equal(),
    segmentedPaddingHorizontalSM: calc(token2.controlPaddingHorizontalSM).sub(lineWidth).equal()
  });
  return genSegmentedStyle(segmentedToken);
}, prepareComponentToken4);

// node_modules/antd/es/segmented/index.js
function isSegmentedLabeledOptionWithIcon(option) {
  return typeof option === "object" && !!option?.icon;
}
var InternalSegmented = React93.forwardRef((props, ref) => {
  const defaultName = useId_default();
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    block,
    options = [],
    size: customSize = "middle",
    style: style2,
    vertical,
    orientation,
    shape = "default",
    name = defaultName,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("segmented");
  const mergedProps = {
    ...props,
    options,
    size: customSize,
    shape
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("segmented", customizePrefixCls);
  const [hashId, cssVarCls] = style_default4(prefixCls);
  const mergedSize = useSize_default(customSize);
  const extendedOptions = React93.useMemo(() => options.map((option) => {
    if (isSegmentedLabeledOptionWithIcon(option)) {
      const {
        icon,
        label,
        ...restOption
      } = option;
      return {
        ...restOption,
        label: React93.createElement(React93.Fragment, null, React93.createElement("span", {
          className: clsx(`${prefixCls}-item-icon`, mergedClassNames.icon),
          style: mergedStyles.icon
        }, icon), label && React93.createElement("span", null, label))
      };
    }
    return option;
  }), [options, prefixCls, mergedClassNames.icon, mergedStyles.icon]);
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const cls = clsx(className, rootClassName, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-vertical`]: mergedVertical,
    [`${prefixCls}-shape-${shape}`]: shape === "round"
  }, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const itemRender = (node2, {
    item
  }) => {
    if (!item.tooltip) {
      return node2;
    }
    const tooltipProps = typeof item.tooltip === "object" ? item.tooltip : {
      title: item.tooltip
    };
    return React93.createElement(tooltip_default, {
      ...tooltipProps
    }, node2);
  };
  return React93.createElement(es_default9, {
    ...restProps,
    name,
    className: cls,
    style: mergedStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    itemRender,
    options: extendedOptions,
    ref,
    prefixCls,
    direction,
    vertical: mergedVertical
  });
});
var Segmented2 = InternalSegmented;
if (true) {
  Segmented2.displayName = "Segmented";
}
var segmented_default = Segmented2;

// node_modules/antd/es/color-picker/context.js
var import_react48 = __toESM(require_react());
var PanelPickerContext = import_react48.default.createContext({});
var PanelPresetsContext = import_react48.default.createContext({});

// node_modules/antd/es/color-picker/components/ColorClear.js
var import_react49 = __toESM(require_react());
var ColorClear = ({
  prefixCls,
  value,
  onChange
}) => {
  const handleClick = () => {
    if (onChange && value && !value.cleared) {
      const hsba = value.toHsb();
      hsba.a = 0;
      const genColor = generateColor2(hsba);
      genColor.cleared = true;
      onChange(genColor);
    }
  };
  return import_react49.default.createElement("div", {
    className: `${prefixCls}-clear`,
    onClick: handleClick
  });
};
var ColorClear_default = ColorClear;

// node_modules/antd/es/color-picker/components/ColorInput.js
var import_react77 = __toESM(require_react());

// node_modules/antd/es/select/index.js
var React144 = __toESM(require_react());

// node_modules/@rc-component/select/es/Select.js
var React136 = __toESM(require_react());

// node_modules/@rc-component/select/es/BaseSelect/index.js
var React117 = __toESM(require_react());

// node_modules/@rc-component/select/es/hooks/useAllowClear.js
var import_react50 = __toESM(require_react());
var useAllowClear = (prefixCls, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode) => {
  const allowClearConfig = (0, import_react50.useMemo)(() => {
    if (typeof allowClear === "boolean") {
      return {
        allowClear
      };
    }
    if (allowClear && typeof allowClear === "object") {
      return allowClear;
    }
    return {
      allowClear: false
    };
  }, [allowClear]);
  return (0, import_react50.useMemo)(() => {
    const mergedAllowClear = !disabled && allowClearConfig.allowClear !== false && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "");
    return {
      allowClear: mergedAllowClear,
      clearIcon: mergedAllowClear ? allowClearConfig.clearIcon || clearIcon || "" : null
    };
  }, [allowClearConfig, clearIcon, disabled, displayValues.length, mergedSearchValue, mode]);
};

// node_modules/@rc-component/select/es/hooks/useBaseProps.js
var React96 = __toESM(require_react());
var BaseSelectContext = React96.createContext(null);
function useBaseProps() {
  return React96.useContext(BaseSelectContext);
}

// node_modules/@rc-component/select/es/hooks/useLock.js
var React97 = __toESM(require_react());
function useLock(duration = 250) {
  const lockRef = React97.useRef(null);
  const timeoutRef = React97.useRef(null);
  React97.useEffect(() => () => {
    window.clearTimeout(timeoutRef.current);
  }, []);
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(() => {
      lockRef.current = null;
    }, duration);
  }
  return [() => lockRef.current, doLock];
}

// node_modules/@rc-component/select/es/hooks/useSelectTriggerControl.js
var React98 = __toESM(require_react());
function isInside(elements, target) {
  return elements.filter((element) => element).some((element) => element.contains(target) || element === target);
}
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  const onGlobalMouseDown = useEvent_default((event) => {
    if (customizedTrigger) {
      return;
    }
    let target = event.target;
    if (target.shadowRoot && event.composed) {
      target = event.composedPath()[0] || target;
    }
    if (event._ori_target) {
      target = event._ori_target;
    }
    if (open && // Marked by SelectInput mouseDown event
    !isInside(elements(), target)) {
      triggerOpen(false);
    }
  });
  React98.useEffect(() => {
    window.addEventListener("mousedown", onGlobalMouseDown);
    return () => window.removeEventListener("mousedown", onGlobalMouseDown);
  }, [onGlobalMouseDown]);
}

// node_modules/@rc-component/select/es/SelectTrigger.js
var React99 = __toESM(require_react());
function _extends11() {
  _extends11 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends11.apply(this, arguments);
}
var getBuiltInPlacements = (popupMatchSelectWidth) => {
  const adjustX = popupMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
};
var SelectTrigger = (props, ref) => {
  const {
    prefixCls,
    disabled,
    visible,
    children,
    popupElement,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    direction = "ltr",
    placement,
    builtinPlacements,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    getPopupContainer,
    empty,
    onPopupVisibleChange,
    onPopupMouseEnter,
    onPopupMouseDown,
    onPopupBlur,
    ...restProps
  } = props;
  const popupPrefixCls = `${prefixCls}-dropdown`;
  let popupNode = popupElement;
  if (popupRender) {
    popupNode = popupRender(popupElement);
  }
  const mergedBuiltinPlacements2 = React99.useMemo(() => builtinPlacements || getBuiltInPlacements(popupMatchSelectWidth), [builtinPlacements, popupMatchSelectWidth]);
  const mergedTransitionName = animation ? `${popupPrefixCls}-${animation}` : transitionName;
  const isNumberPopupWidth = typeof popupMatchSelectWidth === "number";
  const stretch = React99.useMemo(() => {
    if (isNumberPopupWidth) {
      return null;
    }
    return popupMatchSelectWidth === false ? "minWidth" : "width";
  }, [popupMatchSelectWidth, isNumberPopupWidth]);
  let mergedPopupStyle = popupStyle;
  if (isNumberPopupWidth) {
    mergedPopupStyle = {
      ...popupStyle,
      width: popupMatchSelectWidth
    };
  }
  const triggerPopupRef = React99.useRef(null);
  React99.useImperativeHandle(ref, () => ({
    getPopupElement: () => triggerPopupRef.current?.popupElement
  }));
  return React99.createElement(es_default6, _extends11({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: mergedBuiltinPlacements2,
    prefixCls: popupPrefixCls,
    popupMotion: {
      motionName: mergedTransitionName
    },
    popup: React99.createElement("div", {
      onMouseEnter: onPopupMouseEnter,
      onMouseDown: onPopupMouseDown,
      onBlur: onPopupBlur
    }, popupNode),
    ref: triggerPopupRef,
    stretch,
    popupAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: clsx(popupClassName, {
      [`${popupPrefixCls}-empty`]: empty
    }),
    popupStyle: mergedPopupStyle,
    onPopupVisibleChange
  }), children);
};
var RefSelectTrigger = React99.forwardRef(SelectTrigger);
if (true) {
  RefSelectTrigger.displayName = "SelectTrigger";
}
var SelectTrigger_default = RefSelectTrigger;

// node_modules/@rc-component/select/es/utils/valueUtil.js
function getKey(data, index) {
  const {
    key
  } = data;
  let value;
  if ("value" in data) {
    ({
      value
    } = data);
  }
  if (key !== null && key !== void 0) {
    return key;
  }
  if (value !== void 0) {
    return value;
  }
  return `rc-index-key-${index}`;
}
function isValidCount(value) {
  return typeof value !== "undefined" && !Number.isNaN(value);
}
function fillFieldNames(fieldNames, childrenAsData) {
  const {
    label,
    value,
    options,
    groupLabel
  } = fieldNames || {};
  const mergedLabel = label || (childrenAsData ? "children" : "label");
  return {
    label: mergedLabel,
    value: value || "value",
    options: options || "options",
    groupLabel: groupLabel || mergedLabel
  };
}
function flattenOptions(options, {
  fieldNames,
  childrenAsData
} = {}) {
  const flattenList = [];
  const {
    label: fieldLabel,
    value: fieldValue,
    options: fieldOptions,
    groupLabel
  } = fillFieldNames(fieldNames, false);
  function dig(list, isGroupOption) {
    if (!Array.isArray(list)) {
      return;
    }
    list.forEach((data) => {
      if (isGroupOption || !(fieldOptions in data)) {
        const value = data[fieldValue];
        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label: data[fieldLabel],
          value
        });
      } else {
        let grpLabel = data[groupLabel];
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data.label;
        }
        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  const newOption = {
    ...option
  };
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get() {
        warning_default(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
        return newOption;
      }
    });
  }
  return newOption;
}
var getSeparatedContent = (text, tokens, end) => {
  if (!tokens || !tokens.length) {
    return null;
  }
  let match3 = false;
  const separate = (str, [token2, ...restTokens]) => {
    if (!token2) {
      return [str];
    }
    const list2 = str.split(token2);
    match3 = match3 || list2.length > 1;
    return list2.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);
  };
  const list = separate(text, tokens);
  if (match3) {
    return typeof end !== "undefined" ? list.slice(0, end) : list;
  } else {
    return null;
  }
};

// node_modules/@rc-component/select/es/BaseSelect/Polite.js
var React100 = __toESM(require_react());
function Polite(props) {
  const {
    visible,
    values
  } = props;
  if (!visible) {
    return null;
  }
  const MAX_COUNT = 50;
  return React100.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, `${values.slice(0, MAX_COUNT).map(({
    label,
    value
  }) => ["number", "string"].includes(typeof label) ? label : value).join(", ")}`, values.length > MAX_COUNT ? ", ..." : null);
}

// node_modules/@rc-component/select/es/hooks/useOpen.js
var import_react51 = __toESM(require_react());
var internalMacroTask = (fn) => {
  const channel = new MessageChannel();
  channel.port1.onmessage = fn;
  channel.port2.postMessage(null);
};
var macroTask = (fn, times = 1) => {
  if (times <= 0) {
    fn();
    return;
  }
  internalMacroTask(() => {
    macroTask(fn, times - 1);
  });
};
function useOpen(defaultOpen, propOpen, onOpen, postOpen) {
  const [rendered, setRendered] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    setRendered(true);
  }, []);
  const [stateOpen, internalSetOpen] = useControlledState(defaultOpen, propOpen);
  const ssrSafeOpen = rendered ? stateOpen : false;
  const mergedOpen = postOpen(ssrSafeOpen);
  const taskIdRef = (0, import_react51.useRef)(0);
  const triggerEvent = useEvent_default((nextOpen) => {
    if (onOpen && mergedOpen !== nextOpen) {
      onOpen(nextOpen);
    }
    internalSetOpen(nextOpen);
  });
  const toggleOpen = useEvent_default((nextOpen, config = {}) => {
    const {
      cancelFun
    } = config;
    taskIdRef.current += 1;
    const id = taskIdRef.current;
    const nextOpenVal = typeof nextOpen === "boolean" ? nextOpen : !mergedOpen;
    function triggerUpdate() {
      if (
        // Always check if id is match
        id === taskIdRef.current && // Check if need to cancel
        !cancelFun?.()
      ) {
        triggerEvent(nextOpenVal);
      }
    }
    if (nextOpenVal) {
      triggerUpdate();
    } else {
      macroTask(() => {
        triggerUpdate();
      });
    }
  });
  return [mergedOpen, toggleOpen];
}

// node_modules/@rc-component/select/es/SelectInput/index.js
var React115 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Affix.js
var React101 = __toESM(require_react());
function Affix(props) {
  const {
    children,
    ...restProps
  } = props;
  if (!children) {
    return null;
  }
  return React101.createElement("div", restProps, children);
}

// node_modules/@rc-component/select/es/SelectInput/Content/index.js
var React114 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Content/SingleContent.js
var React106 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Input.js
var React103 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/context.js
var React102 = __toESM(require_react());
var SelectInputContext = React102.createContext(null);
function useSelectInputContext() {
  return React102.useContext(SelectInputContext);
}
var context_default3 = SelectInputContext;

// node_modules/@rc-component/select/es/SelectInput/Input.js
var Input = React103.forwardRef((props, ref) => {
  const {
    onChange,
    onKeyDown,
    onBlur,
    style: style2,
    syncWidth,
    value,
    className,
    autoComplete,
    ...restProps
  } = props;
  const {
    prefixCls,
    mode,
    onSearch,
    onSearchSubmit,
    onInputBlur,
    autoFocus,
    tokenWithEnter,
    placeholder,
    components: {
      input: InputComponent = "input"
    }
  } = useSelectInputContext();
  const {
    id,
    classNames,
    styles,
    open,
    activeDescendantId,
    role,
    disabled
  } = useBaseProps() || {};
  const inputCls = clsx(`${prefixCls}-input`, classNames?.input, className);
  const compositionStatusRef = React103.useRef(false);
  const pastedTextRef = React103.useRef(null);
  const inputRef = React103.useRef(null);
  React103.useImperativeHandle(ref, () => inputRef.current);
  const handleChange = (event) => {
    let {
      value: nextVal
    } = event.target;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      nextVal = nextVal.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    if (onSearch) {
      onSearch(nextVal, true, compositionStatusRef.current);
    }
    onChange?.(event);
  };
  const handleKeyDown = (event) => {
    const {
      key
    } = event;
    const {
      value: nextVal
    } = event.currentTarget;
    if (key === "Enter" && mode === "tags" && !compositionStatusRef.current && onSearchSubmit) {
      onSearchSubmit(nextVal);
    }
    onKeyDown?.(event);
  };
  const handleBlur = (event) => {
    onInputBlur?.();
    onBlur?.(event);
  };
  const handleCompositionStart = () => {
    compositionStatusRef.current = true;
  };
  const handleCompositionEnd = (event) => {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      const {
        value: nextVal
      } = event.currentTarget;
      onSearch?.(nextVal, true, false);
    }
  };
  const handlePaste = (event) => {
    const {
      clipboardData
    } = event;
    const pastedValue = clipboardData?.getData("text");
    pastedTextRef.current = pastedValue || "";
  };
  const [widthCssVar, setWidthCssVar] = React103.useState(void 0);
  useLayoutEffect_default(() => {
    const input = inputRef.current;
    if (syncWidth && input) {
      input.style.width = "0px";
      const scrollWidth = input.scrollWidth;
      setWidthCssVar(scrollWidth);
      input.style.width = "";
    }
  }, [syncWidth, value]);
  const sharedInputProps = {
    id,
    type: mode === "combobox" ? "text" : "search",
    ...restProps,
    ref: inputRef,
    style: {
      ...styles?.input,
      ...style2,
      "--select-input-width": widthCssVar
    },
    autoFocus,
    autoComplete: autoComplete || "off",
    className: inputCls,
    disabled,
    value: value || "",
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur,
    onPaste: handlePaste,
    onCompositionStart: handleCompositionStart,
    onCompositionEnd: handleCompositionEnd,
    // Accessibility attributes
    role: role || "combobox",
    "aria-expanded": open || false,
    "aria-haspopup": "listbox",
    "aria-owns": open ? `${id}_list` : void 0,
    "aria-autocomplete": "list",
    "aria-controls": open ? `${id}_list` : void 0,
    "aria-activedescendant": open ? activeDescendantId : void 0
  };
  if (React103.isValidElement(InputComponent)) {
    const existingProps = InputComponent.props || {};
    const mergedProps = {
      placeholder: props.placeholder || placeholder,
      ...sharedInputProps,
      ...existingProps
    };
    Object.keys(existingProps).forEach((key) => {
      const existingValue = existingProps[key];
      if (typeof existingValue === "function") {
        mergedProps[key] = (...args) => {
          existingValue(...args);
          sharedInputProps[key]?.(...args);
        };
      }
    });
    mergedProps.ref = composeRef(InputComponent.ref, sharedInputProps.ref);
    return React103.cloneElement(InputComponent, mergedProps);
  }
  const Component3 = InputComponent;
  return React103.createElement(Component3, sharedInputProps);
});
var Input_default = Input;

// node_modules/@rc-component/select/es/SelectInput/Content/Placeholder.js
var React104 = __toESM(require_react());
function Placeholder(props) {
  const {
    prefixCls,
    placeholder,
    displayValues
  } = useSelectInputContext();
  const {
    classNames,
    styles
  } = useBaseProps();
  const {
    show = true
  } = props;
  if (displayValues.length) {
    return null;
  }
  return React104.createElement("div", {
    className: clsx(`${prefixCls}-placeholder`, classNames?.placeholder),
    style: {
      visibility: show ? "visible" : "hidden",
      ...styles?.placeholder
    }
  }, placeholder);
}

// node_modules/@rc-component/select/es/SelectContext.js
var React105 = __toESM(require_react());
var SelectContext = React105.createContext(null);
var SelectContext_default = SelectContext;

// node_modules/@rc-component/select/es/utils/commonUtil.js
function toArray4(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
function hasValue(value) {
  return value !== void 0 && value !== null;
}
function isComboNoValue(value) {
  return !value && value !== 0;
}
function isTitleType(title) {
  return ["string", "number"].includes(typeof title);
}
function getTitle(item) {
  let title = void 0;
  if (item) {
    if (isTitleType(item.title)) {
      title = item.title.toString();
    } else if (isTitleType(item.label)) {
      title = item.label.toString();
    }
  }
  return title;
}

// node_modules/@rc-component/select/es/SelectInput/Content/SingleContent.js
function _extends12() {
  _extends12 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends12.apply(this, arguments);
}
var SingleContent = React106.forwardRef(({
  inputProps
}, ref) => {
  const {
    prefixCls,
    searchValue,
    activeValue,
    displayValues,
    maxLength,
    mode
  } = useSelectInputContext();
  const {
    triggerOpen,
    title: rootTitle,
    showSearch,
    classNames,
    styles
  } = useBaseProps();
  const selectContext = React106.useContext(SelectContext_default);
  const [inputChanged, setInputChanged] = React106.useState(false);
  const combobox = mode === "combobox";
  const displayValue = displayValues[0];
  const mergedSearchValue = React106.useMemo(() => {
    if (combobox && activeValue && !inputChanged && triggerOpen) {
      return activeValue;
    }
    return showSearch ? searchValue : "";
  }, [combobox, activeValue, inputChanged, triggerOpen, searchValue, showSearch]);
  const optionProps = React106.useMemo(() => {
    let restProps = {
      className: `${prefixCls}-content-value`,
      style: {
        visibility: mergedSearchValue ? "hidden" : "visible"
      }
    };
    if (displayValue && selectContext?.flattenOptions) {
      const option = selectContext.flattenOptions.find((opt) => opt.value === displayValue.value);
      if (option?.data) {
        const {
          label,
          value,
          className,
          style: style2,
          key,
          ...rest
        } = option.data;
        restProps = {
          ...restProps,
          ...rest,
          title: getTitle(option.data),
          className: clsx(restProps.className, className),
          style: {
            ...restProps.style,
            ...style2
          }
        };
      }
    }
    if (displayValue && !restProps.title) {
      restProps.title = getTitle(displayValue);
    }
    if (rootTitle !== void 0) {
      restProps.title = rootTitle;
    }
    return restProps;
  }, [displayValue, selectContext?.flattenOptions, prefixCls, mergedSearchValue, rootTitle]);
  React106.useEffect(() => {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  return React106.createElement("div", {
    className: clsx(`${prefixCls}-content`, classNames?.content),
    style: styles?.content
  }, displayValue ? React106.createElement("div", optionProps, displayValue.label) : React106.createElement(Placeholder, {
    show: !mergedSearchValue
  }), React106.createElement(Input_default, _extends12({
    ref
  }, inputProps, {
    value: mergedSearchValue,
    maxLength: mode === "combobox" ? maxLength : void 0,
    onChange: (e) => {
      setInputChanged(true);
      inputProps.onChange?.(e);
    }
  })));
});
var SingleContent_default = SingleContent;

// node_modules/@rc-component/select/es/SelectInput/Content/MultipleContent.js
var React113 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/Overflow.js
var React111 = __toESM(require_react());
var import_react53 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/Item.js
var React107 = __toESM(require_react());
var UNDEFINED = void 0;
function InternalItem(props, ref) {
  const {
    prefixCls,
    invalidate,
    item,
    renderItem,
    responsive,
    responsiveDisabled,
    registerSize,
    itemKey: itemKey2,
    className,
    style: style2,
    children,
    display,
    order,
    component: Component3 = "div",
    ...restProps
  } = props;
  const mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  React107.useEffect(() => () => {
    internalRegisterSize(null);
  }, []);
  const childNode = renderItem && item !== UNDEFINED ? renderItem(item, {
    index: order
  }) : children;
  let overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  const overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  let itemNode = React107.createElement(Component3, _extends10({
    className: clsx(!invalidate && prefixCls, className),
    style: {
      ...overflowStyle,
      ...style2
    }
  }, overflowProps, restProps, {
    ref
  }), childNode);
  if (responsive) {
    itemNode = React107.createElement(es_default4, {
      onResize: ({
        offsetWidth
      }) => {
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item = React107.forwardRef(InternalItem);
if (true) {
  Item.displayName = "Item";
}
var Item_default = Item;

// node_modules/@rc-component/overflow/es/hooks/useEffectState.js
var React108 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@rc-component/overflow/es/hooks/channelUpdate.js
function channelUpdate(callback) {
  if (typeof MessageChannel === "undefined") {
    raf_default(callback);
  } else {
    const channel = new MessageChannel();
    channel.port1.onmessage = () => callback();
    channel.port2.postMessage(void 0);
  }
}

// node_modules/@rc-component/overflow/es/hooks/useEffectState.js
function useBatcher() {
  const updateFuncRef = React108.useRef(null);
  const notifyEffectUpdate = (callback) => {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate(() => {
        (0, import_react_dom2.unstable_batchedUpdates)(() => {
          updateFuncRef.current.forEach((fn) => {
            fn();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  };
  return notifyEffectUpdate;
}
function useEffectState(notifyEffectUpdate, defaultValue) {
  const [stateValue, setStateValue] = React108.useState(defaultValue);
  const setEffectVal = useEvent_default((nextValue) => {
    notifyEffectUpdate(() => {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}

// node_modules/@rc-component/overflow/es/RawItem.js
var React110 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/context.js
var import_react52 = __toESM(require_react());
var OverflowContext = import_react52.default.createContext(null);

// node_modules/@rc-component/overflow/es/RawItem.js
var InternalRawItem = (props, ref) => {
  const context = React110.useContext(OverflowContext);
  if (!context) {
    const {
      component: Component3 = "div",
      ...restProps2
    } = props;
    return React110.createElement(Component3, _extends10({}, restProps2, {
      ref
    }));
  }
  const {
    className: contextClassName,
    ...restContext
  } = context;
  const {
    className,
    ...restProps
  } = props;
  return React110.createElement(OverflowContext.Provider, {
    value: null
  }, React110.createElement(Item_default, _extends10({
    ref,
    className: clsx(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = React110.forwardRef(InternalRawItem);
if (true) {
  RawItem.displayName = "RawItem";
}
var RawItem_default = RawItem;

// node_modules/@rc-component/overflow/es/Overflow.js
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return `+ ${omittedItems.length} ...`;
}
function Overflow(props, ref) {
  const {
    prefixCls = "rc-overflow",
    data = [],
    renderItem,
    renderRawItem,
    itemKey: itemKey2,
    itemWidth = 10,
    ssr,
    style: style2,
    className,
    maxCount,
    renderRest,
    renderRawRest,
    prefix: prefix2,
    suffix,
    component: Component3 = "div",
    itemComponent,
    onVisibleChange,
    ...restProps
  } = props;
  const fullySSR = ssr === "full";
  const notifyEffectUpdate = useBatcher();
  const [containerWidth, setContainerWidth] = useEffectState(notifyEffectUpdate, null);
  const mergedContainerWidth = containerWidth || 0;
  const [itemWidths, setItemWidths] = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map());
  const [prevRestWidth, setPrevRestWidth] = useEffectState(notifyEffectUpdate, 0);
  const [restWidth, setRestWidth] = useEffectState(notifyEffectUpdate, 0);
  const [prefixWidth, setPrefixWidth] = useEffectState(notifyEffectUpdate, 0);
  const [suffixWidth, setSuffixWidth] = useEffectState(notifyEffectUpdate, 0);
  const [suffixFixedStart, setSuffixFixedStart] = (0, import_react53.useState)(null);
  const [displayCount, setDisplayCount] = (0, import_react53.useState)(null);
  const mergedDisplayCount = React111.useMemo(() => {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  const [restReady, setRestReady] = (0, import_react53.useState)(false);
  const itemPrefixCls = `${prefixCls}-item`;
  const mergedRestWidth = Math.max(prevRestWidth, restWidth);
  const isResponsive = maxCount === RESPONSIVE;
  const shouldResponsive = data.length && isResponsive;
  const invalidate = maxCount === INVALIDATE;
  const showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
  const mergedData = (0, import_react53.useMemo)(() => {
    let items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  const omittedItems = (0, import_react53.useMemo)(() => {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
  const getKey2 = (0, import_react53.useCallback)((item, index) => {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (itemKey2 && item?.[itemKey2]) ?? index;
  }, [itemKey2]);
  const mergedRenderItem = (0, import_react53.useCallback)(renderItem || ((item) => item), [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange?.(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths((origin) => {
      const clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  }
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerPrefixSize(_, width) {
    setPrefixWidth(width);
  }
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index) {
    return itemWidths.get(getKey2(mergedData[index], index));
  }
  useLayoutEffect_default(() => {
    if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
      let totalWidth = prefixWidth + suffixWidth;
      const len = mergedData.length;
      const lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (let i = 0; i < len; i += 1) {
        let currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (
          // Only one means `totalWidth` is the final width
          lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
          i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
        ) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, prefixWidth, suffixWidth, getKey2, mergedData]);
  const displayRest = restReady && !!omittedItems.length;
  let suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  const itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  const internalRenderItemNode = renderRawItem ? (item, index) => {
    const key = getKey2(item, index);
    return React111.createElement(OverflowContext.Provider, {
      key,
      value: {
        ...itemSharedProps,
        order: index,
        item,
        itemKey: key,
        registerSize,
        display: index <= mergedDisplayCount
      }
    }, renderRawItem(item, index));
  } : (item, index) => {
    const key = getKey2(item, index);
    return React111.createElement(Item_default, _extends10({}, itemSharedProps, {
      order: index,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index <= mergedDisplayCount
    }));
  };
  const restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: `${itemPrefixCls}-rest`,
    registerSize: registerOverflowSize,
    display: displayRest
  };
  const mergedRenderRest = renderRest || defaultRenderRest;
  const restNode = renderRawRest ? React111.createElement(OverflowContext.Provider, {
    value: {
      ...itemSharedProps,
      ...restContextProps
    }
  }, renderRawRest(omittedItems)) : React111.createElement(Item_default, _extends10({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  const overflowNode = React111.createElement(Component3, _extends10({
    className: clsx(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), prefix2 && React111.createElement(Item_default, _extends10({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: -1,
    className: `${itemPrefixCls}-prefix`,
    registerSize: registerPrefixSize,
    display: true
  }), prefix2), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && React111.createElement(Item_default, _extends10({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: `${itemPrefixCls}-suffix`,
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  return isResponsive ? React111.createElement(es_default4, {
    onResize: onOverflowResize,
    disabled: !shouldResponsive
  }, overflowNode) : overflowNode;
}
var ForwardOverflow = React111.forwardRef(Overflow);
ForwardOverflow.Item = RawItem_default;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
if (true) {
  ForwardOverflow.displayName = "Overflow";
}
var Overflow_default = ForwardOverflow;

// node_modules/@rc-component/overflow/es/index.js
var es_default10 = Overflow_default;

// node_modules/@rc-component/select/es/TransBtn.js
var React112 = __toESM(require_react());
var TransBtn = (props) => {
  const {
    className,
    style: style2,
    customizeIcon,
    customizeIconProps,
    children,
    onMouseDown,
    onClick
  } = props;
  const icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
  return React112.createElement("span", {
    className,
    onMouseDown: (event) => {
      event.preventDefault();
      onMouseDown?.(event);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none",
      ...style2
    },
    unselectable: "on",
    onClick,
    "aria-hidden": true
  }, icon !== void 0 ? icon : React112.createElement("span", {
    className: clsx(className.split(/\s+/).map((cls) => `${cls}-icon`))
  }, children));
};
var TransBtn_default = TransBtn;

// node_modules/@rc-component/select/es/SelectInput/Content/MultipleContent.js
function _extends13() {
  _extends13 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends13.apply(this, arguments);
}
function itemKey(value) {
  return value.key ?? value.value;
}
var onPreventMouseDown = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var MultipleContent_default = React113.forwardRef(function MultipleContent({
  inputProps
}, ref) {
  const {
    prefixCls,
    displayValues,
    searchValue,
    mode,
    onSelectorRemove,
    removeIcon: removeIconFromContext
  } = useSelectInputContext();
  const {
    disabled,
    showSearch,
    triggerOpen,
    toggleOpen,
    autoClearSearchValue,
    tagRender: tagRenderFromContext,
    maxTagPlaceholder: maxTagPlaceholderFromContext,
    maxTagTextLength,
    maxTagCount,
    classNames,
    styles
  } = useBaseProps();
  const selectionItemPrefixCls = `${prefixCls}-selection-item`;
  let computedSearchValue = searchValue;
  if (!triggerOpen && mode === "multiple" && autoClearSearchValue !== false) {
    computedSearchValue = "";
  }
  const inputValue = showSearch ? computedSearchValue || "" : "";
  const inputEditable = showSearch && !disabled;
  const removeIcon = removeIconFromContext ?? "";
  const maxTagPlaceholder = maxTagPlaceholderFromContext ?? ((omittedValues) => `+ ${omittedValues.length} ...`);
  const tagRender = tagRenderFromContext;
  const onToggleOpen = (newOpen) => {
    toggleOpen(newOpen);
  };
  const onRemove = (value) => {
    onSelectorRemove?.(value);
  };
  const defaultRenderSelector = (item, content, itemDisabled, closable, onClose) => React113.createElement("span", {
    title: getTitle(item),
    className: clsx(selectionItemPrefixCls, {
      [`${selectionItemPrefixCls}-disabled`]: itemDisabled
    }, classNames?.item),
    style: styles?.item
  }, React113.createElement("span", {
    className: clsx(`${selectionItemPrefixCls}-content`, classNames?.itemContent),
    style: styles?.itemContent
  }, content), closable && React113.createElement(TransBtn_default, {
    className: clsx(`${selectionItemPrefixCls}-remove`, classNames?.itemRemove),
    style: styles?.itemRemove,
    onMouseDown: onPreventMouseDown,
    onClick: onClose,
    customizeIcon: removeIcon
  }, ""));
  const customizeRenderSelector = (value, content, itemDisabled, closable, onClose, isMaxTag, info) => {
    const onMouseDown = (e) => {
      onPreventMouseDown(e);
      onToggleOpen(!triggerOpen);
    };
    return React113.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content,
      value,
      index: info?.index,
      disabled: itemDisabled,
      closable,
      onClose,
      isMaxTag: !!isMaxTag
    }));
  };
  const renderItem = (valueItem, info) => {
    const {
      disabled: itemDisabled,
      label,
      value
    } = valueItem;
    const closable = !disabled && !itemDisabled;
    let displayLabel = label;
    if (typeof maxTagTextLength === "number") {
      if (typeof label === "string" || typeof label === "number") {
        const strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
        }
      }
    }
    const onClose = (event) => {
      if (event) {
        event.stopPropagation();
      }
      onRemove(valueItem);
    };
    return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, void 0, info) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  };
  const renderRest = (omittedValues) => {
    if (!displayValues.length) {
      return null;
    }
    const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({
      title: content
    }, content, false);
  };
  return React113.createElement(es_default10, {
    prefixCls: `${prefixCls}-content`,
    className: classNames?.content,
    style: styles?.content,
    prefix: !displayValues.length && (!searchValue || !triggerOpen) ? React113.createElement(Placeholder, null) : null,
    data: displayValues,
    renderItem,
    renderRest,
    suffix: React113.createElement(Input_default, _extends13({
      ref,
      disabled,
      readOnly: !inputEditable
    }, inputProps, {
      value: inputValue || "",
      syncWidth: true
    })),
    itemKey,
    maxCount: maxTagCount
  });
});

// node_modules/@rc-component/select/es/SelectInput/Content/index.js
var SelectContent = React114.forwardRef(function SelectContent2(_, ref) {
  const {
    multiple,
    onInputKeyDown,
    tabIndex
  } = useSelectInputContext();
  const baseProps = useBaseProps();
  const {
    showSearch
  } = baseProps;
  const ariaProps = pickAttrs(baseProps, {
    aria: true
  });
  const sharedInputProps = {
    ...ariaProps,
    onKeyDown: onInputKeyDown,
    readOnly: !showSearch,
    tabIndex
  };
  if (multiple) {
    return React114.createElement(MultipleContent_default, {
      ref,
      inputProps: sharedInputProps
    });
  }
  return React114.createElement(SingleContent_default, {
    ref,
    inputProps: sharedInputProps
  });
});
var Content_default = SelectContent;

// node_modules/@rc-component/select/es/utils/keyUtil.js
function isValidateOpenKey(currentKeyCode) {
  return (
    // Undefined for Edge bug:
    // https://github.com/ant-design/ant-design/issues/51292
    currentKeyCode && // Other keys
    ![
      // System function button
      KeyCode_default.ESC,
      KeyCode_default.SHIFT,
      KeyCode_default.BACKSPACE,
      KeyCode_default.TAB,
      KeyCode_default.WIN_KEY,
      KeyCode_default.ALT,
      KeyCode_default.META,
      KeyCode_default.WIN_KEY_RIGHT,
      KeyCode_default.CTRL,
      KeyCode_default.SEMICOLON,
      KeyCode_default.EQUALS,
      KeyCode_default.CAPS_LOCK,
      KeyCode_default.CONTEXT_MENU,
      // Arrow keys - should not trigger open when navigating in input
      KeyCode_default.UP,
      // KeyCode.DOWN,
      KeyCode_default.LEFT,
      KeyCode_default.RIGHT,
      // F1-F12
      KeyCode_default.F1,
      KeyCode_default.F2,
      KeyCode_default.F3,
      KeyCode_default.F4,
      KeyCode_default.F5,
      KeyCode_default.F6,
      KeyCode_default.F7,
      KeyCode_default.F8,
      KeyCode_default.F9,
      KeyCode_default.F10,
      KeyCode_default.F11,
      KeyCode_default.F12
    ].includes(currentKeyCode)
  );
}

// node_modules/@rc-component/select/es/SelectInput/index.js
function _extends14() {
  _extends14 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends14.apply(this, arguments);
}
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex", "activeValue", "onSelectorRemove", "focused"];
var SelectInput_default = React115.forwardRef(function SelectInput(props, ref) {
  const {
    // Style
    prefixCls,
    className,
    style: style2,
    // UI
    prefix: prefix2,
    suffix,
    clearIcon,
    children,
    // Data
    multiple,
    displayValues,
    placeholder,
    mode,
    // Search
    searchValue,
    onSearch,
    onSearchSubmit,
    onInputBlur,
    // Input
    maxLength,
    autoFocus,
    // Events
    onMouseDown,
    onClearMouseDown,
    onInputKeyDown,
    onSelectorRemove,
    // Token handling
    tokenWithEnter,
    // Components
    components: components2,
    ...restProps
  } = props;
  const {
    triggerOpen,
    toggleOpen,
    showSearch,
    disabled,
    loading,
    classNames,
    styles
  } = useBaseProps();
  const rootRef = React115.useRef(null);
  const inputRef = React115.useRef(null);
  const onInternalInputKeyDown = useEvent_default((event) => {
    const {
      which
    } = event;
    const isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
    if (!isTextAreaElement && triggerOpen && (which === KeyCode_default.UP || which === KeyCode_default.DOWN)) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (isTextAreaElement && !triggerOpen && ~[KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.LEFT, KeyCode_default.RIGHT].indexOf(which)) {
      return;
    }
    if (isValidateOpenKey(which)) {
      toggleOpen(true);
    }
  });
  React115.useImperativeHandle(ref, () => {
    return {
      focus: (options) => {
        (inputRef.current || rootRef.current).focus?.(options);
      },
      blur: () => {
        (inputRef.current || rootRef.current).blur?.();
      },
      nativeElement: rootRef.current
    };
  });
  const onInternalMouseDown = useEvent_default((event) => {
    if (!disabled) {
      const inputDOM = getDOM(inputRef.current);
      event.nativeEvent._ori_target = inputDOM;
      if (inputDOM && event.target !== inputDOM && !inputDOM.contains(event.target)) {
        event.preventDefault();
      }
      const shouldPreventClose = triggerOpen && !multiple && (mode === "combobox" || showSearch);
      if (!event.nativeEvent._select_lazy) {
        inputRef.current?.focus();
        if (!shouldPreventClose) {
          toggleOpen();
        }
      } else if (triggerOpen) {
        toggleOpen(false);
      }
    }
    onMouseDown?.(event);
  });
  const {
    root: RootComponent
  } = components2;
  const domProps = omit(restProps, DEFAULT_OMIT_PROPS);
  const contextValue = {
    ...props,
    onInputKeyDown: onInternalInputKeyDown
  };
  if (RootComponent) {
    if (React115.isValidElement(RootComponent)) {
      return React115.cloneElement(RootComponent, {
        ...domProps,
        ref: composeRef(RootComponent.ref, rootRef)
      });
    }
    return React115.createElement(RootComponent, _extends14({}, domProps, {
      ref: rootRef
    }));
  }
  return React115.createElement(context_default3.Provider, {
    value: contextValue
  }, React115.createElement("div", _extends14({}, domProps, {
    // Style
    ref: rootRef,
    className,
    style: style2,
    onMouseDown: onInternalMouseDown
  }), React115.createElement(Affix, {
    className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
    style: styles?.prefix
  }, prefix2), React115.createElement(Content_default, {
    ref: inputRef
  }), React115.createElement(Affix, {
    className: clsx(`${prefixCls}-suffix`, {
      [`${prefixCls}-suffix-loading`]: loading
    }, classNames?.suffix),
    style: styles?.suffix
  }, suffix), clearIcon && React115.createElement(Affix, {
    className: clsx(`${prefixCls}-clear`, classNames?.clear),
    style: styles?.clear,
    onMouseDown: (e) => {
      e.nativeEvent._select_lazy = true;
      onClearMouseDown?.(e);
    }
  }, clearIcon), children));
});

// node_modules/@rc-component/select/es/hooks/useComponents.js
var React116 = __toESM(require_react());
function useComponents(components2, getInputElement, getRawInputElement) {
  return React116.useMemo(() => {
    let {
      root,
      input
    } = components2 || {};
    if (getRawInputElement) {
      root = getRawInputElement();
    }
    if (getInputElement) {
      input = getInputElement();
    }
    return {
      root,
      input
    };
  }, [components2, getInputElement, getRawInputElement]);
}

// node_modules/@rc-component/select/es/BaseSelect/index.js
function _extends15() {
  _extends15 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends15.apply(this, arguments);
}
var isMultiple = (mode) => mode === "tags" || mode === "multiple";
var BaseSelect = React117.forwardRef((props, ref) => {
  const {
    id,
    prefixCls,
    className,
    styles,
    classNames,
    showSearch,
    tagRender,
    showScrollBar = "optional",
    direction,
    omitDomProps,
    // Value
    displayValues,
    onDisplayValuesChange,
    emptyOptions,
    notFoundContent = "Not Found",
    onClear,
    maxCount,
    placeholder,
    // Mode
    mode,
    // Status
    disabled,
    loading,
    // Customize Input
    getInputElement,
    getRawInputElement,
    // Open
    open,
    defaultOpen,
    onPopupVisibleChange,
    // Active
    activeValue,
    onActiveValueChange,
    activeDescendantId,
    // Search
    searchValue,
    autoClearSearchValue,
    onSearch,
    onSearchSplit,
    tokenSeparators,
    // Icons
    allowClear,
    prefix: prefix2,
    suffix,
    suffixIcon,
    clearIcon,
    // Dropdown
    OptionList: OptionList2,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    // Focus
    showAction = [],
    onFocus,
    onBlur,
    // Rest Events
    onKeyUp,
    onKeyDown,
    onMouseDown,
    // Components
    components: components2,
    // Rest Props
    ...restProps
  } = props;
  const multiple = isMultiple(mode);
  const containerRef = React117.useRef(null);
  const triggerRef = React117.useRef(null);
  const listRef = React117.useRef(null);
  const [focused, setFocused] = React117.useState(false);
  React117.useImperativeHandle(ref, () => ({
    focus: containerRef.current?.focus,
    blur: containerRef.current?.blur,
    scrollTo: (arg) => listRef.current?.scrollTo(arg),
    nativeElement: getDOM(containerRef.current)
  }));
  const mergedComponents = useComponents(components2, getInputElement, getRawInputElement);
  const mergedSearchValue = React117.useMemo(() => {
    if (mode !== "combobox") {
      return searchValue;
    }
    const val = displayValues[0]?.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  const customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
  const emptyListContent = !notFoundContent && emptyOptions;
  const [mergedOpen, triggerOpen] = useOpen(defaultOpen || false, open, onPopupVisibleChange, (nextOpen) => disabled || emptyListContent ? false : nextOpen);
  const tokenWithEnter = React117.useMemo(() => (tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)), [tokenSeparators]);
  const onInternalSearch = (searchText, fromTyping, isCompositing) => {
    if (multiple && isValidCount(maxCount) && displayValues.length >= maxCount) {
      return;
    }
    let ret = true;
    let newSearchText = searchText;
    onActiveValueChange?.(null);
    const separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - displayValues.length : void 0);
    const patchLabels = isCompositing ? null : separatedList;
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit?.(patchLabels);
      triggerOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    if (searchText && fromTyping && ret) {
      triggerOpen(true);
    }
    return ret;
  };
  const onInternalSearchSubmit = (searchText) => {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: "submit"
    });
  };
  React117.useEffect(() => {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  React117.useEffect(() => {
    if (disabled) {
      triggerOpen(false);
      setFocused(false);
    }
  }, [disabled, mergedOpen]);
  const [getClearLock, setClearLock] = useLock();
  const keyLockRef = React117.useRef(false);
  const onInternalKeyDown = (event) => {
    const clearLock = getClearLock();
    const {
      key
    } = event;
    const isEnterKey = key === "Enter";
    if (isEnterKey) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        triggerOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      const cloneDisplayValues = [...displayValues];
      let removedDisplayValue = null;
      for (let i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        const current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
      if (isEnterKey) {
        keyLockRef.current = true;
      }
      listRef.current?.onKeyDown(event);
    }
    onKeyDown?.(event);
  };
  const onInternalKeyUp = (event, ...rest) => {
    if (mergedOpen) {
      listRef.current?.onKeyUp(event, ...rest);
    }
    if (event.key === "Enter") {
      keyLockRef.current = false;
    }
    onKeyUp?.(event, ...rest);
  };
  const onSelectorRemove = useEvent_default((val) => {
    const newValues = displayValues.filter((i) => i !== val);
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  });
  const onInputBlur = () => {
    keyLockRef.current = false;
  };
  const getSelectElements = () => [getDOM(containerRef.current), triggerRef.current?.getPopupElement()];
  useSelectTriggerControl(getSelectElements, mergedOpen, triggerOpen, !!mergedComponents.root);
  const internalMouseDownRef = React117.useRef(false);
  const onInternalFocus = (event) => {
    setFocused(true);
    if (!disabled) {
      if (showAction.includes("focus")) {
        triggerOpen(true);
      }
      onFocus?.(event);
    }
  };
  const onRootBlur = () => {
    if (mergedOpen && !internalMouseDownRef.current) {
      triggerOpen(false, {
        cancelFun: () => isInside(getSelectElements(), document.activeElement)
      });
    }
  };
  const onInternalBlur = (event) => {
    setFocused(false);
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, {
          source: "submit"
        });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    onRootBlur();
    if (!disabled) {
      onBlur?.(event);
    }
  };
  const onRootMouseDown = (event, ...restArgs) => {
    const {
      target
    } = event;
    const popupElement = triggerRef.current?.getPopupElement();
    if (popupElement?.contains(target) && triggerOpen) {
      triggerOpen(true);
    }
    onMouseDown?.(event, ...restArgs);
    internalMouseDownRef.current = true;
    macroTask(() => {
      internalMouseDownRef.current = false;
    });
  };
  const [, forceUpdate] = React117.useState({});
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  let onTriggerVisibleChange;
  if (!!mergedComponents.root) {
    onTriggerVisibleChange = (newOpen) => {
      triggerOpen(newOpen);
    };
  }
  const baseSelectContext = React117.useMemo(() => ({
    ...props,
    notFoundContent,
    open: mergedOpen,
    triggerOpen: mergedOpen,
    id,
    showSearch,
    multiple,
    toggleOpen: triggerOpen,
    showScrollBar,
    styles,
    classNames
  }), [props, notFoundContent, triggerOpen, id, showSearch, multiple, mergedOpen, showScrollBar, styles, classNames]);
  const mergedSuffixIcon = React117.useMemo(() => {
    const nextSuffix = suffix ?? suffixIcon;
    if (typeof nextSuffix === "function") {
      return nextSuffix({
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused,
        showSearch,
        loading
      });
    }
    return nextSuffix;
  }, [suffix, suffixIcon, mergedSearchValue, mergedOpen, focused, showSearch, loading]);
  const onClearMouseDown = () => {
    onClear?.();
    containerRef.current?.focus();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  };
  const {
    allowClear: mergedAllowClear,
    clearIcon: clearNode
  } = useAllowClear(prefixCls, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode);
  const optionList = React117.createElement(OptionList2, {
    ref: listRef
  });
  const mergedClassName = clsx(prefixCls, className, {
    [`${prefixCls}-focused`]: focused,
    [`${prefixCls}-multiple`]: multiple,
    [`${prefixCls}-single`]: !multiple,
    [`${prefixCls}-allow-clear`]: mergedAllowClear,
    [`${prefixCls}-show-arrow`]: mergedSuffixIcon !== void 0 && mergedSuffixIcon !== null,
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-open`]: mergedOpen,
    [`${prefixCls}-customize-input`]: customizeInputElement,
    [`${prefixCls}-show-search`]: showSearch
  });
  let renderNode = React117.createElement(SelectInput_default, _extends15({}, restProps, {
    // Ref
    ref: containerRef,
    prefixCls,
    className: mergedClassName,
    focused,
    prefix: prefix2,
    suffix: mergedSuffixIcon,
    clearIcon: clearNode,
    multiple,
    mode,
    displayValues,
    placeholder,
    searchValue: mergedSearchValue,
    activeValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onInputBlur,
    onFocus: onInternalFocus,
    onBlur: onInternalBlur,
    onClearMouseDown,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onSelectorRemove,
    tokenWithEnter,
    onMouseDown: onRootMouseDown,
    components: mergedComponents
  }));
  renderNode = React117.createElement(SelectTrigger_default, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: mergedOpen,
    popupElement: optionList,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    direction,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    empty: emptyOptions,
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter,
    onPopupMouseDown: onRootMouseDown,
    onPopupBlur: onRootBlur
  }, renderNode);
  return React117.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, React117.createElement(Polite, {
    visible: focused && !mergedOpen,
    values: displayValues
  }), renderNode);
});
if (true) {
  BaseSelect.displayName = "BaseSelect";
}
var BaseSelect_default = BaseSelect;

// node_modules/@rc-component/select/es/OptGroup.js
var OptGroup = () => null;
OptGroup.isSelectOptGroup = true;
var OptGroup_default = OptGroup;

// node_modules/@rc-component/select/es/Option.js
var Option = () => null;
Option.isSelectOption = true;
var Option_default = Option;

// node_modules/@rc-component/virtual-list/es/List.js
var React127 = __toESM(require_react());
var import_react58 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/@rc-component/virtual-list/es/Filler.js
var React118 = __toESM(require_react());
var Filler = React118.forwardRef(({
  height,
  offsetY,
  offsetX,
  children,
  prefixCls,
  onInnerResize,
  innerProps,
  rtl,
  extra
}, ref) => {
  let outerStyle = {};
  let innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offsetY !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = {
      ...innerStyle,
      transform: `translateY(${offsetY}px)`,
      [rtl ? "marginRight" : "marginLeft"]: -offsetX,
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    };
  }
  return React118.createElement("div", {
    style: outerStyle
  }, React118.createElement(es_default4, {
    onResize: ({
      offsetHeight
    }) => {
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, React118.createElement("div", _extends10({
    style: innerStyle,
    className: clsx({
      [`${prefixCls}-holder-inner`]: prefixCls
    }),
    ref
  }, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var Filler_default = Filler;

// node_modules/@rc-component/virtual-list/es/hooks/useChildren.js
var React120 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/Item.js
var React119 = __toESM(require_react());
function Item2({
  children,
  setRef
}) {
  const refFunc = React119.useCallback((node2) => {
    setRef(node2);
  }, []);
  return React119.cloneElement(children, {
    ref: refFunc
  });
}

// node_modules/@rc-component/virtual-list/es/hooks/useChildren.js
function useChildren(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, {
  getKey: getKey2
}) {
  return list.slice(startIndex, endIndex + 1).map((item, index) => {
    const eleIndex = startIndex + index;
    const node2 = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      },
      offsetX
    });
    const key = getKey2(item);
    return React120.createElement(Item2, {
      key,
      setRef: (ele) => setNodeRef(item, ele)
    }, node2);
  });
}

// node_modules/@rc-component/virtual-list/es/hooks/useDiffItem.js
var React121 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/algorithmUtil.js
function findListDiffIndex(originList, targetList, getKey2) {
  const originLen = originList.length;
  const targetLen = targetList.length;
  let shortList;
  let longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  const notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey2(item);
    }
    return notExistKey;
  }
  let diffIndex = null;
  let multiple = Math.abs(originLen - targetLen) !== 1;
  for (let i = 0; i < longList.length; i += 1) {
    const shortKey = getItemKey(shortList[i]);
    const longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}

// node_modules/@rc-component/virtual-list/es/hooks/useDiffItem.js
function useDiffItem(data, getKey2, onDiff) {
  const [prevData, setPrevData] = React121.useState(data);
  const [diffItem, setDiffItem] = React121.useState(null);
  React121.useEffect(() => {
    const diff = findListDiffIndex(prevData || [], data || [], getKey2);
    if (diff?.index !== void 0) {
      onDiff?.(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}

// node_modules/@rc-component/virtual-list/es/hooks/useFrameWheel.js
var import_react55 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/isFirefox.js
var isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default = isFF;

// node_modules/@rc-component/virtual-list/es/hooks/useOriginScroll.js
var import_react54 = __toESM(require_react());
var useOriginScroll_default = ((isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) => {
  const lockRef = (0, import_react54.useRef)(false);
  const lockTimeoutRef = (0, import_react54.useRef)(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(() => {
      lockRef.current = false;
    }, 50);
  }
  const scrollPingRef = (0, import_react54.useRef)({
    top: isScrollAtTop,
    bottom: isScrollAtBottom,
    left: isScrollAtLeft,
    right: isScrollAtRight
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  scrollPingRef.current.left = isScrollAtLeft;
  scrollPingRef.current.right = isScrollAtRight;
  return (isHorizontal, delta, smoothOffset = false) => {
    const originScroll = isHorizontal ? (
      // Pass origin wheel when on the left
      delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
      delta > 0 && scrollPingRef.current.right
    ) : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
    delta > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
});

// node_modules/@rc-component/virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
  const offsetRef = (0, import_react55.useRef)(0);
  const nextFrameRef = (0, import_react55.useRef)(null);
  const wheelValueRef = (0, import_react55.useRef)(null);
  const isMouseScrollRef = (0, import_react55.useRef)(false);
  const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  function onWheelY(e, deltaY) {
    raf_default.cancel(nextFrameRef.current);
    if (originScroll(false, deltaY)) return;
    const event = e;
    if (!event._virtualHandled) {
      event._virtualHandled = true;
    } else {
      return;
    }
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (!isFirefox_default) {
      event.preventDefault();
    }
    nextFrameRef.current = raf_default(() => {
      const patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple, false);
      offsetRef.current = 0;
    });
  }
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFirefox_default) {
      event.preventDefault();
    }
  }
  const wheelDirectionRef = (0, import_react55.useRef)(null);
  const wheelDirectionCleanRef = (0, import_react55.useRef)(null);
  function onWheel(event) {
    if (!inVirtual) return;
    raf_default.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = raf_default(() => {
      wheelDirectionRef.current = null;
    }, 2);
    const {
      deltaX,
      deltaY,
      shiftKey
    } = event;
    let mergedDeltaX = deltaX;
    let mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = "sx";
    }
    const absX = Math.abs(mergedDeltaX);
    const absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
    }
    if (wheelDirectionRef.current === "y") {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }
  function onFireFoxScroll(event) {
    if (!inVirtual) return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}

// node_modules/@rc-component/virtual-list/es/hooks/useGetSize.js
var React122 = __toESM(require_react());
function useGetSize(mergedData, getKey2, heights, itemHeight) {
  const [key2Index, bottomList] = React122.useMemo(() => [/* @__PURE__ */ new Map(), []], [mergedData, heights.id, itemHeight]);
  const getSize = (startKey, endKey = startKey) => {
    let startIndex = key2Index.get(startKey);
    let endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0) {
      const dataLen = mergedData.length;
      for (let i = bottomList.length; i < dataLen; i += 1) {
        const item = mergedData[i];
        const key = getKey2(item);
        key2Index.set(key, i);
        const cacheHeight = heights.get(key) ?? itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }
        if (startIndex !== void 0 && endIndex !== void 0) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  };
  return getSize;
}

// node_modules/@rc-component/virtual-list/es/hooks/useHeights.js
var React123 = __toESM(require_react());
var import_react56 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/CacheMap.js
var CacheMap = class {
  maps;
  // Used for cache key
  // `useMemo` no need to update if `id` not change
  id = 0;
  diffRecords = /* @__PURE__ */ new Map();
  constructor() {
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  set(key, value) {
    this.diffRecords.set(key, this.maps[key]);
    this.maps[key] = value;
    this.id += 1;
  }
  get(key) {
    return this.maps[key];
  }
  /**
   * CacheMap will record the key changed.
   * To help to know what's update in the next render.
   */
  resetRecord() {
    this.diffRecords.clear();
  }
  getRecord() {
    return this.diffRecords;
  }
};
var CacheMap_default = CacheMap;

// node_modules/@rc-component/virtual-list/es/hooks/useHeights.js
function parseNumber(value) {
  const num = parseFloat(value);
  return isNaN(num) ? 0 : num;
}
function useHeights(getKey2, onItemAdd, onItemRemove) {
  const [updatedMark, setUpdatedMark] = React123.useState(0);
  const instanceRef = (0, import_react56.useRef)(/* @__PURE__ */ new Map());
  const heightsRef = (0, import_react56.useRef)(new CacheMap_default());
  const promiseIdRef = (0, import_react56.useRef)(0);
  function cancelRaf() {
    promiseIdRef.current += 1;
  }
  function collectHeight(sync = false) {
    cancelRaf();
    const doCollect = () => {
      let changed = false;
      instanceRef.current.forEach((element, key) => {
        if (element && element.offsetParent) {
          const {
            offsetHeight
          } = element;
          const {
            marginTop,
            marginBottom
          } = getComputedStyle(element);
          const marginTopNum = parseNumber(marginTop);
          const marginBottomNum = parseNumber(marginBottom);
          const totalHeight = offsetHeight + marginTopNum + marginBottomNum;
          if (heightsRef.current.get(key) !== totalHeight) {
            heightsRef.current.set(key, totalHeight);
            changed = true;
          }
        }
      });
      if (changed) {
        setUpdatedMark((c) => c + 1);
      }
    };
    if (sync) {
      doCollect();
    } else {
      promiseIdRef.current += 1;
      const id = promiseIdRef.current;
      Promise.resolve().then(() => {
        if (id === promiseIdRef.current) {
          doCollect();
        }
      });
    }
  }
  function setInstanceRef(item, instance) {
    const key = getKey2(item);
    const origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd?.(item);
      } else {
        onItemRemove?.(item);
      }
    }
  }
  (0, import_react56.useEffect)(() => {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}

// node_modules/@rc-component/virtual-list/es/hooks/useMobileTouchMove.js
var import_react57 = __toESM(require_react());
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  const touchedRef = (0, import_react57.useRef)(false);
  const touchXRef = (0, import_react57.useRef)(0);
  const touchYRef = (0, import_react57.useRef)(0);
  const elementRef = (0, import_react57.useRef)(null);
  const intervalRef = (0, import_react57.useRef)(null);
  let cleanUpEvents;
  const onTouchMove = (e) => {
    if (touchedRef.current) {
      const currentX = Math.ceil(e.touches[0].pageX);
      const currentY = Math.ceil(e.touches[0].pageY);
      let offsetX = touchXRef.current - currentX;
      let offsetY = touchYRef.current - currentY;
      const isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
      if (isHorizontal) {
        touchXRef.current = currentX;
      } else {
        touchYRef.current = currentY;
      }
      const scrollHandled = callback(isHorizontal, isHorizontal ? offsetX : offsetY, false, e);
      if (scrollHandled) {
        e.preventDefault();
      }
      clearInterval(intervalRef.current);
      if (scrollHandled) {
        intervalRef.current = setInterval(() => {
          if (isHorizontal) {
            offsetX *= SMOOTH_PTG;
          } else {
            offsetY *= SMOOTH_PTG;
          }
          const offset = Math.floor(isHorizontal ? offsetX : offsetY);
          if (!callback(isHorizontal, offset, true) || Math.abs(offset) <= 0.1) {
            clearInterval(intervalRef.current);
          }
        }, 16);
      }
    }
  };
  const onTouchEnd = () => {
    touchedRef.current = false;
    cleanUpEvents();
  };
  const onTouchStart = (e) => {
    cleanUpEvents();
    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchXRef.current = Math.ceil(e.touches[0].pageX);
      touchYRef.current = Math.ceil(e.touches[0].pageY);
      elementRef.current = e.target;
      elementRef.current.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      elementRef.current.addEventListener("touchend", onTouchEnd, {
        passive: true
      });
    }
  };
  cleanUpEvents = () => {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect_default(() => {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart, {
        passive: true
      });
    }
    return () => {
      listRef.current?.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}

// node_modules/@rc-component/virtual-list/es/hooks/useScrollDrag.js
var React124 = __toESM(require_react());
function smoothScrollOffset(offset) {
  return Math.floor(offset ** 0.5);
}
function getPageXY(e, horizontal) {
  const obj = "touches" in e ? e.touches[0] : e;
  return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
  React124.useEffect(() => {
    const ele = componentRef.current;
    if (inVirtual && ele) {
      let mouseDownLock = false;
      let rafId;
      let offset;
      const stopScroll = () => {
        raf_default.cancel(rafId);
      };
      const continueScroll = () => {
        stopScroll();
        rafId = raf_default(() => {
          onScrollOffset(offset);
          continueScroll();
        });
      };
      const clearDragState = () => {
        mouseDownLock = false;
        stopScroll();
      };
      const onMouseDown = (e) => {
        if (e.target.draggable || e.button !== 0) {
          return;
        }
        const event = e;
        if (!event._virtualHandled) {
          event._virtualHandled = true;
          mouseDownLock = true;
        }
      };
      const onMouseMove = (e) => {
        if (mouseDownLock) {
          const mouseY = getPageXY(e, false);
          const {
            top,
            bottom
          } = ele.getBoundingClientRect();
          if (mouseY <= top) {
            const diff = top - mouseY;
            offset = -smoothScrollOffset(diff);
            continueScroll();
          } else if (mouseY >= bottom) {
            const diff = mouseY - bottom;
            offset = smoothScrollOffset(diff);
            continueScroll();
          } else {
            stopScroll();
          }
        }
      };
      ele.addEventListener("mousedown", onMouseDown);
      ele.ownerDocument.addEventListener("mouseup", clearDragState);
      ele.ownerDocument.addEventListener("mousemove", onMouseMove);
      ele.ownerDocument.addEventListener("dragend", clearDragState);
      return () => {
        ele.removeEventListener("mousedown", onMouseDown);
        ele.ownerDocument.removeEventListener("mouseup", clearDragState);
        ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
        ele.ownerDocument.removeEventListener("dragend", clearDragState);
        stopScroll();
      };
    }
  }, [inVirtual]);
}

// node_modules/@rc-component/virtual-list/es/hooks/useScrollTo.js
var React125 = __toESM(require_react());
var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  const scrollRef = React125.useRef();
  const [syncState, setSyncState] = React125.useState(null);
  useLayoutEffect_default(() => {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState((ori) => ({
          ...ori
        }));
        return;
      }
      collectHeight();
      const {
        targetAlign,
        originAlign,
        index,
        offset
      } = syncState;
      const height = containerRef.current.clientHeight;
      let needCollectHeight = false;
      let newTargetAlign = targetAlign;
      let targetTop = null;
      if (height) {
        const mergedAlign = targetAlign || originAlign;
        let stackTop = 0;
        let itemTop = 0;
        let itemBottom = 0;
        const maxLen = Math.min(data.length - 1, index);
        for (let i = 0; i <= maxLen; i += 1) {
          const key = getKey2(data[i]);
          itemTop = stackTop;
          const cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        let leftHeight = mergedAlign === "top" ? offset : height - offset;
        for (let i = maxLen; i >= 0; i -= 1) {
          const key = getKey2(data[i]);
          const cacheHeight = heights.get(key);
          if (cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset;
            break;
          default: {
            const {
              scrollTop
            } = containerRef.current;
            const scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState({
          ...syncState,
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        });
      }
    } else if (syncState?.times === MAX_TIMES) {
      warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
    }
  }, [syncState, containerRef.current]);
  return (arg) => {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    raf_default.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && typeof arg === "object") {
      let index;
      const {
        align
      } = arg;
      if ("index" in arg) {
        ({
          index
        } = arg);
      } else {
        index = data.findIndex((item) => getKey2(item) === arg.key);
      }
      const {
        offset = 0
      } = arg;
      setSyncState({
        times: 0,
        index,
        offset,
        originAlign: align
      });
    }
  };
}

// node_modules/@rc-component/virtual-list/es/ScrollBar.js
var React126 = __toESM(require_react());
var ScrollBar = React126.forwardRef((props, ref) => {
  const {
    prefixCls,
    rtl,
    scrollOffset,
    scrollRange,
    onStartMove,
    onStopMove,
    onScroll,
    horizontal,
    spinSize,
    containerSize,
    style: style2,
    thumbStyle: propsThumbStyle,
    showScrollBar
  } = props;
  const [dragging, setDragging] = React126.useState(false);
  const [pageXY, setPageXY] = React126.useState(null);
  const [startTop, setStartTop] = React126.useState(null);
  const isLTR = !rtl;
  const scrollbarRef = React126.useRef();
  const thumbRef = React126.useRef();
  const [visible, setVisible] = React126.useState(showScrollBar);
  const visibleTimeoutRef = React126.useRef();
  const delayHidden = () => {
    if (showScrollBar === true || showScrollBar === false) return;
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(() => {
      setVisible(false);
    }, 3e3);
  };
  const enableScrollRange = scrollRange - containerSize || 0;
  const enableOffsetRange = containerSize - spinSize || 0;
  const top = React126.useMemo(() => {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    const ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);
  const onContainerMouseDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
  };
  const stateRef = React126.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  const onThumbMouseDown = (e) => {
    setDragging(true);
    setPageXY(getPageXY(e, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e.stopPropagation();
    e.preventDefault();
  };
  React126.useEffect(() => {
    const onScrollbarTouchStart = (e) => {
      e.preventDefault();
    };
    const scrollbarEle = scrollbarRef.current;
    const thumbEle = thumbRef.current;
    scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
      passive: false
    });
    thumbEle.addEventListener("touchstart", onThumbMouseDown, {
      passive: false
    });
    return () => {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  const enableScrollRangeRef = React126.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  const enableOffsetRangeRef = React126.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  React126.useEffect(() => {
    if (dragging) {
      let moveRafId;
      const onMouseMove = (e) => {
        const {
          dragging: stateDragging,
          pageY: statePageY,
          startTop: stateStartTop
        } = stateRef.current;
        raf_default.cancel(moveRafId);
        const rect = scrollbarRef.current.getBoundingClientRect();
        const scale = containerSize / (horizontal ? rect.width : rect.height);
        if (stateDragging) {
          const offset = (getPageXY(e, horizontal) - statePageY) * scale;
          let newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset;
          } else {
            newTop += offset;
          }
          const tmpEnableScrollRange = enableScrollRangeRef.current;
          const tmpEnableOffsetRange = enableOffsetRangeRef.current;
          const ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          let newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = raf_default(() => {
            onScroll(newScrollTop, horizontal);
          });
        }
      };
      const onMouseUp = () => {
        setDragging(false);
        onStopMove();
      };
      window.addEventListener("mousemove", onMouseMove, {
        passive: true
      });
      window.addEventListener("touchmove", onMouseMove, {
        passive: true
      });
      window.addEventListener("mouseup", onMouseUp, {
        passive: true
      });
      window.addEventListener("touchend", onMouseUp, {
        passive: true
      });
      return () => {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
        window.removeEventListener("touchend", onMouseUp);
        raf_default.cancel(moveRafId);
      };
    }
  }, [dragging]);
  React126.useEffect(() => {
    delayHidden();
    return () => {
      clearTimeout(visibleTimeoutRef.current);
    };
  }, [scrollOffset]);
  React126.useImperativeHandle(ref, () => ({
    delayHidden
  }));
  const scrollbarPrefixCls = `${prefixCls}-scrollbar`;
  const containerStyle = {
    position: "absolute",
    visibility: visible ? null : "hidden"
  };
  const thumbStyle = {
    position: "absolute",
    borderRadius: 99,
    background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
    cursor: "pointer",
    userSelect: "none"
  };
  if (horizontal) {
    Object.assign(containerStyle, {
      height: 8,
      left: 0,
      right: 0,
      bottom: 0
    });
    Object.assign(thumbStyle, {
      height: "100%",
      width: spinSize,
      [isLTR ? "left" : "right"]: top
    });
  } else {
    Object.assign(containerStyle, {
      width: 8,
      top: 0,
      bottom: 0,
      [isLTR ? "right" : "left"]: 0
    });
    Object.assign(thumbStyle, {
      width: "100%",
      height: spinSize,
      top
    });
  }
  return React126.createElement("div", {
    ref: scrollbarRef,
    className: clsx(scrollbarPrefixCls, {
      [`${scrollbarPrefixCls}-horizontal`]: horizontal,
      [`${scrollbarPrefixCls}-vertical`]: !horizontal,
      [`${scrollbarPrefixCls}-visible`]: visible
    }),
    style: {
      ...containerStyle,
      ...style2
    },
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, React126.createElement("div", {
    ref: thumbRef,
    className: clsx(`${scrollbarPrefixCls}-thumb`, {
      [`${scrollbarPrefixCls}-thumb-moving`]: dragging
    }),
    style: {
      ...thumbStyle,
      ...propsThumbStyle
    },
    onMouseDown: onThumbMouseDown
  }));
});
if (true) {
  ScrollBar.displayName = "ScrollBar";
}
var ScrollBar_default = ScrollBar;

// node_modules/@rc-component/virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize(containerSize = 0, scrollRange = 0) {
  let baseSize = containerSize / scrollRange * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  return Math.floor(baseSize);
}

// node_modules/@rc-component/virtual-list/es/List.js
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  const {
    prefixCls = "rc-virtual-list",
    className,
    height,
    itemHeight,
    fullHeight = true,
    style: style2,
    data,
    children,
    itemKey: itemKey2,
    virtual,
    direction,
    scrollWidth,
    component: Component3 = "div",
    onScroll,
    onVirtualScroll,
    onVisibleChange,
    innerProps,
    extraRender,
    styles,
    showScrollBar = "optional",
    ...restProps
  } = props;
  const getKey2 = React127.useCallback((item) => {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return item?.[itemKey2];
  }, [itemKey2]);
  const [setInstanceRef, collectHeight, heights, heightUpdatedMark] = useHeights(getKey2, null, null);
  const useVirtual = !!(virtual !== false && height && itemHeight);
  const containerHeight = React127.useMemo(() => Object.values(heights.maps).reduce((total, curr) => total + curr, 0), [heights.id, heights.maps]);
  const inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  const isRTL = direction === "rtl";
  const mergedClassName = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: isRTL
  }, className);
  const mergedData = data || EMPTY_DATA;
  const componentRef = (0, import_react58.useRef)();
  const fillerInnerRef = (0, import_react58.useRef)();
  const containerRef = (0, import_react58.useRef)();
  const [offsetTop, setOffsetTop] = (0, import_react58.useState)(0);
  const [offsetLeft, setOffsetLeft] = (0, import_react58.useState)(0);
  const [scrollMoving, setScrollMoving] = (0, import_react58.useState)(false);
  const onScrollbarStartMove = () => {
    setScrollMoving(true);
  };
  const onScrollbarStopMove = () => {
    setScrollMoving(false);
  };
  const sharedConfig = {
    getKey: getKey2
  };
  function syncScrollTop(newTop) {
    setOffsetTop((origin) => {
      let value;
      if (typeof newTop === "function") {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      const alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  const rangeRef = (0, import_react58.useRef)({
    start: 0,
    end: mergedData.length
  });
  const diffItemRef = (0, import_react58.useRef)();
  const [diffItem] = useDiffItem(mergedData, getKey2);
  diffItemRef.current = diffItem;
  const {
    scrollHeight,
    start,
    end,
    offset: fillerOffset
  } = React127.useMemo(() => {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      return {
        scrollHeight: fillerInnerRef.current?.offsetHeight || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    let itemTop = 0;
    let startIndex;
    let startOffset;
    let endIndex;
    const dataLen = mergedData.length;
    for (let i = 0; i < dataLen; i += 1) {
      const item = mergedData[i];
      const key = getKey2(item);
      const cacheHeight = heights.get(key);
      const currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= offsetTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > offsetTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]);
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  React127.useLayoutEffect(() => {
    const changedRecord = heights.getRecord();
    if (changedRecord.size === 1) {
      const recordKey = Array.from(changedRecord.keys())[0];
      const prevCacheHeight = changedRecord.get(recordKey);
      const startItem = mergedData[start];
      if (startItem && prevCacheHeight === void 0) {
        const startIndexKey = getKey2(startItem);
        if (startIndexKey === recordKey) {
          const realStartHeight = heights.get(recordKey);
          const diffHeight = realStartHeight - itemHeight;
          syncScrollTop((ori) => {
            return ori + diffHeight;
          });
        }
      }
    }
    heights.resetRecord();
  }, [scrollHeight]);
  const [size, setSize] = React127.useState({
    width: 0,
    height
  });
  const onHolderResize = (sizeInfo) => {
    setSize({
      width: sizeInfo.offsetWidth,
      height: sizeInfo.offsetHeight
    });
  };
  const verticalScrollBarRef = (0, import_react58.useRef)();
  const horizontalScrollBarRef = (0, import_react58.useRef)();
  const horizontalScrollBarSpinSize = React127.useMemo(() => getSpinSize(size.width, scrollWidth), [size.width, scrollWidth]);
  const verticalScrollBarSpinSize = React127.useMemo(() => getSpinSize(size.height, scrollHeight), [size.height, scrollHeight]);
  const maxScrollHeight = scrollHeight - height;
  const maxScrollHeightRef = (0, import_react58.useRef)(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    let newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  const isScrollAtTop = offsetTop <= 0;
  const isScrollAtBottom = offsetTop >= maxScrollHeight;
  const isScrollAtLeft = offsetLeft <= 0;
  const isScrollAtRight = offsetLeft >= scrollWidth;
  const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  const getVirtualScrollInfo = () => ({
    x: isRTL ? -offsetLeft : offsetLeft,
    y: offsetTop
  });
  const lastVirtualScrollInfoRef = (0, import_react58.useRef)(getVirtualScrollInfo());
  const triggerScroll = useEvent_default((params) => {
    if (onVirtualScroll) {
      const nextInfo = {
        ...getVirtualScrollInfo(),
        ...params
      };
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    const newOffset = newScrollOffset;
    if (horizontal) {
      (0, import_react_dom3.flushSync)(() => {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }
  function onFallbackScroll(e) {
    const {
      scrollTop: newScrollTop
    } = e.currentTarget;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll?.(e);
    triggerScroll();
  }
  const keepInHorizontalRange = (nextOffsetLeft) => {
    let tmpOffsetLeft = nextOffsetLeft;
    const max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
    return tmpOffsetLeft;
  };
  const onWheelDelta = useEvent_default((offsetXY, fromHorizontal) => {
    if (fromHorizontal) {
      (0, import_react_dom3.flushSync)(() => {
        setOffsetLeft((left) => {
          const nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop((top) => {
        const newTop = top + offsetXY;
        return newTop;
      });
    }
  });
  const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta);
  useMobileTouchMove(useVirtual, componentRef, (isHorizontal, delta, smoothOffset, e) => {
    const event = e;
    if (originScroll(isHorizontal, delta, smoothOffset)) {
      return false;
    }
    if (!event || !event._virtualHandled) {
      if (event) {
        event._virtualHandled = true;
      }
      onRawWheel({
        preventDefault() {
        },
        deltaX: isHorizontal ? delta : 0,
        deltaY: isHorizontal ? 0 : delta
      });
      return true;
    }
    return false;
  });
  useScrollDrag(inVirtual, componentRef, (offset) => {
    syncScrollTop((top) => top + offset);
  });
  useLayoutEffect_default(() => {
    function onMozMousePixelScroll(e) {
      const scrollingUpAtTop = isScrollAtTop && e.detail < 0;
      const scrollingDownAtBottom = isScrollAtBottom && e.detail > 0;
      if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
        e.preventDefault();
      }
    }
    const componentEle = componentRef.current;
    componentEle.addEventListener("wheel", onRawWheel, {
      passive: false
    });
    componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
      passive: true
    });
    componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
      passive: false
    });
    return () => {
      componentEle.removeEventListener("wheel", onRawWheel);
      componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual, isScrollAtTop, isScrollAtBottom]);
  useLayoutEffect_default(() => {
    if (scrollWidth) {
      const newOffsetLeft = keepInHorizontalRange(offsetLeft);
      setOffsetLeft(newOffsetLeft);
      triggerScroll({
        x: newOffsetLeft
      });
    }
  }, [size.width, scrollWidth]);
  const delayHideScrollBar = () => {
    verticalScrollBarRef.current?.delayHidden();
    horizontalScrollBarRef.current?.delayHidden();
  };
  const scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, () => collectHeight(true), syncScrollTop, delayHideScrollBar);
  React127.useImperativeHandle(ref, () => ({
    nativeElement: containerRef.current,
    getScrollInfo: getVirtualScrollInfo,
    scrollTo: (config) => {
      function isPosScroll(arg) {
        return arg && typeof arg === "object" && ("left" in arg || "top" in arg);
      }
      if (isPosScroll(config)) {
        if (config.left !== void 0) {
          setOffsetLeft(keepInHorizontalRange(config.left));
        }
        scrollTo(config.top);
      } else {
        scrollTo(config);
      }
    }
  }));
  useLayoutEffect_default(() => {
    if (onVisibleChange) {
      const renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  const getSize = useGetSize(mergedData, getKey2, heights, itemHeight);
  const extraContent = extraRender?.({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize
  });
  const listChildren = useChildren(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
  let componentStyle = null;
  if (height) {
    componentStyle = {
      [fullHeight ? "height" : "maxHeight"]: height,
      ...ScrollStyle
    };
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollWidth) {
        componentStyle.overflowX = "hidden";
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  const containerProps = {};
  if (isRTL) {
    containerProps.dir = "rtl";
  }
  return React127.createElement("div", _extends10({
    ref: containerRef,
    style: {
      ...style2,
      position: "relative"
    },
    className: mergedClassName
  }, containerProps, restProps), React127.createElement(es_default4, {
    onResize: onHolderResize
  }, React127.createElement(Component3, {
    className: `${prefixCls}-holder`,
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, React127.createElement(Filler_default, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && React127.createElement(ScrollBar_default, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles?.verticalScrollBar,
    thumbStyle: styles?.verticalScrollBarThumb,
    showScrollBar
  }), inVirtual && scrollWidth > size.width && React127.createElement(ScrollBar_default, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles?.horizontalScrollBar,
    thumbStyle: styles?.horizontalScrollBarThumb,
    showScrollBar
  }));
}
var List2 = React127.forwardRef(RawList);
List2.displayName = "List";
var List_default2 = List2;

// node_modules/@rc-component/virtual-list/es/index.js
var es_default11 = List_default2;

// node_modules/@rc-component/select/es/OptionList.js
var React128 = __toESM(require_react());
var import_react59 = __toESM(require_react());

// node_modules/@rc-component/select/es/utils/platformUtil.js
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

// node_modules/@rc-component/select/es/OptionList.js
function _extends16() {
  _extends16 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends16.apply(this, arguments);
}
function isTitleType2(content) {
  return typeof content === "string" || typeof content === "number";
}
var OptionList = (_, ref) => {
  const {
    prefixCls,
    id,
    open,
    multiple,
    mode,
    searchValue,
    toggleOpen,
    notFoundContent,
    onPopupScroll,
    showScrollBar
  } = useBaseProps();
  const {
    maxCount,
    flattenOptions: flattenOptions2,
    onActiveValue,
    defaultActiveFirstOption,
    onSelect,
    menuItemSelectedIcon,
    rawValues,
    fieldNames,
    virtual,
    direction,
    listHeight,
    listItemHeight,
    optionRender,
    classNames: contextClassNames,
    styles: contextStyles
  } = React128.useContext(SelectContext_default);
  const itemPrefixCls = `${prefixCls}-item`;
  const memoFlattenOptions = useMemo(() => flattenOptions2, [open, flattenOptions2], (prev2, next2) => next2[0] && prev2[1] !== next2[1]);
  const listRef = React128.useRef(null);
  const overMaxCount = React128.useMemo(() => multiple && isValidCount(maxCount) && rawValues?.size >= maxCount, [multiple, maxCount, rawValues?.size]);
  const onListMouseDown = (event) => {
    event.preventDefault();
  };
  const scrollIntoView = (args) => {
    listRef.current?.scrollTo(typeof args === "number" ? {
      index: args
    } : args);
  };
  const isSelected = React128.useCallback((value) => {
    if (mode === "combobox") {
      return false;
    }
    return rawValues.has(value);
  }, [mode, [...rawValues].toString(), rawValues.size]);
  const getEnabledActiveIndex = (index, offset = 1) => {
    const len = memoFlattenOptions.length;
    for (let i = 0; i < len; i += 1) {
      const current = (index + i * offset + len) % len;
      const {
        group,
        data
      } = memoFlattenOptions[current] || {};
      if (!group && !data?.disabled && (isSelected(data.value) || !overMaxCount)) {
        return current;
      }
    }
    return -1;
  };
  const [activeIndex, setActiveIndex] = React128.useState(() => getEnabledActiveIndex(0));
  const setActive = (index, fromKeyboard = false) => {
    setActiveIndex(index);
    const info = {
      source: fromKeyboard ? "keyboard" : "mouse"
    };
    const flattenItem = memoFlattenOptions[index];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index, info);
  };
  (0, import_react59.useEffect)(() => {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  const isAriaSelected = React128.useCallback((value) => {
    if (mode === "combobox") {
      return String(value).toLowerCase() === searchValue.toLowerCase();
    }
    return rawValues.has(value);
  }, [mode, searchValue, [...rawValues].toString(), rawValues.size]);
  (0, import_react59.useEffect)(() => {
    let timeoutId;
    if (!multiple && open && rawValues.size === 1) {
      const value = Array.from(rawValues)[0];
      const index = memoFlattenOptions.findIndex(({
        data
      }) => searchValue ? String(data.value).startsWith(searchValue) : data.value === value);
      if (index !== -1) {
        setActive(index);
        timeoutId = setTimeout(() => {
          scrollIntoView(index);
        });
      }
    }
    if (open) {
      listRef.current?.scrollTo(void 0);
    }
    return () => clearTimeout(timeoutId);
  }, [open, searchValue]);
  const onSelectValue = (value) => {
    if (value !== void 0) {
      onSelect(value, {
        selected: !rawValues.has(value)
      });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  };
  React128.useImperativeHandle(ref, () => ({
    onKeyDown: (event) => {
      const {
        which,
        ctrlKey
      } = event;
      switch (which) {
        // >>> Arrow keys & ctrl + n/p on Mac
        case KeyCode_default.N:
        case KeyCode_default.P:
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset = 0;
          if (which === KeyCode_default.UP) {
            offset = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode_default.N) {
              offset = 1;
            } else if (which === KeyCode_default.P) {
              offset = -1;
            }
          }
          if (offset !== 0) {
            const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
            scrollIntoView(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        // >>> Select (Tab / Enter)
        case KeyCode_default.TAB:
        case KeyCode_default.ENTER: {
          const item = memoFlattenOptions[activeIndex];
          if (!item || item.data.disabled) {
            return onSelectValue(void 0);
          }
          if (!overMaxCount || rawValues.has(item.value)) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (open) {
            event.preventDefault();
          }
          break;
        }
        // >>> Close
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    },
    scrollTo: (index) => {
      scrollIntoView(index);
    }
  }));
  if (memoFlattenOptions.length === 0) {
    return React128.createElement("div", {
      role: "listbox",
      id: `${id}_list`,
      className: `${itemPrefixCls}-empty`,
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  const omitFieldNameList = Object.keys(fieldNames).map((key) => fieldNames[key]);
  const getLabel = (item) => item.label;
  function getItemAriaProps(item, index) {
    const {
      group
    } = item;
    return {
      role: group ? "presentation" : "option",
      id: `${id}_list_${index}`
    };
  }
  const renderItem = (index) => {
    const item = memoFlattenOptions[index];
    if (!item) {
      return null;
    }
    const itemData = item.data || {};
    const {
      value
    } = itemData;
    const {
      group
    } = item;
    const attrs = pickAttrs(itemData, true);
    const mergedLabel = getLabel(item);
    return item ? React128.createElement("div", _extends16({
      "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
    }, attrs, {
      key: index
    }, getItemAriaProps(item, index), {
      "aria-selected": isAriaSelected(value)
    }), value) : null;
  };
  const a11yProps = {
    role: "listbox",
    id: `${id}_list`
  };
  return React128.createElement(React128.Fragment, null, virtual && React128.createElement("div", _extends16({}, a11yProps, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), React128.createElement(es_default11, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual,
    direction,
    innerProps: virtual ? null : a11yProps,
    showScrollBar,
    className: contextClassNames?.popup?.list,
    style: contextStyles?.popup?.list
  }, (item, itemIndex) => {
    const {
      group,
      groupOption,
      data,
      label,
      value
    } = item;
    const {
      key
    } = data;
    if (group) {
      const groupTitle = data.title ?? (isTitleType2(label) ? label.toString() : void 0);
      return React128.createElement("div", {
        className: clsx(itemPrefixCls, `${itemPrefixCls}-group`, data.className),
        title: groupTitle
      }, label !== void 0 ? label : key);
    }
    const {
      disabled,
      title,
      children,
      style: style2,
      className,
      ...otherProps
    } = data;
    const passedProps = omit(otherProps, omitFieldNameList);
    const selected = isSelected(value);
    const mergedDisabled = disabled || !selected && overMaxCount;
    const optionPrefixCls = `${itemPrefixCls}-option`;
    const optionClassName = clsx(itemPrefixCls, optionPrefixCls, className, contextClassNames?.popup?.listItem, {
      [`${optionPrefixCls}-grouped`]: groupOption,
      [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
      [`${optionPrefixCls}-disabled`]: mergedDisabled,
      [`${optionPrefixCls}-selected`]: selected
    });
    const mergedLabel = getLabel(item);
    const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
    const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
    let optionTitle = isTitleType2(content) ? content.toString() : void 0;
    if (title !== void 0) {
      optionTitle = title;
    }
    return React128.createElement("div", _extends16({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
      "aria-selected": virtual ? void 0 : isAriaSelected(value),
      className: optionClassName,
      title: optionTitle,
      onMouseMove: () => {
        if (activeIndex === itemIndex || mergedDisabled) {
          return;
        }
        setActive(itemIndex);
      },
      onClick: () => {
        if (!mergedDisabled) {
          onSelectValue(value);
        }
      },
      style: {
        ...contextStyles?.popup?.listItem,
        ...style2
      }
    }), React128.createElement("div", {
      className: `${optionPrefixCls}-content`
    }, typeof optionRender === "function" ? optionRender(item, {
      index: itemIndex
    }) : content), React128.isValidElement(menuItemSelectedIcon) || selected, iconVisible && React128.createElement(TransBtn_default, {
      className: `${itemPrefixCls}-option-state`,
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        value,
        disabled: mergedDisabled,
        isSelected: selected
      }
    }, selected ? "" : null));
  }));
};
var RefOptionList = React128.forwardRef(OptionList);
if (true) {
  RefOptionList.displayName = "OptionList";
}
var OptionList_default = RefOptionList;

// node_modules/@rc-component/select/es/hooks/useCache.js
var React129 = __toESM(require_react());
var useCache_default = ((labeledValues, valueOptions) => {
  const cacheRef = React129.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  const filledLabeledValues = React129.useMemo(() => {
    const {
      values: prevValueCache,
      options: prevOptionCache
    } = cacheRef.current;
    const patchedValues = labeledValues.map((item) => {
      if (item.label === void 0) {
        return {
          ...item,
          label: prevValueCache.get(item.value)?.label
        };
      }
      return item;
    });
    const valueCache = /* @__PURE__ */ new Map();
    const optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach((item) => {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  const getOption = React129.useCallback((val) => valueOptions.get(val) || cacheRef.current.options.get(val), [valueOptions]);
  return [filledLabeledValues, getOption];
});

// node_modules/@rc-component/select/es/hooks/useFilterOptions.js
var React130 = __toESM(require_react());
function includes(test, search) {
  return toArray4(test).join("").toUpperCase().includes(search);
}
var useFilterOptions_default = ((options, fieldNames, searchValue, filterOption, optionFilterProp) => {
  return React130.useMemo(() => {
    if (!searchValue || filterOption === false) {
      return options;
    }
    const {
      options: fieldOptions,
      label: fieldLabel,
      value: fieldValue
    } = fieldNames;
    const filteredOptions = [];
    const customizeFilter = typeof filterOption === "function";
    const upperSearch = searchValue.toUpperCase();
    const filterFunc = customizeFilter ? filterOption : (_, option) => {
      if (optionFilterProp && optionFilterProp.length) {
        return optionFilterProp.some((prop) => includes(option[prop], upperSearch));
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
    options.forEach((item) => {
      if (item[fieldOptions]) {
        const matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValue, wrapOption(subItem)));
          if (subOptions.length) {
            filteredOptions.push({
              ...item,
              [fieldOptions]: subOptions
            });
          }
        }
        return;
      }
      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
});

// node_modules/@rc-component/select/es/hooks/useOptions.js
var React132 = __toESM(require_react());

// node_modules/@rc-component/select/es/utils/legacyUtil.js
var React131 = __toESM(require_react());
function convertNodeToOption(node2) {
  const {
    key,
    props: {
      children,
      value,
      ...restProps
    }
  } = node2;
  return {
    key,
    value: value !== void 0 ? value : key,
    children,
    ...restProps
  };
}
function convertChildrenToData(nodes, optionOnly = false) {
  return toArray(nodes).map((node2, index) => {
    if (!React131.isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      type: {
        isSelectOptGroup
      },
      key,
      props: {
        children,
        ...restProps
      }
    } = node2;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node2);
    }
    return {
      key: `__RC_SELECT_GRP__${key === null ? index : key}__`,
      label: key,
      ...restProps,
      options: convertChildrenToData(children)
    };
  }).filter((data) => data);
}

// node_modules/@rc-component/select/es/hooks/useOptions.js
var useOptions = (options, children, fieldNames, optionFilterProp, optionLabelProp) => {
  return React132.useMemo(() => {
    let mergedOptions = options;
    const childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    const valueOptions = /* @__PURE__ */ new Map();
    const labelOptions = /* @__PURE__ */ new Map();
    const setLabelOptions = (labelOptionsMap, option, key) => {
      if (key && typeof key === "string") {
        labelOptionsMap.set(option[key], option);
      }
    };
    const dig = (optionList, isChildren = false) => {
      for (let i = 0; i < optionList.length; i += 1) {
        const option = optionList[i];
        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          optionFilterProp.forEach((prop) => {
            setLabelOptions(labelOptions, option, prop);
          });
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    };
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
};
var useOptions_default = useOptions;

// node_modules/@rc-component/select/es/hooks/useRefFunc.js
var React133 = __toESM(require_react());
function useRefFunc(callback) {
  const funcRef = React133.useRef();
  funcRef.current = callback;
  const cacheFn = React133.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}

// node_modules/@rc-component/select/es/utils/warningPropsUtil.js
var React134 = __toESM(require_react());
function warningProps(props) {
  const {
    mode,
    options,
    children,
    backfill,
    allowClear,
    placeholder,
    getInputElement,
    showSearch,
    onSearch,
    defaultOpen,
    autoFocus,
    labelInValue,
    value,
    optionLabelProp
  } = props;
  const multiple = isMultiple(mode);
  const mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
  const mergedOptions = options || convertChildrenToData(children);
  warning_default(mode !== "tags" || mergedOptions.every((opt) => !opt.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag.");
  if (mode === "tags" || mode === "combobox") {
    const hasNumberValue = mergedOptions.some((item) => {
      if (item.options) {
        return item.options.some((opt) => typeof ("value" in opt ? opt.value : opt.key) === "number");
      }
      return typeof ("value" in item ? item.value : item.key) === "number";
    });
    warning_default(!hasNumberValue, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  warning_default(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.");
  warning_default(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
  warning_default(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode.");
  noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.");
  if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") {
    warning_default(false, "`onSearch` should work with `showSearch` instead of use alone.");
  }
  noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.");
  if (value !== void 0 && value !== null) {
    const values = toArray4(value);
    warning_default(!labelInValue || values.every((val) => typeof val === "object" && ("key" in val || "value" in val)), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`");
    warning_default(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (children) {
    let invalidateChildType = null;
    toArray(children).some((node2) => {
      if (!React134.isValidElement(node2) || !node2.type) {
        return false;
      }
      const {
        type: type5
      } = node2;
      if (type5.isSelectOption) {
        return false;
      }
      if (type5.isSelectOptGroup) {
        const allChildrenValid = toArray(node2.props.children).every((subNode) => {
          if (!React134.isValidElement(subNode) || !node2.type || subNode.type.isSelectOption) {
            return true;
          }
          invalidateChildType = subNode.type;
          return false;
        });
        if (allChildrenValid) {
          return false;
        }
        return true;
      }
      invalidateChildType = type5;
      return true;
    });
    if (invalidateChildType) {
      warning_default(false, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${invalidateChildType.displayName || invalidateChildType.name || invalidateChildType}\`.`);
    }
  }
}
function warningNullOptions(options, fieldNames) {
  if (options) {
    const recursiveOptions = (optionsList, inGroup = false) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames?.value] === null) {
          warning_default(false, "`value` in Select options should not be `null`.");
          return true;
        }
        if (!inGroup && Array.isArray(option[fieldNames?.options]) && recursiveOptions(option[fieldNames?.options], true)) {
          break;
        }
      }
    };
    recursiveOptions(options);
  }
}
var warningPropsUtil_default = warningProps;

// node_modules/@rc-component/select/es/hooks/useSearchConfig.js
var React135 = __toESM(require_react());
function useSearchConfig(showSearch, props, mode) {
  const {
    filterOption,
    searchValue,
    optionFilterProp,
    filterSort,
    onSearch,
    autoClearSearchValue
  } = props;
  return React135.useMemo(() => {
    const isObject2 = typeof showSearch === "object";
    const searchConfig = {
      filterOption,
      searchValue,
      optionFilterProp,
      filterSort,
      onSearch,
      autoClearSearchValue,
      ...isObject2 ? showSearch : {}
    };
    return [isObject2 || mode === "combobox" || mode === "tags" || mode === "multiple" && showSearch === void 0 ? true : showSearch, searchConfig];
  }, [mode, showSearch, filterOption, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue]);
}

// node_modules/@rc-component/select/es/Select.js
function _extends17() {
  _extends17 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends17.apply(this, arguments);
}
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value) {
  return !value || typeof value !== "object";
}
var Select = React136.forwardRef((props, ref) => {
  const {
    id,
    mode,
    prefixCls = "rc-select",
    backfill,
    fieldNames,
    // Search
    showSearch,
    searchValue: legacySearchValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterOption: legacyFilterOption,
    optionFilterProp: legacyOptionFilterProp,
    filterSort: legacyFilterSort,
    // Select
    onSelect,
    onDeselect,
    onActive,
    popupMatchSelectWidth = true,
    optionLabelProp,
    options,
    optionRender,
    children,
    defaultActiveFirstOption,
    menuItemSelectedIcon,
    virtual,
    direction,
    listHeight = 200,
    listItemHeight = 20,
    labelRender,
    // Value
    value,
    defaultValue,
    labelInValue,
    onChange,
    maxCount,
    classNames,
    styles,
    ...restProps
  } = props;
  const searchProps = {
    searchValue: legacySearchValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterOption: legacyFilterOption,
    optionFilterProp: legacyOptionFilterProp,
    filterSort: legacyFilterSort
  };
  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps, mode);
  const {
    filterOption,
    searchValue,
    optionFilterProp,
    filterSort,
    onSearch,
    autoClearSearchValue = true
  } = searchConfig;
  const normalizedOptionFilterProp = React136.useMemo(() => {
    if (!optionFilterProp) return [];
    return Array.isArray(optionFilterProp) ? optionFilterProp : [optionFilterProp];
  }, [optionFilterProp]);
  const mergedId = useId_default(id);
  const multiple = isMultiple(mode);
  const childrenAsData = !!(!options && children);
  const mergedFilterOption = React136.useMemo(() => {
    if (filterOption === void 0 && mode === "combobox") {
      return false;
    }
    return filterOption;
  }, [filterOption, mode]);
  const mergedFieldNames = React136.useMemo(
    () => fillFieldNames(fieldNames, childrenAsData),
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(fieldNames),
      childrenAsData
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const parsedOptions = useOptions_default(options, children, mergedFieldNames, normalizedOptionFilterProp, optionLabelProp);
  const {
    valueOptions,
    labelOptions,
    options: mergedOptions
  } = parsedOptions;
  const convert2LabelValues = React136.useCallback((draftValues) => {
    const valueList = toArray4(draftValues);
    return valueList.map((val) => {
      let rawValue;
      let rawLabel;
      let rawDisabled;
      let rawTitle;
      if (isRawValue(val)) {
        rawValue = val;
      } else {
        rawLabel = val.label;
        rawValue = val.value;
      }
      const option = valueOptions.get(rawValue);
      if (option) {
        if (rawLabel === void 0) rawLabel = option?.[optionLabelProp || mergedFieldNames.label];
        rawDisabled = option?.disabled;
        rawTitle = option?.title;
        if (!optionLabelProp) {
          const optionLabel = option?.[mergedFieldNames.label];
          if (optionLabel !== void 0 && !React136.isValidElement(optionLabel) && !React136.isValidElement(rawLabel) && optionLabel !== rawLabel) {
            warning_default(false, "`label` of `value` is not same as `label` in Select options.");
          }
        }
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawValue,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]);
  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
  const rawLabeledValues = React136.useMemo(() => {
    const newInternalValue = multiple && internalValue === null ? [] : internalValue;
    const values = convert2LabelValues(newInternalValue);
    if (mode === "combobox" && isComboNoValue(values[0]?.value)) {
      return [];
    }
    return values;
  }, [internalValue, convert2LabelValues, mode, multiple]);
  const [mergedValues, getMixedOption] = useCache_default(rawLabeledValues, valueOptions);
  const displayValues = React136.useMemo(() => {
    if (!mode && mergedValues.length === 1) {
      const firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
        return [];
      }
    }
    return mergedValues.map((item) => ({
      ...item,
      label: (typeof labelRender === "function" ? labelRender(item) : item.label) ?? item.value
    }));
  }, [mode, mergedValues, labelRender]);
  const rawValues = React136.useMemo(() => new Set(mergedValues.map((val) => val.value)), [mergedValues]);
  React136.useEffect(() => {
    if (mode === "combobox") {
      const strValue = mergedValues[0]?.value;
      setSearchValue(hasValue(strValue) ? String(strValue) : "");
    }
  }, [mergedValues]);
  const createTagOption = useRefFunc((val, label) => {
    const mergedLabel = label ?? val;
    return {
      [mergedFieldNames.value]: val,
      [mergedFieldNames.label]: mergedLabel
    };
  });
  const filledTagOptions = React136.useMemo(() => {
    if (mode !== "tags") {
      return mergedOptions;
    }
    const cloneOptions = [...mergedOptions];
    const existOptions = (val) => valueOptions.has(val);
    [...mergedValues].sort((a, b) => a.value < b.value ? -1 : 1).forEach((item) => {
      const val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  const filteredOptions = useFilterOptions_default(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, normalizedOptionFilterProp);
  const filledSearchOptions = React136.useMemo(() => {
    const hasItemMatchingSearch = (item) => {
      if (normalizedOptionFilterProp.length) {
        return normalizedOptionFilterProp.some((prop) => item?.[prop] === mergedSearchValue);
      }
      return item?.value === mergedSearchValue;
    };
    if (mode !== "tags" || !mergedSearchValue || filteredOptions.some((item) => hasItemMatchingSearch(item))) {
      return filteredOptions;
    }
    if (filteredOptions.some((item) => item[mergedFieldNames.value] === mergedSearchValue)) {
      return filteredOptions;
    }
    return [createTagOption(mergedSearchValue), ...filteredOptions];
  }, [createTagOption, normalizedOptionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
  const sorter = (inputOptions) => {
    const sortedOptions = [...inputOptions].sort((a, b) => filterSort(a, b, {
      searchValue: mergedSearchValue
    }));
    return sortedOptions.map((item) => {
      if (Array.isArray(item.options)) {
        return {
          ...item,
          options: item.options.length > 0 ? sorter(item.options) : item.options
        };
      }
      return item;
    });
  };
  const orderedFilteredOptions = React136.useMemo(() => {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return sorter(filledSearchOptions);
  }, [filledSearchOptions, filterSort, mergedSearchValue]);
  const displayOptions = React136.useMemo(() => flattenOptions(orderedFilteredOptions, {
    fieldNames: mergedFieldNames,
    childrenAsData
  }), [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
  const triggerChange = (values) => {
    const labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);
    if (onChange && // Trigger event only when value changed
    (labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index) => mergedValues[index]?.value !== newVal?.value))) {
      const returnValues = labelInValue ? labeledValues.map(({
        label: l,
        value: v
      }) => ({
        label: l,
        value: v
      })) : labeledValues.map((v) => v.value);
      const returnOptions = labeledValues.map((v) => injectPropsWithOption(getMixedOption(v.value)));
      onChange(
        // Value
        multiple ? returnValues : returnValues[0],
        // Option
        multiple ? returnOptions : returnOptions[0]
      );
    }
  };
  const [activeValue, setActiveValue] = React136.useState(null);
  const [accessibilityIndex, setAccessibilityIndex] = React136.useState(0);
  const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
  const activeEventRef = React136.useRef();
  const onActiveValue = React136.useCallback((active, index, {
    source = "keyboard"
  } = {}) => {
    setAccessibilityIndex(index);
    if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
      setActiveValue(String(active));
    }
    const promise = Promise.resolve().then(() => {
      if (activeEventRef.current === promise) {
        onActive?.(active);
      }
    });
    activeEventRef.current = promise;
  }, [backfill, mode, onActive]);
  const triggerSelect = (val, selected, type5) => {
    const getSelectEnt = () => {
      const option = getMixedOption(val);
      return [labelInValue ? {
        label: option?.[mergedFieldNames.label],
        value: val
      } : val, injectPropsWithOption(option)];
    };
    if (selected && onSelect) {
      const [wrappedValue, option] = getSelectEnt();
      onSelect(wrappedValue, option);
    } else if (!selected && onDeselect && type5 !== "clear") {
      const [wrappedValue, option] = getSelectEnt();
      onDeselect(wrappedValue, option);
    }
  };
  const onInternalSelect = useRefFunc((val, info) => {
    let cloneValues;
    const mergedSelect = multiple ? info.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [...mergedValues, val] : [val];
    } else {
      cloneValues = mergedValues.filter((v) => v.value !== val);
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect);
    if (mode === "combobox") {
      setActiveValue("");
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue("");
      setActiveValue("");
    }
  });
  const onDisplayValuesChange = (nextValues, info) => {
    triggerChange(nextValues);
    const {
      type: type5,
      values
    } = info;
    if (type5 === "remove" || type5 === "clear") {
      values.forEach((item) => {
        triggerSelect(item.value, false, type5);
      });
    }
  };
  const onInternalSearch = (searchText, info) => {
    setSearchValue(searchText);
    setActiveValue(null);
    if (info.source === "submit") {
      const formatted = (searchText || "").trim();
      if (formatted) {
        const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, formatted]));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue("");
      }
      return;
    }
    if (info.source !== "blur") {
      if (mode === "combobox") {
        triggerChange(searchText);
      }
      onSearch?.(searchText);
    }
  };
  const onInternalSearchSplit = (words) => {
    let patchValues = words;
    if (mode !== "tags") {
      patchValues = words.map((word) => {
        const opt = labelOptions.get(word);
        return opt?.value;
      }).filter((val) => val !== void 0);
    }
    const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, ...patchValues]));
    triggerChange(newRawValues);
    newRawValues.forEach((newRawValue) => {
      triggerSelect(newRawValue, true);
    });
  };
  const selectContext = React136.useMemo(() => {
    const realVirtual = virtual !== false && popupMatchSelectWidth !== false;
    return {
      ...parsedOptions,
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      direction,
      listHeight,
      listItemHeight,
      childrenAsData,
      maxCount,
      optionRender,
      classNames,
      styles
    };
  }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, popupMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender, classNames, styles]);
  if (true) {
    warningPropsUtil_default(props);
    warningNullOptions(mergedOptions, mergedFieldNames);
  }
  return React136.createElement(SelectContext_default.Provider, {
    value: selectContext
  }, React136.createElement(BaseSelect_default, _extends17({}, restProps, {
    // >>> MISC
    id: mergedId,
    prefixCls,
    ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    classNames,
    styles,
    displayValues,
    onDisplayValuesChange,
    maxCount,
    direction,
    showSearch: mergedShowSearch,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    autoClearSearchValue,
    onSearchSplit: onInternalSearchSplit,
    popupMatchSelectWidth,
    OptionList: OptionList_default,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
  })));
});
if (true) {
  Select.displayName = "Select";
}
var TypedSelect = Select;
TypedSelect.Option = Option_default;
TypedSelect.OptGroup = OptGroup_default;
var Select_default = TypedSelect;

// node_modules/@rc-component/select/es/index.js
var es_default12 = Select_default;

// node_modules/antd/es/config-provider/defaultRenderEmpty.js
var import_react61 = __toESM(require_react());

// node_modules/antd/es/empty/index.js
var React139 = __toESM(require_react());

// node_modules/antd/es/empty/empty.js
var React137 = __toESM(require_react());
var Empty = () => {
  const [, token2] = useToken();
  const [locale5] = useLocale_default("Empty");
  const bgColor = new FastColor(token2.colorBgBase);
  const themeStyle = bgColor.toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return React137.createElement("svg", {
    style: themeStyle,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, React137.createElement("title", null, locale5?.description || "Empty"), React137.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, React137.createElement("g", {
    transform: "translate(24 31.67)"
  }, React137.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), React137.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), React137.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), React137.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), React137.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), React137.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), React137.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, React137.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), React137.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
if (true) {
  Empty.displayName = "EmptyImage";
}
var empty_default = Empty;

// node_modules/antd/es/empty/simple.js
var React138 = __toESM(require_react());
var import_react60 = __toESM(require_react());
var Simple = () => {
  const [, token2] = useToken();
  const [locale5] = useLocale_default("Empty");
  const {
    colorFill,
    colorFillTertiary,
    colorFillQuaternary,
    colorBgContainer
  } = token2;
  const {
    borderColor,
    shadowColor,
    contentColor
  } = (0, import_react60.useMemo)(() => ({
    borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
    shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
    contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
  }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
  return React138.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, React138.createElement("title", null, locale5?.description || "Empty"), React138.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, React138.createElement("ellipse", {
    fill: shadowColor,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), React138.createElement("g", {
    fillRule: "nonzero",
    stroke: borderColor
  }, React138.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), React138.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: contentColor
  }))));
};
if (true) {
  Simple.displayName = "SimpleImage";
}
var simple_default = Simple;

// node_modules/antd/es/empty/style/index.js
var genSharedEmptyStyle = (token2) => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      //  &-image  hashId
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${componentCls}-description`]: {
        color: token2.colorTextDescription
      },
      //  &-footer  hashId
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDescription,
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDescription,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
};
var style_default5 = genStyleHooks("Empty", (token2) => {
  const {
    componentCls,
    controlHeightLG,
    calc
  } = token2;
  const emptyToken = merge2(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
  });
  return genSharedEmptyStyle(emptyToken);
});

// node_modules/antd/es/empty/index.js
var defaultEmptyImg = React139.createElement(empty_default, null);
var simpleEmptyImg = React139.createElement(simple_default, null);
var Empty2 = (props) => {
  const {
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    image,
    description,
    children,
    imageStyle,
    style: style2,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    image: contextImage
  } = useComponentConfig("empty");
  const prefixCls = getPrefixCls("empty", customizePrefixCls);
  const [hashId, cssVarCls] = style_default5(prefixCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const [locale5] = useLocale_default("Empty");
  const des = typeof description !== "undefined" ? description : locale5?.description;
  const alt = typeof des === "string" ? des : "empty";
  const mergedImage = image ?? contextImage ?? defaultEmptyImg;
  let imageNode = null;
  if (typeof mergedImage === "string") {
    imageNode = React139.createElement("img", {
      draggable: false,
      alt,
      src: mergedImage
    });
  } else {
    imageNode = mergedImage;
  }
  if (true) {
    const warning5 = devUseWarning("Empty");
    [["imageStyle", "styles.image"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return React139.createElement("div", {
    className: clsx(hashId, cssVarCls, prefixCls, contextClassName, {
      [`${prefixCls}-normal`]: mergedImage === simpleEmptyImg,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, mergedClassNames.root),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    ...restProps
  }, React139.createElement("div", {
    className: clsx(`${prefixCls}-image`, mergedClassNames.image),
    style: {
      ...imageStyle,
      ...mergedStyles.image
    }
  }, imageNode), des && React139.createElement("div", {
    className: clsx(`${prefixCls}-description`, mergedClassNames.description),
    style: mergedStyles.description
  }, des), children && React139.createElement("div", {
    className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
    style: mergedStyles.footer
  }, children));
};
Empty2.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty2.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
if (true) {
  Empty2.displayName = "Empty";
}
var empty_default2 = Empty2;

// node_modules/antd/es/config-provider/defaultRenderEmpty.js
var DefaultRenderEmpty = (props) => {
  const {
    componentName
  } = props;
  const {
    getPrefixCls
  } = (0, import_react61.useContext)(ConfigContext);
  const prefix2 = getPrefixCls("empty");
  switch (componentName) {
    case "Table":
    case "List":
      return import_react61.default.createElement(empty_default2, {
        image: empty_default2.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return import_react61.default.createElement(empty_default2, {
        image: empty_default2.PRESENTED_IMAGE_SIMPLE,
        className: `${prefix2}-small`
      });
    /**
     * This type of component should satisfy the nullish coalescing operator(??) on the left-hand side.
     * to let the component itself implement the logic.
     * For example `Table.filter`.
     */
    case "Table.filter":
      return null;
    default:
      return import_react61.default.createElement(empty_default2, null);
  }
};
var defaultRenderEmpty_default = DefaultRenderEmpty;

// node_modules/antd/es/form/hooks/useVariants.js
var React141 = __toESM(require_react());
var useVariant = (component, variant, legacyBordered) => {
  const {
    variant: configVariant,
    [component]: componentConfig
  } = React141.useContext(ConfigContext);
  const ctxVariant = React141.useContext(VariantContext);
  const configComponentVariant = componentConfig?.variant;
  let mergedVariant;
  if (typeof variant !== "undefined") {
    mergedVariant = variant;
  } else if (legacyBordered === false) {
    mergedVariant = "borderless";
  } else {
    mergedVariant = ctxVariant ?? configComponentVariant ?? configVariant ?? "outlined";
  }
  const enableVariantCls = Variants.includes(mergedVariant);
  return [mergedVariant, enableVariantCls];
};
var useVariants_default = useVariant;

// node_modules/antd/es/select/mergedBuiltinPlacements.js
var getBuiltInPlacements2 = (popupOverflow) => {
  const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
  const sharedConfig = {
    overflow: {
      adjustX: true,
      adjustY: true,
      shiftY: true
    },
    htmlRegion,
    dynamicInset: true
  };
  return {
    bottomLeft: {
      ...sharedConfig,
      points: ["tl", "bl"],
      offset: [0, 4]
    },
    bottomRight: {
      ...sharedConfig,
      points: ["tr", "br"],
      offset: [0, 4]
    },
    topLeft: {
      ...sharedConfig,
      points: ["bl", "tl"],
      offset: [0, -4]
    },
    topRight: {
      ...sharedConfig,
      points: ["br", "tr"],
      offset: [0, -4]
    }
  };
};
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
  return buildInPlacements || getBuiltInPlacements2(popupOverflow);
}
var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

// node_modules/antd/es/style/compact-item.js
function compactItemBorder(token2, parentCls, options, prefixCls) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n) => `&:${n} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    [`&-item:not(${prefixCls}-status-success)`]: {
      zIndex: 2
    },
    "&-item": {
      [hoverEffects]: {
        zIndex: 3
      },
      ...focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 3
        }
      } : {},
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle(token2, options = {
  focus: true
}) {
  const {
    componentCls
  } = token2;
  const {
    componentCls: customizePrefixCls
  } = options;
  const mergedComponentCls = customizePrefixCls || componentCls;
  const compactCls = `${mergedComponentCls}-compact`;
  return {
    [compactCls]: {
      ...compactItemBorder(token2, compactCls, options, mergedComponentCls),
      ...compactItemBorderRadius(mergedComponentCls, compactCls, options)
    }
  };
}

// node_modules/antd/es/select/style/dropdown.js
var genItemStyle = (token2) => {
  const {
    optionHeight,
    optionFontSize,
    optionLineHeight,
    optionPadding
  } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: optionHeight,
    padding: optionPadding,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: optionFontSize,
    lineHeight: optionLineHeight,
    boxSizing: "border-box"
  };
};
var genSingleStyle = (token2) => {
  const {
    antCls,
    componentCls
  } = token2;
  const selectItemCls = `${componentCls}-item`;
  const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
  const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
  const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
  const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
  const selectedItemCls = `${selectItemCls}-option-selected`;
  return [
    {
      [`${componentCls}-dropdown`]: {
        // ========================== Popup ==========================
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
          animationName: slideUpIn
        },
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownIn
        },
        [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
          animationName: slideUpOut
        },
        [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        [selectItemCls]: {
          ...genItemStyle(token2),
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": {
              flex: "auto",
              ...textEllipsis
            },
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.optionActiveBg
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.optionSelectedColor,
              fontWeight: token2.optionSelectedFontWeight,
              backgroundColor: token2.optionSelectedBg,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": {
            ...genItemStyle(token2),
            color: token2.colorTextDisabled
          }
        },
        // https://github.com/ant-design/ant-design/pull/46646
        [`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
          borderEndStartRadius: 0,
          borderEndEndRadius: 0,
          [`& + ${selectedItemCls}`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        },
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
var dropdown_default = genSingleStyle;

// node_modules/antd/es/select/style/select-input-customize.js
var genSelectInputCustomizeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-customize`]: {
      border: 0,
      padding: 0,
      fontSize: "inherit",
      lineHeight: "inherit",
      [`${componentCls}-placeholder`]: {
        display: "none"
      },
      [`${componentCls}-content`]: {
        margin: 0,
        padding: 0,
        "&-value": {
          display: "none"
        }
      }
    }
  };
};
var select_input_customize_default = genSelectInputCustomizeStyle;

// node_modules/antd/es/select/style/select-input-multiple.js
var FIXED_INPUT_MIN_WIDTH = 4;
var genSelectInputMultipleStyle = (token2) => {
  const {
    componentCls,
    calc,
    iconCls,
    paddingXS,
    paddingXXS,
    INTERNAL_FIXED_ITEM_MARGIN,
    lineWidth,
    colorIcon,
    colorIconHover,
    inputPaddingHorizontalBase
  } = token2;
  return {
    "&-multiple": {
      "--select-multi-item-background": token2.multipleItemBg,
      "--select-multi-item-border-color": "transparent",
      "--select-multi-item-border-radius": token2.borderRadiusSM,
      "--select-multi-item-height": token2.multipleItemHeight,
      "--select-multi-padding-base": `calc((var(--select-height) - var(--select-multi-item-height)) / 2)`,
      "--select-multi-padding-vertical": `calc(var(--select-multi-padding-base) - ${INTERNAL_FIXED_ITEM_MARGIN} - ${lineWidth})`,
      "--select-multi-item-padding-horizontal": `calc(${inputPaddingHorizontalBase} - var(--select-multi-padding-vertical) - ${lineWidth} * 2)`,
      // ========================================================
      // ==                        Base                        ==
      // ========================================================
      // ========================= Root =========================
      paddingBlock: `var(--select-multi-padding-vertical)`,
      paddingInlineStart: `calc(var(--select-multi-padding-base) - ${lineWidth})`,
      // ======================== Prefix ========================
      [`${componentCls}-prefix`]: {
        marginInlineStart: "var(--select-multi-item-padding-horizontal)"
      },
      [`${componentCls}-prefix + ${componentCls}-content`]: {
        [`${componentCls}-placeholder`]: {
          insetInlineStart: 0
        },
        [`${componentCls}-content-item${componentCls}-content-item-suffix`]: {
          marginInlineStart: 0
        }
      },
      // ===================== Placeholder ======================
      [`${componentCls}-placeholder`]: {
        position: "absolute",
        lineHeight: "var(--select-line-height)",
        insetInlineStart: "var(--select-multi-item-padding-horizontal)",
        width: "calc(100% - var(--select-multi-item-padding-horizontal))",
        top: "50%",
        transform: "translateY(-50%)"
      },
      // ======================= Content ========================
      [`${componentCls}-content`]: {
        flexWrap: "wrap",
        alignItems: "center",
        lineHeight: 1,
        "&-item-prefix": {
          height: "var(--select-font-size)"
        },
        "&-item": {
          lineHeight: 1,
          maxWidth: `calc(100% - ${FIXED_INPUT_MIN_WIDTH}px)`
        },
        [`${componentCls}-content-item-prefix + ${componentCls}-content-item-suffix,
          ${componentCls}-content-item-suffix:first-child`]: {
          marginInlineStart: "var(--select-multi-item-padding-horizontal)"
        },
        [`${componentCls}-selection-item`]: {
          lineHeight: `calc(var(--select-multi-item-height) - ${lineWidth} * 2)`,
          border: `${lineWidth} solid var(--select-multi-item-border-color)`,
          display: "flex",
          marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
          marginInlineEnd: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
          background: `var(--select-multi-item-background)`,
          borderRadius: `var(--select-multi-item-border-radius)`,
          paddingInlineStart: paddingXS,
          paddingInlineEnd: paddingXXS,
          transition: ["height", "line-height", "padding"].map((key) => `${key} ${token2.motionDurationSlow}`).join(","),
          // >>> Content
          "&-content": {
            ...textEllipsis,
            marginInlineEnd: paddingXXS
          },
          // >>> Remove
          "&-remove": {
            ...resetIcon(),
            display: "inline-flex",
            alignItems: "center",
            color: colorIcon,
            fontWeight: "bold",
            fontSize: 10,
            lineHeight: "inherit",
            cursor: "pointer",
            [`> ${iconCls}`]: {
              verticalAlign: "-0.2em"
            },
            "&:hover": {
              color: colorIconHover
            }
          }
        },
        [`${componentCls}-input`]: {
          lineHeight: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).add("var(--select-multi-item-height)").equal(),
          width: "calc(var(--select-input-width, 0) * 1px)",
          minWidth: FIXED_INPUT_MIN_WIDTH,
          maxWidth: "100%",
          transition: `line-height ${token2.motionDurationSlow}`
        }
      },
      // ========================================================
      // ==                        Size                        ==
      // ========================================================
      [`&${componentCls}-sm`]: {
        "--select-multi-item-height": token2.multipleItemHeightSM,
        "--select-multi-item-border-radius": token2.borderRadiusXS
      },
      [`&${componentCls}-lg`]: {
        "--select-multi-item-height": token2.multipleItemHeightLG,
        "--select-multi-item-border-radius": token2.borderRadius
      },
      // ========================================================
      // ==                      Variants                      ==
      // ========================================================
      [`&${componentCls}-filled`]: {
        "--select-multi-item-border-color": token2.colorSplit,
        "--select-multi-item-background": token2.colorBgContainer,
        [`&${componentCls}-disabled`]: {
          "--select-multi-item-border-color": "transparent"
        }
      }
    }
  };
};
var select_input_multiple_default = genSelectInputMultipleStyle;

// node_modules/antd/es/select/style/select-input.js
var genSelectInputVariableStyle = (token2, colors) => {
  const {
    componentCls
  } = token2;
  const {
    border,
    borderHover,
    borderActive,
    borderOutline
  } = colors;
  const baseBG = colors.background || token2.selectorBg || token2.colorBgContainer;
  return {
    "--select-border-color": border,
    "--select-background": baseBG,
    "--select-color": colors.color || token2.colorText,
    [`&:not(${componentCls}-disabled)`]: {
      "&:hover": {
        "--select-border-color": borderHover,
        "--select-background": colors.backgroundHover || baseBG
      },
      [`&${componentCls}-focused`]: {
        "--select-border-color": borderActive,
        "--select-background": colors.backgroundActive || baseBG,
        boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${borderOutline}`
      }
    },
    [`&${componentCls}-disabled`]: {
      "--select-border-color": colors.borderDisabled || colors.border,
      "--select-background": colors.backgroundDisabled || colors.background
    }
  };
};
var genSelectInputVariantStyle = (token2, variant, colors, errorColors = {}, warningColors = {}, patchStyle) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-${variant}`]: [genSelectInputVariableStyle(token2, colors), {
      [`&${componentCls}-status-error`]: genSelectInputVariableStyle(token2, {
        ...colors,
        color: errorColors.color || token2.colorError,
        ...errorColors
      }),
      [`&${componentCls}-status-warning`]: genSelectInputVariableStyle(token2, {
        ...colors,
        color: warningColors.color || token2.colorWarning,
        ...warningColors
      })
    }, patchStyle]
  };
};
var genSelectInputStyle = (token2) => {
  const {
    componentCls,
    calc,
    fontHeight,
    controlHeight,
    iconCls
  } = token2;
  return {
    [componentCls]: [
      {
        // Border
        "--select-border-radius": token2.borderRadius,
        "--select-border-color": "#000",
        "--select-border-size": token2.lineWidth,
        // Background
        "--select-background": token2.colorBgContainer,
        // Font
        "--select-font-size": token2.fontSize,
        "--select-line-height": token2.lineHeight,
        "--select-font-height": fontHeight,
        "--select-color": token2.colorText,
        // Size
        "--select-height": controlHeight,
        "--select-padding-horizontal": calc(token2.paddingSM).sub(token2.lineWidth).equal(),
        "--select-padding-vertical": "calc((var(--select-height) - var(--select-font-height)) / 2 - var(--select-border-size))",
        // ==========================================================
        // ==                         Base                         ==
        // ==========================================================
        ...resetComponent(token2, true),
        display: "inline-flex",
        // gap: calc(token.paddingXXS).mul(1.5).equal(),
        flexWrap: "nowrap",
        position: "relative",
        transition: `all ${token2.motionDurationSlow}`,
        alignItems: "flex-start",
        outline: 0,
        cursor: "pointer",
        // Border
        borderRadius: "var(--select-border-radius)",
        borderWidth: "var(--select-border-size)",
        borderStyle: token2.lineType,
        borderColor: "var(--select-border-color)",
        // Background
        background: "var(--select-background)",
        // Font
        fontSize: "var(--select-font-size)",
        lineHeight: "var(--select-line-height)",
        color: "var(--select-color)",
        // Padding
        paddingInline: "var(--select-padding-horizontal)",
        paddingBlock: "var(--select-padding-vertical)",
        // ========================= Prefix =========================
        [`${componentCls}-prefix`]: {
          flex: "none",
          lineHeight: 1
        },
        // ====================== Placeholder =======================
        [`${componentCls}-placeholder`]: {
          ...textEllipsis,
          color: token2.colorTextPlaceholder,
          pointerEvents: "none",
          zIndex: 1
        },
        // ======================== Content =========================
        [`${componentCls}-content`]: {
          flex: "auto",
          minWidth: 0,
          position: "relative",
          display: "flex",
          marginInlineEnd: calc(token2.paddingXXS).mul(1.5).equal(),
          "&:before": {
            content: '"\\a0"',
            width: 0,
            overflow: "hidden"
          },
          // >>> Value
          "&-value": {
            ...textEllipsis,
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
            zIndex: 1
          },
          // >>> Input: should only take effect for not customize mode
          // input element with readOnly use cursor pointer
          "input[readonly]": {
            cursor: "inherit",
            caretColor: "transparent"
          }
        },
        [`&-open ${componentCls}-content-value`]: {
          color: token2.colorTextPlaceholder
        },
        // ========================= Suffix =========================
        [`${componentCls}-suffix`]: {
          flex: "none",
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          "> :not(:last-child)": {
            marginInlineEnd: token2.marginXS
          }
        },
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          alignSelf: "center",
          [iconCls]: {
            verticalAlign: "top"
          }
        },
        // ==========================================================
        // ==                       Disabled                       ==
        // ==========================================================
        "&-disabled": {
          background: token2.colorBgContainerDisabled,
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        // ==========================================================
        // ==                         Size                         ==
        // ==========================================================
        "&-sm": {
          "--select-height": token2.controlHeightSM,
          "--select-padding-horizontal": calc(token2.paddingXS).sub(token2.lineWidth).equal(),
          "--select-border-radius": token2.borderRadiusSM
        },
        "&-lg": {
          "--select-height": token2.controlHeightLG,
          "--select-font-size": token2.fontSizeLG,
          "--select-line-height": token2.lineHeightLG,
          "--select-font-height": token2.fontHeightLG,
          "--select-border-radius": token2.borderRadiusLG
        }
      },
      // ============================================================
      // ==                         Input                          ==
      // ============================================================
      {
        [`&:not(${componentCls}-customize)`]: {
          [`${componentCls}-input`]: {
            outline: "none",
            background: "transparent",
            appearance: "none",
            border: 0,
            margin: 0,
            padding: 0,
            color: "inherit",
            "&::-webkit-search-cancel-button": {
              display: "none",
              appearance: "none"
            }
          }
        }
      },
      // ============================================================
      // ==                         Single                         ==
      // ============================================================
      {
        [`&-single:not(${componentCls}-customize)`]: {
          [`${componentCls}-input`]: {
            position: "absolute",
            insetInline: 0,
            insetBlock: "calc(var(--select-padding-vertical) * -1)",
            lineHeight: "calc(var(--select-font-height) + var(--select-padding-vertical) * 2)"
          },
          // Content center align
          [`${componentCls}-content`]: {
            alignSelf: "center"
          }
        }
      },
      // ============================================================
      // ==                        Multiple                        ==
      // ============================================================
      select_input_multiple_default(token2),
      // ========================= Variant ==========================
      // >>> Outlined
      genSelectInputVariantStyle(
        token2,
        "outlined",
        {
          border: token2.colorBorder,
          borderHover: token2.hoverBorderColor,
          borderActive: token2.activeBorderColor,
          borderOutline: token2.activeOutlineColor,
          borderDisabled: token2.colorBorderDisabled
        },
        // Error
        {
          border: token2.colorError,
          borderHover: token2.colorErrorHover,
          borderActive: token2.colorError,
          borderOutline: token2.colorErrorOutline
        },
        // Warning
        {
          border: token2.colorWarning,
          borderHover: token2.colorWarningHover,
          borderActive: token2.colorWarning,
          borderOutline: token2.colorWarningOutline
        }
      ),
      // >>> Filled
      genSelectInputVariantStyle(
        token2,
        "filled",
        {
          border: "transparent",
          borderHover: "transparent",
          borderActive: token2.activeBorderColor,
          borderOutline: "transparent",
          borderDisabled: token2.colorBorderDisabled,
          background: token2.colorFillTertiary,
          backgroundHover: token2.colorFillSecondary,
          backgroundActive: token2.colorBgContainer
        },
        // Error
        {
          background: token2.colorErrorBg,
          backgroundHover: token2.colorErrorBgHover,
          borderActive: token2.colorError
        },
        // Warning
        {
          background: token2.colorWarningBg,
          backgroundHover: token2.colorWarningBgHover,
          borderActive: token2.colorWarning
        }
      ),
      // >>> Borderless
      genSelectInputVariantStyle(token2, "borderless", {
        border: "transparent",
        borderHover: "transparent",
        borderActive: "transparent",
        borderOutline: "transparent",
        background: "transparent"
      }),
      // Underlined
      genSelectInputVariantStyle(
        token2,
        "underlined",
        {
          border: token2.colorBorder,
          borderHover: token2.hoverBorderColor,
          borderActive: token2.activeBorderColor,
          borderOutline: "transparent"
        },
        // Error
        {
          border: token2.colorError,
          borderHover: token2.colorErrorHover,
          borderActive: token2.colorError
        },
        // Warning
        {
          border: token2.colorWarning,
          borderHover: token2.colorWarningHover,
          borderActive: token2.colorWarning
        },
        {
          borderRadius: 0,
          borderTopColor: "transparent",
          borderRightColor: "transparent",
          borderLeftColor: "transparent"
        }
      ),
      // ============================================================
      // ==                         Custom                         ==
      // ============================================================
      select_input_customize_default(token2)
    ]
  };
};
var select_input_default = genSelectInputStyle;

// node_modules/antd/es/select/style/token.js
var prepareComponentToken5 = (token2) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    controlPaddingHorizontal,
    zIndexPopupBase,
    colorText,
    fontWeightStrong,
    controlItemBgActive,
    controlItemBgHover,
    colorBgContainer,
    colorFillSecondary,
    colorBgContainerDisabled,
    colorTextDisabled,
    colorPrimaryHover,
    colorPrimary,
    controlOutline
  } = token2;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
  const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  return {
    INTERNAL_FIXED_ITEM_MARGIN,
    zIndexPopup: zIndexPopupBase + 50,
    optionSelectedColor: colorText,
    optionSelectedFontWeight: fontWeightStrong,
    optionSelectedBg: controlItemBgActive,
    optionActiveBg: controlItemBgHover,
    optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    optionFontSize: fontSize,
    optionLineHeight: lineHeight,
    optionHeight: controlHeight,
    selectorBg: colorBgContainer,
    clearBg: colorBgContainer,
    singleItemHeightLG: controlHeightLG,
    multipleItemBg: colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
    hoverBorderColor: colorPrimaryHover,
    activeBorderColor: colorPrimary,
    activeOutlineColor: controlOutline,
    selectAffixPadding: paddingXXS
  };
};

// node_modules/antd/es/select/style/index.js
var genBaseStyle2 = (token2) => {
  const {
    antCls,
    componentCls,
    inputPaddingHorizontalBase
  } = token2;
  const hoverShowClearStyle = {
    [`${componentCls}-clear`]: {
      opacity: 1,
      background: token2.colorBgBase,
      borderRadius: "50%"
    }
  };
  return {
    [componentCls]: {
      ...resetComponent(token2),
      // ======================== Selection ========================
      [`${componentCls}-selection-item`]: {
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none",
        ...textEllipsis,
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${antCls}-typography`]: {
          display: "inline"
        }
      },
      // ========================= Prefix ==========================
      [`${componentCls}-prefix`]: {
        flex: "none",
        marginInlineEnd: token2.selectAffixPadding
      },
      // ========================== Clear ==========================
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        // https://github.com/ant-design/ant-design/issues/54205
        // Force GPU compositing on Safari to prevent flickering on opacity/transform transitions
        transform: "translateZ(0)",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorIcon
        }
      },
      "@media(hover:none)": hoverShowClearStyle,
      "&:hover": hoverShowClearStyle
    },
    // ========================= Feedback ==========================
    [`${componentCls}-status`]: {
      "&-error, &-warning, &-success, &-validating": {
        [`&${componentCls}-has-feedback`]: {
          [`${componentCls}-clear`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
          }
        }
      }
    }
  };
};
var genSelectStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [componentCls]: {
        // ==================== In Form ====================
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    genBaseStyle2(token2),
    // Dropdown
    dropdown_default(token2),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      focusElCls: `${componentCls}-focused`
    })
  ];
};
var style_default6 = genStyleHooks("Select", (token2, {
  rootPrefixCls
}) => {
  const selectToken = merge2(token2, {
    rootPrefixCls,
    inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(token2.lineWidth).equal(),
    multipleSelectItemHeight: token2.multipleItemHeight,
    selectHeight: token2.controlHeight
  });
  return [genSelectStyle(selectToken), select_input_default(selectToken)];
}, prepareComponentToken5, {
  unitless: {
    optionLineHeight: true,
    optionSelectedFontWeight: true
  }
});

// node_modules/antd/es/select/useIcons.js
var React142 = __toESM(require_react());
function useIcons({
  suffixIcon,
  clearIcon,
  menuItemSelectedIcon,
  removeIcon,
  loading,
  multiple,
  hasFeedback,
  showSuffixIcon,
  feedbackIcon,
  showArrow,
  componentName
}) {
  if (true) {
    const warning5 = devUseWarning(componentName);
    warning5.deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  }
  const mergedClearIcon = clearIcon ?? React142.createElement(CloseCircleFilled_default, null);
  const getSuffixIconNode = (arrowIcon) => {
    if (suffixIcon === null && !hasFeedback && !showArrow) {
      return null;
    }
    return React142.createElement(React142.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
  };
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(React142.createElement(LoadingOutlined_default, {
      spin: true
    }));
  } else {
    mergedSuffixIcon = ({
      open,
      showSearch
    }) => {
      if (open && showSearch) {
        return getSuffixIconNode(React142.createElement(SearchOutlined_default, null));
      }
      return getSuffixIconNode(React142.createElement(DownOutlined_default, null));
    };
  }
  let mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = React142.createElement(CheckOutlined_default, null);
  } else {
    mergedItemIcon = null;
  }
  let mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = React142.createElement(CloseOutlined_default, null);
  }
  return {
    // TODO: remove as when all the deps bumped
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}

// node_modules/antd/es/select/usePopupRender.js
var import_react62 = __toESM(require_react());
function usePopupRender(renderFn) {
  return import_react62.default.useMemo(() => {
    if (!renderFn) {
      return void 0;
    }
    return (...args) => import_react62.default.createElement(ContextIsolator_default, {
      space: true
    }, renderFn.apply(void 0, args));
  }, [renderFn]);
}
var usePopupRender_default = usePopupRender;

// node_modules/antd/es/select/useShowArrow.js
function useShowArrow(suffixIcon, showArrow) {
  return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}

// node_modules/antd/es/select/index.js
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered,
    className,
    rootClassName,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    listHeight = 256,
    placement,
    listItemHeight: customListItemHeight,
    size: customizeSize,
    disabled: customDisabled,
    notFoundContent,
    status: customStatus,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    direction: propDirection,
    style: style2,
    allowClear,
    variant: customizeVariant,
    popupStyle,
    dropdownStyle,
    transitionName,
    tagRender,
    maxCount,
    prefix: prefix2,
    dropdownRender,
    /**
     * @since 5.25.0
     */
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    styles,
    classNames,
    ...rest
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction: contextDirection,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow
  } = React144.useContext(ConfigContext);
  const {
    showSearch,
    style: contextStyle,
    styles: contextStyles,
    className: contextClassName,
    classNames: contextClassNames
  } = useComponentConfig("select");
  const [, token2] = useToken();
  const listItemHeight = customListItemHeight ?? token2?.controlHeight;
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const direction = propDirection ?? contextDirection;
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default("select", customizeVariant, bordered);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default6(prefixCls, rootCls);
  const mode = React144.useMemo(() => {
    const {
      mode: m
    } = props;
    if (m === "combobox") {
      return void 0;
    }
    if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m;
  }, [props.mode]);
  const isMultiple2 = mode === "multiple" || mode === "tags";
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React144.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = renderEmpty?.("Select") || React144.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }
  const {
    suffixIcon,
    itemIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...rest,
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    prefixCls,
    componentName: "Select"
  });
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React144.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedProps = {
    ...props,
    variant,
    status: mergedStatus,
    disabled: mergedDisabled,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupClassName = clsx(mergedClassNames.popup?.root, popupClassName, dropdownClassName, {
    [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
  }, rootClassName, cssVarCls, rootCls, hashId);
  const mergedPopupStyle = {
    ...mergedStyles.popup?.root,
    ...popupStyle ?? dropdownStyle
  };
  const mergedClassName = clsx({
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${variant}`]: enableVariantCls,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
  const memoPlacement = React144.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  if (true) {
    const warning5 = devUseWarning("Select");
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning5.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning5(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
    true ? warning5(!(typeof maxCount !== "undefined" && !isMultiple2), "usage", "`maxCount` only works with mode `multiple` or `tags`") : void 0;
  }
  const [zIndex] = useZIndex("SelectLike", mergedStyles.popup?.root?.zIndex ?? mergedPopupStyle?.zIndex);
  return React144.createElement(es_default12, {
    ref,
    virtual,
    classNames: mergedClassNames,
    styles: mergedStyles,
    showSearch,
    ...selectProps,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    popupMatchSelectWidth: mergedPopupMatchSelectWidth,
    transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: memoPlacement,
    direction,
    prefix: prefix2,
    suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    allowClear: mergedAllowClear,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    popupClassName: mergedPopupClassName,
    disabled: mergedDisabled,
    popupStyle: {
      ...mergedStyles.popup?.root,
      ...mergedPopupStyle,
      zIndex
    },
    maxCount: isMultiple2 ? maxCount : void 0,
    tagRender: isMultiple2 ? tagRender : void 0,
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange
  });
};
if (true) {
  InternalSelect.displayName = "Select";
}
var Select2 = React144.forwardRef(InternalSelect);
var PurePanel3 = PurePanel_default(Select2, "popupAlign");
Select2.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select2.Option = Option_default;
Select2.OptGroup = OptGroup_default;
Select2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel3;
if (true) {
  Select2.displayName = "Select";
}
var select_default = Select2;

// node_modules/antd/es/color-picker/interface.js
var FORMAT_HEX = "hex";
var FORMAT_RGB = "rgb";
var FORMAT_HSB = "hsb";

// node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var import_react68 = __toESM(require_react());

// node_modules/antd/es/color-picker/components/ColorSteppers.js
var import_react67 = __toESM(require_react());

// node_modules/antd/es/input-number/index.js
var React148 = __toESM(require_react());

// node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
  return typeof BigInt === "function";
}

// node_modules/@rc-component/mini-decimal/es/numberUtil.js
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}

// node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js
var BigIntDecimal = (function() {
  function BigIntDecimal2(value) {
    _classCallCheck(this, BigIntDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "negative", void 0);
    _defineProperty(this, "integer", void 0);
    _defineProperty(this, "decimal", void 0);
    _defineProperty(this, "decimalLen", void 0);
    _defineProperty(this, "empty", void 0);
    _defineProperty(this, "nan", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-" || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  _createClass(BigIntDecimal2, [{
    key: "getMark",
    value: function getMark() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }
    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone = new BigIntDecimal2(this.toString());
      clone.negative = !clone.negative;
      return clone;
    }
  }, {
    key: "cal",
    value: function cal(offset, calculator, calDecimalLen) {
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
      var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
      var nextDecimalLength = calDecimalLen(maxDecimalLength);
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value);
      }
      var offset = new BigIntDecimal2(value);
      if (offset.isInvalidate()) {
        return this;
      }
      return this.cal(offset, function(num1, num2) {
        return num1 + num2;
      }, function(len) {
        return len;
      });
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = new BigIntDecimal2(value);
      if (this.isInvalidate() || target.isInvalidate()) {
        return new BigIntDecimal2(NaN);
      }
      return this.cal(target, function(num1, num2) {
        return num1 * num2;
      }, function(len) {
        return len * 2;
      });
    }
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal2;
})();

// node_modules/@rc-component/mini-decimal/es/NumberDecimal.js
var NumberDecimal = (function() {
  function NumberDecimal2(value) {
    _classCallCheck(this, NumberDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "number", void 0);
    _defineProperty(this, "empty", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  _createClass(NumberDecimal2, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal2(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = Number(value);
      if (this.isInvalidate() || Number.isNaN(target)) {
        return new NumberDecimal2(NaN);
      }
      var number4 = this.number * target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal2;
})();

// node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}

// node_modules/@rc-component/mini-decimal/es/index.js
var es_default13 = getMiniDecimal;

// node_modules/@rc-component/util/es/proxyObject.js
function proxyObject(obj, extendProps) {
  if (typeof Proxy !== "undefined" && obj) {
    return new Proxy(obj, {
      get(target, prop) {
        if (extendProps[prop]) {
          return extendProps[prop];
        }
        const originProp = target[prop];
        return typeof originProp === "function" ? originProp.bind(target) : originProp;
      }
    });
  }
  return obj;
}

// node_modules/@rc-component/input-number/es/InputNumber.js
var React146 = __toESM(require_react());

// node_modules/@rc-component/input-number/es/hooks/useCursor.js
var import_react63 = __toESM(require_react());
function useCursor(input, focused) {
  const selectionRef = (0, import_react63.useRef)(null);
  function recordCursor() {
    try {
      const {
        selectionStart: start,
        selectionEnd: end,
        value
      } = input;
      const beforeTxt = value.substring(0, start);
      const afterTxt = value.substring(end);
      selectionRef.current = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e) {
    }
  }
  function restoreCursor() {
    if (input && selectionRef.current && focused) {
      try {
        const {
          value
        } = input;
        const {
          beforeTxt,
          afterTxt,
          start
        } = selectionRef.current;
        let startPos = value.length;
        if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.current.afterTxt.length;
        } else {
          const beforeLastChar = beforeTxt[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e) {
        warning_default(false, `Something warning of cursor restore. Please fire issue about this: ${e.message}`);
      }
    }
  }
  return [recordCursor, restoreCursor];
}

// node_modules/@rc-component/input-number/es/StepHandler.js
var React145 = __toESM(require_react());
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
function StepHandler({
  prefixCls,
  action,
  children,
  disabled,
  className,
  style: style2,
  onStep
}) {
  const isUpAction = action === "up";
  const stepTimeoutRef = React145.useRef();
  const frameIds = React145.useRef([]);
  const onStopStep = () => {
    clearTimeout(stepTimeoutRef.current);
  };
  const onStepMouseDown = (e) => {
    e.preventDefault();
    onStopStep();
    onStep(isUpAction, "handler");
    function loopStep() {
      onStep(isUpAction, "handler");
      stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }
    stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  };
  React145.useEffect(() => () => {
    onStopStep();
    frameIds.current.forEach((id) => {
      raf_default.cancel(id);
    });
  }, []);
  const actionClassName = `${prefixCls}-action`;
  const mergedClassName = clsx(actionClassName, `${actionClassName}-${action}`, {
    [`${actionClassName}-${action}-disabled`]: disabled
  }, className);
  const safeOnStopStep = () => frameIds.current.push(raf_default(onStopStep));
  return React145.createElement("span", {
    unselectable: "on",
    role: "button",
    onMouseUp: safeOnStopStep,
    onMouseLeave: safeOnStopStep,
    onMouseDown: (e) => {
      onStepMouseDown(e);
    },
    "aria-label": isUpAction ? "Increase Value" : "Decrease Value",
    "aria-disabled": disabled,
    className: mergedClassName,
    style: style2
  }, children || React145.createElement("span", {
    unselectable: "on",
    className: `${prefixCls}-action-${action}-inner`
  }));
}

// node_modules/@rc-component/input-number/es/utils/numberUtil.js
function getDecupleSteps(step) {
  const stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
  const hasPoint = stepStr.includes(".");
  if (!hasPoint) {
    return step + "0";
  }
  return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}

// node_modules/@rc-component/util/es/Dom/focus.js
var import_react64 = __toESM(require_react());
function focusable(node2, includePositive = false) {
  if (isVisible_default(node2)) {
    const nodeName = node2.nodeName.toLowerCase();
    const isFocusableElement = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
      node2.isContentEditable || // Anchor with href element
      nodeName === "a" && !!node2.getAttribute("href")
    );
    const tabIndexAttr = node2.getAttribute("tabindex");
    const tabIndexNum = Number(tabIndexAttr);
    let tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node2, includePositive = false) {
  const res = [...node2.querySelectorAll("*")].filter((child) => {
    return focusable(child, includePositive);
  });
  if (focusable(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
function triggerFocus(element, option) {
  if (!element) return;
  element.focus(option);
  const {
    cursor
  } = option || {};
  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}

// node_modules/@rc-component/input-number/es/hooks/useFrame.js
var import_react65 = __toESM(require_react());
var useFrame_default = (() => {
  const idRef = (0, import_react65.useRef)(0);
  const cleanUp = () => {
    raf_default.cancel(idRef.current);
  };
  (0, import_react65.useEffect)(() => cleanUp, []);
  return (callback) => {
    cleanUp();
    idRef.current = raf_default(() => {
      callback();
    });
  };
});

// node_modules/@rc-component/input-number/es/InputNumber.js
function _extends18() {
  _extends18 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends18.apply(this, arguments);
}
var getDecimalValue = (stringMode, decimalValue) => {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = (value) => {
  const decimal = es_default13(value);
  return decimal.isInvalidate() ? null : decimal;
};
var InputNumber = React146.forwardRef((props, ref) => {
  const {
    mode = "input",
    prefixCls = "rc-input-number",
    className,
    style: style2,
    classNames,
    styles,
    min,
    max,
    step = 1,
    defaultValue,
    value,
    disabled,
    readOnly,
    upHandler,
    downHandler,
    keyboard,
    changeOnWheel = false,
    controls = true,
    prefix: prefix2,
    suffix,
    stringMode,
    parser,
    formatter,
    precision,
    decimalSeparator,
    onChange,
    onInput,
    onPressEnter,
    onStep,
    // Mouse Events
    onMouseDown,
    onClick,
    onMouseUp,
    onMouseLeave,
    onMouseMove,
    onMouseEnter,
    onMouseOut,
    changeOnBlur = true,
    ...restProps
  } = props;
  const [focus, setFocus] = React146.useState(false);
  const userTypingRef = React146.useRef(false);
  const compositionRef = React146.useRef(false);
  const shiftKeyRef = React146.useRef(false);
  const rootRef = React146.useRef(null);
  const inputRef = React146.useRef(null);
  React146.useImperativeHandle(ref, () => proxyObject(inputRef.current, {
    focus: (option) => {
      triggerFocus(inputRef.current, option);
    },
    blur: () => {
      inputRef.current?.blur();
    },
    nativeElement: rootRef.current
  }));
  const [decimalValue, setDecimalValue] = React146.useState(() => es_default13(value ?? defaultValue));
  function setUncontrolledDecimalValue(newDecimal) {
    if (value === void 0) {
      setDecimalValue(newDecimal);
    }
  }
  const getPrecision = React146.useCallback((numStr, userTyping) => {
    if (userTyping) {
      return void 0;
    }
    if (precision >= 0) {
      return precision;
    }
    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
  }, [precision, step]);
  const mergedParser = React146.useCallback((num) => {
    const numStr = String(num);
    if (parser) {
      return parser(numStr);
    }
    let parsedStr = numStr;
    if (decimalSeparator) {
      parsedStr = parsedStr.replace(decimalSeparator, ".");
    }
    return parsedStr.replace(/[^\w.-]+/g, "");
  }, [parser, decimalSeparator]);
  const inputValueRef = React146.useRef("");
  const mergedFormatter = React146.useCallback((number4, userTyping) => {
    if (formatter) {
      return formatter(number4, {
        userTyping,
        input: String(inputValueRef.current)
      });
    }
    let str = typeof number4 === "number" ? num2str(number4) : number4;
    if (!userTyping) {
      const mergedPrecision = getPrecision(str, userTyping);
      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
        const separatorStr = decimalSeparator || ".";
        str = toFixed(str, separatorStr, mergedPrecision);
      }
    }
    return str;
  }, [formatter, getPrecision, decimalSeparator]);
  const [inputValue, setInternalInputValue] = React146.useState(() => {
    const initValue = defaultValue ?? value;
    if (decimalValue.isInvalidate() && ["string", "number"].includes(typeof initValue)) {
      return Number.isNaN(initValue) ? "" : initValue;
    }
    return mergedFormatter(decimalValue.toString(), false);
  });
  inputValueRef.current = inputValue;
  function setInputValue(newValue, userTyping) {
    setInternalInputValue(mergedFormatter(
      // Invalidate number is sometime passed by external control, we should let it go
      // Otherwise is controlled by internal interactive logic which check by userTyping
      // You can ref 'show limited value when input is not focused' test for more info.
      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
      userTyping
    ));
  }
  const maxDecimal = React146.useMemo(() => getDecimalIfValidate(max), [max, precision]);
  const minDecimal = React146.useMemo(() => getDecimalIfValidate(min), [min, precision]);
  const upDisabled = React146.useMemo(() => {
    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return maxDecimal.lessEquals(decimalValue);
  }, [maxDecimal, decimalValue]);
  const downDisabled = React146.useMemo(() => {
    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return decimalValue.lessEquals(minDecimal);
  }, [minDecimal, decimalValue]);
  const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);
  const getRangeValue = (target) => {
    if (maxDecimal && !target.lessEquals(maxDecimal)) {
      return maxDecimal;
    }
    if (minDecimal && !minDecimal.lessEquals(target)) {
      return minDecimal;
    }
    return null;
  };
  const isInRange = (target) => !getRangeValue(target);
  const triggerValueUpdate = (newValue, userTyping) => {
    let updateValue = newValue;
    let isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();
    if (!updateValue.isEmpty() && !userTyping) {
      updateValue = getRangeValue(updateValue) || updateValue;
      isRangeValidate = true;
    }
    if (!readOnly && !disabled && isRangeValidate) {
      const numStr = updateValue.toString();
      const mergedPrecision = getPrecision(numStr, userTyping);
      if (mergedPrecision >= 0) {
        updateValue = es_default13(toFixed(numStr, ".", mergedPrecision));
        if (!isInRange(updateValue)) {
          updateValue = es_default13(toFixed(numStr, ".", mergedPrecision, true));
        }
      }
      if (!updateValue.equals(decimalValue)) {
        setUncontrolledDecimalValue(updateValue);
        onChange?.(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
        if (value === void 0) {
          setInputValue(updateValue, userTyping);
        }
      }
      return updateValue;
    }
    return decimalValue;
  };
  const onNextPromise = useFrame_default();
  const collectInputValue = (inputStr) => {
    recordCursor();
    inputValueRef.current = inputStr;
    setInternalInputValue(inputStr);
    if (!compositionRef.current) {
      const finalValue = mergedParser(inputStr);
      const finalDecimal = es_default13(finalValue);
      if (!finalDecimal.isNaN()) {
        triggerValueUpdate(finalDecimal, true);
      }
    }
    onInput?.(inputStr);
    onNextPromise(() => {
      let nextInputStr = inputStr;
      if (!parser) {
        nextInputStr = inputStr.replace(//g, ".");
      }
      if (nextInputStr !== inputStr) {
        collectInputValue(nextInputStr);
      }
    });
  };
  const onCompositionStart = () => {
    compositionRef.current = true;
  };
  const onCompositionEnd = () => {
    compositionRef.current = false;
    collectInputValue(inputRef.current.value);
  };
  const onInternalInput = (e) => {
    collectInputValue(e.target.value);
  };
  const onInternalStep = useEvent_default((up, emitter) => {
    if (up && upDisabled || !up && downDisabled) {
      return;
    }
    userTypingRef.current = false;
    let stepDecimal = es_default13(shiftKeyRef.current ? getDecupleSteps(step) : step);
    if (!up) {
      stepDecimal = stepDecimal.negate();
    }
    const target = (decimalValue || es_default13(0)).add(stepDecimal.toString());
    const updatedValue = triggerValueUpdate(target, false);
    onStep?.(getDecimalValue(stringMode, updatedValue), {
      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
      type: up ? "up" : "down",
      emitter
    });
    inputRef.current?.focus();
  });
  const flushInputValue = (userTyping) => {
    const parsedValue = es_default13(mergedParser(inputValue));
    let formatValue;
    if (!parsedValue.isNaN()) {
      formatValue = triggerValueUpdate(parsedValue, userTyping);
    } else {
      formatValue = triggerValueUpdate(decimalValue, userTyping);
    }
    if (value !== void 0) {
      setInputValue(decimalValue, false);
    } else if (!formatValue.isNaN()) {
      setInputValue(formatValue, false);
    }
  };
  const onBeforeInput = () => {
    userTypingRef.current = true;
  };
  const onKeyDown = (event) => {
    const {
      key,
      shiftKey
    } = event;
    userTypingRef.current = true;
    shiftKeyRef.current = shiftKey;
    if (key === "Enter") {
      if (!compositionRef.current) {
        userTypingRef.current = false;
      }
      flushInputValue(false);
      onPressEnter?.(event);
    }
    if (keyboard === false) {
      return;
    }
    if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
      onInternalStep(key === "Up" || key === "ArrowUp", "keyboard");
      event.preventDefault();
    }
  };
  const onKeyUp = () => {
    userTypingRef.current = false;
    shiftKeyRef.current = false;
  };
  React146.useEffect(() => {
    if (changeOnWheel && focus) {
      const onWheel = (event) => {
        onInternalStep(event.deltaY < 0, "wheel");
        event.preventDefault();
      };
      const input = inputRef.current;
      if (input) {
        input.addEventListener("wheel", onWheel, {
          passive: false
        });
        return () => input.removeEventListener("wheel", onWheel);
      }
    }
  });
  const onBlur = () => {
    if (changeOnBlur) {
      flushInputValue(false);
    }
    setFocus(false);
    userTypingRef.current = false;
  };
  const onInternalMouseDown = (event) => {
    if (inputRef.current && event.target !== inputRef.current) {
      inputRef.current.focus();
      event.preventDefault();
    }
    onMouseDown?.(event);
  };
  useLayoutUpdateEffect(() => {
    if (!decimalValue.isInvalidate()) {
      setInputValue(decimalValue, false);
    }
  }, [precision, formatter]);
  useLayoutUpdateEffect(() => {
    const newValue = es_default13(value);
    setDecimalValue(newValue);
    const currentParsedValue = es_default13(mergedParser(inputValue));
    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
      setInputValue(newValue, userTypingRef.current);
    }
  }, [value]);
  useLayoutUpdateEffect(() => {
    if (formatter) {
      restoreCursor();
    }
  }, [inputValue]);
  const sharedHandlerProps = {
    prefixCls,
    onStep: onInternalStep,
    className: classNames?.action,
    style: styles?.action
  };
  const upNode = React146.createElement(StepHandler, _extends18({}, sharedHandlerProps, {
    action: "up",
    disabled: upDisabled
  }), upHandler);
  const downNode = React146.createElement(StepHandler, _extends18({}, sharedHandlerProps, {
    action: "down",
    disabled: downDisabled
  }), downHandler);
  return React146.createElement("div", {
    ref: rootRef,
    className: clsx(prefixCls, `${prefixCls}-mode-${mode}`, className, classNames?.root, {
      [`${prefixCls}-focused`]: focus,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-readonly`]: readOnly,
      [`${prefixCls}-not-a-number`]: decimalValue.isNaN(),
      [`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange(decimalValue)
    }),
    style: {
      ...styles?.root,
      ...style2
    },
    onMouseDown: onInternalMouseDown,
    onMouseUp,
    onMouseLeave,
    onMouseMove,
    onMouseEnter,
    onMouseOut,
    onClick,
    onFocus: () => {
      setFocus(true);
    },
    onBlur,
    onKeyDown,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBeforeInput
  }, mode === "spinner" && controls && downNode, prefix2 !== void 0 && React146.createElement("div", {
    className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
    style: styles?.prefix
  }, prefix2), React146.createElement("input", _extends18({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
    step,
    ref: inputRef,
    className: clsx(`${prefixCls}-input`, classNames?.input),
    style: styles?.input,
    value: inputValue,
    onChange: onInternalInput,
    disabled,
    readOnly
  }, restProps)), suffix !== void 0 && React146.createElement("div", {
    className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
    style: styles?.suffix
  }, suffix), mode === "spinner" && controls && upNode, mode === "input" && controls && React146.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames?.actions),
    style: styles?.actions
  }, upNode, downNode));
});
if (true) {
  InputNumber.displayName = "InputNumber";
}
var InputNumber_default = InputNumber;

// node_modules/@rc-component/input-number/es/index.js
var es_default14 = InputNumber_default;

// node_modules/antd/es/space/Addon.js
var import_react66 = __toESM(require_react());

// node_modules/antd/es/space/style/addon.js
var genSpaceAddonStyle = (token2) => {
  const {
    componentCls,
    borderRadius,
    paddingSM,
    colorBorder,
    paddingXS,
    fontSizeLG,
    fontSizeSM,
    borderRadiusLG,
    borderRadiusSM,
    colorBgContainerDisabled,
    lineWidth
  } = token2;
  return {
    [componentCls]: [
      // ==========================================================
      // ==                         Base                         ==
      // ==========================================================
      {
        display: "inline-flex",
        alignItems: "center",
        gap: 0,
        paddingInline: paddingSM,
        margin: 0,
        borderWidth: lineWidth,
        borderStyle: "solid",
        borderRadius,
        "&:hover": {
          zIndex: 0
        },
        [`&${componentCls}-disabled`]: {
          color: token2.colorTextDisabled
        },
        "&-large": {
          fontSize: fontSizeLG,
          borderRadius: borderRadiusLG
        },
        "&-small": {
          paddingInline: paddingXS,
          borderRadius: borderRadiusSM,
          fontSize: fontSizeSM
        },
        "&-compact-last-item": {
          borderEndStartRadius: 0,
          borderStartStartRadius: 0
        },
        "&-compact-first-item": {
          borderEndEndRadius: 0,
          borderStartEndRadius: 0
        },
        "&-compact-item:not(:first-child):not(:last-child)": {
          borderRadius: 0
        },
        "&-compact-item:not(:last-child)": {
          borderInlineEndWidth: 0
        },
        "&-compact-item:not(:first-child)": {
          borderInlineStartWidth: 0
        }
      },
      // ==========================================================
      // ==                       Variants                       ==
      // ==========================================================
      {
        "--space-addon-border-color": colorBorder,
        "--space-addon-background": colorBgContainerDisabled,
        // Filled
        "--space-addon-border-color-outlined": colorBorder,
        "--space-addon-background-filled": colorBgContainerDisabled,
        borderColor: "var(--space-addon-border-color)",
        background: "var(--space-addon-background)",
        // ======================= Outlined =======================
        "&-variant-outlined": {
          "--space-addon-border-color": "var(--space-addon-border-color-outlined)"
        },
        // ======================== Filled ========================
        "&-variant-filled": {
          "--space-addon-border-color": "transparent",
          "--space-addon-background": "var(--space-addon-background-filled)",
          // Disabled
          [`&${componentCls}-disabled`]: {
            "--space-addon-border-color": colorBorder,
            "--space-addon-background": colorBgContainerDisabled
          }
        },
        // ====================== Borderless ======================
        "&-variant-borderless": {
          border: "none",
          background: "transparent"
        },
        // ====================== Underlined ======================
        "&-variant-underlined": {
          border: "none",
          background: "transparent"
        }
      },
      // ==========================================================
      // ==                        Status                        ==
      // ==========================================================
      {
        "&-status-error": {
          "--space-addon-border-color-outlined": token2.colorError,
          "--space-addon-background-filled": token2.colorErrorBg,
          color: token2.colorError
        },
        "&-status-warning": {
          "--space-addon-border-color-outlined": token2.colorWarning,
          "--space-addon-background-filled": token2.colorWarningBg,
          color: token2.colorWarning
        }
      }
    ]
  };
};
var addon_default = genStyleHooks(["Space", "Addon"], (token2) => [genSpaceAddonStyle(token2), genCompactItemStyle(token2, {
  focus: false
})]);

// node_modules/antd/es/space/Addon.js
var SpaceAddon = import_react66.default.forwardRef((props, ref) => {
  const {
    className,
    children,
    style: style2,
    prefixCls: customizePrefixCls,
    variant = "outlined",
    disabled,
    status,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction: directionConfig
  } = import_react66.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("space-addon", customizePrefixCls);
  const [hashId, cssVarCls] = addon_default(prefixCls);
  const {
    compactItemClassnames,
    compactSize
  } = useCompactItemContext(prefixCls, directionConfig);
  const statusCls = getStatusClassNames(prefixCls, status);
  const classes = clsx(prefixCls, hashId, compactItemClassnames, cssVarCls, `${prefixCls}-variant-${variant}`, statusCls, {
    [`${prefixCls}-${compactSize}`]: compactSize,
    [`${prefixCls}-disabled`]: disabled
  }, className);
  return import_react66.default.createElement("div", {
    ref,
    className: classes,
    style: style2,
    ...restProps
  }, children);
});
var Addon_default = SpaceAddon;

// node_modules/antd/es/input/style/token.js
function initInputToken(token2) {
  return merge2(token2, {
    inputAffixPadding: token2.paddingXXS
  });
}
var initComponentToken = (token2) => {
  const {
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightSM,
    controlHeightLG,
    fontSizeLG,
    lineHeightLG,
    paddingSM,
    controlPaddingHorizontalSM,
    controlPaddingHorizontal,
    colorFillAlter,
    colorPrimaryHover,
    colorPrimary,
    controlOutlineWidth,
    controlOutline,
    colorErrorOutline,
    colorWarningOutline,
    colorBgContainer,
    inputFontSize,
    inputFontSizeLG,
    inputFontSizeSM
  } = token2;
  const mergedFontSize = inputFontSize || fontSize;
  const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
  const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
  const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
  const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
  const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
  return {
    paddingBlock: Math.max(paddingBlock, 0),
    paddingBlockSM: Math.max(paddingBlockSM, 0),
    paddingBlockLG: Math.max(paddingBlockLG, 0),
    paddingInline: paddingSM - lineWidth,
    paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
    paddingInlineLG: controlPaddingHorizontal - lineWidth,
    addonBg: colorFillAlter,
    activeBorderColor: colorPrimary,
    hoverBorderColor: colorPrimaryHover,
    activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
    errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
    warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
    hoverBg: colorBgContainer,
    activeBg: colorBgContainer,
    inputFontSize: mergedFontSize,
    inputFontSizeLG: mergedFontSizeLG,
    inputFontSizeSM: mergedFontSizeSM
  };
};

// node_modules/antd/es/input/style/variants.js
var genHoverStyle = (token2) => ({
  borderColor: token2.hoverBorderColor,
  backgroundColor: token2.hoverBg
});
var genDisabledStyle = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": {
    ...genHoverStyle(merge2(token2, {
      hoverBorderColor: token2.colorBorder,
      hoverBg: token2.colorBgContainerDisabled
    }))
  }
});
var genBaseOutlinedStyle = (token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: options.borderColor,
  "&:hover": {
    borderColor: options.hoverBorderColor,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: options.activeBorderColor,
    boxShadow: options.activeShadow,
    outline: 0,
    backgroundColor: token2.activeBg
  }
});
var genOutlinedStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseOutlinedStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  },
  [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
    borderColor: options.borderColor
  }
});
var genOutlinedStyle = (token2, extraStyles) => ({
  "&-outlined": {
    ...genBaseOutlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle(token2)
    },
    ...genOutlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    }),
    ...genOutlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});
var genOutlinedGroupStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      borderColor: options.addonBorderColor,
      color: options.addonColor
    }
  }
});
var genOutlinedGroupStyle = (token2) => ({
  "&-outlined": {
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.addonBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    ...genOutlinedGroupStatusStyle(token2, {
      status: "error",
      addonBorderColor: token2.colorError,
      addonColor: token2.colorErrorText
    }),
    ...genOutlinedGroupStatusStyle(token2, {
      status: "warning",
      addonBorderColor: token2.colorWarning,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group-addon`]: {
        ...genDisabledStyle(token2)
      }
    }
  }
});
var genBorderlessStyle = (token2, extraStyles) => {
  const {
    componentCls
  } = token2;
  return {
    "&-borderless": {
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${componentCls}-disabled, &[disabled]`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      // >>>>> Status
      [`&${componentCls}-status-error`]: {
        "&, & input, & textarea": {
          color: token2.colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        "&, & input, & textarea": {
          color: token2.colorWarning
        }
      },
      ...extraStyles
    }
  };
};
var genBaseFilledStyle = (token2, options) => ({
  background: options.bg,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: options?.inputColor ?? "unset"
  },
  "&:hover": {
    background: options.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: options.activeBorderColor,
    backgroundColor: token2.activeBg
  }
});
var genFilledStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseFilledStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  }
});
var genFilledStyle = (token2, extraStyles) => ({
  "&-filled": {
    ...genBaseFilledStyle(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.activeBorderColor,
      inputColor: token2.colorText
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle(token2)
    },
    ...genFilledStatusStyle(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      inputColor: token2.colorErrorText,
      affixColor: token2.colorError
    }),
    ...genFilledStatusStyle(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      inputColor: token2.colorWarningText,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});
var genFilledGroupStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      background: options.addonBg,
      color: options.addonColor
    }
  }
});
var genFilledGroupStyle = (token2) => ({
  "&-filled": {
    [`${token2.componentCls}-group-addon`]: {
      background: token2.colorFillTertiary,
      "&:last-child": {
        position: "static"
      }
    },
    ...genFilledGroupStatusStyle(token2, {
      status: "error",
      addonBg: token2.colorErrorBg,
      addonColor: token2.colorErrorText
    }),
    ...genFilledGroupStatusStyle(token2, {
      status: "warning",
      addonBg: token2.colorWarningBg,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.colorFillTertiary,
          color: token2.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        }
      }
    }
  }
});
var genBaseUnderlinedStyle = (token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: `${unit(token2.lineWidth)} 0`,
  borderStyle: `${token2.lineType} none`,
  borderColor: `transparent transparent ${options.borderColor} transparent`,
  borderRadius: 0,
  "&:hover": {
    borderColor: `transparent transparent ${options.hoverBorderColor} transparent`,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
    outline: 0,
    backgroundColor: token2.activeBg
  }
});
var genUnderlinedStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseUnderlinedStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  },
  [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
    borderColor: `transparent transparent ${options.borderColor} transparent`
  }
});
var genUnderlinedStyle = (token2, extraStyles) => ({
  "&-underlined": {
    ...genBaseUnderlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    }),
    // >>>>> Disabled
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      color: token2.colorTextDisabled,
      boxShadow: "none",
      cursor: "not-allowed",
      "&:hover": {
        borderColor: `transparent transparent ${token2.colorBorder} transparent`
      }
    },
    "input[disabled], textarea[disabled]": {
      cursor: "not-allowed"
    },
    ...genUnderlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    }),
    ...genUnderlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});

// node_modules/antd/es/input/style/index.js
var genPlaceholderStyle = (color) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
var genInputLargeStyle = (token2) => {
  const {
    paddingBlockLG,
    lineHeightLG,
    borderRadiusLG,
    paddingInlineLG
  } = token2;
  return {
    padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
    fontSize: token2.inputFontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
var genInputSmallStyle = (token2) => ({
  padding: `${unit(token2.paddingBlockSM)} ${unit(token2.paddingInlineSM)}`,
  fontSize: token2.inputFontSizeSM,
  borderRadius: token2.borderRadiusSM
});
var genBasicInputStyle = (token2, option = {}) => ({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${unit(token2.paddingBlock)} ${unit(token2.paddingInline)}`,
  color: token2.colorText,
  fontSize: token2.inputFontSize,
  lineHeight: token2.lineHeight,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`,
  ...genPlaceholderStyle(token2.colorTextPlaceholder),
  // Size
  "&-lg": {
    ...genInputLargeStyle(token2),
    ...option.largeStyle
  },
  "&-sm": {
    ...genInputSmallStyle(token2),
    ...option.smallStyle
  },
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
});
var genInputGroupStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: {
      ...genInputLargeStyle(token2)
    },
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: {
      ...genInputSmallStyle(token2)
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${antCls}-select-single`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${unit(token2.paddingInline)}`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.inputFontSize,
        textAlign: "center",
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `${unit(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
            backgroundColor: "inherit",
            border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
            boxShadow: "none"
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [componentCls]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      },
      "&:not(:first-child)": {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: {
      display: "block",
      ...clearFix(),
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: token2.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [componentCls]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        [`${componentCls}-affix-wrapper`]: {
          // borderRadius: 0,
        }
      }
    }
  };
};
var genInputStyle = (token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth,
    calc
  } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBasicInputStyle(token2),
      // Variants
      ...genOutlinedStyle(token2),
      ...genFilledStyle(token2),
      ...genBorderlessStyle(token2),
      ...genUnderlinedStyle(token2),
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        appearance: "none"
      }
    }
  };
};
var genAllowClearStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      padding: 0,
      lineHeight: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      border: "none",
      outline: "none",
      backgroundColor: "transparent",
      "&:hover": {
        color: token2.colorIcon
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${unit(token2.inputAffixPadding)}`
      }
    }
  };
};
var genAffixStyle = (token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  const affixCls = `${componentCls}-affix-wrapper`;
  const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
  return {
    [affixCls]: {
      ...genBasicInputStyle(token2),
      display: "inline-flex",
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${componentCls}`]: {
        padding: 0
      },
      [`> input${componentCls}, > textarea${componentCls}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [componentCls]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription,
          direction: "ltr"
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      },
      ...genAllowClearStyle(token2),
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    },
    //  affix-wrapper borderRadius
    [`${componentCls}-underlined`]: {
      borderRadius: 0
    },
    [affixClsDisabled]: {
      // password disabled
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "not-allowed",
        "&:hover": {
          color: colorIcon
        }
      }
    }
  };
};
var genGroupStyle = (token2) => {
  const {
    componentCls,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: {
      // Style for input-group: input with label, with button or dropdown...
      ...resetComponent(token2),
      ...genInputGroupStyle(token2),
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design/issues/6403
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG,
            fontSize: token2.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        // Variants
        ...genOutlinedGroupStyle(token2),
        ...genFilledGroupStyle(token2),
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        // Fix the issue of input use `addonAfter` param in space compact mode
        // https://github.com/ant-design/ant-design/issues/52483
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      }
    }
  };
};
var genRangeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-out-of-range`]: {
      [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
        color: token2.colorError
      }
    }
  };
};
var useSharedStyle = genStyleHooks(["Input", "Shared"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return [genInputStyle(inputToken), genAffixStyle(inputToken)];
}, initComponentToken, {
  resetFont: false
});
var style_default7 = genStyleHooks(["Input", "Component"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return [
    genGroupStyle(inputToken),
    genRangeStyle(inputToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputToken, {
      focus: true,
      focusElCls: `${inputToken.componentCls}-affix-wrapper-focused`
    })
  ];
}, initComponentToken, {
  resetFont: false
});

// node_modules/antd/es/input-number/style/token.js
var prepareComponentToken6 = (token2) => {
  const handleVisible = token2.handleVisible ?? "auto";
  const handleWidth = token2.controlHeightSM - token2.lineWidth * 2;
  return {
    ...initComponentToken(token2),
    controlWidth: 90,
    handleWidth,
    handleFontSize: token2.fontSize / 2,
    handleVisible,
    handleActiveBg: token2.colorFillAlter,
    handleBg: token2.colorBgContainer,
    filledHandleBg: new FastColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
    handleHoverColor: token2.colorPrimary,
    handleBorderColor: token2.colorBorder,
    handleOpacity: handleVisible === true ? 1 : 0,
    handleVisibleWidth: handleVisible === true ? handleWidth : 0
  };
};

// node_modules/antd/es/input-number/style/index.js
var genInputNumberStyles = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    borderRadius,
    inputFontSizeSM,
    inputFontSizeLG,
    colorError,
    paddingInlineSM,
    paddingBlockSM,
    paddingBlockLG,
    paddingInlineLG,
    colorIcon,
    motionDurationMid,
    handleHoverColor,
    handleOpacity,
    paddingInline,
    paddingBlock,
    handleBg,
    handleActiveBg,
    inputAffixPadding,
    borderRadiusSM,
    controlWidth,
    handleBorderColor,
    filledHandleBg,
    lineHeightLG
  } = token2;
  const borderStyle = `${unit(lineWidth)} ${lineType} ${handleBorderColor}`;
  return [
    // ==========================================================
    // ==                         Base                         ==
    // ==========================================================
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...genBasicInputStyle(token2),
        "--input-number-input-padding-block": unit(paddingBlock),
        "--input-number-input-padding-inline": unit(paddingInline),
        display: "inline-flex",
        width: controlWidth,
        margin: 0,
        paddingBlock: 0,
        borderRadius,
        // ======================= Variants =======================
        ...genOutlinedStyle(token2, {
          [`${componentCls}-actions`]: {
            background: handleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          }
        }),
        ...genFilledStyle(token2, {
          [`${componentCls}-actions`]: {
            background: filledHandleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          },
          "&:focus-within": {
            [`${componentCls}-actions`]: {
              background: handleBg
            }
          }
        }),
        ...genUnderlinedStyle(token2, {
          [`${componentCls}-actions`]: {
            background: handleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          }
        }),
        ...genBorderlessStyle(token2),
        // ========================= RTL ==========================
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        // ===================== Out Of Range =====================
        [`&${componentCls}-out-of-range`]: {
          [`${componentCls}-input`]: {
            color: colorError
          }
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          ...resetComponent(token2),
          width: "100%",
          paddingBlock: `var(--input-number-input-padding-block)`,
          textAlign: "start",
          backgroundColor: "transparent",
          border: 0,
          borderRadius,
          outline: 0,
          transition: `all ${motionDurationMid} linear`,
          appearance: "textfield",
          fontSize: "inherit",
          lineHeight: "inherit",
          ...genPlaceholderStyle(token2.colorTextPlaceholder),
          '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
            margin: 0,
            appearance: "none"
          }
        },
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          width: token2.handleWidth,
          opacity: 1
        },
        // ======================= Disabled =======================
        [`&-disabled ${componentCls}-input`]: {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        }
      }
    },
    // ==========================================================
    // ==                        Action                        ==
    // ==========================================================
    {
      [componentCls]: {
        // ======================= Shared =======================
        [`
          ${componentCls}-action-up-disabled,
          ${componentCls}-action-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-action`]: {
          ...resetIcon(),
          userSelect: "none",
          overflow: "hidden",
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: handleActiveBg
          },
          // Hover
          "&:hover": {
            color: handleHoverColor
          }
        },
        // ===================== Input Mode =====================
        "&-mode-input": {
          overflow: "hidden",
          [`${componentCls}-actions`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineEnd: 0,
            width: token2.handleVisibleWidth,
            opacity: handleOpacity,
            height: "100%",
            borderRadius: 0,
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            transition: `all ${motionDurationMid}`,
            overflow: "hidden",
            // Fix input number inside Menu makes icon too large
            // We arise the selector priority by nest selector here
            // https://github.com/ant-design/ant-design/issues/14367
            [`${componentCls}-action`]: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flex: "auto",
              height: "40%",
              marginInlineEnd: 0,
              fontSize: token2.handleFontSize
            }
          },
          [`&:hover ${componentCls}-actions, &-focused ${componentCls}-actions`]: {
            width: token2.handleWidth,
            opacity: 1
          },
          [`${componentCls}-action`]: {
            color: colorIcon,
            height: "50%",
            borderInlineStart: borderStyle,
            // Hover
            "&:hover": {
              height: `60%`
            }
          },
          [`&${componentCls}-disabled, &${componentCls}-readonly`]: {
            [`${componentCls}-actions`]: {
              display: "none"
            }
          }
        },
        // ==================== Spinner Mode ====================
        [`&${componentCls}-mode-spinner`]: {
          padding: 0,
          width: "auto",
          [`${componentCls}-action`]: {
            flex: "none",
            paddingInline: "var(--input-number-input-padding-inline)",
            "&-up": {
              borderInlineStart: borderStyle
            },
            "&-down": {
              borderInlineEnd: borderStyle
            }
          },
          [`${componentCls}-input`]: {
            textAlign: "center",
            paddingInline: "var(--input-number-input-padding-inline)"
          }
        }
      }
    },
    // ==========================================================
    // ==                         Size                         ==
    // ==========================================================
    {
      [componentCls]: {
        "&-lg": {
          "--input-number-input-padding-block": unit(paddingBlockLG),
          "--input-number-input-padding-inline": unit(paddingInlineLG),
          paddingBlock: 0,
          fontSize: inputFontSizeLG,
          lineHeight: lineHeightLG
        },
        "&-sm": {
          "--input-number-input-padding-block": unit(paddingBlockSM),
          "--input-number-input-padding-inline": unit(paddingInlineSM),
          paddingBlock: 0,
          fontSize: inputFontSizeSM,
          borderRadius: borderRadiusSM
        }
      }
    },
    // ==========================================================
    // ==                      Pre/Suffix                      ==
    // ==========================================================
    {
      [componentCls]: {
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignItems: "center",
          alignSelf: "center",
          pointerEvents: "none"
        },
        [`${componentCls}-prefix`]: {
          marginInlineEnd: inputAffixPadding
        },
        [`${componentCls}-suffix`]: {
          height: "100%",
          marginInlineStart: inputAffixPadding,
          transition: `margin ${motionDurationMid}`
        },
        [`&:hover:not(${componentCls}-without-controls)`]: {
          [`${componentCls}-suffix`]: {
            marginInlineEnd: token2.handleWidth
          }
        }
      }
    }
  ];
};
var genCompatibleStyles = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [`${componentCls}-addon`]: {
      [`&:has(${antCls}-select)`]: {
        border: 0,
        padding: 0
      }
    }
  };
};
var style_default8 = genStyleHooks("InputNumber", (token2) => {
  const inputNumberToken = merge2(token2, initInputToken(token2));
  return [
    genInputNumberStyles(inputNumberToken),
    genCompatibleStyles(inputNumberToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputNumberToken)
  ];
}, prepareComponentToken6, {
  unitless: {
    handleOpacity: true
  },
  resetFont: false
});

// node_modules/antd/es/input-number/index.js
var InternalInputNumber = React148.forwardRef((props, ref) => {
  const inputRef = React148.useRef(null);
  React148.useImperativeHandle(ref, () => inputRef.current);
  const {
    rootClassName,
    size: customizeSize,
    disabled: customDisabled,
    prefixCls,
    addonBefore: _addonBefore,
    addonAfter: _addonAfter,
    prefix: prefix2,
    suffix,
    bordered,
    readOnly,
    status,
    controls = true,
    variant: customVariant,
    className,
    style: style2,
    classNames,
    styles,
    mode,
    ...others
  } = props;
  const {
    direction,
    className: contextClassName,
    style: contextStyle,
    styles: contextStyles,
    classNames: contextClassNames
  } = useComponentConfig("inputNumber");
  const mergedControls = React148.useMemo(() => {
    if (!controls || props.disabled || props.readOnly) {
      return false;
    }
    return controls;
  }, [controls, props.disabled, props.readOnly]);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  let upIcon = mode === "spinner" ? React148.createElement(PlusOutlined_default, null) : React148.createElement(UpOutlined_default, null);
  let downIcon = mode === "spinner" ? React148.createElement(MinusOutlined_default, null) : React148.createElement(DownOutlined_default, null);
  const controlsTemp = typeof mergedControls === "boolean" ? mergedControls : void 0;
  if (typeof mergedControls === "object") {
    upIcon = mergedControls.upIcon || upIcon;
    downIcon = mergedControls.downIcon || downIcon;
  }
  const {
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React148.useContext(FormItemInputContext);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React148.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [variant, enableVariantCls] = useVariants_default("inputNumber", customVariant, bordered);
  const suffixNode = hasFeedback && React148.createElement(React148.Fragment, null, feedbackIcon);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled,
    controls: mergedControls
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  return React148.createElement(es_default14, {
    ref: inputRef,
    mode,
    disabled: mergedDisabled,
    className: clsx(className, rootClassName, mergedClassNames.root, contextClassName, compactItemClassnames, getStatusClassNames(prefixCls, status, hasFeedback), {
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-in-form-item`]: isFormItemInput,
      [`${prefixCls}-without-controls`]: !mergedControls
    }),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    upHandler: upIcon,
    downHandler: downIcon,
    prefixCls,
    readOnly,
    controls: controlsTemp,
    prefix: prefix2,
    suffix: suffixNode || suffix,
    classNames: mergedClassNames,
    styles: mergedStyles,
    ...others
  });
});
var InputNumber2 = React148.forwardRef((props, ref) => {
  const {
    addonBefore,
    addonAfter,
    prefixCls: customizePrefixCls,
    className,
    status: customStatus,
    rootClassName,
    ...rest
  } = props;
  const {
    getPrefixCls
  } = useComponentConfig("inputNumber");
  const prefixCls = getPrefixCls("input-number", customizePrefixCls);
  const {
    status: contextStatus
  } = React148.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls, rootCls);
  const hasLegacyAddon = addonBefore || addonAfter;
  if (true) {
    const typeWarning = devUseWarning("InputNumber");
    [["bordered", "variant"], ["addonAfter", "Space.Compact"], ["addonBefore", "Space.Compact"]].forEach(([prop, newProp]) => {
      typeWarning.deprecated(!(prop in props), prop, newProp);
    });
    typeWarning(!(props.type === "number" && props.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
  }
  const inputNumberNode = React148.createElement(InternalInputNumber, {
    ref,
    ...rest,
    prefixCls,
    status: mergedStatus,
    className: clsx(cssVarCls, rootCls, hashId, className),
    rootClassName: !hasLegacyAddon ? rootClassName : void 0
  });
  if (hasLegacyAddon) {
    const renderAddon = (node2) => {
      if (!node2) {
        return null;
      }
      return React148.createElement(Addon_default, {
        className: clsx(`${prefixCls}-addon`, cssVarCls, hashId),
        variant: props.variant,
        disabled: props.disabled,
        status: mergedStatus
      }, React148.createElement(ContextIsolator_default, {
        form: true
      }, node2));
    };
    const addonBeforeNode = renderAddon(addonBefore);
    const addonAfterNode = renderAddon(addonAfter);
    return React148.createElement(Compact_default, {
      rootClassName
    }, addonBeforeNode, inputNumberNode, addonAfterNode);
  }
  return inputNumberNode;
});
var TypedInputNumber = InputNumber2;
var PureInputNumber = (props) => React148.createElement(config_provider_default, {
  theme: {
    components: {
      InputNumber: {
        handleVisible: true
      }
    }
  }
}, React148.createElement(InputNumber2, {
  ...props
}));
if (true) {
  InternalInputNumber.displayName = "InternalInputNumber";
  TypedInputNumber.displayName = "InputNumber";
}
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
var input_number_default = TypedInputNumber;

// node_modules/antd/es/color-picker/components/ColorSteppers.js
var ColorSteppers = ({
  prefixCls,
  min = 0,
  max = 100,
  value,
  onChange,
  className,
  formatter
}) => {
  const colorSteppersPrefixCls = `${prefixCls}-steppers`;
  const [internalValue, setInternalValue] = (0, import_react67.useState)(0);
  const stepValue = !Number.isNaN(value) ? value : internalValue;
  return import_react67.default.createElement(input_number_default, {
    className: clsx(colorSteppersPrefixCls, className),
    min,
    max,
    value: stepValue,
    formatter,
    size: "small",
    onChange: (step) => {
      setInternalValue(step || 0);
      onChange?.(step);
    }
  });
};
var ColorSteppers_default = ColorSteppers;

// node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var ColorAlphaInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
  const [internalValue, setInternalValue] = (0, import_react68.useState)(() => generateColor2(value || "#000"));
  const alphaValue = value || internalValue;
  const handleAlphaChange = (step) => {
    const hsba = alphaValue.toHsb();
    hsba.a = (step || 0) / 100;
    const genColor = generateColor2(hsba);
    setInternalValue(genColor);
    onChange?.(genColor);
  };
  return import_react68.default.createElement(ColorSteppers_default, {
    value: getColorAlpha(alphaValue),
    prefixCls,
    formatter: (step) => `${step}%`,
    className: colorAlphaInputPrefixCls,
    onChange: handleAlphaChange
  });
};
var ColorAlphaInput_default = ColorAlphaInput;

// node_modules/antd/es/color-picker/components/ColorHexInput.js
var import_react74 = __toESM(require_react());

// node_modules/antd/es/input/Input.js
var import_react73 = __toESM(require_react());

// node_modules/@rc-component/input/es/BaseInput.js
var import_react69 = __toESM(require_react());

// node_modules/@rc-component/input/es/utils/commonUtils.js
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function cloneEvent(event, target, value) {
  const currentTarget = target.cloneNode(true);
  const newEvent = Object.create(event, {
    target: {
      value: currentTarget
    },
    currentTarget: {
      value: currentTarget
    }
  });
  currentTarget.value = value;
  if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
    currentTarget.selectionStart = target.selectionStart;
    currentTarget.selectionEnd = target.selectionEnd;
  }
  currentTarget.setSelectionRange = (...args) => {
    target.setSelectionRange(...args);
  };
  return newEvent;
}
function resolveOnChange(target, e, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  let event = e;
  if (e.type === "click") {
    event = cloneEvent(e, target, "");
    onChange(event);
    return;
  }
  if (target.type !== "file" && targetValue !== void 0) {
    event = cloneEvent(e, target, targetValue);
    onChange(event);
    return;
  }
  onChange(event);
}

// node_modules/@rc-component/input/es/BaseInput.js
function _extends19() {
  _extends19 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends19.apply(this, arguments);
}
var BaseInput = import_react69.default.forwardRef((props, ref) => {
  const {
    inputElement: inputEl,
    children,
    prefixCls,
    prefix: prefix2,
    suffix,
    addonBefore,
    addonAfter,
    className,
    style: style2,
    disabled,
    readOnly,
    focused,
    triggerFocus: triggerFocus2,
    allowClear,
    value,
    handleReset,
    hidden,
    classes,
    classNames,
    dataAttrs,
    styles,
    components: components2,
    onClear
  } = props;
  const inputElement = children ?? inputEl;
  const AffixWrapperComponent = components2?.affixWrapper || "span";
  const GroupWrapperComponent = components2?.groupWrapper || "span";
  const WrapperComponent = components2?.wrapper || "span";
  const GroupAddonComponent = components2?.groupAddon || "span";
  const containerRef = (0, import_react69.useRef)(null);
  const onInputClick = (e) => {
    if (containerRef.current?.contains(e.target)) {
      triggerFocus2?.();
    }
  };
  const hasAffix = hasPrefixSuffix(props);
  let element = (0, import_react69.cloneElement)(inputElement, {
    value,
    className: clsx(inputElement.props?.className, !hasAffix && classNames?.variant) || null
  });
  const groupRef = (0, import_react69.useRef)(null);
  import_react69.default.useImperativeHandle(ref, () => ({
    nativeElement: groupRef.current || containerRef.current
  }));
  if (hasAffix) {
    let clearIcon = null;
    if (allowClear) {
      const needClear = !disabled && !readOnly && value;
      const clearIconCls = `${prefixCls}-clear-icon`;
      const iconNode = typeof allowClear === "object" && allowClear?.clearIcon ? allowClear.clearIcon : "";
      clearIcon = import_react69.default.createElement("button", {
        type: "button",
        tabIndex: -1,
        onClick: (event) => {
          handleReset?.(event);
          onClear?.();
        },
        onMouseDown: (e) => e.preventDefault(),
        className: clsx(clearIconCls, {
          [`${clearIconCls}-hidden`]: !needClear,
          [`${clearIconCls}-has-suffix`]: !!suffix
        })
      }, iconNode);
    }
    const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
    const affixWrapperCls = clsx(affixWrapperPrefixCls, {
      [`${prefixCls}-disabled`]: disabled,
      [`${affixWrapperPrefixCls}-disabled`]: disabled,
      // Not used, but keep it
      [`${affixWrapperPrefixCls}-focused`]: focused,
      // Not used, but keep it
      [`${affixWrapperPrefixCls}-readonly`]: readOnly,
      [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
    }, classes?.affixWrapper, classNames?.affixWrapper, classNames?.variant);
    const suffixNode = (suffix || allowClear) && import_react69.default.createElement("span", {
      className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
      style: styles?.suffix
    }, clearIcon, suffix);
    element = import_react69.default.createElement(AffixWrapperComponent, _extends19({
      className: affixWrapperCls,
      style: styles?.affixWrapper,
      onClick: onInputClick
    }, dataAttrs?.affixWrapper, {
      ref: containerRef
    }), prefix2 && import_react69.default.createElement("span", {
      className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
      style: styles?.prefix
    }, prefix2), element, suffixNode);
  }
  if (hasAddon(props)) {
    const wrapperCls = `${prefixCls}-group`;
    const addonCls = `${wrapperCls}-addon`;
    const groupWrapperCls = `${wrapperCls}-wrapper`;
    const mergedWrapperClassName = clsx(`${prefixCls}-wrapper`, wrapperCls, classes?.wrapper, classNames?.wrapper);
    const mergedGroupClassName = clsx(groupWrapperCls, {
      [`${groupWrapperCls}-disabled`]: disabled
    }, classes?.group, classNames?.groupWrapper);
    element = import_react69.default.createElement(GroupWrapperComponent, {
      className: mergedGroupClassName,
      ref: groupRef
    }, import_react69.default.createElement(WrapperComponent, {
      className: mergedWrapperClassName
    }, addonBefore && import_react69.default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonBefore), element, addonAfter && import_react69.default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonAfter)));
  }
  return import_react69.default.cloneElement(element, {
    className: clsx(element.props?.className, className) || null,
    style: {
      ...element.props?.style,
      ...style2
    },
    hidden
  });
});
var BaseInput_default = BaseInput;

// node_modules/@rc-component/input/es/Input.js
var import_react70 = __toESM(require_react());

// node_modules/@rc-component/input/es/hooks/useCount.js
var React152 = __toESM(require_react());
function useCount(count, showCount) {
  return React152.useMemo(() => {
    let mergedConfig = {};
    if (showCount) {
      mergedConfig.show = typeof showCount === "object" && showCount.formatter ? showCount.formatter : !!showCount;
    }
    mergedConfig = {
      ...mergedConfig,
      ...count
    };
    const {
      show,
      ...rest
    } = mergedConfig;
    return {
      ...rest,
      show: !!show,
      showFormatter: typeof show === "function" ? show : void 0,
      strategy: rest.strategy || ((value) => value.length)
    };
  }, [count, showCount]);
}

// node_modules/@rc-component/input/es/Input.js
function _extends20() {
  _extends20 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends20.apply(this, arguments);
}
var Input2 = (0, import_react70.forwardRef)((props, ref) => {
  const {
    autoComplete,
    onChange,
    onFocus,
    onBlur,
    onPressEnter,
    onKeyDown,
    onKeyUp,
    prefixCls = "rc-input",
    disabled,
    htmlSize,
    className,
    maxLength,
    suffix,
    showCount,
    count,
    type: type5 = "text",
    classes,
    classNames,
    styles,
    onCompositionStart,
    onCompositionEnd,
    ...rest
  } = props;
  const [focused, setFocused] = (0, import_react70.useState)(false);
  const compositionRef = (0, import_react70.useRef)(false);
  const keyLockRef = (0, import_react70.useRef)(false);
  const inputRef = (0, import_react70.useRef)(null);
  const holderRef = (0, import_react70.useRef)(null);
  const focus = (option) => {
    if (inputRef.current) {
      triggerFocus(inputRef.current, option);
    }
  };
  const [value, setValue] = useControlledState(props.defaultValue, props.value);
  const formatValue = value === void 0 || value === null ? "" : String(value);
  const [selection, setSelection] = (0, import_react70.useState)(null);
  const countConfig = useCount(count, showCount);
  const mergedMax = countConfig.max || maxLength;
  const valueLength = countConfig.strategy(formatValue);
  const isOutOfRange = !!mergedMax && valueLength > mergedMax;
  (0, import_react70.useImperativeHandle)(ref, () => ({
    focus,
    blur: () => {
      inputRef.current?.blur();
    },
    setSelectionRange: (start, end, direction) => {
      inputRef.current?.setSelectionRange(start, end, direction);
    },
    select: () => {
      inputRef.current?.select();
    },
    input: inputRef.current,
    nativeElement: holderRef.current?.nativeElement || inputRef.current
  }));
  (0, import_react70.useEffect)(() => {
    if (keyLockRef.current) {
      keyLockRef.current = false;
    }
    setFocused((prev2) => prev2 && disabled ? false : prev2);
  }, [disabled]);
  const triggerChange = (e, currentValue, info) => {
    let cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([inputRef.current?.selectionStart || 0, inputRef.current?.selectionEnd || 0]);
      }
    } else if (info.source === "compositionEnd") {
      return;
    }
    setValue(cutValue);
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e, onChange, cutValue);
    }
  };
  (0, import_react70.useEffect)(() => {
    if (selection) {
      inputRef.current?.setSelectionRange(...selection);
    }
  }, [selection]);
  const onInternalChange = (e) => {
    triggerChange(e, e.target.value, {
      source: "change"
    });
  };
  const onInternalCompositionEnd = (e) => {
    compositionRef.current = false;
    triggerChange(e, e.currentTarget.value, {
      source: "compositionEnd"
    });
    onCompositionEnd?.(e);
  };
  const handleKeyDown = (e) => {
    if (onPressEnter && e.key === "Enter" && !keyLockRef.current && !e.nativeEvent.isComposing) {
      keyLockRef.current = true;
      onPressEnter(e);
    }
    onKeyDown?.(e);
  };
  const handleKeyUp = (e) => {
    if (e.key === "Enter") {
      keyLockRef.current = false;
    }
    onKeyUp?.(e);
  };
  const handleFocus = (e) => {
    setFocused(true);
    onFocus?.(e);
  };
  const handleBlur = (e) => {
    if (keyLockRef.current) {
      keyLockRef.current = false;
    }
    setFocused(false);
    onBlur?.(e);
  };
  const handleReset = (e) => {
    setValue("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e, onChange);
    }
  };
  const outOfRangeCls = isOutOfRange && `${prefixCls}-out-of-range`;
  const getInputElement = () => {
    const otherProps = omit(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames",
      "onClear"
    ]);
    return import_react70.default.createElement("input", _extends20({
      autoComplete
    }, otherProps, {
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      className: clsx(prefixCls, {
        [`${prefixCls}-disabled`]: disabled
      }, classNames?.input),
      style: styles?.input,
      ref: inputRef,
      size: htmlSize,
      type: type5,
      onCompositionStart: (e) => {
        compositionRef.current = true;
        onCompositionStart?.(e);
      },
      onCompositionEnd: onInternalCompositionEnd
    }));
  };
  const getSuffix = () => {
    const hasMaxLength = Number(mergedMax) > 0;
    if (suffix || countConfig.show) {
      const dataCount = countConfig.showFormatter ? countConfig.showFormatter({
        value: formatValue,
        count: valueLength,
        maxLength: mergedMax
      }) : `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
      return import_react70.default.createElement(import_react70.default.Fragment, null, countConfig.show && import_react70.default.createElement("span", {
        className: clsx(`${prefixCls}-show-count-suffix`, {
          [`${prefixCls}-show-count-has-suffix`]: !!suffix
        }, classNames?.count),
        style: {
          ...styles?.count
        }
      }, dataCount), suffix);
    }
    return null;
  };
  return import_react70.default.createElement(BaseInput_default, _extends20({}, rest, {
    prefixCls,
    className: clsx(className, outOfRangeCls),
    handleReset,
    value: formatValue,
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled,
    classes,
    classNames,
    styles,
    ref: holderRef
  }), getInputElement());
});
var Input_default2 = Input2;

// node_modules/@rc-component/input/es/index.js
var es_default15 = Input_default2;

// node_modules/antd/es/_util/getAllowClear.js
var import_react71 = __toESM(require_react());
var getAllowClear = (allowClear) => {
  let mergedAllowClear;
  if (typeof allowClear === "object" && allowClear?.clearIcon) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: import_react71.default.createElement(CloseCircleFilled_default, null)
    };
  }
  return mergedAllowClear;
};
var getAllowClear_default = getAllowClear;

// node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js
var import_react72 = __toESM(require_react());
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = (0, import_react72.useRef)([]);
  const removePasswordTimeout = () => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      if (inputRef.current?.input && inputRef.current?.input.getAttribute("type") === "password" && inputRef.current?.input.hasAttribute("value")) {
        inputRef.current?.input.removeAttribute("value");
      }
    }));
  };
  (0, import_react72.useEffect)(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach((timer) => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}

// node_modules/antd/es/input/utils.js
function hasPrefixSuffix2(props) {
  return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}

// node_modules/antd/es/input/Input.js
var Input3 = (0, import_react73.forwardRef)((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur,
    onFocus,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    style: style2,
    styles,
    rootClassName,
    onChange,
    classNames,
    variant: customVariant,
    ...rest
  } = props;
  if (true) {
    const {
      deprecated
    } = devUseWarning("Input");
    [["bordered", "variant"], ["addonAfter", "Space.Compact"], ["addonBefore", "Space.Compact"]].forEach(([prop, newProp]) => {
      deprecated(!(prop in props), prop, newProp);
    });
  }
  const {
    getPrefixCls,
    direction,
    allowClear: contextAllowClear,
    autoComplete: contextAutoComplete,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("input");
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const inputRef = (0, import_react73.useRef)(null);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
  style_default7(prefixCls, rootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customSize ?? compactSize ?? ctx);
  const disabled = import_react73.default.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = (0, import_react73.useContext)(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const inputHasPrefixSuffix = hasPrefixSuffix2(props) || !!hasFeedback;
  const prevHasPrefixSuffix = (0, import_react73.useRef)(inputHasPrefixSuffix);
  if (true) {
    const warning5 = devUseWarning("Input");
    (0, import_react73.useEffect)(() => {
      if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) {
        true ? warning5(document.activeElement === inputRef.current?.input, "usage", `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`) : void 0;
      }
      prevHasPrefixSuffix.current = inputHasPrefixSuffix;
    }, [inputHasPrefixSuffix]);
  }
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  const handleBlur = (e) => {
    removePasswordTimeout();
    onBlur?.(e);
  };
  const handleFocus = (e) => {
    removePasswordTimeout();
    onFocus?.(e);
  };
  const handleChange = (e) => {
    removePasswordTimeout();
    onChange?.(e);
  };
  const suffixNode = (hasFeedback || suffix) && import_react73.default.createElement(import_react73.default.Fragment, null, suffix, hasFeedback && feedbackIcon);
  const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
  const [variant, enableVariantCls] = useVariants_default("input", customVariant, bordered);
  return import_react73.default.createElement(es_default15, {
    ref: composeRef(ref, inputRef),
    prefixCls,
    autoComplete: contextAutoComplete,
    ...rest,
    disabled: mergedDisabled,
    onBlur: handleBlur,
    onFocus: handleFocus,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    styles: mergedStyles,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: clsx(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName, mergedClassNames.root),
    onChange: handleChange,
    addonBefore: addonBefore && import_react73.default.createElement(ContextIsolator_default, {
      form: true,
      space: true
    }, addonBefore),
    addonAfter: addonAfter && import_react73.default.createElement(ContextIsolator_default, {
      form: true,
      space: true
    }, addonAfter),
    classNames: {
      ...mergedClassNames,
      input: clsx({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, mergedClassNames.input, hashId),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: clsx({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
      }, hashId),
      wrapper: clsx({
        [`${prefixCls}-group-rtl`]: direction === "rtl"
      }, hashId),
      groupWrapper: clsx({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    }
  });
});
if (true) {
  Input3.displayName = "Input";
}
var Input_default3 = Input3;

// node_modules/antd/es/color-picker/components/ColorHexInput.js
var hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
var isHexString = (hex2) => hexReg.test(`#${hex2}`);
var ColorHexInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
  const [hexValue, setHexValue] = (0, import_react74.useState)(() => value ? toHexFormat(value.toHexString()) : void 0);
  (0, import_react74.useEffect)(() => {
    if (value) {
      setHexValue(toHexFormat(value.toHexString()));
    }
  }, [value]);
  const handleHexChange = (e) => {
    const originValue = e.target.value;
    setHexValue(toHexFormat(originValue));
    if (isHexString(toHexFormat(originValue, true))) {
      onChange?.(generateColor2(originValue));
    }
  };
  return import_react74.default.createElement(Input_default3, {
    className: colorHexInputPrefixCls,
    value: hexValue,
    prefix: "#",
    onChange: handleHexChange,
    size: "small"
  });
};
var ColorHexInput_default = ColorHexInput;

// node_modules/antd/es/color-picker/components/ColorHsbInput.js
var import_react75 = __toESM(require_react());
var ColorHsbInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
  const [internalValue, setInternalValue] = (0, import_react75.useState)(() => generateColor2(value || "#000"));
  const hsbValue = value || internalValue;
  const handleHsbChange = (step, type5) => {
    const hsb = hsbValue.toHsb();
    hsb[type5] = type5 === "h" ? step : (step || 0) / 100;
    const genColor = generateColor2(hsb);
    setInternalValue(genColor);
    onChange?.(genColor);
  };
  return import_react75.default.createElement("div", {
    className: colorHsbInputPrefixCls
  }, import_react75.default.createElement(ColorSteppers_default, {
    max: 360,
    min: 0,
    value: Number(hsbValue.toHsb().h),
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => getRoundNumber2(step || 0).toString(),
    onChange: (step) => handleHsbChange(Number(step), "h")
  }), import_react75.default.createElement(ColorSteppers_default, {
    max: 100,
    min: 0,
    value: Number(hsbValue.toHsb().s) * 100,
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => `${getRoundNumber2(step || 0)}%`,
    onChange: (step) => handleHsbChange(Number(step), "s")
  }), import_react75.default.createElement(ColorSteppers_default, {
    max: 100,
    min: 0,
    value: Number(hsbValue.toHsb().b) * 100,
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => `${getRoundNumber2(step || 0)}%`,
    onChange: (step) => handleHsbChange(Number(step), "b")
  }));
};
var ColorHsbInput_default = ColorHsbInput;

// node_modules/antd/es/color-picker/components/ColorRgbInput.js
var import_react76 = __toESM(require_react());
var ColorRgbInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
  const [internalValue, setInternalValue] = (0, import_react76.useState)(() => generateColor2(value || "#000"));
  const rgbValue = value || internalValue;
  const handleRgbChange = (step, type5) => {
    const rgb = rgbValue.toRgb();
    rgb[type5] = step || 0;
    const genColor = generateColor2(rgb);
    setInternalValue(genColor);
    onChange?.(genColor);
  };
  return import_react76.default.createElement("div", {
    className: colorRgbInputPrefixCls
  }, import_react76.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().r),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "r")
  }), import_react76.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().g),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "g")
  }), import_react76.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().b),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "b")
  }));
};
var ColorRgbInput_default = ColorRgbInput;

// node_modules/antd/es/color-picker/components/ColorInput.js
var selectOptions = [FORMAT_HEX, FORMAT_HSB, FORMAT_RGB].map((format2) => ({
  value: format2,
  label: format2.toUpperCase()
}));
var ColorInput = (props) => {
  const {
    prefixCls,
    format: format2,
    value,
    disabledAlpha,
    onFormatChange,
    onChange,
    disabledFormat
  } = props;
  const [colorFormat, setColorFormat] = useControlledState(FORMAT_HEX, format2);
  const colorInputPrefixCls = `${prefixCls}-input`;
  const triggerFormatChange = (newFormat) => {
    setColorFormat(newFormat);
    onFormatChange?.(newFormat);
  };
  const steppersNode = (0, import_react77.useMemo)(() => {
    const inputProps = {
      value,
      prefixCls,
      onChange
    };
    switch (colorFormat) {
      case FORMAT_HSB:
        return import_react77.default.createElement(ColorHsbInput_default, {
          ...inputProps
        });
      case FORMAT_RGB:
        return import_react77.default.createElement(ColorRgbInput_default, {
          ...inputProps
        });
      // case FORMAT_HEX:
      default:
        return import_react77.default.createElement(ColorHexInput_default, {
          ...inputProps
        });
    }
  }, [colorFormat, prefixCls, value, onChange]);
  return import_react77.default.createElement("div", {
    className: `${colorInputPrefixCls}-container`
  }, !disabledFormat && import_react77.default.createElement(select_default, {
    value: colorFormat,
    variant: "borderless",
    getPopupContainer: (current) => current,
    popupMatchSelectWidth: 68,
    placement: "bottomRight",
    onChange: triggerFormatChange,
    className: `${prefixCls}-format-select`,
    size: "small",
    options: selectOptions
  }), import_react77.default.createElement("div", {
    className: colorInputPrefixCls
  }, steppersNode), !disabledAlpha && import_react77.default.createElement(ColorAlphaInput_default, {
    prefixCls,
    value,
    onChange
  }));
};
var ColorInput_default = ColorInput;

// node_modules/antd/es/color-picker/components/ColorSlider.js
var React175 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Slider.js
var React171 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Handles/index.js
var React162 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());

// node_modules/@rc-component/slider/es/util.js
function getOffset(value, min, max) {
  return (value - min) / (max - min);
}
function getDirectionStyle(direction, value, min, max) {
  const offset = getOffset(value, min, max);
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offset * 100}%`;
      positionStyle.transform = "translateX(50%)";
      break;
    case "btt":
      positionStyle.bottom = `${offset * 100}%`;
      positionStyle.transform = "translateY(50%)";
      break;
    case "ttb":
      positionStyle.top = `${offset * 100}%`;
      positionStyle.transform = "translateY(-50%)";
      break;
    default:
      positionStyle.left = `${offset * 100}%`;
      positionStyle.transform = "translateX(-50%)";
      break;
  }
  return positionStyle;
}
function getIndex(value, index) {
  return Array.isArray(value) ? value[index] : value;
}

// node_modules/@rc-component/slider/es/Handles/Handle.js
var React161 = __toESM(require_react());

// node_modules/@rc-component/slider/es/context.js
var React160 = __toESM(require_react());
var SliderContext = React160.createContext({
  min: 0,
  max: 0,
  direction: "ltr",
  step: 1,
  includedStart: 0,
  includedEnd: 0,
  tabIndex: 0,
  keyboard: true,
  styles: {},
  classNames: {}
});
var context_default4 = SliderContext;
var UnstableContext = React160.createContext({});

// node_modules/@rc-component/slider/es/Handles/Handle.js
function _extends21() {
  _extends21 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends21.apply(this, arguments);
}
var Handle = React161.forwardRef((props, ref) => {
  const {
    prefixCls,
    value,
    valueIndex,
    onStartMove,
    onDelete,
    style: style2,
    render,
    dragging,
    draggingDelete,
    onOffsetChange,
    onChangeComplete,
    onFocus,
    onMouseEnter,
    ...restProps
  } = props;
  const {
    min,
    max,
    direction,
    disabled,
    keyboard,
    range: range3,
    tabIndex,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle,
    styles,
    classNames
  } = React161.useContext(context_default4);
  const handlePrefixCls = `${prefixCls}-handle`;
  const onInternalStartMove = (e) => {
    if (!disabled) {
      onStartMove(e, valueIndex);
    }
  };
  const onInternalFocus = (e) => {
    onFocus?.(e, valueIndex);
  };
  const onInternalMouseEnter = (e) => {
    onMouseEnter(e, valueIndex);
  };
  const onKeyDown = (e) => {
    if (!disabled && keyboard) {
      let offset = null;
      switch (e.which || e.keyCode) {
        case KeyCode_default.LEFT:
          offset = direction === "ltr" || direction === "btt" ? -1 : 1;
          break;
        case KeyCode_default.RIGHT:
          offset = direction === "ltr" || direction === "btt" ? 1 : -1;
          break;
        // Up is plus
        case KeyCode_default.UP:
          offset = direction !== "ttb" ? 1 : -1;
          break;
        // Down is minus
        case KeyCode_default.DOWN:
          offset = direction !== "ttb" ? -1 : 1;
          break;
        case KeyCode_default.HOME:
          offset = "min";
          break;
        case KeyCode_default.END:
          offset = "max";
          break;
        case KeyCode_default.PAGE_UP:
          offset = 2;
          break;
        case KeyCode_default.PAGE_DOWN:
          offset = -2;
          break;
        case KeyCode_default.BACKSPACE:
        case KeyCode_default.DELETE:
          onDelete?.(valueIndex);
          break;
      }
      if (offset !== null) {
        e.preventDefault();
        onOffsetChange(offset, valueIndex);
      }
    }
  };
  const handleKeyUp = (e) => {
    switch (e.which || e.keyCode) {
      case KeyCode_default.LEFT:
      case KeyCode_default.RIGHT:
      case KeyCode_default.UP:
      case KeyCode_default.DOWN:
      case KeyCode_default.HOME:
      case KeyCode_default.END:
      case KeyCode_default.PAGE_UP:
      case KeyCode_default.PAGE_DOWN:
        onChangeComplete?.();
        break;
    }
  };
  const positionStyle = getDirectionStyle(direction, value, min, max);
  let divProps = {};
  if (valueIndex !== null) {
    divProps = {
      tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
      role: "slider",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value,
      "aria-disabled": disabled,
      "aria-label": getIndex(ariaLabelForHandle, valueIndex),
      "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
      "aria-required": getIndex(ariaRequired, valueIndex),
      "aria-valuetext": getIndex(ariaValueTextFormatterForHandle, valueIndex)?.(value),
      "aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
      onMouseDown: onInternalStartMove,
      onTouchStart: onInternalStartMove,
      onFocus: onInternalFocus,
      onMouseEnter: onInternalMouseEnter,
      onKeyDown,
      onKeyUp: handleKeyUp
    };
  }
  let handleNode = React161.createElement("div", _extends21({
    ref,
    className: clsx(handlePrefixCls, {
      [`${handlePrefixCls}-${valueIndex + 1}`]: valueIndex !== null && range3,
      [`${handlePrefixCls}-dragging`]: dragging,
      [`${handlePrefixCls}-dragging-delete`]: draggingDelete
    }, classNames.handle),
    style: {
      ...positionStyle,
      ...style2,
      ...styles.handle
    }
  }, divProps, restProps));
  if (render) {
    handleNode = render(handleNode, {
      index: valueIndex,
      prefixCls,
      value,
      dragging,
      draggingDelete
    });
  }
  return handleNode;
});
if (true) {
  Handle.displayName = "Handle";
}
var Handle_default = Handle;

// node_modules/@rc-component/slider/es/Handles/index.js
function _extends22() {
  _extends22 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends22.apply(this, arguments);
}
var Handles = React162.forwardRef((props, ref) => {
  const {
    prefixCls,
    style: style2,
    onStartMove,
    onOffsetChange,
    values,
    handleRender,
    activeHandleRender,
    draggingIndex,
    draggingDelete,
    onFocus,
    ...restProps
  } = props;
  const handlesRef = React162.useRef({});
  const [activeVisible, setActiveVisible] = React162.useState(false);
  const [activeIndex, setActiveIndex] = React162.useState(-1);
  const onActive = (index) => {
    setActiveIndex(index);
    setActiveVisible(true);
  };
  const onHandleFocus = (e, index) => {
    onActive(index);
    onFocus?.(e);
  };
  const onHandleMouseEnter = (e, index) => {
    onActive(index);
  };
  React162.useImperativeHandle(ref, () => ({
    focus: (index) => {
      handlesRef.current[index]?.focus();
    },
    hideHelp: () => {
      (0, import_react_dom4.flushSync)(() => {
        setActiveVisible(false);
      });
    }
  }));
  const handleProps = {
    prefixCls,
    onStartMove,
    onOffsetChange,
    render: handleRender,
    onFocus: onHandleFocus,
    onMouseEnter: onHandleMouseEnter,
    ...restProps
  };
  return React162.createElement(React162.Fragment, null, values.map((value, index) => {
    const dragging = draggingIndex === index;
    return React162.createElement(Handle_default, _extends22({
      ref: (node2) => {
        if (!node2) {
          delete handlesRef.current[index];
        } else {
          handlesRef.current[index] = node2;
        }
      },
      dragging,
      draggingDelete: dragging && draggingDelete,
      style: getIndex(style2, index),
      key: index,
      value,
      valueIndex: index
    }, handleProps));
  }), activeHandleRender && activeVisible && React162.createElement(Handle_default, _extends22({
    key: "a11y"
  }, handleProps, {
    value: values[activeIndex],
    valueIndex: null,
    dragging: draggingIndex !== -1,
    draggingDelete,
    render: activeHandleRender,
    style: {
      pointerEvents: "none"
    },
    tabIndex: null,
    "aria-hidden": true
  })));
});
if (true) {
  Handles.displayName = "Handles";
}
var Handles_default = Handles;

// node_modules/@rc-component/slider/es/Marks/index.js
var React164 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Marks/Mark.js
var React163 = __toESM(require_react());
var Mark = (props) => {
  const {
    prefixCls,
    style: style2,
    children,
    value,
    onClick
  } = props;
  const {
    min,
    max,
    direction,
    includedStart,
    includedEnd,
    included
  } = React163.useContext(context_default4);
  const textCls = `${prefixCls}-text`;
  const positionStyle = getDirectionStyle(direction, value, min, max);
  return React163.createElement("span", {
    className: clsx(textCls, {
      [`${textCls}-active`]: included && includedStart <= value && value <= includedEnd
    }),
    style: {
      ...positionStyle,
      ...style2
    },
    onMouseDown: (e) => {
      e.stopPropagation();
    },
    onClick: () => {
      onClick(value);
    }
  }, children);
};
var Mark_default = Mark;

// node_modules/@rc-component/slider/es/Marks/index.js
var Marks = (props) => {
  const {
    prefixCls,
    marks,
    onClick
  } = props;
  const markPrefixCls = `${prefixCls}-mark`;
  if (!marks.length) {
    return null;
  }
  return React164.createElement("div", {
    className: markPrefixCls
  }, marks.map(({
    value,
    style: style2,
    label
  }) => React164.createElement(Mark_default, {
    key: value,
    prefixCls: markPrefixCls,
    style: style2,
    value,
    onClick
  }, label)));
};
var Marks_default = Marks;

// node_modules/@rc-component/slider/es/Steps/index.js
var React166 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Steps/Dot.js
var React165 = __toESM(require_react());
var Dot = (props) => {
  const {
    prefixCls,
    value,
    style: style2,
    activeStyle
  } = props;
  const {
    min,
    max,
    direction,
    included,
    includedStart,
    includedEnd
  } = React165.useContext(context_default4);
  const dotClassName = `${prefixCls}-dot`;
  const active = included && includedStart <= value && value <= includedEnd;
  let mergedStyle = {
    ...getDirectionStyle(direction, value, min, max),
    ...typeof style2 === "function" ? style2(value) : style2
  };
  if (active) {
    mergedStyle = {
      ...mergedStyle,
      ...typeof activeStyle === "function" ? activeStyle(value) : activeStyle
    };
  }
  return React165.createElement("span", {
    className: clsx(dotClassName, {
      [`${dotClassName}-active`]: active
    }),
    style: mergedStyle
  });
};
var Dot_default = Dot;

// node_modules/@rc-component/slider/es/Steps/index.js
var Steps = (props) => {
  const {
    prefixCls,
    marks,
    dots,
    style: style2,
    activeStyle
  } = props;
  const {
    min,
    max,
    step
  } = React166.useContext(context_default4);
  const stepDots = React166.useMemo(() => {
    const dotSet = /* @__PURE__ */ new Set();
    marks.forEach((mark) => {
      dotSet.add(mark.value);
    });
    if (dots && step !== null) {
      let current = min;
      while (current <= max) {
        dotSet.add(current);
        current += step;
      }
    }
    return Array.from(dotSet);
  }, [min, max, step, dots, marks]);
  return React166.createElement("div", {
    className: `${prefixCls}-step`
  }, stepDots.map((dotValue) => React166.createElement(Dot_default, {
    prefixCls,
    key: dotValue,
    value: dotValue,
    style: style2,
    activeStyle
  })));
};
var Steps_default = Steps;

// node_modules/@rc-component/slider/es/Tracks/index.js
var React168 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Tracks/Track.js
var React167 = __toESM(require_react());
var Track = (props) => {
  const {
    prefixCls,
    style: style2,
    start,
    end,
    index,
    onStartMove,
    replaceCls
  } = props;
  const {
    direction,
    min,
    max,
    disabled,
    range: range3,
    classNames
  } = React167.useContext(context_default4);
  const trackPrefixCls = `${prefixCls}-track`;
  const offsetStart = getOffset(start, min, max);
  const offsetEnd = getOffset(end, min, max);
  const onInternalStartMove = (e) => {
    if (!disabled && onStartMove) {
      onStartMove(e, -1);
    }
  };
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "btt":
      positionStyle.bottom = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "ttb":
      positionStyle.top = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    default:
      positionStyle.left = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
  }
  const className = replaceCls || clsx(trackPrefixCls, {
    [`${trackPrefixCls}-${index + 1}`]: index !== null && range3,
    [`${prefixCls}-track-draggable`]: onStartMove
  }, classNames.track);
  return React167.createElement("div", {
    className,
    style: {
      ...positionStyle,
      ...style2
    },
    onMouseDown: onInternalStartMove,
    onTouchStart: onInternalStartMove
  });
};
var Track_default = Track;

// node_modules/@rc-component/slider/es/Tracks/index.js
var Tracks = (props) => {
  const {
    prefixCls,
    style: style2,
    values,
    startPoint,
    onStartMove
  } = props;
  const {
    included,
    range: range3,
    min,
    styles,
    classNames
  } = React168.useContext(context_default4);
  const trackList = React168.useMemo(() => {
    if (!range3) {
      if (values.length === 0) {
        return [];
      }
      const startValue = startPoint ?? min;
      const endValue = values[0];
      return [{
        start: Math.min(startValue, endValue),
        end: Math.max(startValue, endValue)
      }];
    }
    const list = [];
    for (let i = 0; i < values.length - 1; i += 1) {
      list.push({
        start: values[i],
        end: values[i + 1]
      });
    }
    return list;
  }, [values, range3, startPoint, min]);
  if (!included) {
    return null;
  }
  const tracksNode = trackList?.length && (classNames.tracks || styles.tracks) ? React168.createElement(Track_default, {
    index: null,
    prefixCls,
    start: trackList[0].start,
    end: trackList[trackList.length - 1].end,
    replaceCls: clsx(classNames.tracks, `${prefixCls}-tracks`),
    style: styles.tracks
  }) : null;
  return React168.createElement(React168.Fragment, null, tracksNode, trackList.map(({
    start,
    end
  }, index) => React168.createElement(Track_default, {
    index,
    prefixCls,
    style: {
      ...getIndex(style2, index),
      ...styles.track
    },
    start,
    end,
    key: index,
    onStartMove
  })));
};
var Tracks_default = Tracks;

// node_modules/@rc-component/slider/es/hooks/useDrag.js
var React169 = __toESM(require_react());
var REMOVE_DIST = 130;
function getPosition2(e) {
  const obj = "targetTouches" in e ? e.targetTouches[0] : e;
  return {
    pageX: obj.pageX,
    pageY: obj.pageY
  };
}
function useDrag(containerRef, direction, rawValues, min, max, formatValue, triggerChange, finishChange, offsetValues, editable, minCount) {
  const [draggingValue, setDraggingValue] = React169.useState(null);
  const [draggingIndex, setDraggingIndex] = React169.useState(-1);
  const [draggingDelete, setDraggingDelete] = React169.useState(false);
  const [cacheValues, setCacheValues] = React169.useState(rawValues);
  const [originValues, setOriginValues] = React169.useState(rawValues);
  const mouseMoveEventRef = React169.useRef(null);
  const mouseUpEventRef = React169.useRef(null);
  const touchEventTargetRef = React169.useRef(null);
  const {
    onDragStart,
    onDragChange
  } = React169.useContext(UnstableContext);
  useLayoutEffect_default(() => {
    if (draggingIndex === -1) {
      setCacheValues(rawValues);
    }
  }, [rawValues, draggingIndex]);
  React169.useEffect(() => () => {
    document.removeEventListener("mousemove", mouseMoveEventRef.current);
    document.removeEventListener("mouseup", mouseUpEventRef.current);
    if (touchEventTargetRef.current) {
      touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
      touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
    }
  }, []);
  const flushValues = (nextValues, nextValue, deleteMark) => {
    if (nextValue !== void 0) {
      setDraggingValue(nextValue);
    }
    setCacheValues(nextValues);
    let changeValues = nextValues;
    if (deleteMark) {
      changeValues = nextValues.filter((_, i) => i !== draggingIndex);
    }
    triggerChange(changeValues);
    if (onDragChange) {
      onDragChange({
        rawValues: nextValues,
        deleteIndex: deleteMark ? draggingIndex : -1,
        draggingIndex,
        draggingValue: nextValue
      });
    }
  };
  const updateCacheValue = useEvent_default((valueIndex, offsetPercent, deleteMark) => {
    if (valueIndex === -1) {
      const startValue = originValues[0];
      const endValue = originValues[originValues.length - 1];
      const maxStartOffset = min - startValue;
      const maxEndOffset = max - endValue;
      let offset = offsetPercent * (max - min);
      offset = Math.max(offset, maxStartOffset);
      offset = Math.min(offset, maxEndOffset);
      const formatStartValue = formatValue(startValue + offset);
      offset = formatStartValue - startValue;
      const cloneCacheValues = originValues.map((val) => val + offset);
      flushValues(cloneCacheValues);
    } else {
      const offsetDist = (max - min) * offsetPercent;
      const cloneValues = [...cacheValues];
      cloneValues[valueIndex] = originValues[valueIndex];
      const next2 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
      flushValues(next2.values, next2.value, deleteMark);
    }
  });
  const onStartMove = (e, valueIndex, startValues) => {
    e.stopPropagation();
    const initialValues = startValues || rawValues;
    const originValue = initialValues[valueIndex];
    setDraggingIndex(valueIndex);
    setDraggingValue(originValue);
    setOriginValues(initialValues);
    setCacheValues(initialValues);
    setDraggingDelete(false);
    const {
      pageX: startX,
      pageY: startY
    } = getPosition2(e);
    let deleteMark = false;
    if (onDragStart) {
      onDragStart({
        rawValues: initialValues,
        draggingIndex: valueIndex,
        draggingValue: originValue
      });
    }
    const onMouseMove = (event) => {
      event.preventDefault();
      const {
        pageX: moveX,
        pageY: moveY
      } = getPosition2(event);
      const offsetX = moveX - startX;
      const offsetY = moveY - startY;
      const {
        width,
        height
      } = containerRef.current.getBoundingClientRect();
      let offSetPercent;
      let removeDist;
      switch (direction) {
        case "btt":
          offSetPercent = -offsetY / height;
          removeDist = offsetX;
          break;
        case "ttb":
          offSetPercent = offsetY / height;
          removeDist = offsetX;
          break;
        case "rtl":
          offSetPercent = -offsetX / width;
          removeDist = offsetY;
          break;
        default:
          offSetPercent = offsetX / width;
          removeDist = offsetY;
      }
      deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;
      setDraggingDelete(deleteMark);
      updateCacheValue(valueIndex, offSetPercent, deleteMark);
    };
    const onMouseUp = (event) => {
      event.preventDefault();
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
      if (touchEventTargetRef.current) {
        touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
        touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
      }
      mouseMoveEventRef.current = null;
      mouseUpEventRef.current = null;
      touchEventTargetRef.current = null;
      finishChange(deleteMark);
      setDraggingIndex(-1);
      setDraggingDelete(false);
    };
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    e.currentTarget.addEventListener("touchend", onMouseUp);
    e.currentTarget.addEventListener("touchmove", onMouseMove);
    mouseMoveEventRef.current = onMouseMove;
    mouseUpEventRef.current = onMouseUp;
    touchEventTargetRef.current = e.currentTarget;
  };
  const returnValues = React169.useMemo(() => {
    const sourceValues = [...rawValues].sort((a, b) => a - b);
    const targetValues = [...cacheValues].sort((a, b) => a - b);
    const counts = {};
    targetValues.forEach((val) => {
      counts[val] = (counts[val] || 0) + 1;
    });
    sourceValues.forEach((val) => {
      counts[val] = (counts[val] || 0) - 1;
    });
    const maxDiffCount = editable ? 1 : 0;
    const diffCount = Object.values(counts).reduce((prev2, next2) => prev2 + Math.abs(next2), 0);
    return diffCount <= maxDiffCount ? cacheValues : rawValues;
  }, [rawValues, cacheValues, editable]);
  return [draggingIndex, draggingValue, draggingDelete, returnValues, onStartMove];
}
var useDrag_default = useDrag;

// node_modules/@rc-component/slider/es/hooks/useOffset.js
var React170 = __toESM(require_react());
function useOffset(min, max, step, markList, allowCross, pushable) {
  const formatRangeValue = React170.useCallback((val) => Math.max(min, Math.min(max, val)), [min, max]);
  const formatStepValue = React170.useCallback((val) => {
    if (step !== null) {
      const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
      const getDecimal = (num) => (String(num).split(".")[1] || "").length;
      const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
      const fixedValue = Number(stepValue.toFixed(maxDecimal));
      return min <= fixedValue && fixedValue <= max ? fixedValue : null;
    }
    return null;
  }, [step, min, max, formatRangeValue]);
  const formatValue = React170.useCallback((val) => {
    const formatNextValue = formatRangeValue(val);
    const alignValues = markList.map((mark) => mark.value);
    if (step !== null) {
      alignValues.push(formatStepValue(val));
    }
    alignValues.push(min, max);
    let closeValue = alignValues[0];
    let closeDist = max - min;
    alignValues.forEach((alignValue) => {
      const dist = Math.abs(formatNextValue - alignValue);
      if (dist <= closeDist) {
        closeValue = alignValue;
        closeDist = dist;
      }
    });
    return closeValue;
  }, [min, max, markList, step, formatRangeValue, formatStepValue]);
  const offsetValue = (values, offset, valueIndex, mode = "unit") => {
    if (typeof offset === "number") {
      let nextValue;
      const originValue = values[valueIndex];
      const targetDistValue = originValue + offset;
      let potentialValues = [];
      markList.forEach((mark) => {
        potentialValues.push(mark.value);
      });
      potentialValues.push(min, max);
      potentialValues.push(formatStepValue(originValue));
      const sign = offset > 0 ? 1 : -1;
      if (mode === "unit") {
        potentialValues.push(formatStepValue(originValue + sign * step));
      } else {
        potentialValues.push(formatStepValue(targetDistValue));
      }
      potentialValues = potentialValues.filter((val) => val !== null).filter((val) => offset < 0 ? val <= originValue : val >= originValue);
      if (mode === "unit") {
        potentialValues = potentialValues.filter((val) => val !== originValue);
      }
      const compareValue = mode === "unit" ? originValue : targetDistValue;
      nextValue = potentialValues[0];
      let valueDist = Math.abs(nextValue - compareValue);
      potentialValues.forEach((potentialValue) => {
        const dist = Math.abs(potentialValue - compareValue);
        if (dist < valueDist) {
          nextValue = potentialValue;
          valueDist = dist;
        }
      });
      if (nextValue === void 0) {
        return offset < 0 ? min : max;
      }
      if (mode === "dist") {
        return nextValue;
      }
      if (Math.abs(offset) > 1) {
        const cloneValues = [...values];
        cloneValues[valueIndex] = nextValue;
        return offsetValue(cloneValues, offset - sign, valueIndex, mode);
      }
      return nextValue;
    } else if (offset === "min") {
      return min;
    } else if (offset === "max") {
      return max;
    }
  };
  const offsetChangedValue = (values, offset, valueIndex, mode = "unit") => {
    const originValue = values[valueIndex];
    const nextValue = offsetValue(values, offset, valueIndex, mode);
    return {
      value: nextValue,
      changed: nextValue !== originValue
    };
  };
  const needPush = (dist) => {
    return pushable === null && dist === 0 || typeof pushable === "number" && dist < pushable;
  };
  const offsetValues = (values, offset, valueIndex, mode = "unit") => {
    const nextValues = values.map(formatValue);
    const originValue = nextValues[valueIndex];
    const nextValue = offsetValue(nextValues, offset, valueIndex, mode);
    nextValues[valueIndex] = nextValue;
    if (allowCross === false) {
      const pushNum = pushable || 0;
      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {
        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
      }
      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {
        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
      }
    } else if (typeof pushable === "number" || pushable === null) {
      for (let i = valueIndex + 1; i < nextValues.length; i += 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i],
            changed
          } = offsetChangedValue(nextValues, 1, i));
        }
      }
      for (let i = valueIndex; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i - 1],
            changed
          } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = nextValues.length - 1; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i - 1],
            changed
          } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = 0; i < nextValues.length - 1; i += 1) {
        let changed = true;
        while (needPush(nextValues[i + 1] - nextValues[i]) && changed) {
          ({
            value: nextValues[i + 1],
            changed
          } = offsetChangedValue(nextValues, 1, i + 1));
        }
      }
    }
    return {
      value: nextValues[valueIndex],
      values: nextValues
    };
  };
  return [formatValue, offsetValues];
}

// node_modules/@rc-component/slider/es/hooks/useRange.js
var import_react78 = __toESM(require_react());
function useRange(range3) {
  return (0, import_react78.useMemo)(() => {
    if (range3 === true || !range3) {
      return [!!range3, false, false, 0];
    }
    const {
      editable,
      draggableTrack,
      minCount,
      maxCount
    } = range3;
    if (true) {
      warning(!editable || !draggableTrack, "`editable` can not work with `draggableTrack`.");
    }
    return [true, editable, !editable && draggableTrack, minCount || 0, maxCount];
  }, [range3]);
}

// node_modules/@rc-component/slider/es/Slider.js
var Slider2 = React171.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-slider",
    className,
    style: style2,
    classNames,
    styles,
    id,
    // Status
    disabled = false,
    keyboard = true,
    autoFocus,
    onFocus,
    onBlur,
    // Value
    min = 0,
    max = 100,
    step = 1,
    value,
    defaultValue,
    range: range3,
    count,
    onChange,
    onBeforeChange,
    onAfterChange,
    onChangeComplete,
    // Cross
    allowCross = true,
    pushable = false,
    // Direction
    reverse,
    vertical,
    // Style
    included = true,
    startPoint,
    trackStyle,
    handleStyle,
    railStyle,
    dotStyle,
    activeDotStyle,
    // Decorations
    marks,
    dots,
    // Components
    handleRender,
    activeHandleRender,
    track,
    // Accessibility
    tabIndex = 0,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle
  } = props;
  const handlesRef = React171.useRef(null);
  const containerRef = React171.useRef(null);
  const direction = React171.useMemo(() => {
    if (vertical) {
      return reverse ? "ttb" : "btt";
    }
    return reverse ? "rtl" : "ltr";
  }, [reverse, vertical]);
  const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range3);
  const mergedMin = React171.useMemo(() => isFinite(min) ? min : 0, [min]);
  const mergedMax = React171.useMemo(() => isFinite(max) ? max : 100, [max]);
  const mergedStep = React171.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);
  const mergedPush = React171.useMemo(() => {
    if (typeof pushable === "boolean") {
      return pushable ? mergedStep : false;
    }
    return pushable >= 0 ? pushable : false;
  }, [pushable, mergedStep]);
  const markList = React171.useMemo(() => {
    return Object.keys(marks || {}).map((key) => {
      const mark = marks[key];
      const markObj = {
        value: Number(key)
      };
      if (mark && typeof mark === "object" && !React171.isValidElement(mark) && ("label" in mark || "style" in mark)) {
        markObj.style = mark.style;
        markObj.label = mark.label;
      } else {
        markObj.label = mark;
      }
      return markObj;
    }).filter(({
      label
    }) => label || typeof label === "number").sort((a, b) => a.value - b.value);
  }, [marks]);
  const [formatValue, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);
  const [mergedValue, setValue] = useControlledState(defaultValue, value);
  const rawValues = React171.useMemo(() => {
    const valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    const [val0 = mergedMin] = valueList;
    let returnValues = mergedValue === null ? [] : [val0];
    if (rangeEnabled) {
      returnValues = [...valueList];
      if (count || mergedValue === void 0) {
        const pointCount = count >= 0 ? count + 1 : 2;
        returnValues = returnValues.slice(0, pointCount);
        while (returnValues.length < pointCount) {
          returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);
        }
      }
      returnValues.sort((a, b) => a - b);
    }
    returnValues.forEach((val, index) => {
      returnValues[index] = formatValue(val);
    });
    return returnValues;
  }, [mergedValue, rangeEnabled, mergedMin, count, formatValue]);
  const getTriggerValue = (triggerValues) => rangeEnabled ? triggerValues : triggerValues[0];
  const triggerChange = useEvent_default((nextValues) => {
    const cloneNextValues = [...nextValues].sort((a, b) => a - b);
    if (onChange && !isEqual_default(cloneNextValues, rawValues, true)) {
      onChange(getTriggerValue(cloneNextValues));
    }
    setValue(cloneNextValues);
  });
  const finishChange = useEvent_default((draggingDelete2) => {
    if (draggingDelete2) {
      handlesRef.current.hideHelp();
    }
    const finishValue = getTriggerValue(rawValues);
    onAfterChange?.(finishValue);
    warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
    onChangeComplete?.(finishValue);
  });
  const onDelete = (index) => {
    if (disabled || !rangeEditable || rawValues.length <= minCount) {
      return;
    }
    const cloneNextValues = [...rawValues];
    cloneNextValues.splice(index, 1);
    onBeforeChange?.(getTriggerValue(cloneNextValues));
    triggerChange(cloneNextValues);
    const nextFocusIndex = Math.max(0, index - 1);
    handlesRef.current.hideHelp();
    handlesRef.current.focus(nextFocusIndex);
  };
  const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag_default(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue, triggerChange, finishChange, offsetValues, rangeEditable, minCount);
  const changeToCloseValue = (newValue, e) => {
    if (!disabled) {
      const cloneNextValues = [...rawValues];
      let valueIndex = 0;
      let valueBeforeIndex = 0;
      let valueDist = mergedMax - mergedMin;
      rawValues.forEach((val, index) => {
        const dist = Math.abs(newValue - val);
        if (dist <= valueDist) {
          valueDist = dist;
          valueIndex = index;
        }
        if (val < newValue) {
          valueBeforeIndex = index;
        }
      });
      let focusIndex = valueIndex;
      if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {
        cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);
        focusIndex = valueBeforeIndex + 1;
      } else {
        cloneNextValues[valueIndex] = newValue;
      }
      if (rangeEnabled && !rawValues.length && count === void 0) {
        cloneNextValues.push(newValue);
      }
      const nextValue = getTriggerValue(cloneNextValues);
      onBeforeChange?.(nextValue);
      triggerChange(cloneNextValues);
      if (e) {
        document.activeElement?.blur?.();
        handlesRef.current.focus(focusIndex);
        onStartDrag(e, focusIndex, cloneNextValues);
      } else {
        onAfterChange?.(nextValue);
        warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
        onChangeComplete?.(nextValue);
      }
    }
  };
  const onSliderMouseDown = (e) => {
    e.preventDefault();
    const {
      width,
      height,
      left,
      top,
      bottom,
      right
    } = containerRef.current.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = e;
    let percent;
    switch (direction) {
      case "btt":
        percent = (bottom - clientY) / height;
        break;
      case "ttb":
        percent = (clientY - top) / height;
        break;
      case "rtl":
        percent = (right - clientX) / width;
        break;
      default:
        percent = (clientX - left) / width;
    }
    const nextValue = mergedMin + percent * (mergedMax - mergedMin);
    changeToCloseValue(formatValue(nextValue), e);
  };
  const [keyboardValue, setKeyboardValue] = React171.useState(null);
  const onHandleOffsetChange = (offset, valueIndex) => {
    if (!disabled) {
      const next2 = offsetValues(rawValues, offset, valueIndex);
      onBeforeChange?.(getTriggerValue(rawValues));
      triggerChange(next2.values);
      setKeyboardValue(next2.value);
    }
  };
  React171.useEffect(() => {
    if (keyboardValue !== null) {
      const valueIndex = rawValues.indexOf(keyboardValue);
      if (valueIndex >= 0) {
        handlesRef.current.focus(valueIndex);
      }
    }
    setKeyboardValue(null);
  }, [keyboardValue]);
  const mergedDraggableTrack = React171.useMemo(() => {
    if (rangeDraggableTrack && mergedStep === null) {
      if (true) {
        warning_default(false, "`draggableTrack` is not supported when `step` is `null`.");
      }
      return false;
    }
    return rangeDraggableTrack;
  }, [rangeDraggableTrack, mergedStep]);
  const onStartMove = useEvent_default((e, valueIndex) => {
    onStartDrag(e, valueIndex);
    onBeforeChange?.(getTriggerValue(rawValues));
  });
  const dragging = draggingIndex !== -1;
  React171.useEffect(() => {
    if (!dragging) {
      const valueIndex = rawValues.lastIndexOf(draggingValue);
      handlesRef.current.focus(valueIndex);
    }
  }, [dragging]);
  const sortedCacheValues = React171.useMemo(() => [...cacheValues].sort((a, b) => a - b), [cacheValues]);
  const [includedStart, includedEnd] = React171.useMemo(() => {
    if (!rangeEnabled) {
      return [mergedMin, sortedCacheValues[0]];
    }
    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
  }, [sortedCacheValues, rangeEnabled, mergedMin]);
  React171.useImperativeHandle(ref, () => ({
    focus: () => {
      handlesRef.current.focus(0);
    },
    blur: () => {
      const {
        activeElement
      } = document;
      if (containerRef.current?.contains(activeElement)) {
        activeElement?.blur();
      }
    }
  }));
  React171.useEffect(() => {
    if (autoFocus) {
      handlesRef.current.focus(0);
    }
  }, []);
  const context = React171.useMemo(() => ({
    min: mergedMin,
    max: mergedMax,
    direction,
    disabled,
    keyboard,
    step: mergedStep,
    included,
    includedStart,
    includedEnd,
    range: rangeEnabled,
    tabIndex,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle,
    styles: styles || {},
    classNames: classNames || {}
  }), [mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, rangeEnabled, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames]);
  return React171.createElement(context_default4.Provider, {
    value: context
  }, React171.createElement("div", {
    ref: containerRef,
    className: clsx(prefixCls, className, {
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-vertical`]: vertical,
      [`${prefixCls}-horizontal`]: !vertical,
      [`${prefixCls}-with-marks`]: markList.length
    }),
    style: style2,
    onMouseDown: onSliderMouseDown,
    id
  }, React171.createElement("div", {
    className: clsx(`${prefixCls}-rail`, classNames?.rail),
    style: {
      ...railStyle,
      ...styles?.rail
    }
  }), track !== false && React171.createElement(Tracks_default, {
    prefixCls,
    style: trackStyle,
    values: rawValues,
    startPoint,
    onStartMove: mergedDraggableTrack ? onStartMove : void 0
  }), React171.createElement(Steps_default, {
    prefixCls,
    marks: markList,
    dots,
    style: dotStyle,
    activeStyle: activeDotStyle
  }), React171.createElement(Handles_default, {
    ref: handlesRef,
    prefixCls,
    style: handleStyle,
    values: cacheValues,
    draggingIndex,
    draggingDelete,
    onStartMove,
    onOffsetChange: onHandleOffsetChange,
    onFocus,
    onBlur,
    handleRender,
    activeHandleRender,
    onChangeComplete: finishChange,
    onDelete: rangeEditable ? onDelete : void 0
  }), React171.createElement(Marks_default, {
    prefixCls,
    marks: markList,
    onClick: changeToCloseValue
  })));
});
if (true) {
  Slider2.displayName = "Slider";
}
var Slider_default2 = Slider2;

// node_modules/@rc-component/slider/es/index.js
var es_default16 = Slider_default2;

// node_modules/antd/es/slider/index.js
var import_react81 = __toESM(require_react());

// node_modules/antd/es/slider/Context.js
var import_react79 = __toESM(require_react());
var SliderInternalContext = (0, import_react79.createContext)({});
var Context_default3 = SliderInternalContext;

// node_modules/antd/es/slider/SliderTooltip.js
var React172 = __toESM(require_react());
var import_react80 = __toESM(require_react());
var SliderTooltip = React172.forwardRef((props, ref) => {
  const {
    open,
    draggingDelete,
    value
  } = props;
  const innerRef = (0, import_react80.useRef)(null);
  const mergedOpen = open && !draggingDelete;
  const rafRef = (0, import_react80.useRef)(null);
  function cancelKeepAlign() {
    raf_default.cancel(rafRef.current);
    rafRef.current = null;
  }
  function keepAlign() {
    rafRef.current = raf_default(() => {
      innerRef.current?.forceAlign();
      rafRef.current = null;
    });
  }
  React172.useEffect(() => {
    if (mergedOpen) {
      keepAlign();
    } else {
      cancelKeepAlign();
    }
    return cancelKeepAlign;
  }, [mergedOpen, props.title, value]);
  return React172.createElement(tooltip_default, {
    ref: composeRef(innerRef, ref),
    ...props,
    open: mergedOpen
  });
});
if (true) {
  SliderTooltip.displayName = "SliderTooltip";
}
var SliderTooltip_default = SliderTooltip;

// node_modules/antd/es/slider/style/index.js
var genBaseStyle3 = (token2) => {
  const {
    componentCls,
    antCls,
    controlSize,
    dotSize,
    marginFull,
    marginPart,
    colorFillContentHover,
    handleColorDisabled,
    calc,
    handleSize,
    handleSizeHover,
    handleActiveColor,
    handleActiveOutlineColor,
    handleLineWidth,
    handleLineWidthHover,
    motionDurationMid
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      height: controlSize,
      margin: `${unit(marginPart)} ${unit(marginFull)}`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      "&-vertical": {
        margin: `${unit(marginFull)} ${unit(marginPart)}`
      },
      [`${componentCls}-rail`]: {
        position: "absolute",
        backgroundColor: token2.railBg,
        borderRadius: token2.borderRadiusXS,
        transition: `background-color ${motionDurationMid}`
      },
      [`${componentCls}-track,${componentCls}-tracks`]: {
        position: "absolute",
        transition: `background-color ${motionDurationMid}`
      },
      [`${componentCls}-track`]: {
        backgroundColor: token2.trackBg,
        borderRadius: token2.borderRadiusXS
      },
      [`${componentCls}-track-draggable`]: {
        boxSizing: "content-box",
        backgroundClip: "content-box",
        border: "solid rgba(0,0,0,0)"
      },
      "&:hover": {
        [`${componentCls}-rail`]: {
          backgroundColor: token2.railHoverBg
        },
        [`${componentCls}-track`]: {
          backgroundColor: token2.trackHoverBg
        },
        [`${componentCls}-dot`]: {
          borderColor: colorFillContentHover
        },
        [`${componentCls}-handle::after`]: {
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token2.colorPrimaryBorderHover}`
        },
        [`${componentCls}-dot-active`]: {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`${componentCls}-handle`]: {
        position: "absolute",
        width: handleSize,
        height: handleSize,
        outline: "none",
        userSelect: "none",
        // Dragging status
        "&-dragging-delete": {
          opacity: 0
        },
        // 
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: calc(handleLineWidth).mul(-1).equal(),
          insetBlockStart: calc(handleLineWidth).mul(-1).equal(),
          width: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
          height: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: handleSize,
          height: handleSize,
          backgroundColor: token2.colorBgElevated,
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token2.handleColor}`,
          outline: `0px solid transparent`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${motionDurationMid},
            inset-block-start ${motionDurationMid},
            width ${motionDurationMid},
            height ${motionDurationMid},
            box-shadow ${motionDurationMid},
            outline ${motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
            insetBlockStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
            width: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal(),
            height: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal()
          },
          "&::after": {
            boxShadow: `0 0 0 ${unit(handleLineWidthHover)} ${handleActiveColor}`,
            outline: `6px solid ${handleActiveOutlineColor}`,
            width: handleSizeHover,
            height: handleSizeHover,
            insetInlineStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal(),
            insetBlockStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal()
          }
        }
      },
      [`&-lock ${componentCls}-handle`]: {
        "&::before, &::after": {
          transition: "none"
        }
      },
      [`${componentCls}-mark`]: {
        position: "absolute",
        fontSize: token2.fontSize
      },
      [`${componentCls}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: token2.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: token2.colorText
        }
      },
      [`${componentCls}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        width: dotSize,
        height: dotSize,
        backgroundColor: token2.colorBgElevated,
        border: `${unit(handleLineWidth)} solid ${token2.dotBorderColor}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        pointerEvents: "auto",
        "&-active": {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-rail`]: {
          backgroundColor: `${token2.railBg} !important`
        },
        [`${componentCls}-track`]: {
          backgroundColor: `${token2.trackBgDisabled} !important`
        },
        [`
          ${componentCls}-dot
        `]: {
          backgroundColor: token2.colorBgElevated,
          borderColor: token2.trackBgDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${componentCls}-handle::after`]: {
          backgroundColor: token2.colorBgElevated,
          cursor: "not-allowed",
          width: handleSize,
          height: handleSize,
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${handleColorDisabled}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
          cursor: `not-allowed !important`
        }
      },
      [`&-tooltip ${antCls}-tooltip-container`]: {
        minWidth: "unset"
      }
    }
  };
};
var genDirectionStyle = (token2, horizontal) => {
  const {
    componentCls,
    railSize,
    handleSize,
    dotSize,
    marginFull,
    calc
  } = token2;
  const railPadding = horizontal ? "paddingBlock" : "paddingInline";
  const full = horizontal ? "width" : "height";
  const part = horizontal ? "height" : "width";
  const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
  const markInset = horizontal ? "top" : "insetInlineStart";
  const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
  const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
  const draggableBorder = horizontal ? {
    borderWidth: `${unit(draggableBorderSize)} 0`,
    transform: `translateY(${unit(calc(draggableBorderSize).mul(-1).equal())})`
  } : {
    borderWidth: `0 ${unit(draggableBorderSize)}`,
    transform: `translateX(${unit(token2.calc(draggableBorderSize).mul(-1).equal())})`
  };
  return {
    [railPadding]: railSize,
    [part]: calc(railSize).mul(3).equal(),
    [`${componentCls}-rail`]: {
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-track,${componentCls}-tracks`]: {
      [part]: railSize
    },
    [`${componentCls}-track-draggable`]: {
      ...draggableBorder
    },
    [`${componentCls}-handle`]: {
      [handlePos]: handlePosSize
    },
    [`${componentCls}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      // https://github.com/ant-design/ant-design/issues/43731
      [markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
      [full]: "100%"
    },
    [`${componentCls}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: railSize,
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-dot`]: {
      position: "absolute",
      [handlePos]: calc(railSize).sub(dotSize).div(2).equal()
    }
  };
};
var genHorizontalStyle = (token2) => {
  const {
    componentCls,
    marginPartWithMark
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      ...genDirectionStyle(token2, true),
      [`&${componentCls}-with-marks`]: {
        marginBottom: marginPartWithMark
      }
    }
  };
};
var genVerticalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: {
      ...genDirectionStyle(token2, false),
      height: "100%"
    }
  };
};
var prepareComponentToken7 = (token2) => {
  const increaseHandleWidth = 1;
  const controlSize = token2.controlHeightLG / 4;
  const controlSizeHover = token2.controlHeightSM / 2;
  const handleLineWidth = token2.lineWidth + increaseHandleWidth;
  const handleLineWidthHover = token2.lineWidth + increaseHandleWidth * 1.5;
  const handleActiveColor = token2.colorPrimary;
  const handleActiveOutlineColor = new FastColor(handleActiveColor).setA(0.2).toRgbString();
  return {
    controlSize,
    railSize: 4,
    handleSize: controlSize,
    handleSizeHover: controlSizeHover,
    dotSize: 8,
    handleLineWidth,
    handleLineWidthHover,
    railBg: token2.colorFillTertiary,
    railHoverBg: token2.colorFillSecondary,
    trackBg: token2.colorPrimaryBorder,
    trackHoverBg: token2.colorPrimaryBorderHover,
    handleColor: token2.colorPrimaryBorder,
    handleActiveColor,
    handleActiveOutlineColor,
    handleColorDisabled: new FastColor(token2.colorTextDisabled).onBackground(token2.colorBgContainer).toHexString(),
    dotBorderColor: token2.colorBorderSecondary,
    dotActiveBorderColor: token2.colorPrimaryBorder,
    trackBgDisabled: token2.colorBgContainerDisabled
  };
};
var style_default9 = genStyleHooks("Slider", (token2) => {
  const sliderToken = merge2(token2, {
    marginPart: token2.calc(token2.controlHeight).sub(token2.controlSize).div(2).equal(),
    marginFull: token2.calc(token2.controlSize).div(2).equal(),
    marginPartWithMark: token2.calc(token2.controlHeightLG).sub(token2.controlSize).equal()
  });
  return [genBaseStyle3(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken)];
}, prepareComponentToken7);

// node_modules/antd/es/slider/useRafLock.js
var React173 = __toESM(require_react());
function useRafLock() {
  const [state, setState] = React173.useState(false);
  const rafRef = React173.useRef(null);
  const cleanup2 = () => {
    raf_default.cancel(rafRef.current);
  };
  const setDelayState = (nextState) => {
    cleanup2();
    if (nextState) {
      setState(nextState);
    } else {
      rafRef.current = raf_default(() => {
        setState(nextState);
      });
    }
  };
  React173.useEffect(() => cleanup2, []);
  return [state, setDelayState];
}

// node_modules/antd/es/slider/index.js
function getTipFormatter(tipFormatter) {
  if (tipFormatter || tipFormatter === null) {
    return tipFormatter;
  }
  return (val) => typeof val === "number" ? val.toString() : "";
}
var Slider3 = import_react81.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    range: range3,
    className,
    rootClassName,
    style: style2,
    disabled,
    // Deprecated Props
    tooltip = {},
    onChangeComplete,
    classNames,
    styles,
    vertical,
    orientation,
    ...restProps
  } = props;
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const {
    getPrefixCls,
    direction: contextDirection,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    getPopupContainer
  } = useComponentConfig("slider");
  const contextDisabled = import_react81.default.useContext(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const mergedProps = {
    ...props,
    disabled: mergedDisabled,
    vertical: mergedVertical
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const {
    handleRender: contextHandleRender,
    direction: internalContextDirection
  } = import_react81.default.useContext(Context_default3);
  const mergedDirection = internalContextDirection || contextDirection;
  const isRTL = mergedDirection === "rtl";
  const [hoverOpen, setHoverOpen] = useRafLock();
  const [focusOpen, setFocusOpen] = useRafLock();
  const tooltipProps = {
    ...tooltip
  };
  const {
    open: tooltipOpen,
    placement: tooltipPlacement,
    getPopupContainer: getTooltipPopupContainer,
    prefixCls: customizeTooltipPrefixCls,
    formatter: tipFormatter
  } = tooltipProps;
  const lockOpen = tooltipOpen;
  const activeOpen = (hoverOpen || focusOpen) && lockOpen !== false;
  const mergedTipFormatter = getTipFormatter(tipFormatter);
  const [dragging, setDragging] = useRafLock();
  const onInternalChangeComplete = (nextValues) => {
    onChangeComplete?.(nextValues);
    setDragging(false);
  };
  const getTooltipPlacement = (placement, vert) => {
    if (placement) {
      return placement;
    }
    if (!vert) {
      return "top";
    }
    return isRTL ? "left" : "right";
  };
  const prefixCls = getPrefixCls("slider", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const rootClassNames = clsx(className, contextClassName, mergedClassNames.root, rootClassName, {
    [`${prefixCls}-rtl`]: isRTL,
    [`${prefixCls}-lock`]: dragging
  }, hashId, cssVarCls);
  if (isRTL && !mergedVertical) {
    restProps.reverse = !restProps.reverse;
  }
  if (true) {
    const warning5 = devUseWarning("Slider");
    [["tooltipPrefixCls", "prefixCls"], ["getTooltipPopupContainer", "getPopupContainer"], ["tipFormatter", "formatter"], ["tooltipPlacement", "placement"], ["tooltipVisible", "open"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, `tooltip.${newName}`);
    });
  }
  import_react81.default.useEffect(() => {
    const onMouseUp = () => {
      raf_default(() => {
        setFocusOpen(false);
      }, 1);
    };
    document.addEventListener("mouseup", onMouseUp);
    return () => {
      document.removeEventListener("mouseup", onMouseUp);
    };
  }, []);
  const useActiveTooltipHandle = range3 && !lockOpen;
  const handleRender = contextHandleRender || ((node2, info) => {
    const {
      index
    } = info;
    const nodeProps = node2.props;
    function proxyEvent(eventName, event, triggerRestPropsEvent) {
      if (triggerRestPropsEvent) {
        restProps[eventName]?.(event);
      }
      nodeProps[eventName]?.(event);
    }
    const passedProps = {
      ...nodeProps,
      onMouseEnter: (e) => {
        setHoverOpen(true);
        proxyEvent("onMouseEnter", e);
      },
      onMouseLeave: (e) => {
        setHoverOpen(false);
        proxyEvent("onMouseLeave", e);
      },
      onMouseDown: (e) => {
        setFocusOpen(true);
        setDragging(true);
        proxyEvent("onMouseDown", e);
      },
      onFocus: (e) => {
        setFocusOpen(true);
        restProps.onFocus?.(e);
        proxyEvent("onFocus", e, true);
      },
      onBlur: (e) => {
        setFocusOpen(false);
        restProps.onBlur?.(e);
        proxyEvent("onBlur", e, true);
      }
    };
    const cloneNode = import_react81.default.cloneElement(node2, passedProps);
    const open = (!!lockOpen || activeOpen) && mergedTipFormatter !== null;
    if (!useActiveTooltipHandle) {
      return import_react81.default.createElement(SliderTooltip_default, {
        ...tooltipProps,
        prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
        title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
        value: info.value,
        open,
        placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
        key: index,
        classNames: {
          root: `${prefixCls}-tooltip`
        },
        getPopupContainer: getTooltipPopupContainer || getPopupContainer
      }, cloneNode);
    }
    return cloneNode;
  });
  const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
    const cloneNode = import_react81.default.cloneElement(handle, {
      style: {
        ...handle.props.style,
        visibility: "hidden"
      }
    });
    return import_react81.default.createElement(SliderTooltip_default, {
      ...tooltipProps,
      prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
      title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
      open: mergedTipFormatter !== null && activeOpen,
      placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
      key: "tooltip",
      classNames: {
        root: `${prefixCls}-tooltip`
      },
      getPopupContainer: getTooltipPopupContainer || getPopupContainer,
      draggingDelete: info.draggingDelete
    }, cloneNode);
  } : void 0;
  const rootStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return (
    // @ts-ignore
    import_react81.default.createElement(es_default16, {
      ...restProps,
      classNames: mergedClassNames,
      styles: mergedStyles,
      step: restProps.step,
      range: range3,
      className: rootClassNames,
      style: rootStyle,
      disabled: mergedDisabled,
      vertical: mergedVertical,
      ref,
      prefixCls,
      handleRender,
      activeHandleRender,
      onChangeComplete: onInternalChangeComplete
    })
  );
});
if (true) {
  Slider3.displayName = "Slider";
}
var slider_default = Slider3;

// node_modules/antd/es/color-picker/components/ColorSlider.js
var GradientColorSlider = (props) => {
  const {
    prefixCls,
    colors,
    type: type5,
    color,
    range: range3 = false,
    className,
    activeIndex,
    onActive,
    onDragStart,
    onDragChange,
    onKeyDelete,
    ...restProps
  } = props;
  const sliderProps = {
    ...restProps,
    track: false
  };
  const linearCss = React175.useMemo(() => {
    const colorsStr = colors.map((c) => `${c.color} ${c.percent}%`).join(", ");
    return `linear-gradient(90deg, ${colorsStr})`;
  }, [colors]);
  const pointColor = React175.useMemo(() => {
    if (!color || !type5) {
      return null;
    }
    if (type5 === "alpha") {
      return color.toRgbString();
    }
    return `hsl(${color.toHsb().h}, 100%, 50%)`;
  }, [color, type5]);
  const onInternalDragStart = useEvent_default(onDragStart);
  const onInternalDragChange = useEvent_default(onDragChange);
  const unstableContext = React175.useMemo(() => ({
    onDragStart: onInternalDragStart,
    onDragChange: onInternalDragChange
  }), []);
  const handleRender = useEvent_default((ori, info) => {
    const {
      onFocus,
      style: style2,
      className: handleCls,
      onKeyDown
    } = ori.props;
    const mergedStyle = {
      ...style2
    };
    if (type5 === "gradient") {
      mergedStyle.background = getGradientPercentColor(colors, info.value);
    }
    return React175.cloneElement(ori, {
      onFocus: (e) => {
        onActive?.(info.index);
        onFocus?.(e);
      },
      style: mergedStyle,
      className: clsx(handleCls, {
        [`${prefixCls}-slider-handle-active`]: activeIndex === info.index
      }),
      onKeyDown: (e) => {
        if ((e.key === "Delete" || e.key === "Backspace") && onKeyDelete) {
          onKeyDelete(info.index);
        }
        onKeyDown?.(e);
      }
    });
  });
  const sliderContext = React175.useMemo(() => ({
    direction: "ltr",
    handleRender
  }), []);
  return React175.createElement(Context_default3.Provider, {
    value: sliderContext
  }, React175.createElement(UnstableContext.Provider, {
    value: unstableContext
  }, React175.createElement(slider_default, {
    ...sliderProps,
    className: clsx(className, `${prefixCls}-slider`),
    tooltip: {
      open: false
    },
    range: {
      editable: range3,
      minCount: 2
    },
    styles: {
      rail: {
        background: linearCss
      },
      handle: pointColor ? {
        background: pointColor
      } : {}
    },
    classNames: {
      rail: `${prefixCls}-slider-rail`,
      handle: `${prefixCls}-slider-handle`
    }
  })));
};
var SingleColorSlider = (props) => {
  const {
    value,
    onChange,
    onChangeComplete
  } = props;
  const singleOnChange = (v) => onChange(v[0]);
  const singleOnChangeComplete = (v) => onChangeComplete(v[0]);
  return React175.createElement(GradientColorSlider, {
    ...props,
    value: [value],
    onChange: singleOnChange,
    onChangeComplete: singleOnChangeComplete
  });
};
var ColorSlider_default = SingleColorSlider;

// node_modules/antd/es/color-picker/components/PanelPicker/GradientColorBar.js
var React176 = __toESM(require_react());
function sortColors(colors) {
  return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);
}
var GradientColorBar = (props) => {
  const {
    prefixCls,
    mode,
    onChange,
    onChangeComplete,
    onActive,
    activeIndex,
    onGradientDragging,
    colors
  } = props;
  const isGradient = mode === "gradient";
  const colorList = React176.useMemo(() => colors.map((info) => ({
    percent: info.percent,
    color: info.color.toRgbString()
  })), [colors]);
  const values = React176.useMemo(() => colorList.map((info) => info.percent), [colorList]);
  const colorsRef = React176.useRef(colorList);
  const onDragStart = ({
    rawValues,
    draggingIndex,
    draggingValue
  }) => {
    if (rawValues.length > colorList.length) {
      const newPointColor = getGradientPercentColor(colorList, draggingValue);
      const nextColors = _toConsumableArray(colorList);
      nextColors.splice(draggingIndex, 0, {
        percent: draggingValue,
        color: newPointColor
      });
      colorsRef.current = nextColors;
    } else {
      colorsRef.current = colorList;
    }
    onGradientDragging(true);
    onChange(new AggregationColor(sortColors(colorsRef.current)), true);
  };
  const onDragChange = ({
    deleteIndex,
    draggingIndex,
    draggingValue
  }) => {
    let nextColors = _toConsumableArray(colorsRef.current);
    if (deleteIndex !== -1) {
      nextColors.splice(deleteIndex, 1);
    } else {
      nextColors[draggingIndex] = {
        ...nextColors[draggingIndex],
        percent: draggingValue
      };
      nextColors = sortColors(nextColors);
    }
    onChange(new AggregationColor(nextColors), true);
  };
  const onKeyDelete = (index) => {
    const nextColors = _toConsumableArray(colorList);
    nextColors.splice(index, 1);
    const nextColor = new AggregationColor(nextColors);
    onChange(nextColor);
    onChangeComplete(nextColor);
  };
  const onInternalChangeComplete = (nextValues) => {
    onChangeComplete(new AggregationColor(colorList));
    if (activeIndex >= nextValues.length) {
      onActive(nextValues.length - 1);
    }
    onGradientDragging(false);
  };
  if (!isGradient) {
    return null;
  }
  return React176.createElement(GradientColorSlider, {
    min: 0,
    max: 100,
    prefixCls,
    className: `${prefixCls}-gradient-slider`,
    colors: colorList,
    color: null,
    value: values,
    range: true,
    onChangeComplete: onInternalChangeComplete,
    disabled: false,
    type: "gradient",
    // Active
    activeIndex,
    onActive,
    // Drag
    onDragStart,
    onDragChange,
    onKeyDelete
  });
};
var GradientColorBar_default = React176.memo(GradientColorBar);

// node_modules/antd/es/color-picker/components/PanelPicker/index.js
var components = {
  slider: ColorSlider_default
};
var PanelPicker = () => {
  const panelPickerContext = (0, import_react82.useContext)(PanelPickerContext);
  const {
    mode,
    onModeChange,
    modeOptions,
    prefixCls,
    allowClear,
    value,
    disabledAlpha,
    onChange,
    onClear,
    onChangeComplete,
    activeIndex,
    gradientDragging,
    ...injectProps
  } = panelPickerContext;
  const colors = import_react82.default.useMemo(() => {
    if (!value.cleared) {
      return value.getColors();
    }
    return [{
      percent: 0,
      color: new AggregationColor("")
    }, {
      percent: 100,
      color: new AggregationColor("")
    }];
  }, [value]);
  const isSingle = !value.isGradient();
  const [lockedColor, setLockedColor] = import_react82.default.useState(value);
  useLayoutEffect_default(() => {
    if (!isSingle) {
      setLockedColor(colors[activeIndex]?.color);
    }
  }, [isSingle, colors, gradientDragging, activeIndex]);
  const activeColor = import_react82.default.useMemo(() => {
    if (isSingle) {
      return value;
    }
    if (gradientDragging) {
      return lockedColor;
    }
    return colors[activeIndex]?.color;
  }, [colors, value, activeIndex, isSingle, lockedColor, gradientDragging]);
  const [pickerColor, setPickerColor] = import_react82.default.useState(activeColor);
  const [forceSync, setForceSync] = useForceUpdate();
  const mergedPickerColor = pickerColor?.equals(activeColor) ? activeColor : pickerColor;
  useLayoutEffect_default(() => {
    setPickerColor(activeColor);
  }, [forceSync, activeColor?.toHexString()]);
  const fillColor = (nextColor, info) => {
    let submitColor = generateColor2(nextColor);
    if (value.cleared) {
      const rgb = submitColor.toRgb();
      if (!rgb.r && !rgb.g && !rgb.b && info) {
        const {
          type: infoType,
          value: infoValue = 0
        } = info;
        submitColor = new AggregationColor({
          h: infoType === "hue" ? infoValue : 0,
          s: 1,
          b: 1,
          a: infoType === "alpha" ? infoValue / 100 : 1
        });
      } else {
        submitColor = genAlphaColor(submitColor);
      }
    }
    if (mode === "single") {
      return submitColor;
    }
    const nextColors = _toConsumableArray(colors);
    nextColors[activeIndex] = {
      ...nextColors[activeIndex],
      color: submitColor
    };
    return new AggregationColor(nextColors);
  };
  const onPickerChange = (colorValue, fromPicker, info) => {
    const nextColor = fillColor(colorValue, info);
    setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);
    onChange(nextColor, fromPicker);
  };
  const onInternalChangeComplete = (nextColor, info) => {
    onChangeComplete(fillColor(nextColor, info));
    setForceSync();
  };
  const onInputChange = (colorValue) => {
    onChange(fillColor(colorValue));
  };
  let operationNode = null;
  const showMode = modeOptions.length > 1;
  if (allowClear || showMode) {
    operationNode = import_react82.default.createElement("div", {
      className: `${prefixCls}-operation`
    }, showMode && import_react82.default.createElement(segmented_default, {
      size: "small",
      options: modeOptions,
      value: mode,
      onChange: onModeChange
    }), import_react82.default.createElement(ColorClear_default, {
      prefixCls,
      value,
      onChange: (clearColor) => {
        onChange(clearColor);
        onClear?.();
      },
      ...injectProps
    }));
  }
  return import_react82.default.createElement(import_react82.default.Fragment, null, operationNode, import_react82.default.createElement(GradientColorBar_default, {
    ...panelPickerContext,
    colors
  }), import_react82.default.createElement(es_default8, {
    prefixCls,
    value: mergedPickerColor?.toHsb(),
    disabledAlpha,
    onChange: (colorValue, info) => {
      onPickerChange(colorValue, true, info);
    },
    onChangeComplete: (colorValue, info) => {
      onInternalChangeComplete(colorValue, info);
    },
    components
  }), import_react82.default.createElement(ColorInput_default, {
    value: activeColor,
    onChange: onInputChange,
    prefixCls,
    disabledAlpha,
    ...injectProps
  }));
};
var PanelPicker_default = PanelPicker;

// node_modules/antd/es/color-picker/components/PanelPresets.js
var import_react88 = __toESM(require_react());

// node_modules/antd/es/color-picker/components/ColorPresets.js
var import_react87 = __toESM(require_react());

// node_modules/antd/es/collapse/Collapse.js
var React183 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/Collapse.js
var import_react86 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/hooks/useItems.js
var import_react85 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/Panel.js
var import_react84 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/PanelContent.js
var import_react83 = __toESM(require_react());
var PanelContent = import_react83.default.forwardRef((props, ref) => {
  const {
    prefixCls,
    forceRender,
    className,
    style: style2,
    children,
    isActive: isActive2,
    role,
    classNames: customizeClassNames,
    styles
  } = props;
  const [rendered, setRendered] = import_react83.default.useState(isActive2 || forceRender);
  import_react83.default.useEffect(() => {
    if (forceRender || isActive2) {
      setRendered(true);
    }
  }, [forceRender, isActive2]);
  if (!rendered) {
    return null;
  }
  return import_react83.default.createElement("div", {
    ref,
    className: clsx(`${prefixCls}-panel`, {
      [`${prefixCls}-panel-active`]: isActive2,
      [`${prefixCls}-panel-inactive`]: !isActive2
    }, className),
    style: style2,
    role
  }, import_react83.default.createElement("div", {
    className: clsx(`${prefixCls}-body`, customizeClassNames?.body),
    style: styles?.body
  }, children));
});
if (true) {
  PanelContent.displayName = "PanelContent";
}
var PanelContent_default = PanelContent;

// node_modules/@rc-component/collapse/es/Panel.js
var CollapsePanel = import_react84.default.forwardRef((props, ref) => {
  const {
    showArrow = true,
    headerClass,
    isActive: isActive2,
    onItemClick,
    forceRender,
    className,
    classNames: customizeClassNames = {},
    styles = {},
    prefixCls,
    collapsible,
    accordion,
    panelKey,
    extra,
    header,
    expandIcon,
    openMotion,
    destroyOnHidden,
    children,
    ...resetProps
  } = props;
  const disabled = collapsible === "disabled";
  const ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
  const collapsibleProps = {
    onClick: () => {
      onItemClick?.(panelKey);
    },
    onKeyDown: (e) => {
      if (e.key === "Enter" || e.keyCode === KeyCode_default.ENTER || e.which === KeyCode_default.ENTER) {
        onItemClick?.(panelKey);
      }
    },
    role: accordion ? "tab" : "button",
    ["aria-expanded"]: isActive2,
    ["aria-disabled"]: disabled,
    tabIndex: disabled ? -1 : 0
  };
  const iconNodeInner = typeof expandIcon === "function" ? expandIcon(props) : import_react84.default.createElement("i", {
    className: "arrow"
  });
  const iconNode = iconNodeInner && import_react84.default.createElement("div", _extends10({
    className: clsx(`${prefixCls}-expand-icon`, customizeClassNames?.icon),
    style: styles?.icon
  }, ["header", "icon"].includes(collapsible) ? collapsibleProps : {}), iconNodeInner);
  const collapsePanelClassNames = clsx(`${prefixCls}-item`, {
    [`${prefixCls}-item-active`]: isActive2,
    [`${prefixCls}-item-disabled`]: disabled
  }, className);
  const headerClassName = clsx(headerClass, `${prefixCls}-header`, {
    [`${prefixCls}-collapsible-${collapsible}`]: !!collapsible
  }, customizeClassNames?.header);
  const headerProps = {
    className: headerClassName,
    style: styles?.header,
    ...["header", "icon"].includes(collapsible) ? {} : collapsibleProps
  };
  return import_react84.default.createElement("div", _extends10({}, resetProps, {
    ref,
    className: collapsePanelClassNames
  }), import_react84.default.createElement("div", headerProps, showArrow && iconNode, import_react84.default.createElement("span", _extends10({
    className: clsx(`${prefixCls}-title`, customizeClassNames?.title),
    style: styles?.title
  }, collapsible === "header" ? collapsibleProps : {}), header), ifExtraExist && import_react84.default.createElement("div", {
    className: `${prefixCls}-extra`
  }, extra)), import_react84.default.createElement(es_default5, _extends10({
    visible: isActive2,
    leavedClassName: `${prefixCls}-panel-hidden`
  }, openMotion, {
    forceRender,
    removeOnLeave: destroyOnHidden
  }), ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => {
    return import_react84.default.createElement(PanelContent_default, {
      ref: motionRef,
      prefixCls,
      className: motionClassName,
      classNames: customizeClassNames,
      style: motionStyle,
      styles,
      isActive: isActive2,
      forceRender,
      role: accordion ? "tabpanel" : void 0
    }, children);
  }));
});
var Panel_default = CollapsePanel;

// node_modules/@rc-component/collapse/es/hooks/useItems.js
var convertItemsToNodes = (items, props) => {
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon,
    classNames: collapseClassNames,
    styles
  } = props;
  return items.map((item, index) => {
    const {
      children,
      label,
      key: rawKey,
      collapsible: rawCollapsible,
      onItemClick: rawOnItemClick,
      destroyOnHidden: rawDestroyOnHidden,
      ...restProps
    } = item;
    const key = String(rawKey ?? index);
    const mergeCollapsible = rawCollapsible ?? collapsible;
    const mergedDestroyOnHidden = rawDestroyOnHidden ?? destroyOnHidden;
    const handleItemClick = (value) => {
      if (mergeCollapsible === "disabled") {
        return;
      }
      onItemClick(value);
      rawOnItemClick?.(value);
    };
    let isActive2 = false;
    if (accordion) {
      isActive2 = activeKey[0] === key;
    } else {
      isActive2 = activeKey.indexOf(key) > -1;
    }
    return import_react85.default.createElement(Panel_default, _extends10({}, restProps, {
      classNames: collapseClassNames,
      styles,
      prefixCls,
      key,
      panelKey: key,
      isActive: isActive2,
      accordion,
      openMotion,
      expandIcon,
      header: label,
      collapsible: mergeCollapsible,
      onItemClick: handleItemClick,
      destroyOnHidden: mergedDestroyOnHidden
    }), children);
  });
};
var getNewChild = (child, index, props) => {
  if (!child) {
    return null;
  }
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon,
    classNames: collapseClassNames,
    styles
  } = props;
  const key = child.key || String(index);
  const {
    header,
    headerClass,
    destroyOnHidden: childDestroyOnHidden,
    collapsible: childCollapsible,
    onItemClick: childOnItemClick
  } = child.props;
  let isActive2 = false;
  if (accordion) {
    isActive2 = activeKey[0] === key;
  } else {
    isActive2 = activeKey.indexOf(key) > -1;
  }
  const mergeCollapsible = childCollapsible ?? collapsible;
  const handleItemClick = (value) => {
    if (mergeCollapsible === "disabled") {
      return;
    }
    onItemClick(value);
    childOnItemClick?.(value);
  };
  const childProps = {
    key,
    panelKey: key,
    header,
    headerClass,
    classNames: collapseClassNames,
    styles,
    isActive: isActive2,
    prefixCls,
    destroyOnHidden: childDestroyOnHidden ?? destroyOnHidden,
    openMotion,
    accordion,
    children: child.props.children,
    onItemClick: handleItemClick,
    expandIcon,
    collapsible: mergeCollapsible
  };
  if (typeof child.type === "string") {
    return child;
  }
  Object.keys(childProps).forEach((propName) => {
    if (typeof childProps[propName] === "undefined") {
      delete childProps[propName];
    }
  });
  return import_react85.default.cloneElement(child, childProps);
};
function useItems(items, rawChildren, props) {
  if (Array.isArray(items)) {
    return convertItemsToNodes(items, props);
  }
  return toArray(rawChildren).map((child, index) => getNewChild(child, index, props));
}
var useItems_default = useItems;

// node_modules/@rc-component/collapse/es/Collapse.js
function getActiveKeysArray(activeKey) {
  let currentActiveKey = activeKey;
  if (!Array.isArray(currentActiveKey)) {
    const activeKeyType = typeof currentActiveKey;
    currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
  }
  return currentActiveKey.map((key) => String(key));
}
var Collapse = import_react86.default.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-collapse",
    destroyOnHidden = false,
    style: style2,
    accordion,
    className,
    children,
    collapsible,
    openMotion,
    expandIcon,
    activeKey: rawActiveKey,
    defaultActiveKey,
    onChange,
    items,
    classNames: customizeClassNames,
    styles
  } = props;
  const collapseClassName = clsx(prefixCls, className);
  const [internalActiveKey, setActiveKey] = useControlledState(defaultActiveKey, rawActiveKey);
  const activeKey = getActiveKeysArray(internalActiveKey);
  const triggerActiveKey = useEvent_default((next2) => {
    const nextKeys = getActiveKeysArray(next2);
    setActiveKey(nextKeys);
    onChange?.(nextKeys);
  });
  const onItemClick = (key) => {
    if (accordion) {
      triggerActiveKey(activeKey[0] === key ? [] : [key]);
    } else {
      triggerActiveKey(activeKey.includes(key) ? activeKey.filter((item) => item !== key) : [...activeKey, key]);
    }
  };
  warning_default(!children, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
  const mergedChildren = useItems_default(items, children, {
    prefixCls,
    accordion,
    openMotion,
    expandIcon,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    classNames: customizeClassNames,
    styles
  });
  return import_react86.default.createElement("div", _extends10({
    ref,
    className: collapseClassName,
    style: style2,
    role: accordion ? "tablist" : void 0
  }, pickAttrs(props, {
    aria: true,
    data: true
  })), mergedChildren);
});
var Collapse_default = Object.assign(Collapse, {
  /**
   * @deprecated use `items` instead, will be removed in `v4.0.0`
   */
  Panel: Panel_default
});

// node_modules/@rc-component/collapse/es/index.js
var es_default17 = Collapse_default;
var {
  Panel
} = Collapse_default;

// node_modules/antd/es/collapse/CollapsePanel.js
var React182 = __toESM(require_react());
var CollapsePanel2 = React182.forwardRef((props, ref) => {
  if (true) {
    const warning5 = devUseWarning("Collapse.Panel");
    warning5.deprecated(!("disabled" in props), "disabled", 'collapsible="disabled"');
  }
  const {
    getPrefixCls
  } = React182.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showArrow = true
  } = props;
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const collapsePanelClassName = clsx({
    [`${prefixCls}-no-arrow`]: !showArrow
  }, className);
  return React182.createElement(es_default17.Panel, {
    ref,
    ...props,
    prefixCls,
    className: collapsePanelClassName
  });
});
var CollapsePanel_default = CollapsePanel2;

// node_modules/antd/es/collapse/style/index.js
var genBaseStyle4 = (token2) => {
  const {
    componentCls,
    contentBg,
    padding,
    headerBg,
    headerPadding,
    collapseHeaderPaddingSM,
    collapseHeaderPaddingLG,
    collapsePanelBorderRadius,
    lineWidth,
    lineType,
    colorBorder,
    colorText,
    colorTextHeading,
    colorTextDisabled,
    fontSizeLG,
    lineHeight,
    lineHeightLG,
    marginSM,
    paddingSM,
    paddingLG,
    paddingXS,
    motionDurationSlow,
    fontSizeIcon,
    contentPadding,
    fontHeight,
    fontHeightLG
  } = token2;
  const borderBase = `${unit(lineWidth)} ${lineType} ${colorBorder}`;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      backgroundColor: headerBg,
      border: borderBase,
      borderRadius: collapsePanelBorderRadius,
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${componentCls}-item`]: {
        borderBottom: borderBase,
        "&:first-child": {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)} 0 0`
          }
        },
        "&:last-child": {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}`
          }
        },
        [`> ${componentCls}-header`]: {
          position: "relative",
          // Compatible with old version of antd, should remove in next version
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: headerPadding,
          color: colorTextHeading,
          lineHeight,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}, visibility 0s`,
          ...genFocusStyle(token2),
          [`> ${componentCls}-title`]: {
            flex: "auto"
          },
          // >>>>> Arrow
          [`${componentCls}-expand-icon`]: {
            height: fontHeight,
            display: "flex",
            alignItems: "center",
            marginInlineEnd: marginSM
          },
          [`${componentCls}-arrow`]: {
            ...resetIcon(),
            fontSize: fontSizeIcon,
            // when `transform: rotate()` is applied to icon's root element
            transition: `transform ${motionDurationSlow}`,
            // when `transform: rotate()` is applied to icon's child element
            svg: {
              transition: `transform ${motionDurationSlow}`
            }
          },
          // >>>>> Text
          [`${componentCls}-title`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${componentCls}-collapsible-header`]: {
          cursor: "default",
          [`${componentCls}-title`]: {
            flex: "none",
            cursor: "pointer"
          },
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`${componentCls}-collapsible-icon`]: {
          cursor: "unset",
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        }
      },
      [`${componentCls}-panel`]: {
        color: colorText,
        backgroundColor: contentBg,
        borderTop: borderBase,
        [`& > ${componentCls}-body`]: {
          padding: contentPadding
        },
        "&-hidden": {
          display: "none"
        }
      },
      "&-small": {
        [`> ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingSM,
            paddingInlineStart: paddingXS,
            [`> ${componentCls}-expand-icon`]: {
              // Arrow offset
              marginInlineStart: token2.calc(paddingSM).sub(paddingXS).equal()
            }
          },
          [`> ${componentCls}-panel > ${componentCls}-body`]: {
            padding: paddingSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-item`]: {
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingLG,
            paddingInlineStart: padding,
            [`> ${componentCls}-expand-icon`]: {
              height: fontHeightLG,
              // Arrow offset
              marginInlineStart: token2.calc(paddingLG).sub(padding).equal()
            }
          },
          [`> ${componentCls}-panel > ${componentCls}-body`]: {
            padding: paddingLG
          }
        }
      },
      [`${componentCls}-item:last-child`]: {
        borderBottom: 0,
        [`> ${componentCls}-panel`]: {
          borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}`
        }
      },
      [`& ${componentCls}-item-disabled > ${componentCls}-header`]: {
        [`
          &,
          & > .arrow
        `]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Placement ==========================
      [`&${componentCls}-icon-placement-end`]: {
        [`& > ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            [`${componentCls}-expand-icon`]: {
              order: 1,
              marginInlineEnd: 0,
              marginInlineStart: marginSM
            }
          }
        }
      }
    }
  };
};
var genArrowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
  return {
    [`${componentCls}-rtl`]: {
      [fixedSelector]: {
        transform: `rotate(180deg)`
      }
    }
  };
};
var genBorderlessStyle2 = (token2) => {
  const {
    componentCls,
    headerBg,
    borderlessContentPadding,
    borderlessContentBg,
    colorBorder
  } = token2;
  return {
    [`${componentCls}-borderless`]: {
      backgroundColor: headerBg,
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: `1px solid ${colorBorder}`
      },
      [`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: {
        borderRadius: 0
      },
      [`> ${componentCls}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${componentCls}-item > ${componentCls}-panel`]: {
        backgroundColor: borderlessContentBg,
        borderTop: 0
      },
      [`> ${componentCls}-item > ${componentCls}-panel > ${componentCls}-body`]: {
        padding: borderlessContentPadding
      }
    }
  };
};
var genGhostStyle = (token2) => {
  const {
    componentCls,
    paddingSM
  } = token2;
  return {
    [`${componentCls}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: 0,
        [`> ${componentCls}-panel`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${componentCls}-body`]: {
            paddingBlock: paddingSM
          }
        }
      }
    }
  };
};
var prepareComponentToken8 = (token2) => ({
  headerPadding: `${token2.paddingSM}px ${token2.padding}px`,
  headerBg: token2.colorFillAlter,
  contentPadding: `${token2.padding}px 16px`,
  // Fixed Value
  contentBg: token2.colorBgContainer,
  borderlessContentPadding: `${token2.paddingXXS}px 16px ${token2.padding}px`,
  borderlessContentBg: "transparent"
});
var style_default10 = genStyleHooks("Collapse", (token2) => {
  const collapseToken = merge2(token2, {
    collapseHeaderPaddingSM: `${unit(token2.paddingXS)} ${unit(token2.paddingSM)}`,
    collapseHeaderPaddingLG: `${unit(token2.padding)} ${unit(token2.paddingLG)}`,
    collapsePanelBorderRadius: token2.borderRadiusLG
  });
  return [genBaseStyle4(collapseToken), genBorderlessStyle2(collapseToken), genGhostStyle(collapseToken), genArrowStyle(collapseToken), collapse_default(collapseToken)];
}, prepareComponentToken8);

// node_modules/antd/es/collapse/Collapse.js
var Collapse2 = React183.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction,
    expandIcon: contextExpandIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("collapse");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    bordered = true,
    ghost,
    size: customizeSize,
    expandIconPlacement,
    expandIconPosition,
    children,
    destroyInactivePanel,
    destroyOnHidden,
    expandIcon,
    classNames,
    styles
  } = props;
  const mergedSize = useSize_default((ctx) => customizeSize ?? ctx ?? "middle");
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [hashId, cssVarCls] = style_default10(prefixCls);
  const mergedPlacement = expandIconPlacement ?? expandIconPosition ?? "start";
  const mergedProps = {
    ...props,
    size: mergedSize,
    bordered,
    expandIconPlacement: mergedPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedExpandIcon = expandIcon ?? contextExpandIcon;
  if (true) {
    const warning5 = devUseWarning("Collapse");
    [["destroyInactivePanel", "destroyOnHidden"], ["expandIconPosition", "expandIconPlacement"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const renderExpandIcon = React183.useCallback((panelProps = {}) => {
    const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : React183.createElement(RightOutlined_default, {
      rotate: panelProps.isActive ? direction === "rtl" ? -90 : 90 : void 0,
      "aria-label": panelProps.isActive ? "expanded" : "collapsed"
    });
    return cloneElement7(icon, () => ({
      className: clsx(icon?.props?.className, `${prefixCls}-arrow`)
    }));
  }, [mergedExpandIcon, prefixCls, direction]);
  const collapseClassName = clsx(`${prefixCls}-icon-placement-${mergedPlacement}`, {
    [`${prefixCls}-borderless`]: !bordered,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-ghost`]: !!ghost,
    [`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
  }, contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const openMotion = React183.useMemo(() => ({
    ...motion_default(rootPrefixCls),
    motionAppear: false,
    leavedClassName: `${prefixCls}-panel-hidden`
  }), [rootPrefixCls, prefixCls]);
  const items = React183.useMemo(() => {
    if (children) {
      return toArray(children).map((child) => child);
    }
    return null;
  }, [children]);
  return (
    // @ts-ignore
    React183.createElement(es_default17, {
      ref,
      openMotion,
      ...omit(props, ["rootClassName"]),
      expandIcon: renderExpandIcon,
      prefixCls,
      className: collapseClassName,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      classNames: mergedClassNames,
      styles: mergedStyles,
      destroyOnHidden: destroyOnHidden ?? destroyInactivePanel
    }, items)
  );
});
if (true) {
  Collapse2.displayName = "Collapse";
}
var Collapse_default2 = Object.assign(Collapse2, {
  Panel: CollapsePanel_default
});

// node_modules/antd/es/collapse/index.js
var collapse_default2 = Collapse_default2;

// node_modules/antd/es/color-picker/components/ColorPresets.js
var genPresetColor2 = (list) => list.map((value) => {
  value.colors = value.colors.map(generateColor2);
  return value;
});
var isBright = (value, bgColorToken) => {
  const {
    r,
    g,
    b,
    a
  } = value.toRgb();
  const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
  if (a <= 0.5) {
    return hsv.v > 0.5;
  }
  return r * 0.299 + g * 0.587 + b * 0.114 > 192;
};
var genCollapsePanelKey = (preset, index) => {
  const mergedKey = preset.key ?? index;
  return `panel-${mergedKey}`;
};
var ColorPresets = ({
  prefixCls,
  presets,
  value: color,
  onChange
}) => {
  const [locale5] = useLocale_default("ColorPicker");
  const [, token2] = useToken();
  const presetsValue = (0, import_react87.useMemo)(() => genPresetColor2(presets), [presets]);
  const colorPresetsPrefixCls = `${prefixCls}-presets`;
  const activeKeys = (0, import_react87.useMemo)(() => presetsValue.reduce((acc, preset, index) => {
    const {
      defaultOpen = true
    } = preset;
    if (defaultOpen) {
      acc.push(genCollapsePanelKey(preset, index));
    }
    return acc;
  }, []), [presetsValue]);
  const handleClick = (colorValue) => {
    onChange?.(colorValue);
  };
  const items = presetsValue.map((preset, index) => ({
    key: genCollapsePanelKey(preset, index),
    label: import_react87.default.createElement("div", {
      className: `${colorPresetsPrefixCls}-label`
    }, preset?.label),
    children: import_react87.default.createElement("div", {
      className: `${colorPresetsPrefixCls}-items`
    }, Array.isArray(preset?.colors) && preset.colors?.length > 0 ? preset.colors.map((presetColor, index2) => {
      const colorInst = generateColor2(presetColor);
      return import_react87.default.createElement(
        ColorBlock_default,
        {
          // eslint-disable-next-line react/no-array-index-key
          key: `preset-${index2}-${presetColor.toHexString()}`,
          color: colorInst.toCssString(),
          prefixCls,
          className: clsx(`${colorPresetsPrefixCls}-color`, {
            [`${colorPresetsPrefixCls}-color-checked`]: presetColor.toCssString() === color?.toCssString(),
            [`${colorPresetsPrefixCls}-color-bright`]: isBright(presetColor, token2.colorBgElevated)
          }),
          onClick: () => handleClick(presetColor)
        }
      );
    }) : import_react87.default.createElement("span", {
      className: `${colorPresetsPrefixCls}-empty`
    }, locale5.presetEmpty))
  }));
  return import_react87.default.createElement("div", {
    className: colorPresetsPrefixCls
  }, import_react87.default.createElement(collapse_default2, {
    defaultActiveKey: activeKeys,
    ghost: true,
    items
  }));
};
var ColorPresets_default = ColorPresets;

// node_modules/antd/es/color-picker/components/PanelPresets.js
var PanelPresets = () => {
  const {
    prefixCls,
    value,
    presets,
    onChange
  } = (0, import_react88.useContext)(PanelPresetsContext);
  return Array.isArray(presets) ? import_react88.default.createElement(ColorPresets_default, {
    value,
    presets,
    prefixCls,
    onChange
  }) : null;
};
var PanelPresets_default = PanelPresets;

// node_modules/antd/es/color-picker/ColorPickerPanel.js
var ColorPickerPanel = (props) => {
  const {
    prefixCls,
    presets,
    panelRender,
    value,
    onChange,
    onClear,
    allowClear,
    disabledAlpha,
    mode,
    onModeChange,
    modeOptions,
    onChangeComplete,
    activeIndex,
    onActive,
    format: format2,
    onFormatChange,
    gradientDragging,
    onGradientDragging,
    disabledFormat
  } = props;
  const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
  const panelContext = import_react89.default.useMemo(() => ({
    prefixCls,
    value,
    onChange,
    onClear,
    allowClear,
    disabledAlpha,
    mode,
    onModeChange,
    modeOptions,
    onChangeComplete,
    activeIndex,
    onActive,
    format: format2,
    onFormatChange,
    gradientDragging,
    onGradientDragging,
    disabledFormat
  }), [prefixCls, value, onChange, onClear, allowClear, disabledAlpha, mode, onModeChange, modeOptions, onChangeComplete, activeIndex, onActive, format2, onFormatChange, gradientDragging, onGradientDragging, disabledFormat]);
  const presetContext = import_react89.default.useMemo(() => ({
    prefixCls,
    value,
    presets,
    onChange
  }), [prefixCls, value, presets, onChange]);
  const innerPanel = import_react89.default.createElement("div", {
    className: `${colorPickerPanelPrefixCls}-content`
  }, import_react89.default.createElement(PanelPicker_default, null), Array.isArray(presets) && import_react89.default.createElement(divider_default, null), import_react89.default.createElement(PanelPresets_default, null));
  return import_react89.default.createElement(PanelPickerContext.Provider, {
    value: panelContext
  }, import_react89.default.createElement(PanelPresetsContext.Provider, {
    value: presetContext
  }, import_react89.default.createElement("div", {
    className: colorPickerPanelPrefixCls
  }, typeof panelRender === "function" ? panelRender(innerPanel, {
    components: {
      Picker: PanelPicker_default,
      Presets: PanelPresets_default
    }
  }) : innerPanel)));
};
if (true) {
  ColorPickerPanel.displayName = "ColorPickerPanel";
}
var ColorPickerPanel_default = ColorPickerPanel;

// node_modules/antd/es/color-picker/components/ColorTrigger.js
var import_react90 = __toESM(require_react());
var ColorTrigger = (0, import_react90.forwardRef)((props, ref) => {
  const {
    color,
    prefixCls,
    open,
    disabled,
    format: format2,
    className,
    showText,
    activeIndex,
    ...rest
  } = props;
  const colorTriggerPrefixCls = `${prefixCls}-trigger`;
  const colorTextPrefixCls = `${colorTriggerPrefixCls}-text`;
  const colorTextCellPrefixCls = `${colorTextPrefixCls}-cell`;
  const [locale5] = useLocale_default("ColorPicker");
  const desc = import_react90.default.useMemo(() => {
    if (!showText) {
      return "";
    }
    if (typeof showText === "function") {
      return showText(color);
    }
    if (color.cleared) {
      return locale5.transparent;
    }
    if (color.isGradient()) {
      return color.getColors().map((c, index) => {
        const inactive = activeIndex !== -1 && activeIndex !== index;
        return import_react90.default.createElement("span", {
          key: index,
          className: clsx(colorTextCellPrefixCls, inactive && `${colorTextCellPrefixCls}-inactive`)
        }, c.color.toRgbString(), " ", c.percent, "%");
      });
    }
    const hexString = color.toHexString().toUpperCase();
    const alpha = getColorAlpha(color);
    switch (format2) {
      case "rgb":
        return color.toRgbString();
      case "hsb":
        return color.toHsbString();
      // case 'hex':
      default:
        return alpha < 100 ? `${hexString.slice(0, 7)},${alpha}%` : hexString;
    }
  }, [color, format2, showText, activeIndex, locale5.transparent, colorTextCellPrefixCls]);
  const containerNode = (0, import_react90.useMemo)(() => color.cleared ? import_react90.default.createElement(ColorClear_default, {
    prefixCls
  }) : import_react90.default.createElement(ColorBlock_default, {
    prefixCls,
    color: color.toCssString()
  }), [color, prefixCls]);
  return import_react90.default.createElement("div", {
    ref,
    className: clsx(colorTriggerPrefixCls, className, {
      [`${colorTriggerPrefixCls}-active`]: open,
      [`${colorTriggerPrefixCls}-disabled`]: disabled
    }),
    ...pickAttrs(rest)
  }, containerNode, showText && import_react90.default.createElement("div", {
    className: colorTextPrefixCls
  }, desc));
});
var ColorTrigger_default = ColorTrigger;

// node_modules/antd/es/color-picker/hooks/useModeColor.js
var React188 = __toESM(require_react());
function useModeColor(defaultValue, value, mode) {
  const [locale5] = useLocale_default("ColorPicker");
  const [mergedColor, setMergedColor] = useControlledState(defaultValue, value);
  const [modeState, setModeState] = React188.useState("single");
  const [modeOptionList, modeSet] = React188.useMemo(() => {
    const list = (Array.isArray(mode) ? mode : [mode]).filter((m) => m);
    if (!list.length) {
      list.push("single");
    }
    const modes = new Set(list);
    const optionList = [];
    const pushOption = (modeType, localeTxt) => {
      if (modes.has(modeType)) {
        optionList.push({
          label: localeTxt,
          value: modeType
        });
      }
    };
    pushOption("single", locale5.singleColor);
    pushOption("gradient", locale5.gradientColor);
    return [optionList, modes];
  }, [mode, locale5.singleColor, locale5.gradientColor]);
  const [cacheColor, setCacheColor] = React188.useState(null);
  const setColor = useEvent_default((nextColor) => {
    setCacheColor(nextColor);
    setMergedColor(nextColor);
  });
  const postColor = React188.useMemo(() => {
    const colorObj = generateColor2(mergedColor || "");
    return colorObj.equals(cacheColor) ? cacheColor : colorObj;
  }, [mergedColor, cacheColor]);
  const postMode = React188.useMemo(() => {
    if (modeSet.has(modeState)) {
      return modeState;
    }
    return modeOptionList[0]?.value;
  }, [modeSet, modeState, modeOptionList]);
  React188.useEffect(() => {
    setModeState(postColor.isGradient() ? "gradient" : "single");
  }, [postColor]);
  return [postColor, setColor, postMode, setModeState, modeOptionList];
}

// node_modules/antd/es/color-picker/style/color-block.js
var getTransBg = (size, colorFill) => ({
  backgroundImage: `conic-gradient(${colorFill} 25%, transparent 25% 50%, ${colorFill} 50% 75%, transparent 75% 100%)`,
  backgroundSize: `${size} ${size}`
});
var genColorBlockStyle = (token2, size) => {
  const {
    componentCls,
    borderRadiusSM,
    colorPickerInsetShadow,
    lineWidth,
    colorFillSecondary
  } = token2;
  return {
    [`${componentCls}-color-block`]: {
      position: "relative",
      borderRadius: borderRadiusSM,
      width: size,
      height: size,
      boxShadow: colorPickerInsetShadow,
      flex: "none",
      ...getTransBg("50%", token2.colorFillSecondary),
      [`${componentCls}-color-block-inner`]: {
        width: "100%",
        height: "100%",
        boxShadow: `inset 0 0 0 ${unit(lineWidth)} ${colorFillSecondary}`,
        borderRadius: "inherit"
      }
    }
  };
};
var color_block_default = genColorBlockStyle;

// node_modules/antd/es/color-picker/style/input.js
var genInputStyle2 = (token2) => {
  const {
    componentCls,
    antCls,
    fontSizeSM,
    lineHeightSM,
    colorPickerAlphaInputWidth,
    marginXXS,
    paddingXXS,
    controlHeightSM,
    marginXS,
    fontSizeIcon,
    paddingXS,
    colorTextPlaceholder,
    colorPickerInputNumberHandleWidth,
    lineWidth
  } = token2;
  return {
    [`${componentCls}-input-container`]: {
      display: "flex",
      [`${componentCls}-steppers${antCls}-input-number`]: {
        fontSize: fontSizeSM,
        lineHeight: lineHeightSM,
        padding: 0,
        [`${antCls}-input-number-input`]: {
          paddingInlineStart: paddingXXS,
          paddingInlineEnd: 0
        },
        [`${antCls}-input-number-handler-wrap`]: {
          width: colorPickerInputNumberHandleWidth
        }
      },
      [`${componentCls}-steppers${componentCls}-alpha-input`]: {
        flex: `0 0 ${unit(colorPickerAlphaInputWidth)}`,
        marginInlineStart: marginXXS
      },
      [`${componentCls}-format-select${antCls}-select`]: {
        marginInlineEnd: marginXS,
        width: "auto",
        "&-single": {
          [`${antCls}-select-selector`]: {
            padding: 0,
            border: 0
          },
          [`${antCls}-select-arrow`]: {
            insetInlineEnd: 0
          },
          [`${antCls}-select-selection-item`]: {
            paddingInlineEnd: token2.calc(fontSizeIcon).add(marginXXS).equal(),
            fontSize: fontSizeSM,
            lineHeight: unit(controlHeightSM)
          },
          [`${antCls}-select-item-option-content`]: {
            fontSize: fontSizeSM,
            lineHeight: lineHeightSM
          },
          [`${antCls}-select-dropdown`]: {
            [`${antCls}-select-item`]: {
              minHeight: "auto"
            }
          }
        }
      },
      [`${componentCls}-input`]: {
        gap: marginXXS,
        alignItems: "center",
        flex: 1,
        width: 0,
        [`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
          height: controlHeightSM,
          display: "flex",
          gap: marginXXS,
          alignItems: "center"
        },
        [`${componentCls}-steppers`]: {
          flex: 1
        },
        [`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
          flex: 1,
          padding: `0 ${unit(paddingXS)}`,
          [`${antCls}-input`]: {
            fontSize: fontSizeSM,
            textTransform: "uppercase",
            lineHeight: unit(token2.calc(controlHeightSM).sub(token2.calc(lineWidth).mul(2)).equal())
          },
          [`${antCls}-input-prefix`]: {
            color: colorTextPlaceholder
          }
        }
      }
    }
  };
};
var input_default = genInputStyle2;

// node_modules/antd/es/color-picker/style/picker.js
var genPickerStyle = (token2) => {
  const {
    componentCls,
    controlHeightLG,
    borderRadiusSM,
    colorPickerInsetShadow,
    marginSM,
    colorBgElevated,
    colorFillSecondary,
    lineWidthBold,
    colorPickerHandlerSize
  } = token2;
  return {
    userSelect: "none",
    [`${componentCls}-select`]: {
      [`${componentCls}-palette`]: {
        minHeight: token2.calc(controlHeightLG).mul(4).equal(),
        overflow: "hidden",
        borderRadius: borderRadiusSM
      },
      [`${componentCls}-saturation`]: {
        position: "absolute",
        borderRadius: "inherit",
        boxShadow: colorPickerInsetShadow,
        inset: 0
      },
      marginBottom: marginSM
    },
    // ======================== Panel =========================
    [`${componentCls}-handler`]: {
      width: colorPickerHandlerSize,
      height: colorPickerHandlerSize,
      border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
      position: "relative",
      borderRadius: "50%",
      cursor: "pointer",
      boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`
    }
  };
};
var picker_default = genPickerStyle;

// node_modules/antd/es/color-picker/style/presets.js
var genPresetsStyle = (token2) => {
  const {
    componentCls,
    antCls,
    colorTextQuaternary,
    paddingXXS,
    colorPickerPresetColorSize,
    fontSizeSM,
    colorText,
    lineHeightSM,
    lineWidth,
    borderRadius,
    colorFill,
    colorWhite,
    marginXXS,
    paddingXS,
    fontHeightSM
  } = token2;
  return {
    [`${componentCls}-presets`]: {
      [`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
        padding: 0,
        [`${antCls}-collapse-expand-icon`]: {
          height: fontHeightSM,
          color: colorTextQuaternary,
          paddingInlineEnd: paddingXXS
        }
      },
      [`${antCls}-collapse`]: {
        display: "flex",
        flexDirection: "column",
        gap: marginXXS
      },
      [`${antCls}-collapse-item > ${antCls}-collapse-panel > ${antCls}-collapse-body`]: {
        padding: `${unit(paddingXS)} 0`
      },
      "&-label": {
        fontSize: fontSizeSM,
        color: colorText,
        lineHeight: lineHeightSM
      },
      "&-items": {
        display: "flex",
        flexWrap: "wrap",
        gap: token2.calc(marginXXS).mul(1.5).equal(),
        [`${componentCls}-presets-color`]: {
          position: "relative",
          cursor: "pointer",
          width: colorPickerPresetColorSize,
          height: colorPickerPresetColorSize,
          "&::before": {
            content: '""',
            pointerEvents: "none",
            width: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            height: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            position: "absolute",
            top: token2.calc(lineWidth).mul(-2).equal(),
            insetInlineStart: token2.calc(lineWidth).mul(-2).equal(),
            borderRadius,
            border: `${unit(lineWidth)} solid transparent`,
            transition: `border-color ${token2.motionDurationMid} ${token2.motionEaseInBack}`
          },
          "&:hover::before": {
            borderColor: colorFill
          },
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: token2.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
            height: token2.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
            border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          },
          [`&${componentCls}-presets-color-checked`]: {
            "&::after": {
              opacity: 1,
              borderColor: colorWhite,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `transform ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            },
            [`&${componentCls}-presets-color-bright`]: {
              "&::after": {
                borderColor: "rgba(0, 0, 0, 0.45)"
              }
            }
          }
        }
      },
      "&-empty": {
        fontSize: fontSizeSM,
        color: colorTextQuaternary
      }
    }
  };
};
var presets_default = genPresetsStyle;

// node_modules/antd/es/color-picker/style/slider.js
var genSliderStyle = (token2) => {
  const {
    componentCls,
    colorPickerInsetShadow,
    colorBgElevated,
    colorFillSecondary,
    lineWidthBold,
    colorPickerHandlerSizeSM,
    colorPickerSliderHeight,
    marginSM,
    marginXS
  } = token2;
  const handleInnerSize = token2.calc(colorPickerHandlerSizeSM).sub(token2.calc(lineWidthBold).mul(2).equal()).equal();
  const handleHoverSize = token2.calc(colorPickerHandlerSizeSM).add(token2.calc(lineWidthBold).mul(2).equal()).equal();
  const activeHandleStyle = {
    "&:after": {
      transform: "scale(1)",
      boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${token2.colorPrimaryActive}`
    }
  };
  return {
    // ======================== Slider ========================
    [`${componentCls}-slider`]: [getTransBg(unit(colorPickerSliderHeight), token2.colorFillSecondary), {
      margin: 0,
      padding: 0,
      height: colorPickerSliderHeight,
      borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
      "&-rail": {
        height: colorPickerSliderHeight,
        borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
        boxShadow: colorPickerInsetShadow
      },
      [`& ${componentCls}-slider-handle`]: {
        width: handleInnerSize,
        height: handleInnerSize,
        top: 0,
        borderRadius: "100%",
        "&:before": {
          display: "block",
          position: "absolute",
          background: "transparent",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          top: "50%",
          transform: "translate(-50%, -50%)",
          width: handleHoverSize,
          height: handleHoverSize,
          borderRadius: "100%"
        },
        "&:after": {
          width: colorPickerHandlerSizeSM,
          height: colorPickerHandlerSizeSM,
          border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
          boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
          outline: "none",
          insetInlineStart: token2.calc(lineWidthBold).mul(-1).equal(),
          top: token2.calc(lineWidthBold).mul(-1).equal(),
          background: "transparent",
          transition: "none"
        },
        "&:focus": activeHandleStyle
      }
    }],
    // ======================== Layout ========================
    [`${componentCls}-slider-container`]: {
      display: "flex",
      gap: marginSM,
      marginBottom: marginSM,
      // Group
      [`${componentCls}-slider-group`]: {
        flex: 1,
        flexDirection: "column",
        justifyContent: "space-between",
        display: "flex",
        "&-disabled-alpha": {
          justifyContent: "center"
        }
      }
    },
    [`${componentCls}-gradient-slider`]: {
      marginBottom: marginXS,
      [`& ${componentCls}-slider-handle`]: {
        "&:after": {
          transform: "scale(0.8)"
        },
        "&-active, &:focus": activeHandleStyle
      }
    }
  };
};
var slider_default2 = genSliderStyle;

// node_modules/antd/es/color-picker/style/index.js
var genActiveStyle = (token2, borderColor, outlineColor) => ({
  borderInlineEndWidth: token2.lineWidth,
  borderColor,
  boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${outlineColor}`,
  outline: 0
});
var genRtlStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    "&-rtl": {
      [`${componentCls}-presets-color`]: {
        "&::after": {
          direction: "ltr"
        }
      },
      [`${componentCls}-clear`]: {
        "&::after": {
          direction: "ltr"
        }
      }
    }
  };
};
var genClearStyle = (token2, size, extraStyle) => {
  const {
    componentCls,
    borderRadiusSM,
    lineWidth,
    colorSplit,
    colorBorder,
    red6
  } = token2;
  return {
    [`${componentCls}-clear`]: {
      width: size,
      height: size,
      borderRadius: borderRadiusSM,
      border: `${unit(lineWidth)} solid ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      cursor: "inherit",
      transition: `all ${token2.motionDurationFast}`,
      ...extraStyle,
      "&::after": {
        content: '""',
        position: "absolute",
        insetInlineEnd: token2.calc(lineWidth).mul(-1).equal(),
        top: token2.calc(lineWidth).mul(-1).equal(),
        display: "block",
        width: 40,
        // maximum
        height: 2,
        // fixed
        transformOrigin: `calc(100% - 1px) 1px`,
        transform: "rotate(-45deg)",
        backgroundColor: red6
      },
      "&:hover": {
        borderColor: colorBorder
      }
    }
  };
};
var genStatusStyle = (token2) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorHover,
    colorWarningHover,
    colorErrorOutline,
    colorWarningOutline
  } = token2;
  return {
    [`&${componentCls}-status-error`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorError, colorErrorOutline)
      }
    },
    [`&${componentCls}-status-warning`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorWarning, colorWarningOutline)
      }
    }
  };
};
var genSizeStyle = (token2) => {
  const {
    componentCls,
    controlHeightLG,
    controlHeightSM,
    controlHeight,
    controlHeightXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusXS,
    borderRadiusLG,
    fontSizeLG
  } = token2;
  return {
    [`&${componentCls}-lg`]: {
      minWidth: controlHeightLG,
      minHeight: controlHeightLG,
      borderRadius: borderRadiusLG,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeight,
        height: controlHeight,
        borderRadius
      },
      [`${componentCls}-trigger-text`]: {
        fontSize: fontSizeLG
      }
    },
    [`&${componentCls}-sm`]: {
      minWidth: controlHeightSM,
      minHeight: controlHeightSM,
      borderRadius: borderRadiusSM,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeightXS,
        height: controlHeightXS,
        borderRadius: borderRadiusXS
      },
      [`${componentCls}-trigger-text`]: {
        lineHeight: unit(controlHeightXS)
      }
    }
  };
};
var genColorPickerStyle = (token2) => {
  const {
    antCls,
    componentCls,
    colorPickerWidth,
    colorPrimary,
    motionDurationMid,
    colorBgElevated,
    colorTextDisabled,
    colorText,
    colorBgContainerDisabled,
    borderRadius,
    marginXS,
    marginSM,
    controlHeight,
    controlHeightSM,
    colorBgTextActive,
    colorPickerPresetColorSize,
    colorPickerPreviewSize,
    lineWidth,
    colorBorder,
    paddingXXS,
    fontSize,
    colorPrimaryHover,
    controlOutline
  } = token2;
  return [{
    [componentCls]: {
      [`${componentCls}-inner`]: {
        "&-content": {
          display: "flex",
          flexDirection: "column",
          width: colorPickerWidth,
          [`& > ${antCls}-divider`]: {
            margin: `${unit(marginSM)} 0 ${unit(marginXS)}`
          }
        },
        [`${componentCls}-panel`]: {
          ...picker_default(token2)
        },
        ...slider_default2(token2),
        ...color_block_default(token2, colorPickerPreviewSize),
        ...input_default(token2),
        ...presets_default(token2),
        ...genClearStyle(token2, colorPickerPresetColorSize, {
          marginInlineStart: "auto"
        }),
        // Operation bar
        [`${componentCls}-operation`]: {
          display: "flex",
          justifyContent: "space-between",
          marginBottom: marginXS
        }
      },
      "&-trigger": {
        minWidth: controlHeight,
        minHeight: controlHeight,
        borderRadius,
        border: `${unit(lineWidth)} solid ${colorBorder}`,
        cursor: "pointer",
        display: "inline-flex",
        alignItems: "flex-start",
        justifyContent: "center",
        transition: `all ${motionDurationMid}`,
        background: colorBgElevated,
        padding: token2.calc(paddingXXS).sub(lineWidth).equal(),
        [`${componentCls}-trigger-text`]: {
          marginInlineStart: marginXS,
          marginInlineEnd: token2.calc(marginXS).sub(token2.calc(paddingXXS).sub(lineWidth)).equal(),
          fontSize,
          color: colorText,
          alignSelf: "center",
          "&-cell": {
            "&:not(:last-child):after": {
              content: '", "'
            },
            "&-inactive": {
              color: colorTextDisabled
            }
          }
        },
        "&:hover": {
          borderColor: colorPrimaryHover
        },
        [`&${componentCls}-trigger-active`]: {
          ...genActiveStyle(token2, colorPrimary, controlOutline)
        },
        "&-disabled": {
          color: colorTextDisabled,
          background: colorBgContainerDisabled,
          cursor: "not-allowed",
          "&:hover": {
            borderColor: colorBgTextActive
          },
          [`${componentCls}-trigger-text`]: {
            color: colorTextDisabled
          }
        },
        ...genClearStyle(token2, controlHeightSM),
        ...color_block_default(token2, controlHeightSM),
        ...genStatusStyle(token2),
        ...genSizeStyle(token2)
      },
      ...genRtlStyle(token2)
    }
  }, genCompactItemStyle(token2, {
    focusElCls: `${componentCls}-trigger-active`
  })];
};
var style_default11 = genStyleHooks("ColorPicker", (token2) => {
  const {
    colorTextQuaternary,
    marginSM
  } = token2;
  const colorPickerSliderHeight = 8;
  const colorPickerToken = merge2(token2, {
    colorPickerWidth: 234,
    colorPickerHandlerSize: 16,
    colorPickerHandlerSizeSM: 12,
    colorPickerAlphaInputWidth: 44,
    colorPickerInputNumberHandleWidth: 16,
    colorPickerPresetColorSize: 24,
    colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
    colorPickerSliderHeight,
    colorPickerPreviewSize: token2.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
  });
  return genColorPickerStyle(colorPickerToken);
});

// node_modules/antd/es/color-picker/ColorPicker.js
var ColorPicker2 = (props) => {
  const {
    mode,
    value,
    defaultValue,
    format: format2,
    defaultFormat,
    allowClear = false,
    presets,
    children,
    trigger = "click",
    open,
    disabled,
    placement = "bottomLeft",
    arrow = true,
    panelRender,
    showText,
    style: style2,
    className,
    size: customizeSize,
    rootClassName,
    prefixCls: customizePrefixCls,
    styles,
    classNames,
    disabledAlpha = false,
    onFormatChange,
    onChange,
    onClear,
    onOpenChange,
    onChangeComplete,
    getPopupContainer,
    autoAdjustOverflow = true,
    destroyTooltipOnHide,
    destroyOnHidden,
    disabledFormat,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("colorPicker");
  const contextDisabled = (0, import_react91.useContext)(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const mergedProps = {
    ...props,
    trigger,
    allowClear,
    autoAdjustOverflow,
    disabledAlpha,
    arrow,
    placement,
    disabled: mergedDisabled,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const [internalPopupOpen, setPopupOpen] = useControlledState(false, open);
  const popupOpen = !mergedDisabled && internalPopupOpen;
  const [formatValue, setFormatValue] = useControlledState(defaultFormat, format2);
  const triggerFormatChange = (newFormat) => {
    setFormatValue(newFormat);
    if (formatValue !== newFormat) {
      onFormatChange?.(newFormat);
    }
  };
  const triggerOpenChange = (visible) => {
    if (!visible || !mergedDisabled) {
      setPopupOpen(visible);
      onOpenChange?.(visible);
    }
  };
  const [mergedColor, setColor, modeState, setModeState, modeOptions] = useModeColor(defaultValue, value, mode);
  const isAlphaColor = (0, import_react91.useMemo)(() => getColorAlpha(mergedColor) < 100, [mergedColor]);
  const [cachedGradientColor, setCachedGradientColor] = import_react91.default.useState(null);
  const onInternalChangeComplete = (color) => {
    if (onChangeComplete) {
      let changeColor = generateColor2(color);
      if (disabledAlpha && isAlphaColor) {
        changeColor = genAlphaColor(color);
      }
      onChangeComplete(changeColor);
    }
  };
  const onInternalChange = (data, changeFromPickerDrag) => {
    let color = generateColor2(data);
    if (disabledAlpha && isAlphaColor) {
      color = genAlphaColor(color);
    }
    setColor(color);
    setCachedGradientColor(null);
    if (onChange) {
      onChange(color, color.toCssString());
    }
    if (!changeFromPickerDrag) {
      onInternalChangeComplete(color);
    }
  };
  const [activeIndex, setActiveIndex] = import_react91.default.useState(0);
  const [gradientDragging, setGradientDragging] = import_react91.default.useState(false);
  const onInternalModeChange = (newMode) => {
    setModeState(newMode);
    if (newMode === "single" && mergedColor.isGradient()) {
      setActiveIndex(0);
      onInternalChange(new AggregationColor(mergedColor.getColors()[0].color));
      setCachedGradientColor(mergedColor);
    } else if (newMode === "gradient" && !mergedColor.isGradient()) {
      const baseColor = isAlphaColor ? genAlphaColor(mergedColor) : mergedColor;
      onInternalChange(new AggregationColor(cachedGradientColor || [{
        percent: 0,
        color: baseColor
      }, {
        percent: 100,
        color: baseColor
      }]));
    }
  };
  const {
    status: contextStatus
  } = import_react91.default.useContext(FormItemInputContext);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default11(prefixCls, rootCls);
  const rtlCls = {
    [`${prefixCls}-rtl`]: direction
  };
  const mergedRootCls = clsx(mergedClassNames.root, rootClassName, cssVarCls, rootCls, rtlCls);
  const mergedCls = clsx(getStatusClassNames(prefixCls, contextStatus), {
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large"
  }, compactItemClassnames, contextClassName, mergedRootCls, className, hashId);
  const mergedPopupCls = clsx(prefixCls, mergedRootCls, mergedClassNames.popup?.root);
  if (true) {
    const warning5 = devUseWarning("ColorPicker");
    true ? warning5(!(disabledAlpha && isAlphaColor), "usage", "`disabledAlpha` will make the alpha to be 100% when use alpha color.") : void 0;
  }
  const popoverProps = {
    open: popupOpen,
    trigger,
    placement,
    arrow,
    rootClassName,
    getPopupContainer,
    autoAdjustOverflow,
    destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
  };
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return import_react91.default.createElement(popover_default, {
    classNames: {
      root: mergedPopupCls
    },
    styles: {
      root: mergedStyles.popup?.root,
      container: styles?.popupOverlayInner
    },
    onOpenChange: triggerOpenChange,
    content: import_react91.default.createElement(ContextIsolator_default, {
      form: true
    }, import_react91.default.createElement(ColorPickerPanel_default, {
      mode: modeState,
      onModeChange: onInternalModeChange,
      modeOptions,
      prefixCls,
      value: mergedColor,
      allowClear,
      disabled: mergedDisabled,
      disabledAlpha,
      presets,
      panelRender,
      format: formatValue,
      onFormatChange: triggerFormatChange,
      onChange: onInternalChange,
      onChangeComplete: onInternalChangeComplete,
      onClear,
      activeIndex,
      onActive: setActiveIndex,
      gradientDragging,
      onGradientDragging: setGradientDragging,
      disabledFormat
    })),
    ...popoverProps
  }, children || import_react91.default.createElement(ColorTrigger_default, {
    activeIndex: popupOpen ? activeIndex : -1,
    open: popupOpen,
    className: mergedCls,
    style: mergedStyle,
    prefixCls,
    disabled: mergedDisabled,
    showText,
    format: formatValue,
    ...rest,
    color: mergedColor
  }));
};
if (true) {
  ColorPicker2.displayName = "ColorPicker";
}
var PurePanel4 = PurePanel_default(
  ColorPicker2,
  void 0,
  (props) => ({
    ...props,
    placement: "bottom",
    autoAdjustOverflow: false
  }),
  "color-picker",
  /* istanbul ignore next */
  (prefixCls) => prefixCls
);
ColorPicker2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel4;
var ColorPicker_default2 = ColorPicker2;

// node_modules/antd/es/color-picker/index.js
var color_picker_default = ColorPicker_default2;

export {
  useEvent_default,
  useLayoutUpdateEffect,
  useLayoutEffect_default,
  useSafeState,
  useControlledState,
  get,
  set,
  omit,
  toArray,
  isEqual_default,
  FieldContext_default,
  ListContext_default,
  _typeof,
  _defineProperty,
  _objectSpread2,
  _unsupportedIterableToArray,
  _toConsumableArray,
  _classCallCheck,
  _createClass,
  _inherits,
  _getPrototypeOf,
  _isNativeReflectConstruct,
  _possibleConstructorReturn,
  Field_default,
  List_default,
  useForm_default,
  useWatch_default,
  es_default2 as es_default,
  FormContext2 as FormContext,
  NoStyleItemContext,
  FormProvider2 as FormProvider,
  FormItemPrefixContext,
  FormItemInputContext,
  NoFormStyle,
  VariantContext,
  pickAttrs,
  devUseWarning,
  warning_default2 as warning_default,
  en_US_default,
  en_US_default4 as en_US_default2,
  en_US_default5 as en_US_default3,
  en_US_default6 as en_US_default4,
  getConfirmLocale,
  useLocale_default,
  extendsObject_default,
  isNonNullable_default,
  pickClosable,
  computeClosable,
  useClosable,
  useForceUpdate,
  useMergedMask,
  mergeClassNames,
  mergeStyles,
  resolveStyleOrClass,
  useMergeSemantic,
  useMultipleSelect,
  useOrientation,
  usePatchElement,
  useProxyImperativeHandle,
  useSyncState,
  createTheme,
  unit,
  getComputedToken,
  Keyframes_default,
  version_default2 as version_default,
  defaultPresetColors,
  seed_default,
  genColorMapToken,
  genControlHeight_default,
  getLineHeight,
  genFontMapToken_default,
  derivative,
  theme_default,
  defaultConfig,
  DesignTokenContext,
  getAlphaColor_default,
  formatToken,
  useToken,
  zindexContext_default,
  CONTAINER_MAX_OFFSET,
  useZIndex,
  validateMessagesContext_default,
  getScrollBarSize,
  getTargetScrollBarSize,
  es_default3 as es_default2,
  getDOM,
  es_default4 as es_default3,
  useId_default,
  raf_default,
  CSSMotionList_default,
  es_default5 as es_default4,
  isVisible_default,
  es_default6 as es_default5,
  defaultPrefixCls,
  ConfigContext,
  useComponentConfig,
  DisabledContextProvider,
  DisabledContext_default,
  SizeContext_default,
  _slicedToArray,
  merge2 as merge,
  PresetColors,
  textEllipsis,
  resetComponent,
  resetIcon,
  clearFix,
  genFocusOutline,
  genFocusStyle,
  operationUnit,
  genStyleHooks,
  genComponentStyleHook,
  genSubStyleComponent,
  genCssVar,
  genPresetColor,
  warnContext,
  globalConfig,
  config_provider_default,
  useSize_default,
  useCompactItemContext,
  Compact_default,
  ContextIsolator_default,
  withPureRenderTheme,
  PurePanel_default,
  getStatusClassNames,
  getMergedStatus,
  useCSSVarCls_default,
  KeyCode_default,
  getRenderPropValue,
  getTransitionName2 as getTransitionName,
  motion_default,
  isFragment2 as isFragment,
  replaceElement,
  cloneElement7 as cloneElement,
  getArrowToken,
  genRoundedArrow,
  MAX_VERTICAL_CONTENT_RADIUS,
  getArrowOffsetToken,
  getArrowStyle,
  getPlacements,
  useMergedArrow_default,
  collapse_default,
  initFadeMotion,
  initMoveMotion,
  slideUpIn,
  slideUpOut,
  slideDownIn,
  slideDownOut,
  initSlideMotion,
  zoomIn,
  initZoomMotion,
  isPresetColor,
  isPresetStatusColor,
  AggregationColor,
  tooltip_default,
  RawPurePanel,
  PurePanel_default3 as PurePanel_default2,
  popover_default,
  divider_default,
  _extends10 as _extends,
  segmented_default,
  useBaseProps,
  es_default10 as es_default6,
  BaseSelect_default,
  es_default11 as es_default7,
  empty_default2 as empty_default,
  defaultRenderEmpty_default,
  useVariants_default,
  mergedBuiltinPlacements_default,
  genCompactItemStyle,
  style_default6 as style_default,
  useIcons,
  usePopupRender_default,
  useShowArrow,
  select_default,
  getFocusNodeList,
  triggerFocus,
  Addon_default,
  initInputToken,
  initComponentToken,
  genDisabledStyle,
  genBaseOutlinedStyle,
  genOutlinedStyle,
  genBorderlessStyle,
  genFilledStyle,
  genUnderlinedStyle,
  genPlaceholderStyle,
  genInputSmallStyle,
  genBasicInputStyle,
  useSharedStyle,
  style_default7 as style_default2,
  input_number_default,
  resolveOnChange,
  BaseInput_default,
  useCount,
  getAllowClear_default,
  useRemovePasswordTimeout,
  Input_default3 as Input_default,
  slider_default,
  collapse_default2,
  isBright,
  color_picker_default
};
//# sourceMappingURL=chunk-3GVSBFAG.js.map
