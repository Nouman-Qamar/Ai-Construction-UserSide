"use client";
import {
  Addon_default,
  AggregationColor,
  BaseInput_default,
  BaseSelect_default,
  CONTAINER_MAX_OFFSET,
  CSSMotionList_default,
  Compact_default,
  ConfigContext,
  ContextIsolator_default,
  DesignTokenContext,
  DisabledContextProvider,
  DisabledContext_default,
  FieldContext_default,
  Field_default,
  FormContext,
  FormItemInputContext,
  FormItemPrefixContext,
  FormProvider,
  Input_default,
  KeyCode_default,
  Keyframes_default,
  ListContext_default,
  List_default,
  MAX_VERTICAL_CONTENT_RADIUS,
  NoFormStyle,
  NoStyleItemContext,
  PresetColors,
  PurePanel_default,
  PurePanel_default2,
  RawPurePanel,
  SizeContext_default,
  VariantContext,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _extends,
  _getPrototypeOf,
  _inherits,
  _isNativeReflectConstruct,
  _objectSpread2,
  _possibleConstructorReturn,
  _slicedToArray,
  _toConsumableArray,
  _typeof,
  _unsupportedIterableToArray,
  clearFix,
  cloneElement,
  collapse_default,
  collapse_default2,
  color_picker_default,
  computeClosable,
  config_provider_default,
  createTheme,
  defaultConfig,
  defaultPrefixCls,
  defaultPresetColors,
  defaultRenderEmpty_default,
  derivative,
  devUseWarning,
  divider_default,
  empty_default,
  en_US_default,
  en_US_default2,
  en_US_default3,
  en_US_default4,
  es_default,
  es_default2,
  es_default3,
  es_default4,
  es_default5,
  es_default6,
  es_default7,
  extendsObject_default,
  formatToken,
  genBaseOutlinedStyle,
  genBasicInputStyle,
  genBorderlessStyle,
  genColorMapToken,
  genCompactItemStyle,
  genComponentStyleHook,
  genControlHeight_default,
  genCssVar,
  genDisabledStyle,
  genFilledStyle,
  genFocusOutline,
  genFocusStyle,
  genFontMapToken_default,
  genInputSmallStyle,
  genOutlinedStyle,
  genPlaceholderStyle,
  genPresetColor,
  genRoundedArrow,
  genStyleHooks,
  genSubStyleComponent,
  genUnderlinedStyle,
  get,
  getAllowClear_default,
  getAlphaColor_default,
  getArrowOffsetToken,
  getArrowStyle,
  getArrowToken,
  getComputedToken,
  getConfirmLocale,
  getDOM,
  getFocusNodeList,
  getLineHeight,
  getMergedStatus,
  getPlacements,
  getRenderPropValue,
  getScrollBarSize,
  getStatusClassNames,
  getTargetScrollBarSize,
  getTransitionName,
  globalConfig,
  initComponentToken,
  initFadeMotion,
  initInputToken,
  initMoveMotion,
  initSlideMotion,
  initZoomMotion,
  input_number_default,
  isBright,
  isEqual_default,
  isFragment,
  isNonNullable_default,
  isPresetColor,
  isPresetStatusColor,
  isVisible_default,
  merge,
  mergeClassNames,
  mergeStyles,
  mergedBuiltinPlacements_default,
  motion_default,
  omit,
  operationUnit,
  pickAttrs,
  pickClosable,
  popover_default,
  raf_default,
  replaceElement,
  resetComponent,
  resetIcon,
  resolveOnChange,
  resolveStyleOrClass,
  seed_default,
  segmented_default,
  select_default,
  set,
  slideDownIn,
  slideDownOut,
  slideUpIn,
  slideUpOut,
  slider_default,
  style_default,
  style_default2,
  textEllipsis,
  theme_default,
  toArray,
  tooltip_default,
  triggerFocus,
  unit,
  useBaseProps,
  useCSSVarCls_default,
  useClosable,
  useCompactItemContext,
  useComponentConfig,
  useControlledState,
  useCount,
  useEvent_default,
  useForceUpdate,
  useForm_default,
  useIcons,
  useId_default,
  useLayoutEffect_default,
  useLayoutUpdateEffect,
  useLocale_default,
  useMergeSemantic,
  useMergedArrow_default,
  useMergedMask,
  useMultipleSelect,
  useOrientation,
  usePatchElement,
  usePopupRender_default,
  useProxyImperativeHandle,
  useRemovePasswordTimeout,
  useSafeState,
  useSharedStyle,
  useShowArrow,
  useSize_default,
  useSyncState,
  useToken,
  useVariants_default,
  useWatch_default,
  useZIndex,
  validateMessagesContext_default,
  version_default,
  warnContext,
  warning_default as warning_default2,
  withPureRenderTheme,
  zindexContext_default,
  zoomIn
} from "./chunk-3GVSBFAG.js";
import {
  BarsOutlined_default,
  CalendarOutlined_default,
  CaretDownFilled_default,
  CaretDownOutlined_default,
  CaretUpOutlined_default,
  CheckCircleFilled_default,
  CheckOutlined_default,
  ClockCircleOutlined_default,
  CloseCircleFilled_default,
  CloseOutlined_default,
  CopyOutlined_default,
  DeleteOutlined_default,
  DoubleLeftOutlined_default,
  DoubleRightOutlined_default,
  DownOutlined_default,
  DownloadOutlined_default,
  EditOutlined_default,
  EllipsisOutlined_default,
  EnterOutlined_default,
  ExclamationCircleFilled_default,
  EyeInvisibleOutlined_default,
  EyeOutlined_default,
  FastColor,
  FileOutlined_default,
  FileTextOutlined_default,
  FileTwoTone_default,
  FilterFilled_default,
  FolderOpenOutlined_default,
  FolderOutlined_default,
  HolderOutlined_default,
  InfoCircleFilled_default,
  LeftOutlined_default,
  LoadingOutlined_default,
  MinusSquareOutlined_default,
  PaperClipOutlined_default,
  PictureTwoTone_default,
  PlusOutlined_default,
  PlusSquareOutlined_default,
  QuestionCircleOutlined_default,
  ReloadOutlined_default,
  RightOutlined_default,
  RotateLeftOutlined_default,
  RotateRightOutlined_default,
  SearchOutlined_default,
  StarFilled_default,
  SwapOutlined_default,
  SwapRightOutlined_default,
  UpOutlined_default,
  VerticalAlignTopOutlined_default,
  WarningFilled_default,
  ZoomInOutlined_default,
  ZoomOutOutlined_default,
  blue,
  canUseDom,
  clsx,
  composeRef,
  contains,
  fillRef,
  generate,
  getNodeRef,
  gold,
  presetPrimaryColors,
  supportNodeRef,
  supportRef,
  useComposeRef,
  useMemo,
  warning,
  warning_default
} from "./chunk-RLLPNQTR.js";
import {
  require_client
} from "./chunk-SYCL3R42.js";
import {
  require_react_dom
} from "./chunk-OZA3KNTY.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-UV3U5RPD.js";

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !(function(t2, e3) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e3();
    })(exports, (function() {
      "use strict";
      var t2 = 1e3, e3 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o3 = "week", c = "month", f = "quarter", h = "year", d = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e4 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
      } }, m = function(t3, e4, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e4 ? t3 : "" + Array(e4 + 1 - r3.length).join(n3) + t3;
      }, v = { s: m, z: function(t3) {
        var e4 = -t3.utcOffset(), n3 = Math.abs(e4), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
        return (e4 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t3(e4, n3) {
        if (e4.date() < n3.date()) return -t3(n3, e4);
        var r3 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i2 = e4.clone().add(r3, c), s2 = n3 - i2 < 0, u2 = e4.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n3 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c, y: h, w: o3, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p]);
      }, w = function t3(e4, n3, r3) {
        var i2;
        if (!e4) return g;
        if ("string" == typeof e4) {
          var s2 = e4.toLowerCase();
          D[s2] && (i2 = s2), n3 && (D[s2] = n3, i2 = s2);
          var u2 = e4.split("-");
          if (!i2 && u2.length > 1) return t3(u2[0]);
        } else {
          var a2 = e4.name;
          D[a2] = e4, i2 = a2;
        }
        return !r3 && i2 && (g = i2), i2 || !r3 && g;
      }, O = function(t3, e4) {
        if (S(t3)) return t3.clone();
        var n3 = "object" == typeof e4 ? e4 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t3, e4) {
        return O(t3, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
      };
      var _ = (function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t3) {
          this.$d = (function(t4) {
            var e4 = t4.date, n3 = t4.utc;
            if (null === e4) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e4)) return /* @__PURE__ */ new Date();
            if (e4 instanceof Date) return new Date(e4);
            if ("string" == typeof e4 && !/Z$/i.test(e4)) {
              var r3 = e4.match($);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e4);
          })(t3), this.init();
        }, m2.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m2.isSame = function(t3, e4) {
          var n3 = O(t3);
          return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
        }, m2.isAfter = function(t3, e4) {
          return O(t3) < this.startOf(e4);
        }, m2.isBefore = function(t3, e4) {
          return this.endOf(e4) < O(t3);
        }, m2.$g = function(t3, e4, n3) {
          return b.u(t3) ? this[e4] : this.set(n3, t3);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t3, e4) {
          var n3 = this, r3 = !!b.u(e4) || e4, f2 = b.p(t3), l3 = function(t4, e5) {
            var i2 = b.w(n3.$u ? Date.UTC(n3.$y, e5, t4) : new Date(n3.$y, e5, t4), n3);
            return r3 ? i2 : i2.endOf(a);
          }, $2 = function(t4, e5) {
            return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o3:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l3(r3 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m2.$set = function(t3, e4) {
          var n3, o4 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o4], $2 = o4 === a ? this.$D + (e4 - this.$W) : e4;
          if (o4 === c || o4 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l3]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m2.set = function(t3, e4) {
          return this.clone().$set(t3, e4);
        }, m2.get = function(t3) {
          return this[b.p(t3)]();
        }, m2.add = function(r3, f2) {
          var d2, l3 = this;
          r3 = Number(r3);
          var $2 = b.p(f2), y2 = function(t3) {
            var e4 = O(l3);
            return b.w(e4.date(e4.date() + Math.round(t3 * r3)), l3);
          };
          if ($2 === c) return this.set(c, this.$M + r3);
          if ($2 === h) return this.set(h, this.$y + r3);
          if ($2 === a) return y2(1);
          if ($2 === o3) return y2(7);
          var M3 = (d2 = {}, d2[s] = e3, d2[u] = n2, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r3 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t3, e4) {
          return this.add(-1 * t3, e4);
        }, m2.format = function(t3) {
          var e4 = this, n3 = this.$locale();
          if (!this.isValid()) return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o4 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h2 = function(t4, n4, i3, s3) {
            return t4 && (t4[n4] || t4(e4, r3)) || i3[n4].slice(0, s3);
          }, d2 = function(t4) {
            return b.s(s2 % 12 || 12, t4, "0");
          }, $2 = f2 || function(t4, e5, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, (function(t4, r4) {
            return r4 || (function(t5) {
              switch (t5) {
                case "YY":
                  return String(e4.$y).slice(-2);
                case "YYYY":
                  return b.s(e4.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n3.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e4.$D;
                case "DD":
                  return b.s(e4.$D, 2, "0");
                case "d":
                  return String(e4.$W);
                case "dd":
                  return h2(n3.weekdaysMin, e4.$W, o4, 2);
                case "ddd":
                  return h2(n3.weekdaysShort, e4.$W, o4, 3);
                case "dddd":
                  return o4[e4.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e4.$s);
                case "ss":
                  return b.s(e4.$s, 2, "0");
                case "SSS":
                  return b.s(e4.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            })(t4) || i2.replace(":", "");
          }));
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d2, l3) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e3, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o3:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n2;
              break;
            case s:
              $2 = g2 / e3;
              break;
            case i:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l3 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t3, e4) {
          if (!t3) return this.$L;
          var n3 = this.clone(), r3 = w(t3, e4, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      })(), k = _.prototype;
      return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t3) {
        k[t3[1]] = function(e4) {
          return this.$g(e4, t3[0], t3[1]);
        };
      })), O.extend = function(t3, e4) {
        return t3.$i || (t3(e4, _, O), t3.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    }));
  }
});

// node_modules/dayjs/plugin/weekday.js
var require_weekday = __commonJS({
  "node_modules/dayjs/plugin/weekday.js"(exports, module) {
    !(function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekday = t2();
    })(exports, (function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekday = function(e4) {
          var t3 = this.$locale().weekStart || 0, i = this.$W, n2 = (i < t3 ? i + 7 : i) - t3;
          return this.$utils().u(e4) ? n2 : this.subtract(n2, "day").add(e4, "day");
        };
      };
    }));
  }
});

// node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "node_modules/dayjs/plugin/localeData.js"(exports, module) {
    !(function(n2, e3) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (n2 = "undefined" != typeof globalThis ? globalThis : n2 || self).dayjs_plugin_localeData = e3();
    })(exports, (function() {
      "use strict";
      return function(n2, e3, t2) {
        var r2 = e3.prototype, o3 = function(n3) {
          return n3 && (n3.indexOf ? n3 : n3.s);
        }, u = function(n3, e4, t3, r3, u2) {
          var i2 = n3.name ? n3 : n3.$locale(), a2 = o3(i2[e4]), s2 = o3(i2[t3]), f = a2 || s2.map((function(n4) {
            return n4.slice(0, r3);
          }));
          if (!u2) return f;
          var d = i2.weekStart;
          return f.map((function(n4, e5) {
            return f[(e5 + (d || 0)) % 7];
          }));
        }, i = function() {
          return t2.Ls[t2.locale()];
        }, a = function(n3, e4) {
          return n3.formats[e4] || (function(n4) {
            return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(n5, e5, t3) {
              return e5 || t3.slice(1);
            }));
          })(n3.formats[e4.toUpperCase()]);
        }, s = function() {
          var n3 = this;
          return { months: function(e4) {
            return e4 ? e4.format("MMMM") : u(n3, "months");
          }, monthsShort: function(e4) {
            return e4 ? e4.format("MMM") : u(n3, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n3.$locale().weekStart || 0;
          }, weekdays: function(e4) {
            return e4 ? e4.format("dddd") : u(n3, "weekdays");
          }, weekdaysMin: function(e4) {
            return e4 ? e4.format("dd") : u(n3, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e4) {
            return e4 ? e4.format("ddd") : u(n3, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e4) {
            return a(n3.$locale(), e4);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r2.localeData = function() {
          return s.bind(this)();
        }, t2.localeData = function() {
          var n3 = i();
          return { firstDayOfWeek: function() {
            return n3.weekStart || 0;
          }, weekdays: function() {
            return t2.weekdays();
          }, weekdaysShort: function() {
            return t2.weekdaysShort();
          }, weekdaysMin: function() {
            return t2.weekdaysMin();
          }, months: function() {
            return t2.months();
          }, monthsShort: function() {
            return t2.monthsShort();
          }, longDateFormat: function(e4) {
            return a(n3, e4);
          }, meridiem: n3.meridiem, ordinal: n3.ordinal };
        }, t2.months = function() {
          return u(i(), "months");
        }, t2.monthsShort = function() {
          return u(i(), "monthsShort", "months", 3);
        }, t2.weekdays = function(n3) {
          return u(i(), "weekdays", null, null, n3);
        }, t2.weekdaysShort = function(n3) {
          return u(i(), "weekdaysShort", "weekdays", 3, n3);
        }, t2.weekdaysMin = function(n3) {
          return u(i(), "weekdaysMin", "weekdays", 2, n3);
        };
      };
    }));
  }
});

// node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "node_modules/dayjs/plugin/weekOfYear.js"(exports, module) {
    !(function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekOfYear = t2();
    })(exports, (function() {
      "use strict";
      var e3 = "week", t2 = "year";
      return function(i, n2, r2) {
        var f = n2.prototype;
        f.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2) return this.add(7 * (i2 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e3);
            if (f2.isBefore(s)) return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e3).subtract(1, "millisecond"), o3 = this.diff(a, e3, true);
          return o3 < 0 ? r2(this).startOf("week").week() : Math.ceil(o3);
        }, f.weeks = function(e4) {
          return void 0 === e4 && (e4 = null), this.week(e4);
        };
      };
    }));
  }
});

// node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "node_modules/dayjs/plugin/weekYear.js"(exports, module) {
    !(function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekYear = t2();
    })(exports, (function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekYear = function() {
          var e4 = this.month(), t3 = this.week(), n2 = this.year();
          return 1 === t3 && 11 === e4 ? n2 + 1 : 0 === e4 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    }));
  }
});

// node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/dayjs/plugin/advancedFormat.js"(exports, module) {
    !(function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_advancedFormat = t2();
    })(exports, (function() {
      "use strict";
      return function(e3, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e4) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid()) return n2.bind(this)(e4);
          var s = this.$utils(), a = (e4 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e5) {
            switch (e5) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s.s(t3.week(), "w" === e5 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t3.isoWeek(), "W" === e5 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e5 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e5;
            }
          }));
          return n2.bind(this)(a);
        };
      };
    }));
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
    !(function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_customParseFormat = t2();
    })(exports, (function() {
      "use strict";
      var e3 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i = /\d\d?/, o3 = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e4) {
        return (e4 = +e4) + (e4 > 68 ? 1900 : 2e3);
      };
      var f = function(e4) {
        return function(t3) {
          this[e4] = +t3;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e4) {
        (this.zone || (this.zone = {})).offset = (function(e5) {
          if (!e5) return 0;
          if ("Z" === e5) return 0;
          var t3 = e5.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        })(e4);
      }], u = function(e4) {
        var t3 = s[e4];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, d = function(e4, t3) {
        var n3, r3 = s.meridiem;
        if (r3) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e4.indexOf(r3(i2, 0, t3)) > -1) {
            n3 = i2 > 12;
            break;
          }
        } else n3 = e4 === (t3 ? "pm" : "PM");
        return n3;
      }, c = { A: [o3, function(e4) {
        this.afternoon = d(e4, false);
      }], a: [o3, function(e4) {
        this.afternoon = d(e4, true);
      }], Q: [n2, function(e4) {
        this.month = 3 * (e4 - 1) + 1;
      }], S: [n2, function(e4) {
        this.milliseconds = 100 * +e4;
      }], SS: [r2, function(e4) {
        this.milliseconds = 10 * +e4;
      }], SSS: [/\d{3}/, function(e4) {
        this.milliseconds = +e4;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r2, f("day")], Do: [o3, function(e4) {
        var t3 = s.ordinal, n3 = e4.match(/\d+/);
        if (this.day = n3[0], t3) for (var r3 = 1; r3 <= 31; r3 += 1) t3(r3).replace(/\[|\]/g, "") === e4 && (this.day = r3);
      }], w: [i, f("week")], ww: [r2, f("week")], M: [i, f("month")], MM: [r2, f("month")], MMM: [o3, function(e4) {
        var t3 = u("months"), n3 = (u("monthsShort") || t3.map((function(e5) {
          return e5.slice(0, 3);
        }))).indexOf(e4) + 1;
        if (n3 < 1) throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [o3, function(e4) {
        var t3 = u("months").indexOf(e4) + 1;
        if (t3 < 1) throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r2, function(e4) {
        this.year = a(e4);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l2(n3) {
        var r3, i2;
        r3 = n3, i2 = s && s.formats;
        for (var o4 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t3, n4, r4) {
          var o5 = r4 && r4.toUpperCase();
          return n4 || i2[r4] || e3[r4] || i2[o5].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e4, t4, n5) {
            return t4 || n5.slice(1);
          }));
        }))).match(t2), a2 = o4.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o4[f2], u2 = c[h2], d2 = u2 && u2[0], l3 = u2 && u2[1];
          o4[f2] = l3 ? { regex: d2, parser: l3 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e4) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i3 = o4[n4];
            if ("string" == typeof i3) r4 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e4.slice(r4), u3 = s2.exec(h3)[0];
              f3.call(t3, u3), e4 = e4.replace(u3, "");
            }
          }
          return (function(e5) {
            var t4 = e5.afternoon;
            if (void 0 !== t4) {
              var n5 = e5.hours;
              t4 ? n5 < 12 && (e5.hours += 12) : 12 === n5 && (e5.hours = 0), delete e5.afternoon;
            }
          })(t3), t3;
        };
      }
      return function(e4, t3, n3) {
        n3.p.customParseFormat = true, e4 && e4.parseTwoDigitYear && (a = e4.parseTwoDigitYear);
        var r3 = t3.prototype, i2 = r3.parse;
        r3.parse = function(e5) {
          var t4 = e5.date, r4 = e5.utc, o4 = e5.args;
          this.$u = r4;
          var a2 = o4[1];
          if ("string" == typeof a2) {
            var f2 = true === o4[2], h2 = true === o4[3], u2 = f2 || h2, d2 = o4[2];
            h2 && (d2 = o4[2]), s = this.$locale(), !f2 && d2 && (s = n3.Ls[d2]), this.$d = (function(e6, t5, n4, r5) {
              try {
                if (["x", "X"].indexOf(t5) > -1) return new Date(("X" === t5 ? 1e3 : 1) * e6);
                var i3 = l2(t5)(e6), o5 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o5 || s2 ? 1 : M2.getDate()), p = o5 || M2.getFullYear(), v = 0;
                o5 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n4 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r5(D).week(m2).toDate()), D);
              } catch (e7) {
                return /* @__PURE__ */ new Date("");
              }
            })(t4, a2, r4, n3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array) for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
            o4[1] = a2[m - 1];
            var M = n3.apply(this, o4);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e5);
        };
      };
    }));
  }
});

// node_modules/is-mobile/index.js
var require_is_mobile = __commonJS({
  "node_modules/is-mobile/index.js"(exports, module) {
    "use strict";
    module.exports = isMobile2;
    module.exports.isMobile = isMobile2;
    module.exports.default = isMobile2;
    var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|redmi|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
    var notMobileRE = /CrOS/;
    var tabletRE = /android|ipad|playbook|silk/i;
    function isMobile2(opts) {
      if (!opts) opts = {};
      let ua = opts.ua;
      if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
      if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
        ua = ua.headers["user-agent"];
      }
      if (typeof ua !== "string") return false;
      let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
      if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
        result = true;
      }
      return result;
    }
  }
});

// node_modules/string-convert/camel2hyphen.js
var require_camel2hyphen = __commonJS({
  "node_modules/string-convert/camel2hyphen.js"(exports, module) {
    var camel2hyphen = function(str) {
      return str.replace(/[A-Z]/g, function(match) {
        return "-" + match.toLowerCase();
      }).toLowerCase();
    };
    module.exports = camel2hyphen;
  }
});

// node_modules/json2mq/index.js
var require_json2mq = __commonJS({
  "node_modules/json2mq/index.js"(exports, module) {
    var camel2hyphen = require_camel2hyphen();
    var isDimension = function(feature) {
      var re = /[height|width]$/;
      return re.test(feature);
    };
    var obj2mq = function(obj) {
      var mq = "";
      var features = Object.keys(obj);
      features.forEach(function(feature, index2) {
        var value = obj[feature];
        feature = camel2hyphen(feature);
        if (isDimension(feature) && typeof value === "number") {
          value = value + "px";
        }
        if (value === true) {
          mq += feature;
        } else if (value === false) {
          mq += "not " + feature;
        } else {
          mq += "(" + feature + ": " + value + ")";
        }
        if (index2 < features.length - 1) {
          mq += " and ";
        }
      });
      return mq;
    };
    var json2mq2 = function(query) {
      var mq = "";
      if (typeof query === "string") {
        return query;
      }
      if (query instanceof Array) {
        query.forEach(function(q, index2) {
          mq += obj2mq(q);
          if (index2 < query.length - 1) {
            mq += ", ";
          }
        });
        return mq;
      }
      return obj2mq(query);
    };
    module.exports = json2mq2;
  }
});

// node_modules/antd/es/_util/getReactMajorVersionCanDelMe.js
var import_react = __toESM(require_react());
function getReactMajorVersion() {
  const majorVersion = Number.parseInt(import_react.version.split(".")[0], 10);
  return majorVersion;
}

// node_modules/antd/es/affix/index.js
var import_react2 = __toESM(require_react());

// node_modules/antd/es/_util/throttleByAnimationFrame.js
function throttleByAnimationFrame(fn) {
  let requestId = null;
  const later = (args) => () => {
    requestId = null;
    fn.apply(void 0, _toConsumableArray(args));
  };
  const throttled = (...args) => {
    if (requestId === null) {
      requestId = raf_default(later(args));
    }
  };
  throttled.cancel = () => {
    raf_default.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
var throttleByAnimationFrame_default = throttleByAnimationFrame;

// node_modules/antd/es/affix/style/index.js
var genSharedAffixStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      position: "fixed",
      zIndex: token.zIndexPopup
    }
  };
};
var prepareComponentToken = (token) => ({
  zIndexPopup: token.zIndexBase + 10
});
var style_default3 = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken);

// node_modules/antd/es/affix/utils.js
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderRect, targetRect, offsetTop) {
  if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) {
    return offsetTop + targetRect.top;
  }
  return void 0;
}
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) {
    const targetBottomOffset = window.innerHeight - targetRect.bottom;
    return offsetBottom + targetBottomOffset;
  }
  return void 0;
}

// node_modules/antd/es/affix/index.js
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
var AFFIX_STATUS_NONE = 0;
var AFFIX_STATUS_PREPARE = 1;
var Affix = import_react2.default.forwardRef((props, ref) => {
  const {
    style,
    offsetTop,
    offsetBottom,
    prefixCls,
    className,
    rootClassName,
    children,
    target,
    onChange,
    onTestUpdatePosition,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("affix");
  const {
    getTargetContainer
  } = import_react2.default.useContext(ConfigContext);
  const affixPrefixCls = getPrefixCls("affix", prefixCls);
  const [lastAffix, setLastAffix] = import_react2.default.useState(false);
  const [affixStyle, setAffixStyle] = import_react2.default.useState();
  const [placeholderStyle, setPlaceholderStyle] = import_react2.default.useState();
  const status = import_react2.default.useRef(AFFIX_STATUS_NONE);
  const prevTarget = import_react2.default.useRef(null);
  const prevListener = import_react2.default.useRef(null);
  const placeholderNodeRef = import_react2.default.useRef(null);
  const fixedNodeRef = import_react2.default.useRef(null);
  const timer = import_react2.default.useRef(null);
  const targetFunc = target ?? getTargetContainer ?? getDefaultTarget;
  const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
  const measure = () => {
    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {
      return;
    }
    const targetNode = targetFunc();
    if (targetNode) {
      const newState = {
        status: AFFIX_STATUS_NONE
      };
      const placeholderRect = getTargetRect(placeholderNodeRef.current);
      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
        return;
      }
      const targetRect = getTargetRect(targetNode);
      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
      if (fixedTop !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      } else if (fixedBottom !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (lastAffix !== newState.lastAffix) {
        onChange?.(newState.lastAffix);
      }
      status.current = newState.status;
      setAffixStyle(newState.affixStyle);
      setPlaceholderStyle(newState.placeholderStyle);
      setLastAffix(newState.lastAffix);
    }
  };
  const prepareMeasure = () => {
    status.current = AFFIX_STATUS_PREPARE;
    measure();
    if (false) {
      onTestUpdatePosition?.();
    }
  };
  const updatePosition = throttleByAnimationFrame_default(() => {
    prepareMeasure();
  });
  const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
    if (targetFunc && affixStyle) {
      const targetNode = targetFunc();
      if (targetNode && placeholderNodeRef.current) {
        const targetRect = getTargetRect(targetNode);
        const placeholderRect = getTargetRect(placeholderNodeRef.current);
        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
        if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
          return;
        }
      }
    }
    prepareMeasure();
  });
  const addListeners = () => {
    const listenerTarget = targetFunc?.();
    if (!listenerTarget) {
      return;
    }
    TRIGGER_EVENTS.forEach((eventName) => {
      if (prevListener.current) {
        prevTarget.current?.removeEventListener(eventName, prevListener.current);
      }
      listenerTarget?.addEventListener(eventName, lazyUpdatePosition);
    });
    prevTarget.current = listenerTarget;
    prevListener.current = lazyUpdatePosition;
  };
  const removeListeners = () => {
    const newTarget = targetFunc?.();
    TRIGGER_EVENTS.forEach((eventName) => {
      newTarget?.removeEventListener(eventName, lazyUpdatePosition);
      if (prevListener.current) {
        prevTarget.current?.removeEventListener(eventName, prevListener.current);
      }
    });
    updatePosition.cancel();
    lazyUpdatePosition.cancel();
  };
  import_react2.default.useImperativeHandle(ref, () => ({
    updatePosition
  }));
  import_react2.default.useEffect(() => {
    timer.current = setTimeout(addListeners);
    return () => {
      if (timer.current) {
        clearTimeout(timer.current);
        timer.current = null;
      }
      removeListeners();
    };
  }, []);
  import_react2.default.useEffect(() => {
    addListeners();
    return () => removeListeners();
  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);
  import_react2.default.useEffect(() => {
    updatePosition();
  }, [target, offsetTop, offsetBottom]);
  const [hashId, cssVarCls] = style_default3(affixPrefixCls);
  const rootCls = clsx(rootClassName, hashId, affixPrefixCls, cssVarCls);
  const mergedCls = clsx({
    [rootCls]: affixStyle
  });
  return import_react2.default.createElement(es_default3, {
    onResize: updatePosition
  }, import_react2.default.createElement("div", {
    style: {
      ...contextStyle,
      ...style
    },
    className: clsx(className, contextClassName),
    ref: placeholderNodeRef,
    ...restProps
  }, affixStyle && import_react2.default.createElement("div", {
    style: placeholderStyle,
    "aria-hidden": "true"
  }), import_react2.default.createElement("div", {
    className: mergedCls,
    ref: fixedNodeRef,
    style: affixStyle
  }, import_react2.default.createElement(es_default3, {
    onResize: updatePosition
  }, children))));
});
if (true) {
  Affix.displayName = "Affix";
}
var affix_default = Affix;

// node_modules/antd/es/alert/Alert.js
var React2 = __toESM(require_react());

// node_modules/antd/es/alert/style/index.js
var genAlertTypeStyle = (bgColor, borderColor, iconColor, token, alertCls) => ({
  background: bgColor,
  border: `${unit(token.lineWidth)} ${token.lineType} ${borderColor}`,
  [`${alertCls}-icon`]: {
    color: iconColor
  }
});
var genBaseStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow: duration,
    marginXS,
    marginSM,
    fontSize,
    fontSizeLG,
    lineHeight,
    borderRadiusLG: borderRadius,
    motionEaseInOutCirc,
    withDescriptionIconSize,
    colorText,
    colorTextHeading,
    withDescriptionPadding,
    defaultPadding
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: defaultPadding,
      wordWrap: "break-word",
      borderRadius,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-section`]: {
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginXS,
        lineHeight: 0
      },
      "&-description": {
        display: "none",
        fontSize,
        lineHeight
      },
      "&-title": {
        color: colorTextHeading
      },
      [`&${componentCls}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
      },
      [`&${componentCls}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    },
    [`${componentCls}-with-description`]: {
      alignItems: "flex-start",
      padding: withDescriptionPadding,
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginSM,
        fontSize: withDescriptionIconSize,
        lineHeight: 0
      },
      [`${componentCls}-title`]: {
        display: "block",
        marginBottom: marginXS,
        color: colorTextHeading,
        fontSize: fontSizeLG
      },
      [`${componentCls}-description`]: {
        display: "block",
        color: colorText
      }
    },
    [`${componentCls}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
};
var genTypeStyle = (token) => {
  const {
    componentCls,
    colorSuccess,
    colorSuccessBorder,
    colorSuccessBg,
    colorWarning,
    colorWarningBorder,
    colorWarningBg,
    colorError,
    colorErrorBorder,
    colorErrorBg,
    colorInfo,
    colorInfoBorder,
    colorInfoBg
  } = token;
  return {
    [componentCls]: {
      "&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token, componentCls),
      "&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token, componentCls),
      "&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token, componentCls),
      "&-error": {
        ...genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token, componentCls),
        [`${componentCls}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      }
    }
  };
};
var genActionStyle = (token) => {
  const {
    componentCls,
    iconCls,
    motionDurationMid,
    marginXS,
    fontSizeIcon,
    colorIcon,
    colorIconHover
  } = token;
  return {
    [componentCls]: {
      "&-actions": {
        marginInlineStart: marginXS
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: marginXS,
        padding: 0,
        overflow: "hidden",
        fontSize: fontSizeIcon,
        lineHeight: unit(fontSizeIcon),
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${iconCls}-close`]: {
          color: colorIcon,
          transition: `color ${motionDurationMid}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
      "&-close-text": {
        color: colorIcon,
        transition: `color ${motionDurationMid}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
};
var prepareComponentToken2 = (token) => {
  const paddingHorizontal = 12;
  return {
    withDescriptionIconSize: token.fontSizeHeading3,
    defaultPadding: `${token.paddingContentVerticalSM}px ${paddingHorizontal}px`,
    withDescriptionPadding: `${token.paddingMD}px ${token.paddingContentHorizontalLG}px`
  };
};
var style_default4 = genStyleHooks("Alert", (token) => [genBaseStyle(token), genTypeStyle(token), genActionStyle(token)], prepareComponentToken2);

// node_modules/antd/es/alert/Alert.js
var iconMapFilled = {
  success: CheckCircleFilled_default,
  info: InfoCircleFilled_default,
  error: CloseCircleFilled_default,
  warning: ExclamationCircleFilled_default
};
var IconNode = (props) => {
  const {
    icon,
    prefixCls,
    type,
    className,
    style
  } = props;
  const iconType = iconMapFilled[type] || null;
  if (icon) {
    return replaceElement(icon, React2.createElement("span", {
      className: `${prefixCls}-icon`
    }, icon), () => ({
      className: clsx(icon.props.className, className),
      style
    }));
  }
  return React2.createElement(iconType, {
    className,
    style
  });
};
var CloseIconNode = (props) => {
  const {
    isClosable,
    prefixCls,
    closeIcon,
    handleClose,
    ariaProps,
    className,
    style
  } = props;
  const mergedCloseIcon = closeIcon === true || closeIcon === void 0 ? React2.createElement(CloseOutlined_default, null) : closeIcon;
  return isClosable ? React2.createElement("button", {
    type: "button",
    onClick: handleClose,
    className: clsx(`${prefixCls}-close-icon`, className),
    tabIndex: 0,
    style,
    ...ariaProps
  }, mergedCloseIcon) : null;
};
var Alert = React2.forwardRef((props, ref) => {
  const {
    description,
    prefixCls: customizePrefixCls,
    message: message2,
    title,
    banner,
    className,
    rootClassName,
    style,
    onMouseEnter,
    onMouseLeave,
    onClick,
    afterClose,
    showIcon,
    closable,
    closeText,
    closeIcon,
    action,
    id,
    styles,
    classNames,
    ...otherProps
  } = props;
  const mergedTitle = title ?? message2;
  const [closed, setClosed] = React2.useState(false);
  if (true) {
    const warning2 = devUseWarning("Alert");
    [["closeText", "closable.closeIcon"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const internalRef = React2.useRef(null);
  React2.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const {
    getPrefixCls,
    direction,
    closable: contextClosable,
    closeIcon: contextCloseIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("alert");
  const prefixCls = getPrefixCls("alert", customizePrefixCls);
  const [hashId, cssVarCls] = style_default4(prefixCls);
  const {
    onClose: closableOnClose,
    afterClose: closableAfterClose
  } = closable && typeof closable === "object" ? closable : {};
  const handleClose = (e3) => {
    setClosed(true);
    (closableOnClose ?? props.onClose)?.(e3);
  };
  const type = React2.useMemo(() => {
    if (props.type !== void 0) {
      return props.type;
    }
    return banner ? "warning" : "info";
  }, [props.type, banner]);
  const isClosable = React2.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon) {
      return true;
    }
    if (closeText) {
      return true;
    }
    if (typeof closable === "boolean") {
      return closable;
    }
    if (closeIcon !== false && isNonNullable_default(closeIcon)) {
      return true;
    }
    return !!contextClosable;
  }, [closeText, closeIcon, closable, contextClosable]);
  const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
  const mergedProps = {
    ...props,
    prefixCls,
    type,
    showIcon: isShowIcon,
    closable: isClosable
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const alertCls = clsx(prefixCls, `${prefixCls}-${type}`, {
    [`${prefixCls}-with-description`]: !!description,
    [`${prefixCls}-no-icon`]: !isShowIcon,
    [`${prefixCls}-banner`]: !!banner,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, cssVarCls, hashId);
  const restProps = pickAttrs(otherProps, {
    aria: true,
    data: true
  });
  const mergedCloseIcon = React2.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon) {
      return closable.closeIcon;
    }
    if (closeText) {
      return closeText;
    }
    if (closeIcon !== void 0) {
      return closeIcon;
    }
    if (typeof contextClosable === "object" && contextClosable.closeIcon) {
      return contextClosable.closeIcon;
    }
    return contextCloseIcon;
  }, [closeIcon, closable, contextClosable, closeText, contextCloseIcon]);
  const mergedAriaProps = React2.useMemo(() => {
    const merged = closable ?? contextClosable;
    if (typeof merged === "object") {
      return pickAttrs(merged, {
        data: true,
        aria: true
      });
    }
    return {};
  }, [closable, contextClosable]);
  return React2.createElement(es_default4, {
    visible: !closed,
    motionName: `${prefixCls}-motion`,
    motionAppear: false,
    motionEnter: false,
    onLeaveStart: (node) => ({
      maxHeight: node.offsetHeight
    }),
    onLeaveEnd: closableAfterClose ?? afterClose
  }, ({
    className: motionClassName,
    style: motionStyle
  }, setRef) => React2.createElement("div", {
    id,
    ref: composeRef(internalRef, setRef),
    "data-show": !closed,
    className: clsx(alertCls, motionClassName),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style,
      ...motionStyle
    },
    onMouseEnter,
    onMouseLeave,
    onClick,
    role: "alert",
    ...restProps
  }, isShowIcon ? React2.createElement(IconNode, {
    className: clsx(`${prefixCls}-icon`, mergedClassNames.icon),
    style: mergedStyles.icon,
    description,
    icon: props.icon,
    prefixCls,
    type
  }) : null, React2.createElement("div", {
    className: clsx(`${prefixCls}-section`, mergedClassNames.section),
    style: mergedStyles.section
  }, mergedTitle ? React2.createElement("div", {
    className: clsx(`${prefixCls}-title`, mergedClassNames.title),
    style: mergedStyles.title
  }, mergedTitle) : null, description ? React2.createElement("div", {
    className: clsx(`${prefixCls}-description`, mergedClassNames.description),
    style: mergedStyles.description
  }, description) : null), action ? React2.createElement("div", {
    className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
    style: mergedStyles.actions
  }, action) : null, React2.createElement(CloseIconNode, {
    className: mergedClassNames.close,
    style: mergedStyles.close,
    isClosable,
    prefixCls,
    closeIcon: mergedCloseIcon,
    handleClose,
    ariaProps: mergedAriaProps
  })));
});
if (true) {
  Alert.displayName = "Alert";
}
var Alert_default = Alert;

// node_modules/@babel/runtime/helpers/esm/callSuper.js
function _callSuper(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}

// node_modules/antd/es/alert/ErrorBoundary.js
var React3 = __toESM(require_react());
var ErrorBoundary = (function(_React$Component) {
  function ErrorBoundary2() {
    var _this;
    _classCallCheck(this, ErrorBoundary2);
    _this = _callSuper(this, ErrorBoundary2, arguments);
    _this.state = {
      error: void 0,
      info: {
        componentStack: ""
      }
    };
    return _this;
  }
  _inherits(ErrorBoundary2, _React$Component);
  return _createClass(ErrorBoundary2, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error, info) {
      this.setState({
        error,
        info
      });
    }
  }, {
    key: "render",
    value: function render2() {
      const {
        message: message2,
        title,
        description,
        id,
        children
      } = this.props;
      const {
        error,
        info
      } = this.state;
      const mergedTitle = title ?? message2;
      const componentStack = info?.componentStack || null;
      const errorMessage = typeof mergedTitle === "undefined" ? (error || "").toString() : mergedTitle;
      const errorDescription = typeof description === "undefined" ? componentStack : description;
      if (error) {
        return React3.createElement(Alert_default, {
          id,
          type: "error",
          title: errorMessage,
          description: React3.createElement("pre", {
            style: {
              fontSize: "0.9em",
              overflowX: "auto"
            }
          }, errorDescription)
        });
      }
      return children;
    }
  }]);
})(React3.Component);
var ErrorBoundary_default = ErrorBoundary;

// node_modules/antd/es/alert/index.js
var Alert2 = Alert_default;
Alert2.ErrorBoundary = ErrorBoundary_default;
var alert_default = Alert2;

// node_modules/antd/es/anchor/Anchor.js
var React6 = __toESM(require_react());

// node_modules/compute-scroll-into-view/dist/index.js
var t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
var e = (t2, e3) => (!e3 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2);
var n = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o3 = getComputedStyle(t2, null);
    return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t3) => {
      const e3 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
};
var o = (t2, e3, n2, o3, l2, r2, i, s) => r2 < t2 && i > e3 || r2 > t2 && i < e3 ? 0 : r2 <= t2 && s <= n2 || i >= e3 && s >= n2 ? r2 - t2 - o3 : i > e3 && s < n2 || r2 < t2 && s > n2 ? i - e3 + l2 : 0;
var l = (t2) => {
  const e3 = t2.parentElement;
  return null == e3 ? t2.getRootNode().host || null : e3;
};
var r = (e3, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document) return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
  if (!t(e3)) throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w = [];
  let W = e3;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
  }
  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e3.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e4 = window.getComputedStyle(t2);
    return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
  })(e3);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e4 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e4.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e4 === m && !n(e4) || x >= i2 && I <= d2 && R >= h2 && C <= s2)) return L;
    const a2 = getComputedStyle(e4), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
    let B2 = 0, F2 = 0;
    const V2 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : r3 / e4.offsetWidth : 0, Y = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : l2 / e4.offsetHeight : 0;
    if (m === e4) B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
    else {
      B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h2 - g2 : "center" === u ? D - (h2 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o(h2, s2, r3, g2, W2 + V2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: n2 } = e4;
      B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e4.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t3 + F2 / X, e4.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
    }
    L.push({ el: e4, top: B2, left: F2 });
  }
  return L;
};

// node_modules/scroll-into-view-if-needed/dist/index.js
var o2 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
function e2(e3, r2) {
  if (!e3.isConnected || !((t2) => {
    let o3 = t2;
    for (; o3 && o3.parentNode; ) {
      if (o3.parentNode === document) return true;
      o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
    }
    return false;
  })(e3)) return;
  const n2 = ((t2) => {
    const o3 = window.getComputedStyle(t2);
    return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
  })(e3);
  if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2)) return r2.behavior(r(e3, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a, top: i, left: s } of r(e3, o2(r2))) {
    const t2 = i - n2.top + n2.bottom, o3 = s - n2.left + n2.right;
    a.scroll({ top: t2, left: o3, behavior: l2 });
  }
}

// node_modules/antd/es/_util/getScroll.js
function isWindow(obj) {
  return isNonNullable_default(obj) && obj === obj.window;
}
var getScroll = (target) => {
  if (typeof window === "undefined") {
    return 0;
  }
  let result = 0;
  if (isWindow(target)) {
    result = target.pageYOffset;
  } else if (target instanceof Document) {
    result = target.documentElement.scrollTop;
  } else if (target instanceof HTMLElement) {
    result = target.scrollTop;
  } else if (target) {
    result = target["scrollTop"];
  }
  if (target && !isWindow(target) && typeof result !== "number") {
    result = (target.ownerDocument ?? target).documentElement?.scrollTop;
  }
  return result;
};
var getScroll_default = getScroll;

// node_modules/antd/es/_util/easings.js
function easeInOutCubic(t2, b, c, d) {
  const cc = c - b;
  t2 /= d / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
}

// node_modules/antd/es/_util/scrollTo.js
function scrollTo(y, options = {}) {
  const {
    getContainer = () => window,
    callback,
    duration = 450
  } = options;
  const container = getContainer();
  const scrollTop = getScroll_default(container);
  const startTime = Date.now();
  let rafId;
  const frameFunc = () => {
    const timestamp = Date.now();
    const time = timestamp - startTime;
    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
    if (isWindow(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      rafId = raf_default(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  rafId = raf_default(frameFunc);
  return () => {
    raf_default.cancel(rafId);
  };
}

// node_modules/antd/es/anchor/AnchorLink.js
var React5 = __toESM(require_react());

// node_modules/antd/es/anchor/context.js
var React4 = __toESM(require_react());
var AnchorContext = React4.createContext(void 0);
var context_default = AnchorContext;

// node_modules/antd/es/anchor/AnchorLink.js
var AnchorLink = (props) => {
  const {
    href,
    title,
    prefixCls: customizePrefixCls,
    children,
    className,
    target,
    replace
  } = props;
  const context = React5.useContext(context_default);
  const {
    registerLink,
    unregisterLink,
    scrollTo: scrollTo2,
    onClick,
    activeLink,
    direction,
    classNames: mergedClassNames,
    styles: mergedStyles
  } = context || {};
  React5.useEffect(() => {
    registerLink?.(href);
    return () => {
      unregisterLink?.(href);
    };
  }, [href]);
  const handleClick = (e3) => {
    onClick?.(e3, {
      title,
      href
    });
    scrollTo2?.(href);
    if (e3.defaultPrevented) {
      return;
    }
    const isExternalLink = href.startsWith("http://") || href.startsWith("https://");
    if (isExternalLink) {
      if (replace) {
        e3.preventDefault();
        window.location.replace(href);
      }
      return;
    }
    e3.preventDefault();
    const historyMethod = replace ? "replaceState" : "pushState";
    window.history[historyMethod](null, "", href);
  };
  if (true) {
    const warning2 = devUseWarning("Anchor.Link");
    true ? warning2(!children || direction !== "horizontal", "usage", "`Anchor.Link children` is not supported when `Anchor` direction is horizontal") : void 0;
  }
  const {
    getPrefixCls
  } = React5.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customizePrefixCls);
  const active = activeLink === href;
  const wrapperClassName = clsx(`${prefixCls}-link`, className, mergedClassNames?.item, {
    [`${prefixCls}-link-active`]: active
  });
  const titleClassName = clsx(`${prefixCls}-link-title`, mergedClassNames?.itemTitle, {
    [`${prefixCls}-link-title-active`]: active
  });
  return React5.createElement("div", {
    className: wrapperClassName,
    style: mergedStyles?.item
  }, React5.createElement("a", {
    className: titleClassName,
    style: mergedStyles?.itemTitle,
    href,
    title: typeof title === "string" ? title : "",
    target,
    onClick: handleClick
  }, title), direction !== "horizontal" ? children : null);
};
var AnchorLink_default = AnchorLink;

// node_modules/antd/es/anchor/style/index.js
var genSharedAnchorStyle = (token) => {
  const {
    componentCls,
    holderOffsetBlock,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary,
    lineType,
    colorSplit,
    calc
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),
      paddingBlockStart: holderOffsetBlock,
      // delete overflow: auto
      // overflow: 'auto',
      [componentCls]: {
        ...resetComponent(token),
        position: "relative",
        paddingInlineStart: lineWidthBold,
        [`${componentCls}-link`]: {
          paddingBlock: token.linkPaddingBlock,
          paddingInline: `${unit(token.linkPaddingInlineStart)} 0`,
          "&-title": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            marginBlockEnd: token.anchorTitleBlock,
            color: token.colorText,
            transition: `all ${token.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          },
          [`&-active > ${componentCls}-link-title`]: {
            color: token.colorPrimary
          },
          // link link
          [`${componentCls}-link`]: {
            paddingBlock: token.anchorPaddingBlockSecondary
          }
        }
      },
      [`&:not(${componentCls}-wrapper-horizontal)`]: {
        [componentCls]: {
          "&::before": {
            position: "absolute",
            insetInlineStart: 0,
            top: 0,
            height: "100%",
            borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,
            content: '" "'
          },
          [`${componentCls}-ink`]: {
            position: "absolute",
            insetInlineStart: 0,
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${motionDurationSlow} ease-in-out`,
            width: lineWidthBold,
            backgroundColor: colorPrimary,
            [`&${componentCls}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: {
        display: "none"
      }
    }
  };
};
var genSharedAnchorHorizontalStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary
  } = token;
  return {
    [`${componentCls}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: 0
        },
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
        content: '" "'
      },
      [componentCls]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
          /* Safari and Chrome */
        },
        [`${componentCls}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${componentCls}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
          height: lineWidthBold,
          backgroundColor: colorPrimary
        }
      }
    }
  };
};
var prepareComponentToken3 = (token) => ({
  linkPaddingBlock: token.paddingXXS,
  linkPaddingInlineStart: token.padding
});
var style_default5 = genStyleHooks("Anchor", (token) => {
  const {
    fontSize,
    fontSizeLG,
    paddingXXS,
    calc
  } = token;
  const anchorToken = merge(token, {
    holderOffsetBlock: paddingXXS,
    anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),
    anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),
    anchorBallSize: calc(fontSizeLG).div(2).equal()
  });
  return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
}, prepareComponentToken3);

// node_modules/antd/es/anchor/Anchor.js
function getDefaultContainer() {
  return window;
}
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  const rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      return rect.top - element.ownerDocument.documentElement.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
var sharpMatcherRegex = /#([\S ]+)$/;
var Anchor = (props) => {
  const {
    rootClassName,
    prefixCls: customPrefixCls,
    className,
    style,
    offsetTop,
    affix = true,
    showInkInFixed = false,
    children,
    items,
    direction: anchorDirection = "vertical",
    bounds,
    targetOffset: targetOffset3,
    onClick,
    onChange,
    getContainer,
    getCurrentAnchor,
    replace,
    classNames,
    styles
  } = props;
  if (true) {
    const warning2 = devUseWarning("Anchor");
    warning2.deprecated(!children, "Anchor children", "items");
    true ? warning2(!(anchorDirection === "horizontal" && items?.some((n2) => "children" in n2)), "usage", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.") : void 0;
  }
  const [links, setLinks] = React6.useState([]);
  const [activeLink, setActiveLink] = React6.useState(null);
  const activeLinkRef = React6.useRef(activeLink);
  const wrapperRef = React6.useRef(null);
  const spanLinkNode = React6.useRef(null);
  const animating = React6.useRef(false);
  const scrollRequestId = React6.useRef(null);
  const {
    direction,
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("anchor");
  const {
    getTargetContainer
  } = React6.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customPrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default5(prefixCls, rootCls);
  const getCurrentContainer = getContainer ?? getTargetContainer ?? getDefaultContainer;
  const dependencyListItem = JSON.stringify(links);
  const registerLink = useEvent_default((link) => {
    if (!links.includes(link)) {
      setLinks((prev) => [].concat(_toConsumableArray(prev), [link]));
    }
  });
  const unregisterLink = useEvent_default((link) => {
    if (links.includes(link)) {
      setLinks((prev) => prev.filter((i) => i !== link));
    }
  });
  const updateInk = () => {
    const linkNode = wrapperRef.current?.querySelector(`.${prefixCls}-link-title-active`);
    if (linkNode && spanLinkNode.current) {
      const {
        style: inkStyle
      } = spanLinkNode.current;
      const horizontalAnchor = anchorDirection === "horizontal";
      inkStyle.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
      inkStyle.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
      inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
      inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
      if (horizontalAnchor) {
        e2(linkNode, {
          scrollMode: "if-needed",
          block: "nearest"
        });
      }
    }
  };
  const getInternalCurrentAnchor = (_links, _offsetTop = 0, _bounds = 5) => {
    const linkSections = [];
    const container = getCurrentContainer();
    _links.forEach((link) => {
      const sharpLinkMatch = sharpMatcherRegex.exec(link?.toString());
      if (!sharpLinkMatch) {
        return;
      }
      const target = document.getElementById(sharpLinkMatch[1]);
      if (target) {
        const top = getOffsetTop(target, container);
        if (top <= _offsetTop + _bounds) {
          linkSections.push({
            link,
            top
          });
        }
      }
    });
    if (linkSections.length) {
      const maxSection = linkSections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);
      return maxSection.link;
    }
    return "";
  };
  const setCurrentActiveLink = useEvent_default((link) => {
    if (activeLinkRef.current === link) {
      return;
    }
    const newLink = typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link;
    setActiveLink(newLink);
    activeLinkRef.current = newLink;
    onChange?.(link);
  });
  const handleScroll = React6.useCallback(() => {
    if (animating.current) {
      return;
    }
    const currentActiveLink = getInternalCurrentAnchor(links, targetOffset3 !== void 0 ? targetOffset3 : offsetTop || 0, bounds);
    setCurrentActiveLink(currentActiveLink);
  }, [links, targetOffset3, offsetTop, bounds]);
  const handleScrollTo = React6.useCallback((link) => {
    const previousActiveLink = activeLinkRef.current;
    setCurrentActiveLink(link);
    const sharpLinkMatch = sharpMatcherRegex.exec(link);
    if (!sharpLinkMatch) {
      return;
    }
    const targetElement = document.getElementById(sharpLinkMatch[1]);
    if (!targetElement) {
      return;
    }
    if (animating.current) {
      if (previousActiveLink === link) {
        return;
      }
      scrollRequestId.current?.();
    }
    const container = getCurrentContainer();
    const scrollTop = getScroll_default(container);
    const eleOffsetTop = getOffsetTop(targetElement, container);
    let y = scrollTop + eleOffsetTop;
    y -= targetOffset3 !== void 0 ? targetOffset3 : offsetTop || 0;
    animating.current = true;
    scrollRequestId.current = scrollTo(y, {
      getContainer: getCurrentContainer,
      callback() {
        animating.current = false;
      }
    });
  }, [targetOffset3, offsetTop]);
  const mergedProps = {
    ...props,
    direction: anchorDirection
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const wrapperClass = clsx(hashId, cssVarCls, rootCls, rootClassName, `${prefixCls}-wrapper`, {
    [`${prefixCls}-wrapper-horizontal`]: anchorDirection === "horizontal",
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, contextClassName, mergedClassNames.root);
  const anchorClass = clsx(prefixCls, {
    [`${prefixCls}-fixed`]: !affix && !showInkInFixed
  });
  const inkClass = clsx(`${prefixCls}-ink`, mergedClassNames.indicator, {
    [`${prefixCls}-ink-visible`]: activeLink
  });
  const wrapperStyle = {
    maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh",
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const createNestedLink = (options) => Array.isArray(options) ? options.map((item) => React6.createElement(AnchorLink_default, {
    replace,
    ...item,
    key: item.key
  }, anchorDirection === "vertical" && createNestedLink(item.children))) : null;
  const anchorContent = React6.createElement("div", {
    ref: wrapperRef,
    className: wrapperClass,
    style: wrapperStyle
  }, React6.createElement("div", {
    className: anchorClass
  }, React6.createElement("span", {
    className: inkClass,
    ref: spanLinkNode,
    style: mergedStyles.indicator
  }), "items" in props ? createNestedLink(items) : children));
  React6.useEffect(() => {
    const scrollContainer = getCurrentContainer();
    handleScroll();
    scrollContainer?.addEventListener("scroll", handleScroll);
    return () => {
      scrollContainer?.removeEventListener("scroll", handleScroll);
    };
  }, [dependencyListItem]);
  React6.useEffect(() => {
    if (typeof getCurrentAnchor === "function") {
      setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ""));
    }
  }, [getCurrentAnchor]);
  React6.useEffect(() => {
    updateInk();
  }, [anchorDirection, getCurrentAnchor, dependencyListItem, activeLink]);
  const memoizedContextValue = React6.useMemo(() => ({
    registerLink,
    unregisterLink,
    scrollTo: handleScrollTo,
    activeLink,
    onClick,
    direction: anchorDirection,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [activeLink, onClick, handleScrollTo, anchorDirection, mergedStyles, mergedClassNames]);
  const affixProps = affix && typeof affix === "object" ? affix : void 0;
  return React6.createElement(context_default.Provider, {
    value: memoizedContextValue
  }, affix ? React6.createElement(affix_default, {
    offsetTop,
    target: getCurrentContainer,
    ...affixProps
  }, anchorContent) : anchorContent);
};
if (true) {
  Anchor.displayName = "Anchor";
}
var Anchor_default = Anchor;

// node_modules/antd/es/anchor/index.js
var Anchor2 = Anchor_default;
Anchor2.Link = AnchorLink_default;
var anchor_default = Anchor2;

// node_modules/antd/es/app/App.js
var import_react22 = __toESM(require_react());

// node_modules/antd/es/message/useMessage.js
var React13 = __toESM(require_react());

// node_modules/@rc-component/notification/es/hooks/useNotification.js
var React11 = __toESM(require_react());

// node_modules/@rc-component/notification/es/Notifications.js
var React10 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@rc-component/notification/es/NoticeList.js
var import_react4 = __toESM(require_react());

// node_modules/@rc-component/notification/es/Notice.js
var React7 = __toESM(require_react());
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var Notify = React7.forwardRef((props, ref) => {
  const {
    prefixCls,
    style,
    className,
    duration = 4.5,
    showProgress,
    pauseOnHover = true,
    eventKey,
    content,
    closable,
    props: divProps,
    onClick,
    onNoticeClose,
    times,
    hovering: forcedHovering
  } = props;
  const [hovering, setHovering] = React7.useState(false);
  const [percent, setPercent] = React7.useState(0);
  const [spentTime, setSpentTime] = React7.useState(0);
  const mergedHovering = forcedHovering || hovering;
  const mergedDuration = typeof duration === "number" ? duration : 0;
  const mergedShowProgress = mergedDuration > 0 && showProgress;
  const onInternalClose = () => {
    onNoticeClose(eventKey);
  };
  const onCloseKeyDown = (e3) => {
    if (e3.key === "Enter" || e3.code === "Enter" || e3.keyCode === KeyCode_default.ENTER) {
      onInternalClose();
    }
  };
  React7.useEffect(() => {
    if (!mergedHovering && mergedDuration > 0) {
      const start = Date.now() - spentTime;
      const timeout = setTimeout(() => {
        onInternalClose();
      }, mergedDuration * 1e3 - spentTime);
      return () => {
        if (pauseOnHover) {
          clearTimeout(timeout);
        }
        setSpentTime(Date.now() - start);
      };
    }
  }, [mergedDuration, mergedHovering, times]);
  React7.useEffect(() => {
    if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
      const start = performance.now();
      let animationFrame;
      const calculate = () => {
        cancelAnimationFrame(animationFrame);
        animationFrame = requestAnimationFrame((timestamp) => {
          const runtime = timestamp + spentTime - start;
          const progress = Math.min(runtime / (mergedDuration * 1e3), 1);
          setPercent(progress * 100);
          if (progress < 1) {
            calculate();
          }
        });
      };
      calculate();
      return () => {
        if (pauseOnHover) {
          cancelAnimationFrame(animationFrame);
        }
      };
    }
  }, [mergedDuration, spentTime, mergedHovering, mergedShowProgress, times]);
  const closableObj = React7.useMemo(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    return {};
  }, [closable]);
  const ariaProps = pickAttrs(closableObj, true);
  const validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
  const noticePrefixCls = `${prefixCls}-notice`;
  return React7.createElement("div", _extends2({}, divProps, {
    ref,
    className: clsx(noticePrefixCls, className, {
      [`${noticePrefixCls}-closable`]: closable
    }),
    style,
    onMouseEnter: (e3) => {
      setHovering(true);
      divProps?.onMouseEnter?.(e3);
    },
    onMouseLeave: (e3) => {
      setHovering(false);
      divProps?.onMouseLeave?.(e3);
    },
    onClick
  }), React7.createElement("div", {
    className: `${noticePrefixCls}-content`
  }, content), closable && React7.createElement("button", _extends2({
    className: `${noticePrefixCls}-close`,
    onKeyDown: onCloseKeyDown,
    "aria-label": "Close"
  }, ariaProps, {
    onClick: (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      onInternalClose();
    }
  }), closableObj.closeIcon ?? "x"), mergedShowProgress && React7.createElement("progress", {
    className: `${noticePrefixCls}-progress`,
    max: "100",
    value: validPercent
  }, validPercent + "%"));
});
var Notice_default = Notify;

// node_modules/@rc-component/notification/es/NotificationProvider.js
var import_react3 = __toESM(require_react());
var NotificationContext = import_react3.default.createContext({});
var NotificationProvider = ({
  children,
  classNames
}) => {
  return import_react3.default.createElement(NotificationContext.Provider, {
    value: {
      classNames
    }
  }, children);
};
var NotificationProvider_default = NotificationProvider;

// node_modules/@rc-component/notification/es/hooks/useStack.js
var DEFAULT_OFFSET = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = (config) => {
  const result = {
    offset: DEFAULT_OFFSET,
    threshold: DEFAULT_THRESHOLD,
    gap: DEFAULT_GAP
  };
  if (config && typeof config === "object") {
    result.offset = config.offset ?? DEFAULT_OFFSET;
    result.threshold = config.threshold ?? DEFAULT_THRESHOLD;
    result.gap = config.gap ?? DEFAULT_GAP;
  }
  return [!!config, result];
};
var useStack_default = useStack;

// node_modules/@rc-component/notification/es/NoticeList.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var NoticeList = (props) => {
  const {
    configList,
    placement,
    prefixCls,
    className,
    style,
    motion: motion2,
    onAllNoticeRemoved,
    onNoticeClose,
    stack: stackConfig
  } = props;
  const {
    classNames: ctxCls
  } = (0, import_react4.useContext)(NotificationContext);
  const dictRef = (0, import_react4.useRef)({});
  const [latestNotice, setLatestNotice] = (0, import_react4.useState)(null);
  const [hoverKeys, setHoverKeys] = (0, import_react4.useState)([]);
  const keys = configList.map((config) => ({
    config,
    key: String(config.key)
  }));
  const [stack, {
    offset: offset3,
    threshold,
    gap
  }] = useStack_default(stackConfig);
  const expanded = stack && (hoverKeys.length > 0 || keys.length <= threshold);
  const placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
  (0, import_react4.useEffect)(() => {
    if (stack && hoverKeys.length > 1) {
      setHoverKeys((prev) => prev.filter((key) => keys.some(({
        key: dataKey
      }) => key === dataKey)));
    }
  }, [hoverKeys, keys, stack]);
  (0, import_react4.useEffect)(() => {
    if (stack && dictRef.current[keys[keys.length - 1]?.key]) {
      setLatestNotice(dictRef.current[keys[keys.length - 1]?.key]);
    }
  }, [keys, stack]);
  return import_react4.default.createElement(CSSMotionList_default, _extends3({
    key: placement,
    className: clsx(prefixCls, `${prefixCls}-${placement}`, ctxCls?.list, className, {
      [`${prefixCls}-stack`]: !!stack,
      [`${prefixCls}-stack-expanded`]: expanded
    }),
    style,
    keys,
    motionAppear: true
  }, placementMotion, {
    onAllRemoved: () => {
      onAllNoticeRemoved(placement);
    }
  }), ({
    config,
    className: motionClassName,
    style: motionStyle,
    index: motionIndex
  }, nodeRef) => {
    const {
      key,
      times
    } = config;
    const strKey = String(key);
    const {
      className: configClassName,
      style: configStyle,
      classNames: configClassNames,
      styles: configStyles,
      ...restConfig
    } = config;
    const dataIndex = keys.findIndex((item) => item.key === strKey);
    const stackStyle = {};
    if (stack) {
      const index2 = keys.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
      const transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
      if (index2 > 0) {
        stackStyle.height = expanded ? dictRef.current[strKey]?.offsetHeight : latestNotice?.offsetHeight;
        let verticalOffset = 0;
        for (let i = 0; i < index2; i++) {
          verticalOffset += dictRef.current[keys[keys.length - 1 - i].key]?.offsetHeight + gap;
        }
        const transformY = (expanded ? verticalOffset : index2 * offset3) * (placement.startsWith("top") ? 1 : -1);
        const scaleX = !expanded && latestNotice?.offsetWidth && dictRef.current[strKey]?.offsetWidth ? (latestNotice?.offsetWidth - offset3 * 2 * (index2 < 3 ? index2 : 3)) / dictRef.current[strKey]?.offsetWidth : 1;
        stackStyle.transform = `translate3d(${transformX}, ${transformY}px, 0) scaleX(${scaleX})`;
      } else {
        stackStyle.transform = `translate3d(${transformX}, 0, 0)`;
      }
    }
    return import_react4.default.createElement("div", {
      ref: nodeRef,
      className: clsx(`${prefixCls}-notice-wrapper`, motionClassName, configClassNames?.wrapper),
      style: {
        ...motionStyle,
        ...stackStyle,
        ...configStyles?.wrapper
      },
      onMouseEnter: () => setHoverKeys((prev) => prev.includes(strKey) ? prev : [...prev, strKey]),
      onMouseLeave: () => setHoverKeys((prev) => prev.filter((k) => k !== strKey))
    }, import_react4.default.createElement(Notice_default, _extends3({}, restConfig, {
      ref: (node) => {
        if (dataIndex > -1) {
          dictRef.current[strKey] = node;
        } else {
          delete dictRef.current[strKey];
        }
      },
      prefixCls,
      classNames: configClassNames,
      styles: configStyles,
      className: clsx(configClassName, ctxCls?.notice),
      style: configStyle,
      times,
      key,
      eventKey: key,
      onNoticeClose,
      hovering: stack && hoverKeys.length > 0
    })));
  });
};
if (true) {
  NoticeList.displayName = "NoticeList";
}
var NoticeList_default = NoticeList;

// node_modules/@rc-component/notification/es/Notifications.js
var Notifications = React10.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-notification",
    container,
    motion: motion2,
    maxCount,
    className,
    style,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3
  } = props;
  const [configList, setConfigList] = React10.useState([]);
  const onNoticeClose = (key) => {
    const config = configList.find((item) => item.key === key);
    const closable = config?.closable;
    const closableObj = closable && typeof closable === "object" ? closable : {};
    const {
      onClose: closableOnClose
    } = closableObj;
    closableOnClose?.();
    config?.onClose?.();
    setConfigList((list) => list.filter((item) => item.key !== key));
  };
  React10.useImperativeHandle(ref, () => ({
    open: (config) => {
      setConfigList((list) => {
        let clone = [...list];
        const index2 = clone.findIndex((item) => item.key === config.key);
        const innerConfig = {
          ...config
        };
        if (index2 >= 0) {
          innerConfig.times = (list[index2]?.times || 0) + 1;
          clone[index2] = innerConfig;
        } else {
          innerConfig.times = 0;
          clone.push(innerConfig);
        }
        if (maxCount > 0 && clone.length > maxCount) {
          clone = clone.slice(-maxCount);
        }
        return clone;
      });
    },
    close: (key) => {
      onNoticeClose(key);
    },
    destroy: () => {
      setConfigList([]);
    }
  }));
  const [placements4, setPlacements] = React10.useState({});
  React10.useEffect(() => {
    const nextPlacements = {};
    configList.forEach((config) => {
      const {
        placement = "topRight"
      } = config;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements4).forEach((placement) => {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  const onAllNoticeRemoved = (placement) => {
    setPlacements((originPlacements) => {
      const clone = {
        ...originPlacements
      };
      const list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  };
  const emptyRef = React10.useRef(false);
  React10.useEffect(() => {
    if (Object.keys(placements4).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved?.();
      emptyRef.current = false;
    }
  }, [placements4]);
  if (!container) {
    return null;
  }
  const placementList = Object.keys(placements4);
  return (0, import_react_dom.createPortal)(React10.createElement(React10.Fragment, null, placementList.map((placement) => {
    const placementConfigList = placements4[placement];
    const list = React10.createElement(NoticeList_default, {
      key: placement,
      configList: placementConfigList,
      placement,
      prefixCls,
      className: className?.(placement),
      style: style?.(placement),
      motion: motion2,
      onNoticeClose,
      onAllNoticeRemoved,
      stack
    });
    return renderNotifications3 ? renderNotifications3(list, {
      prefixCls,
      key: placement
    }) : list;
  })), container);
});
if (true) {
  Notifications.displayName = "Notifications";
}
var Notifications_default = Notifications;

// node_modules/@rc-component/notification/es/hooks/useNotification.js
var defaultGetContainer = () => document.body;
var uniqueKey = 0;
function mergeConfig(...objList) {
  const clone = {};
  objList.forEach((obj) => {
    if (obj) {
      Object.keys(obj).forEach((key) => {
        const val = obj[key];
        if (val !== void 0) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification(rootConfig = {}) {
  const {
    getContainer = defaultGetContainer,
    motion: motion2,
    prefixCls,
    maxCount,
    className,
    style,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3,
    ...shareConfig
  } = rootConfig;
  const [container, setContainer] = React11.useState();
  const notificationsRef = React11.useRef();
  const contextHolder = React11.createElement(Notifications_default, {
    container,
    ref: notificationsRef,
    prefixCls,
    motion: motion2,
    maxCount,
    className,
    style,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3
  });
  const [taskQueue3, setTaskQueue] = React11.useState([]);
  const open3 = useEvent_default((config) => {
    const mergedConfig = mergeConfig(shareConfig, config);
    if (mergedConfig.key === null || mergedConfig.key === void 0) {
      mergedConfig.key = `rc-notification-${uniqueKey}`;
      uniqueKey += 1;
    }
    setTaskQueue((queue) => [...queue, {
      type: "open",
      config: mergedConfig
    }]);
  });
  const api = React11.useMemo(() => ({
    open: open3,
    close: (key) => {
      setTaskQueue((queue) => [...queue, {
        type: "close",
        key
      }]);
    },
    destroy: () => {
      setTaskQueue((queue) => [...queue, {
        type: "destroy"
      }]);
    }
  }), []);
  React11.useEffect(() => {
    setContainer(getContainer());
  });
  React11.useEffect(() => {
    if (notificationsRef.current && taskQueue3.length) {
      taskQueue3.forEach((task) => {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      let oriTaskQueue;
      let tgtTaskQueue;
      setTaskQueue((oriQueue) => {
        if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
          oriTaskQueue = oriQueue;
          tgtTaskQueue = oriQueue.filter((task) => !taskQueue3.includes(task));
        }
        return tgtTaskQueue;
      });
    }
  }, [taskQueue3]);
  return [api, contextHolder];
}

// node_modules/antd/es/message/PurePanel.js
var React12 = __toESM(require_react());

// node_modules/antd/es/message/style/index.js
var genMessageStyle = (token) => {
  const {
    componentCls,
    iconCls,
    boxShadow,
    colorText,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    // Custom token
    contentPadding,
    contentBg
  } = token;
  const noticeCls = `${componentCls}-notice`;
  const messageMoveIn = new Keyframes_default("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframes_default("MessageMoveOut", {
    "0%": {
      maxHeight: token.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  const noticeStyle = {
    padding: paddingXS,
    textAlign: "center",
    [`${componentCls}-custom-content`]: {
      display: "flex",
      alignItems: "center"
    },
    [`${componentCls}-custom-content > ${iconCls}`]: {
      marginInlineEnd: marginXS,
      // affected by ltr or rtl
      fontSize: fontSizeLG
    },
    [`${noticeCls}-content`]: {
      display: "inline-block",
      padding: contentPadding,
      background: contentBg,
      borderRadius: borderRadiusLG,
      boxShadow,
      pointerEvents: "all"
    },
    [`${componentCls}-success > ${iconCls}`]: {
      color: colorSuccess
    },
    [`${componentCls}-error > ${iconCls}`]: {
      color: colorError
    },
    [`${componentCls}-warning > ${iconCls}`]: {
      color: colorWarning
    },
    [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
      color: colorInfo
    }
  };
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token),
        color: colorText,
        position: "fixed",
        top: marginXS,
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: {
          ...noticeStyle
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${componentCls}-notice-pure-panel`]: {
        ...noticeStyle,
        padding: 0,
        textAlign: "start"
      }
    }
  ];
};
var prepareComponentToken4 = (token) => ({
  zIndexPopup: token.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
  contentBg: token.colorBgElevated,
  contentPadding: `${(token.controlHeightLG - token.fontSize * token.lineHeight) / 2}px ${token.paddingSM}px`
});
var style_default6 = genStyleHooks("Message", (token) => {
  const combinedToken = merge(token, {
    height: 150
  });
  return genMessageStyle(combinedToken);
}, prepareComponentToken4);

// node_modules/antd/es/message/PurePanel.js
var TypeIcon = {
  info: React12.createElement(InfoCircleFilled_default, null),
  success: React12.createElement(CheckCircleFilled_default, null),
  error: React12.createElement(CloseCircleFilled_default, null),
  warning: React12.createElement(ExclamationCircleFilled_default, null),
  loading: React12.createElement(LoadingOutlined_default, null)
};
var PureContent = (props) => {
  const {
    prefixCls,
    type,
    icon,
    children,
    classNames: pureContentClassNames,
    styles
  } = props;
  const iconElement = icon || type && TypeIcon[type];
  const iconNode = cloneElement(iconElement, (currentProps) => {
    const mergedStyle = {
      ...currentProps?.style,
      ...styles?.icon
    };
    return {
      className: clsx(currentProps.className, pureContentClassNames?.icon),
      style: mergedStyle
    };
  });
  return React12.createElement("div", {
    className: clsx(`${prefixCls}-custom-content`, `${prefixCls}-${type}`)
  }, iconNode, React12.createElement("span", {
    className: pureContentClassNames?.content,
    style: styles?.content
  }, children));
};
var PurePanel = (props) => {
  const {
    prefixCls: staticPrefixCls,
    className,
    style,
    type,
    icon,
    content,
    classNames: messageClassNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("message");
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default6(prefixCls, rootCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, messageClassNames], [contextStyles, styles], {
    props
  });
  return React12.createElement(Notice_default, {
    ...restProps,
    prefixCls,
    className: clsx(contextClassName, mergedClassNames.root, className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    eventKey: "pure",
    duration: null,
    content: React12.createElement(PureContent, {
      prefixCls,
      type,
      icon,
      classNames: mergedClassNames,
      styles: mergedStyles
    }, content)
  });
};
var PurePanel_default3 = PurePanel;

// node_modules/antd/es/message/util.js
function getMotion(prefixCls, transitionName) {
  return {
    motionName: transitionName ?? `${prefixCls}-move-up`
  };
}
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = () => {
    closeFn?.();
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}

// node_modules/antd/es/message/useMessage.js
var DEFAULT_OFFSET2 = 8;
var DEFAULT_DURATION = 3;
var Wrapper = ({
  children,
  prefixCls
}) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default6(prefixCls, rootCls);
  return React13.createElement(NotificationProvider_default, {
    classNames: {
      list: clsx(hashId, cssVarCls, rootCls)
    }
  }, children);
};
var renderNotifications = (node, {
  prefixCls,
  key
}) => React13.createElement(Wrapper, {
  prefixCls,
  key
}, node);
var Holder = React13.forwardRef((props, ref) => {
  const {
    top,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    duration = DEFAULT_DURATION,
    rtl,
    transitionName,
    onAllRemoved,
    pauseOnHover = true
  } = props;
  const {
    getPrefixCls,
    direction,
    getPopupContainer
  } = useComponentConfig("message");
  const {
    message: message2
  } = React13.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const getStyle3 = () => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: top ?? DEFAULT_OFFSET2
  });
  const getClassName = () => clsx({
    [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
  });
  const getNotificationMotion = () => getMotion(prefixCls, transitionName);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([props?.classNames, message2?.classNames], [props?.styles, message2?.styles], {
    props
  });
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle3,
    className: getClassName,
    motion: getNotificationMotion,
    // closable=false requires-no closeIcon
    closable: false,
    duration,
    getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
    maxCount,
    onAllRemoved,
    renderNotifications,
    pauseOnHover
  });
  React13.useImperativeHandle(ref, () => ({
    ...api,
    prefixCls,
    message: message2,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = React13.useRef(null);
  const warning2 = devUseWarning("Message");
  const wrapAPI = React13.useMemo(() => {
    const close = (key) => {
      holderRef.current?.close(key);
    };
    const open3 = (config) => {
      if (!holderRef.current) {
        true ? warning2(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        message: message2,
        classNames: originClassNames,
        styles: originStyles
      } = holderRef.current;
      const contextClassName = message2?.className || {};
      const contextStyle = message2?.style || {};
      const rawContextClassNames = message2?.classNames || {};
      const rawContextStyles = message2?.styles || {};
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type,
        key,
        className,
        style,
        onClose,
        classNames: configClassNames = {},
        styles = {},
        ...restConfig
      } = config;
      let mergedKey = key;
      if (!isNonNullable_default(mergedKey)) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      const contextConfig = {
        ...messageConfig,
        ...config
      };
      const contextClassNames = resolveStyleOrClass(rawContextClassNames, {
        props: contextConfig
      });
      const semanticClassNames = resolveStyleOrClass(configClassNames, {
        props: contextConfig
      });
      const contextStyles = resolveStyleOrClass(rawContextStyles, {
        props: contextConfig
      });
      const semanticStyles = resolveStyleOrClass(styles, {
        props: contextConfig
      });
      const mergedClassNames = mergeClassNames(void 0, contextClassNames, semanticClassNames, originClassNames);
      const mergedStyles = mergeStyles(contextStyles, semanticStyles, originStyles);
      return wrapPromiseFn((resolve) => {
        originOpen({
          ...restConfig,
          key: mergedKey,
          content: React13.createElement(PureContent, {
            prefixCls,
            type,
            icon,
            classNames: mergedClassNames,
            styles: mergedStyles
          }, content),
          placement: "top",
          className: clsx({
            [`${noticePrefixCls}-${type}`]: type
          }, className, contextClassName, mergedClassNames.root),
          style: {
            ...mergedStyles.root,
            ...contextStyle,
            ...style
          },
          onClose: () => {
            onClose?.();
            resolve();
          }
        });
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy3 = (key) => {
      if (key !== void 0) {
        close(key);
      } else {
        holderRef.current?.destroy();
      }
    };
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys = ["info", "success", "warning", "error", "loading"];
    keys.forEach((type) => {
      const typeOpen2 = (jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = {
          onClose: mergedOnClose,
          duration: mergedDuration,
          ...config,
          type
        };
        return open3(mergedConfig);
      };
      clone[type] = typeOpen2;
    });
    return clone;
  }, []);
  return [wrapAPI, React13.createElement(Holder, {
    key: "message-holder",
    ...messageConfig,
    ref: holderRef
  })];
}
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}

// node_modules/antd/es/modal/useModal/index.js
var React50 = __toESM(require_react());

// node_modules/antd/es/modal/confirm.js
var import_react19 = __toESM(require_react());

// node_modules/@rc-component/util/es/React/render.js
var import_client = __toESM(require_client());
var MARK = "__rc_react_root__";
function render(node, container) {
  const root = container[MARK] || (0, import_client.createRoot)(container);
  root.render(node);
  container[MARK] = root;
}
async function unmount(container) {
  return Promise.resolve().then(() => {
    container[MARK]?.unmount();
    delete container[MARK];
  });
}

// node_modules/antd/es/modal/ConfirmDialog.js
var React47 = __toESM(require_react());

// node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var import_react11 = __toESM(require_react());

// node_modules/antd/es/_util/ActionButton.js
var React22 = __toESM(require_react());

// node_modules/antd/es/button/Button.js
var import_react9 = __toESM(require_react());

// node_modules/antd/es/_util/wave/index.js
var import_react5 = __toESM(require_react());

// node_modules/antd/es/_util/wave/style.js
var genWaveStyle = (token) => {
  const {
    componentCls,
    colorPrimary
  } = token;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token.motionEaseOutCirc}`, `opacity 2s ${token.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${token.motionDurationSlow} ${token.motionEaseInOut}`, `opacity ${token.motionDurationSlow} ${token.motionEaseInOut}`].join(",")
        }
      }
    }
  };
};
var style_default7 = genComponentStyleHook("Wave", genWaveStyle);

// node_modules/antd/es/_util/wave/useWave.js
var React15 = __toESM(require_react());

// node_modules/antd/es/_util/wave/interface.js
var TARGET_CLS = `${defaultPrefixCls}-wave-target`;

// node_modules/antd/es/_util/wave/WaveEffect.js
var React14 = __toESM(require_react());

// node_modules/antd/es/_util/wave/util.js
function isValidWaveColor(color) {
  return color && typeof color === "string" && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
  color !== "transparent" && color !== "canvastext";
}
function getTargetWaveColor(node, colorSource = null) {
  const style = getComputedStyle(node);
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = style;
  if (colorSource && isValidWaveColor(style[colorSource])) {
    return style[colorSource];
  }
  return [borderTopColor, borderColor, backgroundColor].find(isValidWaveColor) ?? null;
}

// node_modules/antd/es/_util/wave/WaveEffect.js
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
var WaveEffect = (props) => {
  const {
    className,
    target,
    component,
    colorSource
  } = props;
  const divRef = React14.useRef(null);
  const [color, setWaveColor] = React14.useState(null);
  const [borderRadius, setBorderRadius] = React14.useState([]);
  const [left, setLeft] = React14.useState(0);
  const [top, setTop] = React14.useState(0);
  const [width, setWidth] = React14.useState(0);
  const [height, setHeight] = React14.useState(0);
  const [enabled, setEnabled] = React14.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
  };
  if (color) {
    waveStyle["--wave-color"] = color;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor(target, colorSource));
    const isStatic = nodeStyle.position === "static";
    const {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-Number.parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum(-Number.parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(Number.parseFloat(radius2))));
  }
  React14.useEffect(() => {
    if (target) {
      const id = raf_default(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(syncPos);
        resizeObserver.observe(target);
      }
      return () => {
        raf_default.cancel(id);
        resizeObserver?.disconnect();
      };
    }
  }, [target]);
  if (!enabled) {
    return null;
  }
  const isSmallComponent = (component === "Checkbox" || component === "Radio") && target?.classList.contains(TARGET_CLS);
  return React14.createElement(es_default4, {
    visible: true,
    motionAppear: true,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (_, event) => {
      if (event.deadline || event.propertyName === "opacity") {
        const holder = divRef.current?.parentElement;
        unmount(holder).then(() => {
          holder?.remove();
        });
      }
      return false;
    }
  }, ({
    className: motionClassName
  }, ref) => React14.createElement("div", {
    ref: composeRef(divRef, ref),
    className: clsx(className, motionClassName, {
      "wave-quick": isSmallComponent
    }),
    style: waveStyle
  }));
};
var showWaveEffect = (target, info) => {
  const {
    component
  } = info;
  if (component === "Checkbox" && !target.querySelector("input")?.checked) {
    return;
  }
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = "0px";
  holder.style.top = "0px";
  target?.insertBefore(holder, target?.firstChild);
  render(React14.createElement(WaveEffect, {
    ...info,
    target
  }), holder);
};
var WaveEffect_default = showWaveEffect;

// node_modules/antd/es/_util/wave/useWave.js
var useWave = (nodeRef, className, component, colorSource) => {
  const {
    wave
  } = React15.useContext(ConfigContext);
  const [, token, hashId] = useToken();
  const showWave = useEvent_default((event) => {
    const node = nodeRef.current;
    if (wave?.disabled || !node) {
      return;
    }
    const targetNode = node.querySelector(`.${TARGET_CLS}`) || node;
    const {
      showEffect
    } = wave || {};
    (showEffect || WaveEffect_default)(targetNode, {
      className,
      token,
      component,
      event,
      hashId,
      colorSource
    });
  });
  const rafId = React15.useRef(null);
  React15.useEffect(() => () => {
    raf_default.cancel(rafId.current);
  }, []);
  const showDebounceWave = (event) => {
    raf_default.cancel(rafId.current);
    rafId.current = raf_default(() => {
      showWave(event);
    });
  };
  return showDebounceWave;
};
var useWave_default = useWave;

// node_modules/antd/es/_util/wave/index.js
var Wave = (props) => {
  const {
    children,
    disabled,
    component,
    colorSource
  } = props;
  const {
    getPrefixCls
  } = (0, import_react5.useContext)(ConfigContext);
  const containerRef = (0, import_react5.useRef)(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = style_default7(prefixCls);
  const showWave = useWave_default(containerRef, clsx(prefixCls, hashId), component, colorSource);
  import_react5.default.useEffect(() => {
    const node = containerRef.current;
    if (!node || node.nodeType !== window.Node.ELEMENT_NODE || disabled) {
      return;
    }
    const onClick = (e3) => {
      if (!isVisible_default(e3.target) || // No need wave
      !node.getAttribute || node.getAttribute("disabled") || node.disabled || node.className.includes("disabled") && !node.className.includes("disabled:") || node.getAttribute("aria-disabled") === "true" || node.className.includes("-leave")) {
        return;
      }
      showWave(e3);
    };
    node.addEventListener("click", onClick, true);
    return () => {
      node.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!import_react5.default.isValidElement(children)) {
    return children ?? null;
  }
  const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
  return cloneElement(children, {
    ref
  });
};
if (true) {
  Wave.displayName = "Wave";
}
var wave_default = Wave;

// node_modules/antd/es/button/ButtonGroup.js
var React17 = __toESM(require_react());
var GroupSizeContext = React17.createContext(void 0);
var ButtonGroup = (props) => {
  const {
    getPrefixCls,
    direction
  } = React17.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    size,
    className,
    ...others
  } = props;
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = useToken();
  const sizeCls = React17.useMemo(() => {
    switch (size) {
      case "large":
        return "lg";
      case "small":
        return "sm";
      default:
        return "";
    }
  }, [size]);
  if (true) {
    const warning2 = devUseWarning("Button.Group");
    warning2.deprecated(false, "Button.Group", "Space.Compact");
    true ? warning2(!size || ["large", "small", "middle"].includes(size), "usage", "Invalid prop `size`.") : void 0;
  }
  const classes = clsx(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return React17.createElement(GroupSizeContext.Provider, {
    value: size
  }, React17.createElement("div", {
    ...others,
    className: classes
  }));
};
var ButtonGroup_default = ButtonGroup;

// node_modules/antd/es/button/buttonHelpers.js
var import_react6 = __toESM(require_react());
var rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type) {
  if (type === "danger") {
    return {
      danger: true
    };
  }
  return {
    type
  };
}
function isString(str) {
  return typeof str === "string";
}
function isUnBorderedButtonVariant(type) {
  return type === "text" || type === "link";
}
function splitCNCharsBySpace(child, needInserted, style, className) {
  if (!isNonNullable_default(child) || child === "") {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, (oriProps) => ({
      ...oriProps,
      children: oriProps.children.split("").join(SPACE),
      className,
      style
    }));
  }
  if (isString(child)) {
    return import_react6.default.createElement("span", {
      className,
      style
    }, isTwoCNChar(child) ? child.split("").join(SPACE) : child);
  }
  if (isFragment(child)) {
    return import_react6.default.createElement("span", {
      className,
      style
    }, child);
  }
  return cloneElement(child, (oriProps) => ({
    ...oriProps,
    className: clsx(oriProps.className, className) || void 0,
    style: {
      ...oriProps.style,
      ...style
    }
  }));
}
function spaceChildren(children, needInserted, style, className) {
  let isPrevChildPure = false;
  const childList = [];
  import_react6.default.Children.forEach(children, (child) => {
    const type = typeof child;
    const isCurrentChildPure = type === "string" || type === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return import_react6.default.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted, style, className));
}
var _ButtonColorTypes = ["default", "primary", "danger"].concat(_toConsumableArray(PresetColors));

// node_modules/antd/es/button/DefaultLoadingIcon.js
var import_react8 = __toESM(require_react());

// node_modules/antd/es/button/IconWrapper.js
var import_react7 = __toESM(require_react());
var IconWrapper = (0, import_react7.forwardRef)((props, ref) => {
  const {
    className,
    style,
    children,
    prefixCls
  } = props;
  const iconWrapperCls = clsx(`${prefixCls}-icon`, className);
  return import_react7.default.createElement("span", {
    ref,
    className: iconWrapperCls,
    style
  }, children);
});
var IconWrapper_default = IconWrapper;

// node_modules/antd/es/button/DefaultLoadingIcon.js
var InnerLoadingIcon = (0, import_react8.forwardRef)((props, ref) => {
  const {
    prefixCls,
    className,
    style,
    iconClassName
  } = props;
  const mergedIconCls = clsx(`${prefixCls}-loading-icon`, className);
  return import_react8.default.createElement(IconWrapper_default, {
    prefixCls,
    className: mergedIconCls,
    style,
    ref
  }, import_react8.default.createElement(LoadingOutlined_default, {
    className: iconClassName
  }));
});
var getCollapsedWidth = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
});
var getRealWidth = (node) => ({
  width: node.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
});
var DefaultLoadingIcon = (props) => {
  const {
    prefixCls,
    loading,
    existIcon,
    className,
    style,
    mount
  } = props;
  const visible = !!loading;
  if (existIcon) {
    return import_react8.default.createElement(InnerLoadingIcon, {
      prefixCls,
      className,
      style
    });
  }
  return import_react8.default.createElement(es_default4, {
    visible,
    // Used for minus flex gap style only
    motionName: `${prefixCls}-loading-icon-motion`,
    motionAppear: !mount,
    motionEnter: !mount,
    motionLeave: !mount,
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, ({
    className: motionCls,
    style: motionStyle
  }, ref) => {
    const mergedStyle = {
      ...style,
      ...motionStyle
    };
    return import_react8.default.createElement(InnerLoadingIcon, {
      prefixCls,
      className: clsx(className, motionCls),
      style: mergedStyle,
      ref
    });
  });
};
var DefaultLoadingIcon_default = DefaultLoadingIcon;

// node_modules/antd/es/button/style/group.js
var genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
  // Border
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
var genGroupStyle = (token) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    groupBorderColor,
    colorErrorHover
  } = token;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: token.calc(lineWidth).mul(-1).equal(),
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      // Border Color
      genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
var group_default = genGroupStyle;

// node_modules/antd/es/button/style/token.js
var prepareToken = (token) => {
  const {
    paddingInline,
    onlyIconSize,
    borderColorDisabled
  } = token;
  const buttonToken = merge(token, {
    buttonPaddingHorizontal: paddingInline,
    buttonPaddingVertical: 0,
    buttonIconOnlyFontSize: onlyIconSize,
    colorBorderDisabled: borderColorDisabled
  });
  return buttonToken;
};
var prepareComponentToken5 = (token) => {
  const contentFontSize = token.contentFontSize ?? token.fontSize;
  const contentFontSizeSM = token.contentFontSizeSM ?? token.fontSize;
  const contentFontSizeLG = token.contentFontSizeLG ?? token.fontSizeLG;
  const contentLineHeight = token.contentLineHeight ?? getLineHeight(contentFontSize);
  const contentLineHeightSM = token.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
  const contentLineHeightLG = token.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
  const solidTextColor = isBright(new AggregationColor(token.colorBgSolid), "#fff") ? "#000" : "#fff";
  const shadowColorTokens = PresetColors.reduce((prev, colorKey) => ({
    ...prev,
    [`${colorKey}ShadowColor`]: `0 ${unit(token.controlOutlineWidth)} 0 ${getAlphaColor_default(token[`${colorKey}1`], token.colorBgContainer)}`
  }), {});
  const defaultBgDisabled = token.colorBgContainerDisabled;
  const dashedBgDisabled = token.colorBgContainerDisabled;
  return {
    ...shadowColorTokens,
    fontWeight: 400,
    iconGap: token.marginXS,
    defaultShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlTmpOutline}`,
    primaryShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlOutline}`,
    dangerShadow: `0 ${token.controlOutlineWidth}px 0 ${token.colorErrorOutline}`,
    primaryColor: token.colorTextLightSolid,
    dangerColor: token.colorTextLightSolid,
    borderColorDisabled: token.colorBorderDisabled,
    defaultGhostColor: token.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: token.colorBgContainer,
    paddingInline: token.paddingContentHorizontal - token.lineWidth,
    paddingInlineLG: token.paddingContentHorizontal - token.lineWidth,
    paddingInlineSM: 8 - token.lineWidth,
    onlyIconSize: "inherit",
    onlyIconSizeSM: "inherit",
    onlyIconSizeLG: "inherit",
    groupBorderColor: token.colorPrimaryHover,
    linkHoverBg: "transparent",
    textTextColor: token.colorText,
    textTextHoverColor: token.colorText,
    textTextActiveColor: token.colorText,
    textHoverBg: token.colorFillTertiary,
    defaultColor: token.colorText,
    defaultBg: token.colorBgContainer,
    defaultBorderColor: token.colorBorder,
    defaultBorderColorDisabled: token.colorBorder,
    defaultHoverBg: token.colorBgContainer,
    defaultHoverColor: token.colorPrimaryHover,
    defaultHoverBorderColor: token.colorPrimaryHover,
    defaultActiveBg: token.colorBgContainer,
    defaultActiveColor: token.colorPrimaryActive,
    defaultActiveBorderColor: token.colorPrimaryActive,
    solidTextColor,
    contentFontSize,
    contentFontSizeSM,
    contentFontSizeLG,
    contentLineHeight,
    contentLineHeightSM,
    contentLineHeightLG,
    paddingBlock: Math.max((token.controlHeight - contentFontSize * contentLineHeight) / 2 - token.lineWidth, 0),
    paddingBlockSM: Math.max((token.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token.lineWidth, 0),
    paddingBlockLG: Math.max((token.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token.lineWidth, 0),
    defaultBgDisabled,
    dashedBgDisabled
  };
};

// node_modules/antd/es/button/style/variant.js
var genVariantStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  const getCssVar = genCssVar(antCls, "btn");
  return {
    [componentCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        // Border
        [getCssVar("border-width")]: "1px",
        [getCssVar("border-color")]: "#000",
        [getCssVar("border-color-hover")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-color-active")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-color-disabled")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-style")]: "solid",
        // Text
        [getCssVar("text-color")]: "#000",
        [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
        [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`,
        [getCssVar("text-color-disabled")]: `var(${getCssVar("text-color")})`,
        // Background
        [getCssVar("bg-color")]: "#ddd",
        [getCssVar("bg-color-hover")]: `var(${getCssVar("bg-color")})`,
        [getCssVar("bg-color-active")]: `var(${getCssVar("bg-color")})`,
        [getCssVar("bg-color-disabled")]: token.colorBgContainerDisabled,
        [getCssVar("bg-color-container")]: token.colorBgContainer,
        // Shadow
        [getCssVar("shadow")]: "none"
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        // Basic
        border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color")})`,
        color: `var(${getCssVar("text-color")})`,
        backgroundColor: `var(${getCssVar("bg-color")})`,
        // Status
        [`&:not(:disabled):not(${componentCls}-disabled)`]: {
          // Hover
          "&:hover": {
            border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-hover")})`,
            color: `var(${getCssVar("text-color-hover")})`,
            backgroundColor: `var(${getCssVar("bg-color-hover")})`
          },
          // Active
          "&:active": {
            border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-active")})`,
            color: `var(${getCssVar("text-color-active")})`,
            backgroundColor: `var(${getCssVar("bg-color-active")})`
          }
        }
      },
      // ==============================================================
      // ==                         Variants                         ==
      // ==============================================================
      {
        // >>>>> Solid
        [`&${componentCls}-variant-solid`]: {
          // Solid Variables
          [getCssVar("solid-bg-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("solid-bg-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("solid-bg-color-active")]: `var(${getCssVar("color-active")})`,
          // Variables
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: token.colorTextLightSolid,
          [getCssVar("bg-color")]: `var(${getCssVar("solid-bg-color")})`,
          [getCssVar("bg-color-hover")]: `var(${getCssVar("solid-bg-color-hover")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("solid-bg-color-active")})`,
          // Box Shadow
          boxShadow: `var(${getCssVar("shadow")})`
        },
        // >>>>> Outlined & Dashed
        [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
          [getCssVar("border-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("border-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("border-color-active")]: `var(${getCssVar("color-active")})`,
          [getCssVar("bg-color")]: `var(${getCssVar("bg-color-container")})`,
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
          // Box Shadow
          boxShadow: `var(${getCssVar("shadow")})`
        },
        // >>>>> Dashed
        [`&${componentCls}-variant-dashed`]: {
          [getCssVar("border-style")]: "dashed",
          [getCssVar("bg-color-disabled")]: token.dashedBgDisabled
        },
        // >>>>> Filled
        [`&${componentCls}-variant-filled`]: {
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("bg-color")]: `var(${getCssVar("color-light")})`,
          [getCssVar("bg-color-hover")]: `var(${getCssVar("color-light-hover")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
        },
        // >>>>> Text & Link
        [`&${componentCls}-variant-text, &${componentCls}-variant-link`]: {
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
          [getCssVar("bg-color")]: "transparent",
          [getCssVar("bg-color-hover")]: "transparent",
          [getCssVar("bg-color-active")]: "transparent",
          [`&:disabled, &${token.componentCls}-disabled`]: {
            background: "transparent",
            borderColor: "transparent"
          }
        },
        // >>>>> Text
        [`&${componentCls}-variant-text`]: {
          [getCssVar("bg-color-hover")]: `var(${getCssVar("color-light")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
        }
      },
      // ==============================================================
      // ==                          Colors                          ==
      // ==============================================================
      {
        // ======================== By Default ========================
        // >>>>> Link
        [`&${componentCls}-variant-link`]: {
          [getCssVar("color-base")]: token.colorLink,
          [getCssVar("color-hover")]: token.colorLinkHover,
          [getCssVar("color-active")]: token.colorLinkActive
        },
        // ======================== Compatible ========================
        // >>>>> Primary
        [`&${componentCls}-color-primary`]: {
          [getCssVar("color-base")]: token.colorPrimary,
          [getCssVar("color-hover")]: token.colorPrimaryHover,
          [getCssVar("color-active")]: token.colorPrimaryActive,
          [getCssVar("color-light")]: token.colorPrimaryBg,
          [getCssVar("color-light-hover")]: token.colorPrimaryBgHover,
          [getCssVar("color-light-active")]: token.colorPrimaryBorder,
          [getCssVar("shadow")]: token.primaryShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token.primaryColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          }
        },
        // >>>>> Danger
        [`&${componentCls}-color-dangerous`]: {
          [getCssVar("color-base")]: token.colorError,
          [getCssVar("color-hover")]: token.colorErrorHover,
          [getCssVar("color-active")]: token.colorErrorActive,
          [getCssVar("color-light")]: token.colorErrorBg,
          [getCssVar("color-light-hover")]: token.colorErrorBgFilledHover,
          [getCssVar("color-light-active")]: token.colorErrorBgActive,
          [getCssVar("shadow")]: token.dangerShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token.dangerColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          }
        },
        // >>>>> Default
        [`&${componentCls}-color-default`]: {
          [getCssVar("solid-bg-color")]: token.colorBgSolid,
          [getCssVar("solid-bg-color-hover")]: token.colorBgSolidHover,
          [getCssVar("solid-bg-color-active")]: token.colorBgSolidActive,
          [getCssVar("color-base")]: token.defaultBorderColor,
          [getCssVar("color-hover")]: token.defaultHoverBorderColor,
          [getCssVar("color-active")]: token.defaultActiveBorderColor,
          [getCssVar("color-light")]: token.colorFillTertiary,
          [getCssVar("color-light-hover")]: token.colorFillSecondary,
          [getCssVar("color-light-active")]: token.colorFill,
          [getCssVar("text-color")]: token.colorText,
          [getCssVar("text-color-hover")]: token.defaultHoverBorderColor,
          [getCssVar("text-color-active")]: token.defaultActiveBorderColor,
          [getCssVar("shadow")]: token.defaultShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token.solidTextColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          },
          [`&${componentCls}-variant-filled, &${componentCls}-variant-text`]: {
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          },
          [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
            [getCssVar("bg-color-hover")]: token.defaultHoverBg,
            [getCssVar("bg-color-active")]: token.defaultActiveBg
          },
          [`&${componentCls}-background-ghost`]: {
            [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
              [getCssVar("text-color")]: token.defaultGhostColor,
              [getCssVar("border-color")]: token.defaultGhostBorderColor
            }
          }
        }
      },
      // >>>>> Preset Colors
      PresetColors.map((colorKey) => {
        const darkColor = token[`${colorKey}6`];
        const lightColor = token[`${colorKey}1`];
        const hoverColor = token[`${colorKey}5`];
        const lightHoverColor = token[`${colorKey}2`];
        const lightActiveColor = token[`${colorKey}3`];
        const activeColor = token[`${colorKey}7`];
        const shadowColor = token[`${colorKey}ShadowColor`];
        return {
          [`&${componentCls}-color-${colorKey}`]: {
            [getCssVar("color-base")]: darkColor,
            [getCssVar("color-hover")]: hoverColor,
            [getCssVar("color-active")]: activeColor,
            [getCssVar("color-light")]: lightColor,
            [getCssVar("color-light-hover")]: lightHoverColor,
            [getCssVar("color-light-active")]: lightActiveColor,
            [getCssVar("shadow")]: shadowColor
          }
        };
      }),
      // ==============================================================
      // ==                         Disabled                         ==
      // ==============================================================
      {
        // Disabled
        [`&:disabled, &${token.componentCls}-disabled`]: {
          cursor: "not-allowed",
          borderColor: token.colorBorderDisabled,
          background: `var(${getCssVar("bg-color-disabled")})`,
          color: token.colorTextDisabled,
          boxShadow: "none"
        }
      },
      // ==============================================================
      // ==                          Ghost                           ==
      // ==============================================================
      {
        // Ghost
        [`&${componentCls}-background-ghost`]: {
          [getCssVar("bg-color")]: "transparent",
          [getCssVar("shadow")]: "none"
        }
      }
    ]
  };
};
var variant_default = genVariantStyle;

// node_modules/antd/es/button/style/index.js
var genSharedButtonStyle = (token) => {
  const {
    componentCls,
    iconCls,
    fontWeight,
    opacityLoading,
    motionDurationSlow,
    motionEaseInOut,
    iconGap,
    calc
  } = token;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: iconGap,
      alignItems: "center",
      justifyContent: "center",
      fontWeight,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      cursor: "pointer",
      transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      "&:disabled > *": {
        pointerEvents: "none"
      },
      // https://github.com/ant-design/ant-design/issues/51380
      [`${componentCls}-icon > svg`]: resetIcon(),
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": genFocusStyle(token),
      [`&${componentCls}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-icon-only`]: {
        paddingInline: 0,
        // make `btn-icon-only` not too narrow
        [`&${componentCls}-compact-item`]: {
          flex: "none"
        }
      },
      // Loading
      [`&${componentCls}-loading`]: {
        opacity: opacityLoading,
        cursor: "default"
      },
      [`${componentCls}-loading-icon`]: {
        transition: ["width", "opacity", "margin"].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
      },
      // iconPlacement
      [`&:not(${componentCls}-icon-end)`]: {
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineEnd: calc(iconGap).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineEnd: 0
          },
          "&-leave-start": {
            marginInlineEnd: 0
          },
          "&-leave-active": {
            marginInlineEnd: calc(iconGap).mul(-1).equal()
          }
        }
      },
      "&-icon-end": {
        flexDirection: "row-reverse",
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineStart: calc(iconGap).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineStart: 0
          },
          "&-leave-start": {
            marginInlineStart: 0
          },
          "&-leave-active": {
            marginInlineStart: calc(iconGap).mul(-1).equal()
          }
        }
      }
    }
  };
};
var genCircleButtonStyle = (token) => ({
  minWidth: token.controlHeight,
  paddingInline: 0,
  borderRadius: "50%"
});
var genButtonStyle = (token, prefixCls = "") => {
  const {
    componentCls,
    controlHeight,
    fontSize,
    borderRadius,
    buttonPaddingHorizontal,
    iconCls,
    buttonPaddingVertical,
    buttonIconOnlyFontSize
  } = token;
  return [
    {
      [prefixCls]: {
        fontSize,
        height: controlHeight,
        padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
        borderRadius,
        [`&${componentCls}-icon-only`]: {
          width: controlHeight,
          [iconCls]: {
            fontSize: buttonIconOnlyFontSize
          }
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token)
    },
    {
      [`${componentCls}${componentCls}-round${prefixCls}`]: {
        borderRadius: token.controlHeight,
        [`&:not(${componentCls}-icon-only)`]: {
          paddingInline: token.buttonPaddingHorizontal
        }
      }
    }
  ];
};
var genSizeBaseButtonStyle = (token) => {
  const baseToken = merge(token, {
    fontSize: token.contentFontSize
  });
  return genButtonStyle(baseToken, token.componentCls);
};
var genSizeSmallButtonStyle = (token) => {
  const smallToken = merge(token, {
    controlHeight: token.controlHeightSM,
    fontSize: token.contentFontSizeSM,
    padding: token.paddingXS,
    buttonPaddingHorizontal: token.paddingInlineSM,
    buttonPaddingVertical: 0,
    borderRadius: token.borderRadiusSM,
    buttonIconOnlyFontSize: token.onlyIconSizeSM
  });
  return genButtonStyle(smallToken, `${token.componentCls}-sm`);
};
var genSizeLargeButtonStyle = (token) => {
  const largeToken = merge(token, {
    controlHeight: token.controlHeightLG,
    fontSize: token.contentFontSizeLG,
    buttonPaddingHorizontal: token.paddingInlineLG,
    buttonPaddingVertical: 0,
    borderRadius: token.borderRadiusLG,
    buttonIconOnlyFontSize: token.onlyIconSizeLG
  });
  return genButtonStyle(largeToken, `${token.componentCls}-lg`);
};
var genBlockButtonStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
var style_default8 = genStyleHooks("Button", (token) => {
  const buttonToken = prepareToken(token);
  return [
    // Shared
    genSharedButtonStyle(buttonToken),
    // Size
    genSizeBaseButtonStyle(buttonToken),
    genSizeSmallButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    // Block
    genBlockButtonStyle(buttonToken),
    // Variant
    variant_default(buttonToken),
    // Button Group
    group_default(buttonToken)
  ];
}, prepareComponentToken5, {
  unitless: {
    fontWeight: true,
    contentLineHeight: true,
    contentLineHeightSM: true,
    contentLineHeightLG: true
  }
});

// node_modules/antd/es/style/compact-item-vertical.js
function compactItemVerticalBorder(token, parentCls, prefixCls) {
  return {
    // border collapse
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: token.calc(token.lineWidth).mul(-1).equal()
    },
    [`&-item:not(${prefixCls}-status-success)`]: {
      zIndex: 2
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 3
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle(token) {
  const compactCls = `${token.componentCls}-compact-vertical`;
  return {
    [compactCls]: {
      ...compactItemVerticalBorder(token, compactCls, token.componentCls),
      ...compactItemBorderVerticalRadius(token.componentCls, compactCls)
    }
  };
}

// node_modules/antd/es/button/style/compact.js
var genButtonCompactStyle = (token) => {
  const {
    componentCls,
    colorPrimaryHover,
    lineWidth,
    calc
  } = token;
  const insetOffset = calc(lineWidth).mul(-1).equal();
  const getCompactBorderStyle = (vertical) => {
    const itemCls = `${componentCls}-compact${vertical ? "-vertical" : ""}-item`;
    const selector = `${itemCls}${componentCls}-primary:not([disabled])`;
    return {
      // TODO: Border color transition should be not cover when has color.
      [itemCls]: {
        transition: `none`
      },
      [`${selector} + ${selector}::before`]: {
        position: "absolute",
        top: vertical ? insetOffset : 0,
        insetInlineStart: vertical ? 0 : insetOffset,
        backgroundColor: colorPrimaryHover,
        content: '""',
        width: vertical ? "100%" : lineWidth,
        height: vertical ? lineWidth : "100%"
      }
    };
  };
  return {
    ...getCompactBorderStyle(),
    ...getCompactBorderStyle(true)
  };
};
var compact_default = genSubStyleComponent(["Button", "compact"], (token) => {
  const buttonToken = prepareToken(token);
  return [
    // Space Compact
    genCompactItemStyle(buttonToken),
    genCompactItemVerticalStyle(buttonToken),
    genButtonCompactStyle(buttonToken)
  ];
}, prepareComponentToken5);

// node_modules/antd/es/button/Button.js
function getLoadingConfig(loading) {
  if (typeof loading === "object" && loading) {
    let delay = loading?.delay;
    delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
    return {
      loading: delay <= 0,
      delay
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
var ButtonTypeMap = {
  default: ["default", "outlined"],
  primary: ["primary", "solid"],
  dashed: ["default", "dashed"],
  // `link` is not a real color but we should compatible with it
  link: ["link", "link"],
  text: ["default", "text"]
};
var InternalCompoundedButton = import_react9.default.forwardRef((props, ref) => {
  const {
    _skipSemantic,
    loading = false,
    prefixCls: customizePrefixCls,
    color,
    variant,
    type,
    danger = false,
    shape: customizeShape,
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    iconPosition,
    iconPlacement,
    ghost = false,
    block = false,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType = "button",
    classNames,
    styles,
    style,
    autoInsertSpace,
    autoFocus,
    ...rest
  } = props;
  const childNodes = toArray(children);
  const mergedType = type || "default";
  const {
    button
  } = import_react9.default.useContext(ConfigContext);
  const shape = customizeShape || button?.shape || "default";
  const [parsedColor, parsedVariant] = (0, import_react9.useMemo)(() => {
    if (color && variant) {
      return [color, variant];
    }
    if (type || danger) {
      const colorVariantPair = ButtonTypeMap[mergedType] || [];
      if (danger) {
        return ["danger", colorVariantPair[1]];
      }
      return colorVariantPair;
    }
    if (button?.color && button?.variant) {
      return [button.color, button.variant];
    }
    return ["default", "outlined"];
  }, [color, variant, type, danger, button?.color, button?.variant, mergedType]);
  const [mergedColor, mergedVariant] = (0, import_react9.useMemo)(() => {
    if (ghost && parsedVariant === "solid") {
      return [parsedColor, "outlined"];
    }
    return [parsedColor, parsedVariant];
  }, [parsedColor, parsedVariant, ghost]);
  const isDanger = mergedColor === "danger";
  const mergedColorText = isDanger ? "dangerous" : mergedColor;
  const {
    getPrefixCls,
    direction,
    autoInsertSpace: contextAutoInsertSpace,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("button");
  const mergedInsertSpace = autoInsertSpace ?? contextAutoInsertSpace ?? true;
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const disabled = (0, import_react9.useContext)(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const groupSize = (0, import_react9.useContext)(GroupSizeContext);
  const loadingOrDelay = (0, import_react9.useMemo)(() => getLoadingConfig(loading), [loading]);
  const [innerLoading, setLoading] = (0, import_react9.useState)(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = (0, import_react9.useState)(false);
  const buttonRef = (0, import_react9.useRef)(null);
  const mergedRef = useComposeRef(ref, buttonRef);
  const needInserted = childNodes.length === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
  const isMountRef = (0, import_react9.useRef)(true);
  import_react9.default.useEffect(() => {
    isMountRef.current = false;
    return () => {
      isMountRef.current = true;
    };
  }, []);
  useLayoutEffect_default(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    return cleanupTimer;
  }, [loadingOrDelay.delay, loadingOrDelay.loading]);
  (0, import_react9.useEffect)(() => {
    if (!buttonRef.current || !mergedInsertSpace) {
      return;
    }
    const buttonText = buttonRef.current.textContent || "";
    if (needInserted && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  });
  (0, import_react9.useEffect)(() => {
    if (autoFocus && buttonRef.current) {
      buttonRef.current.focus();
    }
  }, []);
  const handleClick = import_react9.default.useCallback((e3) => {
    if (innerLoading || mergedDisabled) {
      e3.preventDefault();
      return;
    }
    props.onClick?.("href" in props ? e3 : e3);
  }, [props.onClick, innerLoading, mergedDisabled]);
  if (true) {
    const warning2 = devUseWarning("Button");
    true ? warning2(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
    true ? warning2(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.") : void 0;
    warning2.deprecated(!iconPosition, "iconPosition", "iconPlacement");
  }
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  const sizeFullName = useSize_default((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
  const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] ?? "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const mergedIconPlacement = iconPlacement ?? iconPosition ?? "start";
  const linkButtonRestProps = omit(rest, ["navigate"]);
  const mergedProps = {
    ...props,
    type: mergedType,
    color: mergedColor,
    variant: mergedVariant,
    danger: isDanger,
    shape,
    size: sizeFullName,
    disabled: mergedDisabled,
    loading: innerLoading,
    iconPlacement: mergedIconPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([_skipSemantic ? void 0 : contextClassNames, classNames], [_skipSemantic ? void 0 : contextStyles, styles], {
    props: mergedProps
  });
  const classes = clsx(prefixCls, hashId, cssVarCls, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape !== "square" && shape,
    // Compatible with versions earlier than 5.21.0
    [`${prefixCls}-${mergedType}`]: mergedType,
    [`${prefixCls}-dangerous`]: danger,
    [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
    [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-icon-end`]: mergedIconPlacement === "end"
  }, compactItemClassnames, className, rootClassName, contextClassName, mergedClassNames.root);
  const fullStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const iconSharedProps = {
    className: mergedClassNames.icon,
    style: mergedStyles.icon
  };
  const iconWrapperElement = (child) => import_react9.default.createElement(IconWrapper_default, {
    prefixCls,
    ...iconSharedProps
  }, child);
  const defaultLoadingIconElement = import_react9.default.createElement(DefaultLoadingIcon_default, {
    existIcon: !!icon,
    prefixCls,
    loading: innerLoading,
    mount: isMountRef.current,
    ...iconSharedProps
  });
  let iconNode;
  if (icon && !innerLoading) {
    iconNode = iconWrapperElement(icon);
  } else if (loading && typeof loading === "object" && loading.icon) {
    iconNode = iconWrapperElement(loading.icon);
  } else {
    iconNode = defaultLoadingIconElement;
  }
  const contentNode = isNonNullable_default(children) ? spaceChildren(children, needInserted && mergedInsertSpace, mergedStyles.content, mergedClassNames.content) : null;
  if (linkButtonRestProps.href !== void 0) {
    return import_react9.default.createElement("a", {
      ...linkButtonRestProps,
      className: clsx(classes, {
        [`${prefixCls}-disabled`]: mergedDisabled
      }),
      href: mergedDisabled ? void 0 : linkButtonRestProps.href,
      style: fullStyle,
      onClick: handleClick,
      ref: mergedRef,
      tabIndex: mergedDisabled ? -1 : 0,
      "aria-disabled": mergedDisabled
    }, iconNode, contentNode);
  }
  let buttonNode = import_react9.default.createElement("button", {
    ...rest,
    type: htmlType,
    className: classes,
    style: fullStyle,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: mergedRef
  }, iconNode, contentNode, compactItemClassnames && import_react9.default.createElement(compact_default, {
    prefixCls
  }));
  if (!isUnBorderedButtonVariant(mergedVariant)) {
    buttonNode = import_react9.default.createElement(wave_default, {
      component: "Button",
      disabled: innerLoading
    }, buttonNode);
  }
  return buttonNode;
});
var Button = InternalCompoundedButton;
Button.Group = ButtonGroup_default;
Button.__ANT_BUTTON = true;
if (true) {
  Button.displayName = "Button";
}
var Button_default = Button;

// node_modules/antd/es/_util/ActionButton.js
var isThenable = (thing) => {
  return typeof thing?.then === "function";
};
var ActionButton = (props) => {
  const {
    type,
    children,
    prefixCls,
    buttonProps,
    close,
    autoFocus,
    emitEvent,
    isSilent,
    quitOnNullishReturnValue,
    actionFn
  } = props;
  const clickedRef = React22.useRef(false);
  const buttonRef = React22.useRef(null);
  const [loading, setLoading] = useSafeState(false);
  const onInternalClose = (...args) => {
    close?.(...args);
  };
  React22.useEffect(() => {
    let timeoutId = null;
    if (autoFocus) {
      timeoutId = setTimeout(() => {
        buttonRef.current?.focus({
          preventScroll: true
        });
      });
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [autoFocus]);
  const handlePromiseOnOk = (returnValueOfOnOk) => {
    if (!isThenable(returnValueOfOnOk)) {
      return;
    }
    setLoading(true);
    returnValueOfOnOk.then((...args) => {
      setLoading(false, true);
      onInternalClose.apply(void 0, args);
      clickedRef.current = false;
    }, (e3) => {
      setLoading(false, true);
      clickedRef.current = false;
      if (isSilent?.()) {
        return;
      }
      return Promise.reject(e3);
    });
  };
  const onClick = (e3) => {
    if (clickedRef.current) {
      return;
    }
    clickedRef.current = true;
    if (!actionFn) {
      onInternalClose();
      return;
    }
    let returnValueOfOnOk;
    if (emitEvent) {
      returnValueOfOnOk = actionFn(e3);
      if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
        clickedRef.current = false;
        onInternalClose(e3);
        return;
      }
    } else if (actionFn.length) {
      returnValueOfOnOk = actionFn(close);
      clickedRef.current = false;
    } else {
      returnValueOfOnOk = actionFn();
      if (!isThenable(returnValueOfOnOk)) {
        onInternalClose();
        return;
      }
    }
    handlePromiseOnOk(returnValueOfOnOk);
  };
  return React22.createElement(Button_default, {
    ...convertLegacyProps(type),
    onClick,
    loading,
    prefixCls,
    ...buttonProps,
    ref: buttonRef
  }, children);
};
var ActionButton_default = ActionButton;

// node_modules/antd/es/modal/context.js
var import_react10 = __toESM(require_react());
var ModalContext = import_react10.default.createContext({});
var {
  Provider: ModalContextProvider
} = ModalContext;

// node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var ConfirmCancelBtn = () => {
  const {
    autoFocusButton,
    cancelButtonProps,
    cancelTextLocale,
    isSilent,
    mergedOkCancel,
    rootPrefixCls,
    close,
    onCancel,
    onConfirm,
    onClose
  } = (0, import_react11.useContext)(ModalContext);
  return mergedOkCancel ? import_react11.default.createElement(ActionButton_default, {
    isSilent,
    actionFn: onCancel,
    close: (...args) => {
      close?.(...args);
      onConfirm?.(false);
      onClose?.();
    },
    autoFocus: autoFocusButton === "cancel",
    buttonProps: cancelButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, cancelTextLocale) : null;
};
var ConfirmCancelBtn_default = ConfirmCancelBtn;

// node_modules/antd/es/modal/components/ConfirmOkBtn.js
var import_react12 = __toESM(require_react());
var ConfirmOkBtn = () => {
  const {
    autoFocusButton,
    close,
    isSilent,
    okButtonProps,
    rootPrefixCls,
    okTextLocale,
    okType,
    onConfirm,
    onOk,
    onClose
  } = (0, import_react12.useContext)(ModalContext);
  return import_react12.default.createElement(ActionButton_default, {
    isSilent,
    type: okType || "primary",
    actionFn: onOk,
    close: (...args) => {
      close?.(...args);
      onConfirm?.(true);
      onClose?.();
    },
    autoFocus: autoFocusButton === "ok",
    buttonProps: okButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, okTextLocale);
};
var ConfirmOkBtn_default = ConfirmOkBtn;

// node_modules/antd/es/modal/Modal.js
var React46 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/DialogWrap.js
var React32 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/context.js
var React26 = __toESM(require_react());
var RefContext = React26.createContext({});

// node_modules/@rc-component/dialog/es/Dialog/index.js
var React31 = __toESM(require_react());
var import_react15 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/util.js
function getMotionName(prefixCls, transitionName, animationName) {
  let motionName = transitionName;
  if (!motionName && animationName) {
    motionName = `${prefixCls}-${animationName}`;
  }
  return motionName;
}
function getScroll2(w, top) {
  let ret = w[`page${top ? "Y" : "X"}Offset`];
  const method = `scroll${top ? "Top" : "Left"}`;
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method];
    if (typeof ret !== "number") {
      ret = d.body[method];
    }
  }
  return ret;
}
function offset(el) {
  const rect = el.getBoundingClientRect();
  const pos = {
    left: rect.left,
    top: rect.top
  };
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll2(w);
  pos.top += getScroll2(w, true);
  return pos;
}

// node_modules/@rc-component/dialog/es/Dialog/Content/index.js
var React29 = __toESM(require_react());
var import_react14 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/Dialog/Content/Panel.js
var import_react13 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/Dialog/Content/MemoChildren.js
var React27 = __toESM(require_react());
var MemoChildren_default = React27.memo(({
  children
}) => children, (_, {
  shouldUpdate
}) => !shouldUpdate);

// node_modules/@rc-component/dialog/es/Dialog/Content/Panel.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var entityStyle = {
  outline: "none"
};
var Panel = import_react13.default.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style,
    title,
    ariaId,
    footer,
    closable,
    closeIcon,
    onClose,
    children,
    bodyStyle,
    bodyProps,
    modalRender,
    onMouseDown,
    onMouseUp,
    holderRef,
    visible,
    forceRender,
    width,
    height,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  const {
    panel: panelRef
  } = import_react13.default.useContext(RefContext);
  const mergedRef = useComposeRef(holderRef, panelRef);
  const sentinelStartRef = (0, import_react13.useRef)(null);
  const sentinelEndRef = (0, import_react13.useRef)(null);
  import_react13.default.useImperativeHandle(ref, () => ({
    focus: () => {
      sentinelStartRef.current?.focus({
        preventScroll: true
      });
    },
    changeActive: (next) => {
      const {
        activeElement
      } = document;
      if (next && activeElement === sentinelEndRef.current) {
        sentinelStartRef.current.focus({
          preventScroll: true
        });
      } else if (!next && activeElement === sentinelStartRef.current) {
        sentinelEndRef.current.focus({
          preventScroll: true
        });
      }
    }
  }));
  const contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  const footerNode = footer ? import_react13.default.createElement("div", {
    className: clsx(`${prefixCls}-footer`, modalClassNames?.footer),
    style: {
      ...modalStyles?.footer
    }
  }, footer) : null;
  const headerNode = title ? import_react13.default.createElement("div", {
    className: clsx(`${prefixCls}-header`, modalClassNames?.header),
    style: {
      ...modalStyles?.header
    }
  }, import_react13.default.createElement("div", {
    className: clsx(`${prefixCls}-title`, modalClassNames?.title),
    id: ariaId,
    style: {
      ...modalStyles?.title
    }
  }, title)) : null;
  const closableObj = (0, import_react13.useMemo)(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return {
        closeIcon: closeIcon ?? import_react13.default.createElement("span", {
          className: `${prefixCls}-close-x`
        })
      };
    }
    return {};
  }, [closable, closeIcon, prefixCls]);
  const ariaProps = pickAttrs(closableObj, true);
  const closeBtnIsDisabled = typeof closable === "object" && closable.disabled;
  const closerNode = closable ? import_react13.default.createElement("button", _extends4({
    type: "button",
    onClick: onClose,
    "aria-label": "Close"
  }, ariaProps, {
    className: `${prefixCls}-close`,
    disabled: closeBtnIsDisabled
  }), closableObj.closeIcon) : null;
  const content = import_react13.default.createElement("div", {
    className: clsx(`${prefixCls}-container`, modalClassNames?.container),
    style: modalStyles?.container
  }, closerNode, headerNode, import_react13.default.createElement("div", _extends4({
    className: clsx(`${prefixCls}-body`, modalClassNames?.body),
    style: {
      ...bodyStyle,
      ...modalStyles?.body
    }
  }, bodyProps), children), footerNode);
  return import_react13.default.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": title ? ariaId : null,
    "aria-modal": "true",
    ref: mergedRef,
    style: {
      ...style,
      ...contentStyle
    },
    className: clsx(prefixCls, className),
    onMouseDown,
    onMouseUp
  }, import_react13.default.createElement("div", {
    ref: sentinelStartRef,
    tabIndex: 0,
    style: entityStyle
  }, import_react13.default.createElement(MemoChildren_default, {
    shouldUpdate: visible || forceRender
  }, modalRender ? modalRender(content) : content)), import_react13.default.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle
  }));
});
if (true) {
  Panel.displayName = "Panel";
}
var Panel_default = Panel;

// node_modules/@rc-component/dialog/es/Dialog/Content/index.js
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
var Content = React29.forwardRef((props, ref) => {
  const {
    prefixCls,
    title,
    style,
    className,
    visible,
    forceRender,
    destroyOnHidden,
    motionName,
    ariaId,
    onVisibleChanged,
    mousePosition: mousePosition2
  } = props;
  const dialogRef = (0, import_react14.useRef)(null);
  const panelRef = (0, import_react14.useRef)(null);
  React29.useImperativeHandle(ref, () => ({
    ...panelRef.current,
    inMotion: dialogRef.current.inMotion,
    enableMotion: dialogRef.current.enableMotion
  }));
  const [transformOrigin, setTransformOrigin] = React29.useState();
  const contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    const elementOffset = offset(dialogRef.current.nativeElement);
    setTransformOrigin(mousePosition2 && (mousePosition2.x || mousePosition2.y) ? `${mousePosition2.x - elementOffset.left}px ${mousePosition2.y - elementOffset.top}px` : "");
  }
  return React29.createElement(es_default4, {
    visible,
    onVisibleChanged,
    onAppearPrepare: onPrepare,
    onEnterPrepare: onPrepare,
    forceRender,
    motionName,
    removeOnLeave: destroyOnHidden,
    ref: dialogRef
  }, ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => React29.createElement(Panel_default, _extends5({}, props, {
    ref: panelRef,
    title,
    ariaId,
    prefixCls,
    holderRef: motionRef,
    style: {
      ...motionStyle,
      ...style,
      ...contentStyle
    },
    className: clsx(className, motionClassName)
  })));
});
if (true) {
  Content.displayName = "Content";
}
var Content_default = Content;

// node_modules/@rc-component/dialog/es/Dialog/Mask.js
var React30 = __toESM(require_react());
function _extends6() {
  _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
var Mask = (props) => {
  const {
    prefixCls,
    style,
    visible,
    maskProps,
    motionName,
    className
  } = props;
  return React30.createElement(es_default4, {
    key: "mask",
    visible,
    motionName,
    leavedClassName: `${prefixCls}-mask-hidden`
  }, ({
    className: motionClassName,
    style: motionStyle
  }, ref) => React30.createElement("div", _extends6({
    ref,
    style: {
      ...motionStyle,
      ...style
    },
    className: clsx(`${prefixCls}-mask`, motionClassName, className)
  }, maskProps)));
};
var Mask_default = Mask;

// node_modules/@rc-component/dialog/es/Dialog/index.js
function _extends7() {
  _extends7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
var Dialog = (props) => {
  const {
    prefixCls = "rc-dialog",
    zIndex,
    visible = false,
    keyboard = true,
    focusTriggerAfterClose = true,
    // scrollLocker,
    // Wrapper
    wrapStyle,
    wrapClassName,
    wrapProps,
    onClose,
    afterOpenChange,
    afterClose,
    // Dialog
    transitionName,
    animation,
    closable = true,
    // Mask
    mask = true,
    maskTransitionName,
    maskAnimation,
    maskClosable = true,
    maskStyle,
    maskProps,
    rootClassName,
    rootStyle,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  if (true) {
    ["wrapStyle", "bodyStyle", "maskStyle"].forEach((prop) => {
      warning(!(prop in props), `${prop} is deprecated, please use styles instead.`);
    });
    if ("wrapClassName" in props) {
      warning(false, `wrapClassName is deprecated, please use classNames instead.`);
    }
  }
  const lastOutSideActiveElementRef = (0, import_react15.useRef)(null);
  const wrapperRef = (0, import_react15.useRef)(null);
  const contentRef = (0, import_react15.useRef)(null);
  const [animatedVisible, setAnimatedVisible] = React31.useState(visible);
  const ariaId = useId_default();
  function saveLastOutSideActiveElementRef() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  function focusDialogContent() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      contentRef.current?.focus();
    }
  }
  function doClose() {
    setAnimatedVisible(false);
    if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
      try {
        lastOutSideActiveElementRef.current.focus({
          preventScroll: true
        });
      } catch (e3) {
      }
      lastOutSideActiveElementRef.current = null;
    }
    if (animatedVisible) {
      afterClose?.();
    }
  }
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      focusDialogContent();
    } else {
      doClose();
    }
    afterOpenChange?.(newVisible);
  }
  function onInternalClose(e3) {
    onClose?.(e3);
  }
  const contentClickRef = (0, import_react15.useRef)(false);
  const contentTimeoutRef = (0, import_react15.useRef)(null);
  const onContentMouseDown = () => {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  const onContentMouseUp = () => {
    contentTimeoutRef.current = setTimeout(() => {
      contentClickRef.current = false;
    });
  };
  let onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = (e3) => {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e3.target) {
        onInternalClose(e3);
      }
    };
  }
  function onWrapperKeyDown(e3) {
    if (keyboard && e3.keyCode === KeyCode_default.ESC) {
      e3.stopPropagation();
      onInternalClose(e3);
      return;
    }
    if (visible && e3.keyCode === KeyCode_default.TAB) {
      contentRef.current.changeActive(!e3.shiftKey);
    }
  }
  (0, import_react15.useEffect)(() => {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    } else if (animatedVisible && contentRef.current.enableMotion() && !contentRef.current.inMotion()) {
      doClose();
    }
  }, [visible]);
  (0, import_react15.useEffect)(() => () => {
    clearTimeout(contentTimeoutRef.current);
  }, []);
  const mergedStyle = {
    zIndex,
    ...wrapStyle,
    ...modalStyles?.wrapper,
    display: !animatedVisible ? "none" : null
  };
  return React31.createElement("div", _extends7({
    className: clsx(`${prefixCls}-root`, rootClassName),
    style: rootStyle
  }, pickAttrs(props, {
    data: true
  })), React31.createElement(Mask_default, {
    prefixCls,
    visible: mask && visible,
    motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
    style: {
      zIndex,
      ...maskStyle,
      ...modalStyles?.mask
    },
    maskProps,
    className: modalClassNames?.mask
  }), React31.createElement("div", _extends7({
    tabIndex: -1,
    onKeyDown: onWrapperKeyDown,
    className: clsx(`${prefixCls}-wrap`, wrapClassName, modalClassNames?.wrapper),
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: mergedStyle
  }, wrapProps), React31.createElement(Content_default, _extends7({}, props, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    ref: contentRef,
    closable,
    ariaId,
    prefixCls,
    visible: visible && animatedVisible,
    onClose: onInternalClose,
    onVisibleChanged: onDialogVisibleChanged,
    motionName: getMotionName(prefixCls, transitionName, animation)
  }))));
};
var Dialog_default = Dialog;

// node_modules/@rc-component/dialog/es/DialogWrap.js
function _extends8() {
  _extends8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
var DialogWrap = (props) => {
  const {
    visible,
    getContainer,
    forceRender,
    destroyOnHidden = false,
    afterClose,
    closable,
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React32.useState(visible);
  const refContext = React32.useMemo(() => ({
    panel: panelRef
  }), [panelRef]);
  React32.useEffect(() => {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (!forceRender && destroyOnHidden && !animatedVisible) {
    return null;
  }
  return React32.createElement(RefContext.Provider, {
    value: refContext
  }, React32.createElement(es_default2, {
    open: visible || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer,
    autoLock: visible || animatedVisible
  }, React32.createElement(Dialog_default, _extends8({}, props, {
    destroyOnHidden,
    afterClose: () => {
      const closableObj = closable && typeof closable === "object" ? closable : {};
      const {
        afterClose: closableAfterClose
      } = closableObj || {};
      closableAfterClose?.();
      afterClose?.();
      setAnimatedVisible(false);
    }
  }))));
};
if (true) {
  DialogWrap.displayName = "Dialog";
}
var DialogWrap_default = DialogWrap;

// node_modules/@rc-component/dialog/es/index.js
var es_default8 = DialogWrap_default;

// node_modules/@rc-component/util/es/Dom/styleChecker.js
var isStyleNameSupport = (styleName) => {
  if (canUseDom() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const {
      documentElement
    } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
};
var isStyleValueSupport = (styleName, value) => {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}

// node_modules/antd/es/_util/styleChecker.js
var canUseDocElement = () => canUseDom() && window.document.documentElement;

// node_modules/antd/es/skeleton/Skeleton.js
var React41 = __toESM(require_react());

// node_modules/antd/es/skeleton/Avatar.js
var React34 = __toESM(require_react());

// node_modules/antd/es/skeleton/Element.js
var React33 = __toESM(require_react());
var Element2 = (props) => {
  const {
    prefixCls,
    className,
    style,
    size,
    shape
  } = props;
  const sizeCls = clsx({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = clsx({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = React33.useMemo(() => typeof size === "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return React33.createElement("span", {
    className: clsx(prefixCls, sizeCls, shapeCls, className),
    style: {
      ...sizeStyle,
      ...style
    }
  });
};
var Element_default = Element2;

// node_modules/antd/es/skeleton/style/index.js
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
});
var genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: unit(size)
});
var genSkeletonElementSize = (size) => ({
  width: size,
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonColor = (token) => ({
  background: token.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
});
var genSkeletonElementInputSize = (size, calc) => ({
  width: calc(size).mul(5).equal(),
  minWidth: calc(size).mul(5).equal(),
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonElementAvatar = (token) => {
  const {
    skeletonAvatarCls,
    gradientFromColor,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token;
  return {
    [skeletonAvatarCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      ...genSkeletonElementSize(controlHeight)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: {
      ...genSkeletonElementSize(controlHeightLG)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: {
      ...genSkeletonElementSize(controlHeightSM)
    }
  };
};
var genSkeletonElementInput = (token) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token;
  return {
    [skeletonInputCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      ...genSkeletonElementInputSize(controlHeight, calc)
    },
    [`${skeletonInputCls}-lg`]: {
      ...genSkeletonElementInputSize(controlHeightLG, calc)
    },
    [`${skeletonInputCls}-sm`]: {
      ...genSkeletonElementInputSize(controlHeightSM, calc)
    }
  };
};
var genSkeletonElementShape = (token) => {
  const {
    gradientFromColor,
    borderRadiusSM,
    imageSizeBase,
    calc
  } = token;
  return {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "middle",
    background: gradientFromColor,
    borderRadius: borderRadiusSM,
    ...genSkeletonElementSize(calc(imageSizeBase).mul(2).equal())
  };
};
var genSkeletonElementNode = (token) => {
  return {
    [token.skeletonNodeCls]: {
      ...genSkeletonElementShape(token)
    }
  };
};
var genSkeletonElementImage = (token) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    calc
  } = token;
  return {
    [skeletonImageCls]: {
      ...genSkeletonElementShape(token),
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: {
        ...genSkeletonElementSize(imageSizeBase),
        maxWidth: calc(imageSizeBase).mul(4).equal(),
        maxHeight: calc(imageSizeBase).mul(4).equal()
      },
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    },
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
var genSkeletonElementButtonShape = (token, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
var genSkeletonElementButtonSize = (size, calc) => ({
  width: calc(size).mul(2).equal(),
  minWidth: calc(size).mul(2).equal(),
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonElementButton = (token) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token;
  return {
    [skeletonButtonCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      width: calc(controlHeight).mul(2).equal(),
      minWidth: calc(controlHeight).mul(2).equal(),
      ...genSkeletonElementButtonSize(controlHeight, calc)
    },
    ...genSkeletonElementButtonShape(token, controlHeight, skeletonButtonCls),
    [`${skeletonButtonCls}-lg`]: {
      ...genSkeletonElementButtonSize(controlHeightLG, calc)
    },
    ...genSkeletonElementButtonShape(token, controlHeightLG, `${skeletonButtonCls}-lg`),
    [`${skeletonButtonCls}-sm`]: {
      ...genSkeletonElementButtonSize(controlHeightSM, calc)
    },
    ...genSkeletonElementButtonShape(token, controlHeightSM, `${skeletonButtonCls}-sm`)
  };
};
var genBaseStyle2 = (token) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonNodeCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    padding,
    marginSM,
    borderRadius,
    titleHeight,
    blockRadius,
    paragraphLiHeight,
    controlHeightXS,
    paragraphMarginTop
  } = token;
  return {
    [componentCls]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [skeletonAvatarCls]: {
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor,
          ...genSkeletonElementSize(controlHeight)
        },
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: {
          ...genSkeletonElementSize(controlHeightLG)
        },
        [`${skeletonAvatarCls}-sm`]: {
          ...genSkeletonElementSize(controlHeightSM)
        }
      },
      [`${componentCls}-section`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [skeletonTitleCls]: {
          width: "100%",
          height: titleHeight,
          background: gradientFromColor,
          borderRadius: blockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [skeletonParagraphCls]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: paragraphLiHeight,
            listStyle: "none",
            background: gradientFromColor,
            borderRadius: blockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-section`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-section`]: {
      // Title
      [skeletonTitleCls]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: paragraphMarginTop
        }
      }
    },
    // Skeleton with element
    [`${componentCls}${componentCls}-element`]: {
      display: "inline-block",
      width: "auto",
      ...genSkeletonElementButton(token),
      ...genSkeletonElementAvatar(token),
      ...genSkeletonElementInput(token),
      ...genSkeletonElementNode(token),
      ...genSkeletonElementImage(token)
    },
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [skeletonButtonCls]: {
        width: "100%"
      },
      [skeletonInputCls]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonNodeCls},
        ${skeletonImageCls}
      `]: {
        ...genSkeletonColor(token)
      }
    }
  };
};
var prepareComponentToken6 = (token) => {
  const {
    colorFillContent,
    colorFill
  } = token;
  const gradientFromColor = colorFillContent;
  const gradientToColor = colorFill;
  return {
    color: gradientFromColor,
    colorGradientEnd: gradientToColor,
    gradientFromColor,
    gradientToColor,
    titleHeight: token.controlHeight / 2,
    blockRadius: token.borderRadiusSM,
    paragraphMarginTop: token.marginLG + token.marginXXS,
    paragraphLiHeight: token.controlHeight / 2
  };
};
var style_default9 = genStyleHooks("Skeleton", (token) => {
  const {
    componentCls,
    calc
  } = token;
  const skeletonToken = merge(token, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonNodeCls: `${componentCls}-node`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: calc(token.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${token.gradientFromColor} 25%, ${token.gradientToColor} 37%, ${token.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return genBaseStyle2(skeletonToken);
}, prepareComponentToken6, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
});

// node_modules/antd/es/skeleton/Avatar.js
var SkeletonAvatar = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    active,
    style,
    styles,
    shape = "circle",
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React34.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, classNames?.root, className, rootClassName, hashId, cssVarCls);
  return React34.createElement("div", {
    className: cls,
    style: styles?.root
  }, React34.createElement(Element_default, {
    prefixCls: `${prefixCls}-avatar`,
    className: classNames?.content,
    style: {
      ...styles?.content,
      ...style
    },
    shape,
    size,
    ...rest
  }));
};
var Avatar_default = SkeletonAvatar;

// node_modules/antd/es/skeleton/Button.js
var React35 = __toESM(require_react());
var SkeletonButton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    active,
    style,
    styles,
    block = false,
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React35.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, classNames?.root, className, rootClassName, hashId, cssVarCls);
  return React35.createElement("div", {
    className: cls,
    style: styles?.root
  }, React35.createElement(Element_default, {
    prefixCls: `${prefixCls}-button`,
    className: classNames?.content,
    style: {
      ...styles?.content,
      ...style
    },
    size,
    ...rest
  }));
};
var Button_default2 = SkeletonButton;

// node_modules/antd/es/skeleton/Image.js
var React37 = __toESM(require_react());

// node_modules/antd/es/skeleton/Node.js
var React36 = __toESM(require_react());
var SkeletonNode = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    internalClassName,
    style,
    styles,
    active,
    children
  } = props;
  const {
    getPrefixCls
  } = React36.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, classNames?.root, className, rootClassName, cssVarCls);
  return React36.createElement("div", {
    className: cls,
    style: styles?.root
  }, React36.createElement("div", {
    className: clsx(classNames?.content, internalClassName || `${prefixCls}-node`),
    style: {
      ...styles?.content,
      ...style
    }
  }, children));
};
var Node_default = SkeletonNode;

// node_modules/antd/es/skeleton/Image.js
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = (props) => {
  const {
    getPrefixCls
  } = React37.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", props.prefixCls);
  return React37.createElement(Node_default, {
    ...props,
    internalClassName: `${prefixCls}-image`
  }, React37.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${prefixCls}-image-svg`
  }, React37.createElement("title", null, "Image placeholder"), React37.createElement("path", {
    d: path,
    className: `${prefixCls}-image-path`
  })));
};
var Image_default = SkeletonImage;

// node_modules/antd/es/skeleton/Input.js
var React38 = __toESM(require_react());
var SkeletonInput = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    active,
    block,
    style,
    styles,
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React38.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, classNames?.root, className, rootClassName, hashId, cssVarCls);
  return React38.createElement("div", {
    className: cls,
    style: styles?.root
  }, React38.createElement(Element_default, {
    prefixCls: `${prefixCls}-input`,
    className: classNames?.content,
    style: {
      ...styles?.content,
      ...style
    },
    size,
    ...rest
  }));
};
var Input_default2 = SkeletonInput;

// node_modules/antd/es/skeleton/Paragraph.js
var React39 = __toESM(require_react());
var getWidth = (index2, props) => {
  const {
    width,
    rows = 2
  } = props;
  if (Array.isArray(width)) {
    return width[index2];
  }
  if (rows - 1 === index2) {
    return width;
  }
  return void 0;
};
var Paragraph = (props) => {
  const {
    prefixCls,
    className,
    style,
    rows = 0
  } = props;
  const rowList = Array.from({
    length: rows
  }).map((_, index2) => (
    // eslint-disable-next-line react/no-array-index-key
    React39.createElement("li", {
      key: index2,
      style: {
        width: getWidth(index2, props)
      }
    })
  ));
  return React39.createElement("ul", {
    className: clsx(prefixCls, className),
    style
  }, rowList);
};
var Paragraph_default = Paragraph;

// node_modules/antd/es/skeleton/Title.js
var React40 = __toESM(require_react());
var Title = ({
  prefixCls,
  className,
  width,
  style
}) => (
  // biome-ignore lint/a11y/useHeadingContent: HOC here
  React40.createElement("h3", {
    className: clsx(prefixCls, className),
    style: {
      width,
      ...style
    }
  })
);
var Title_default = Title;

// node_modules/antd/es/skeleton/Skeleton.js
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  if (!hasAvatar || !hasTitle) {
    basicProps.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
var Skeleton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    classNames,
    style,
    styles,
    children,
    avatar = false,
    title = true,
    paragraph = true,
    active,
    round
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("skeleton");
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls);
  const mergedProps = {
    ...props,
    avatar,
    title,
    paragraph
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = {
        className: mergedClassNames.avatar,
        prefixCls: `${prefixCls}-avatar`,
        ...getAvatarBasicProps(hasTitle, hasParagraph),
        ...getComponentProps(avatar),
        style: mergedStyles.avatar
      };
      avatarNode = React41.createElement("div", {
        className: clsx(mergedClassNames.header, `${prefixCls}-header`),
        style: mergedStyles.header
      }, React41.createElement(Element_default, {
        ...avatarProps
      }));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = {
          className: mergedClassNames.title,
          prefixCls: `${prefixCls}-title`,
          ...getTitleBasicProps(hasAvatar, hasParagraph),
          ...getComponentProps(title),
          style: mergedStyles.title
        };
        $title = React41.createElement(Title_default, {
          ...titleProps
        });
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = {
          className: mergedClassNames.paragraph,
          prefixCls: `${prefixCls}-paragraph`,
          ...getParagraphBasicProps(hasAvatar, hasTitle),
          ...getComponentProps(paragraph),
          style: mergedStyles.paragraph
        };
        paragraphNode = React41.createElement(Paragraph_default, {
          ...paragraphProps
        });
      }
      contentNode = React41.createElement("div", {
        className: clsx(mergedClassNames.section, `${prefixCls}-section`),
        style: mergedStyles.section
      }, $title, paragraphNode);
    }
    const cls = clsx(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-round`]: round
    }, mergedClassNames.root, contextClassName, className, rootClassName, hashId, cssVarCls);
    return React41.createElement("div", {
      className: cls,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style
      }
    }, avatarNode, contentNode);
  }
  return children ?? null;
};
Skeleton.Button = Button_default2;
Skeleton.Avatar = Avatar_default;
Skeleton.Input = Input_default2;
Skeleton.Image = Image_default;
Skeleton.Node = Node_default;
if (true) {
  Skeleton.displayName = "Skeleton";
}
var Skeleton_default = Skeleton;

// node_modules/antd/es/skeleton/index.js
var skeleton_default = Skeleton_default;

// node_modules/antd/es/watermark/context.js
var React42 = __toESM(require_react());
function voidFunc() {
}
var WatermarkContext = React42.createContext({
  add: voidFunc,
  remove: voidFunc
});
function usePanelRef(panelSelector) {
  const watermark = React42.useContext(WatermarkContext);
  const panelEleRef = React42.useRef(null);
  const panelRef = useEvent_default((ele) => {
    if (ele) {
      const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
      if (innerContentEle) {
        watermark.add(innerContentEle);
        panelEleRef.current = innerContentEle;
      }
    } else {
      watermark.remove(panelEleRef.current);
    }
  });
  return panelRef;
}
var context_default2 = WatermarkContext;

// node_modules/antd/es/modal/shared.js
var import_react18 = __toESM(require_react());

// node_modules/antd/es/modal/components/NormalCancelBtn.js
var import_react16 = __toESM(require_react());
var NormalCancelBtn = () => {
  const {
    cancelButtonProps,
    cancelTextLocale,
    onCancel
  } = (0, import_react16.useContext)(ModalContext);
  return import_react16.default.createElement(Button_default, {
    onClick: onCancel,
    ...cancelButtonProps
  }, cancelTextLocale);
};
var NormalCancelBtn_default = NormalCancelBtn;

// node_modules/antd/es/modal/components/NormalOkBtn.js
var import_react17 = __toESM(require_react());
var NormalOkBtn = () => {
  const {
    confirmLoading,
    okButtonProps,
    okType,
    okTextLocale,
    onOk
  } = (0, import_react17.useContext)(ModalContext);
  return import_react17.default.createElement(Button_default, {
    ...convertLegacyProps(okType),
    loading: confirmLoading,
    onClick: onOk,
    ...okButtonProps
  }, okTextLocale);
};
var NormalOkBtn_default = NormalOkBtn;

// node_modules/antd/es/modal/shared.js
function renderCloseIcon(prefixCls, closeIcon) {
  return import_react18.default.createElement("span", {
    className: `${prefixCls}-close-x`
  }, closeIcon || import_react18.default.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  }));
}
var Footer = (props) => {
  const {
    okText,
    okType = "primary",
    cancelText,
    confirmLoading,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps,
    footer
  } = props;
  const [locale2] = useLocale_default("Modal", getConfirmLocale());
  const okTextLocale = okText || locale2?.okText;
  const cancelTextLocale = cancelText || locale2?.cancelText;
  const memoizedValue = import_react18.default.useMemo(() => {
    return {
      confirmLoading,
      okButtonProps,
      cancelButtonProps,
      okTextLocale,
      cancelTextLocale,
      okType,
      onOk,
      onCancel
    };
  }, [confirmLoading, okButtonProps, cancelButtonProps, okTextLocale, cancelTextLocale, okType, onOk, onCancel]);
  let footerNode;
  if (typeof footer === "function" || typeof footer === "undefined") {
    footerNode = import_react18.default.createElement(import_react18.default.Fragment, null, import_react18.default.createElement(NormalCancelBtn_default, null), import_react18.default.createElement(NormalOkBtn_default, null));
    if (typeof footer === "function") {
      footerNode = footer(footerNode, {
        OkBtn: NormalOkBtn_default,
        CancelBtn: NormalCancelBtn_default
      });
    }
    footerNode = import_react18.default.createElement(ModalContextProvider, {
      value: memoizedValue
    }, footerNode);
  } else {
    footerNode = footer;
  }
  return import_react18.default.createElement(DisabledContextProvider, {
    disabled: false
  }, footerNode);
};

// node_modules/antd/es/grid/style/index.js
var genGridRowStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    // Grid system
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
};
var genGridColStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    // Grid system
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
};
var genLoopGridColumnsStyle = (token, sizeCls) => {
  const {
    prefixCls,
    componentCls,
    gridColumns
  } = token;
  const gridColumnsStyle = {};
  for (let i = gridColumns; i >= 0; i--) {
    if (i === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
        // https://github.com/ant-design/ant-design/issues/44456
        // Form set `display: flex` on Col which will override `display: block`.
        // Let's get it from css variable to support override.
        {
          ["--ant-display"]: "block",
          // Fallback to display if variable not support
          display: "block"
        },
        {
          display: "var(--ant-display)",
          flex: `0 0 ${i / gridColumns * 100}%`,
          maxWidth: `${i / gridColumns * 100}%`
        }
      ];
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: i
      };
    }
  }
  gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
    flex: `var(--${prefixCls}${sizeCls}-flex)`
  };
  return gridColumnsStyle;
};
var genGridStyle = (token, sizeCls) => genLoopGridColumnsStyle(token, sizeCls);
var genGridMediaStyle = (token, screenSize, sizeCls) => ({
  [`@media (min-width: ${unit(screenSize)})`]: {
    ...genGridStyle(token, sizeCls)
  }
});
var prepareRowComponentToken = () => ({});
var prepareColComponentToken = () => ({});
var useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
var getMediaSize = (token) => {
  const mediaSizesMap = {
    xs: token.screenXSMin,
    sm: token.screenSMMin,
    md: token.screenMDMin,
    lg: token.screenLGMin,
    xl: token.screenXLMin,
    xxl: token.screenXXLMin
  };
  return mediaSizesMap;
};
var useColStyle = genStyleHooks("Grid", (token) => {
  const gridToken = merge(token, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  });
  const gridMediaSizesMap = getMediaSize(gridToken);
  delete gridMediaSizesMap.xs;
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => ({
    ...pre,
    ...cur
  }), {})];
}, prepareColComponentToken);

// node_modules/antd/es/modal/style/index.js
function box(position2) {
  return {
    position: position2,
    inset: 0
  };
}
var genModalMaskStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  return [{
    [`${componentCls}-root`]: {
      [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: token.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      // https://github.com/ant-design/ant-design/issues/37329
      // https://github.com/ant-design/ant-design/issues/40272
      [`${componentCls}${antCls}-zoom-leave ${componentCls}-container`]: {
        pointerEvents: "none"
      },
      [`${componentCls}-mask`]: {
        ...box("fixed"),
        zIndex: token.zIndexPopupBase,
        height: "100%",
        backgroundColor: token.colorBgMask,
        pointerEvents: "none",
        [`&${componentCls}-mask-blur`]: {
          backdropFilter: "blur(4px)"
        },
        [`${componentCls}-hidden`]: {
          display: "none"
        }
      },
      [`${componentCls}-wrap`]: {
        ...box("fixed"),
        zIndex: token.zIndexPopupBase,
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      }
    }
  }, {
    [`${componentCls}-root`]: initFadeMotion(token)
  }];
};
var genModalStyle = (token) => {
  const {
    componentCls
  } = token;
  return [
    // ======================== Root =========================
    {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [componentCls]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${token.screenSMMax}px)`]: {
          [componentCls]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${unit(token.marginXS)} auto`
          },
          [`${componentCls}-centered`]: {
            [componentCls]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [componentCls]: {
        ...resetComponent(token),
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${unit(token.calc(token.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: token.paddingLG,
        [`${componentCls}-title`]: {
          margin: 0,
          color: token.titleColor,
          fontWeight: token.fontWeightStrong,
          fontSize: token.titleFontSize,
          lineHeight: token.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-container`]: {
          position: "relative",
          backgroundColor: token.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: token.borderRadiusLG,
          boxShadow: token.boxShadow,
          pointerEvents: "auto",
          padding: token.contentPadding
        },
        [`${componentCls}-close`]: {
          position: "absolute",
          top: token.calc(token.modalHeaderHeight).sub(token.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: token.calc(token.modalHeaderHeight).sub(token.modalCloseBtnSize).div(2).equal(),
          zIndex: token.calc(token.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: token.modalCloseIconColor,
          fontWeight: token.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: token.borderRadiusSM,
          width: token.modalCloseBtnSize,
          height: token.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${token.motionDurationMid}, background-color ${token.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: token.fontSizeLG,
            fontStyle: "normal",
            lineHeight: unit(token.modalCloseBtnSize),
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:disabled": {
            pointerEvents: "none"
          },
          "&:hover": {
            color: token.modalCloseIconHoverColor,
            backgroundColor: token.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: token.colorBgTextActive
          },
          ...genFocusStyle(token)
        },
        [`${componentCls}-header`]: {
          color: token.colorText,
          background: token.headerBg,
          borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0`,
          marginBottom: token.headerMarginBottom,
          padding: token.headerPadding,
          borderBottom: token.headerBorderBottom
        },
        [`${componentCls}-body`]: {
          fontSize: token.fontSize,
          lineHeight: token.lineHeight,
          wordWrap: "break-word",
          padding: token.bodyPadding,
          [`${componentCls}-body-skeleton`]: {
            width: "100%",
            height: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            margin: `${unit(token.margin)} auto`
          }
        },
        [`${componentCls}-footer`]: {
          textAlign: "end",
          background: token.footerBg,
          marginTop: token.footerMarginTop,
          padding: token.footerPadding,
          borderTop: token.footerBorderTop,
          borderRadius: token.footerBorderRadius,
          [`> ${token.antCls}-btn + ${token.antCls}-btn`]: {
            marginInlineStart: token.marginXS
          }
        },
        [`${componentCls}-open`]: {
          overflow: "hidden"
        }
      }
    },
    // ======================== Pure =========================
    {
      [`${componentCls}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${componentCls}-container,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${componentCls}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
};
var genRTLStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-root`]: {
      [`${componentCls}-wrap-rtl`]: {
        direction: "rtl",
        [`${componentCls}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
};
var genResponsiveWidthStyle = (token) => {
  const {
    componentCls
  } = token;
  const oriGridMediaSizesMap = getMediaSize(token);
  const gridMediaSizesMap = {
    ...oriGridMediaSizesMap
  };
  delete gridMediaSizesMap.xs;
  const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
  const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({
    [`@media (min-width: ${unit(gridMediaSizesMap[key])})`]: {
      width: `var(${cssVarPrefix}${key}-width)`
    }
  }));
  return {
    [`${componentCls}-root`]: {
      [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index2) => {
        const previousKey = Object.keys(oriGridMediaSizesMap)[index2 - 1];
        return previousKey ? {
          [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)`
        } : null;
      })), [{
        width: `var(${cssVarPrefix}xs-width)`
      }], _toConsumableArray(responsiveStyles))
    }
  };
};
var prepareToken2 = (token) => {
  const headerPaddingVertical = token.padding;
  const headerFontSize = token.fontSizeHeading5;
  const headerLineHeight = token.lineHeightHeading5;
  const modalToken = merge(token, {
    modalHeaderHeight: token.calc(token.calc(headerLineHeight).mul(headerFontSize).equal()).add(token.calc(headerPaddingVertical).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: token.colorSplit,
    modalFooterBorderStyle: token.lineType,
    modalFooterBorderWidth: token.lineWidth,
    modalCloseIconColor: token.colorIcon,
    modalCloseIconHoverColor: token.colorIconHover,
    modalCloseBtnSize: token.controlHeight,
    modalConfirmIconSize: token.fontHeight,
    modalTitleHeight: token.calc(token.titleFontSize).mul(token.titleLineHeight).equal()
  });
  return modalToken;
};
var prepareComponentToken7 = (token) => ({
  footerBg: "transparent",
  headerBg: "transparent",
  titleLineHeight: token.lineHeightHeading5,
  titleFontSize: token.fontSizeHeading5,
  contentBg: token.colorBgElevated,
  titleColor: token.colorTextHeading,
  // internal
  contentPadding: token.wireframe ? 0 : `${unit(token.paddingMD)} ${unit(token.paddingContentHorizontalLG)}`,
  headerPadding: token.wireframe ? `${unit(token.padding)} ${unit(token.paddingLG)}` : 0,
  headerBorderBottom: token.wireframe ? `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}` : "none",
  headerMarginBottom: token.wireframe ? 0 : token.marginXS,
  bodyPadding: token.wireframe ? token.paddingLG : 0,
  footerPadding: token.wireframe ? `${unit(token.paddingXS)} ${unit(token.padding)}` : 0,
  footerBorderTop: token.wireframe ? `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}` : "none",
  footerBorderRadius: token.wireframe ? `0 0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)}` : 0,
  footerMarginTop: token.wireframe ? 0 : token.marginSM,
  confirmBodyPadding: token.wireframe ? `${unit(token.padding * 2)} ${unit(token.padding * 2)} ${unit(token.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: token.wireframe ? token.margin : token.marginSM,
  confirmBtnsMarginTop: token.wireframe ? token.marginLG : token.marginSM,
  mask: true
});
var style_default10 = genStyleHooks("Modal", (token) => {
  const modalToken = prepareToken2(token);
  return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), initZoomMotion(modalToken, "zoom"), genResponsiveWidthStyle(modalToken)];
}, prepareComponentToken7, {
  unitless: {
    titleLineHeight: true
  }
});

// node_modules/antd/es/modal/Modal.js
var mousePosition;
var getClickPosition = (e3) => {
  mousePosition = {
    x: e3.pageX,
    y: e3.pageY
  };
  setTimeout(() => {
    mousePosition = null;
  }, 100);
};
if (canUseDocElement()) {
  document.documentElement.addEventListener("click", getClickPosition, true);
}
var Modal = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    open: open3,
    wrapClassName,
    centered,
    getContainer,
    focusTriggerAfterClose = true,
    style,
    width = 520,
    footer,
    classNames,
    styles,
    children,
    loading,
    confirmLoading,
    zIndex: customizeZIndex,
    mousePosition: customizeMousePosition,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps,
    destroyOnHidden,
    destroyOnClose,
    panelRef = null,
    closable,
    mask: modalMask,
    modalRender,
    ...restProps
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    centered: contextCentered,
    cancelButtonProps: contextCancelButtonProps,
    okButtonProps: contextOkButtonProps,
    mask: contextMask
  } = useComponentConfig("modal");
  const {
    modal: modalContext
  } = React46.useContext(ConfigContext);
  const [closableAfterclose, onClose] = React46.useMemo(() => {
    if (typeof closable === "boolean") {
      return [void 0, void 0];
    }
    return [closable?.afterClose, closable?.onClose];
  }, [closable]);
  const prefixCls = getPrefixCls("modal", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [mergedMask, maskBlurClassName] = useMergedMask(modalMask, contextMask, prefixCls);
  const handleCancel = (e3) => {
    if (confirmLoading) {
      return;
    }
    onCancel?.(e3);
    onClose?.();
  };
  const handleOk = (e3) => {
    onOk?.(e3);
    onClose?.();
  };
  if (true) {
    const warning2 = devUseWarning("Modal");
    [["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"], ["destroyOnClose", "destroyOnHidden"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default10(prefixCls, rootCls);
  const wrapClassNameExtended = clsx(wrapClassName, {
    [`${prefixCls}-centered`]: centered ?? contextCentered,
    [`${prefixCls}-wrap-rtl`]: direction === "rtl"
  });
  const dialogFooter = footer !== null && !loading ? React46.createElement(Footer, {
    ...props,
    okButtonProps: {
      ...contextOkButtonProps,
      ...okButtonProps
    },
    onOk: handleOk,
    cancelButtonProps: {
      ...contextCancelButtonProps,
      ...cancelButtonProps
    },
    onCancel: handleCancel
  }) : null;
  const [rawClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
    closable: true,
    closeIcon: React46.createElement(CloseOutlined_default, {
      className: `${prefixCls}-close-icon`
    }),
    closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
  });
  const mergedClosable = rawClosable ? {
    disabled: closeBtnIsDisabled,
    closeIcon: mergedCloseIcon,
    afterClose: closableAfterclose,
    ...ariaProps
  } : false;
  const mergedModalRender = modalRender ? (node) => React46.createElement("div", {
    className: `${prefixCls}-render`
  }, modalRender(node)) : void 0;
  const panelClassName = `.${prefixCls}-${modalRender ? "render" : "container"}`;
  const innerPanelRef = usePanelRef(panelClassName);
  const mergedPanelRef = composeRef(panelRef, innerPanelRef);
  const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
  const mergedProps = {
    ...props,
    width,
    panelRef,
    focusTriggerAfterClose,
    mask: mergedMask,
    zIndex
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames, maskBlurClassName], [contextStyles, styles], {
    props: mergedProps
  });
  const [numWidth, responsiveWidth] = React46.useMemo(() => {
    if (width && typeof width === "object") {
      return [void 0, width];
    }
    return [width, void 0];
  }, [width]);
  const responsiveWidthVars = React46.useMemo(() => {
    const vars = {};
    if (responsiveWidth) {
      Object.keys(responsiveWidth).forEach((breakpoint) => {
        const breakpointWidth = responsiveWidth[breakpoint];
        if (breakpointWidth !== void 0) {
          vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
        }
      });
    }
    return vars;
  }, [prefixCls, responsiveWidth]);
  return React46.createElement(ContextIsolator_default, {
    form: true,
    space: true
  }, React46.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, React46.createElement(es_default8, {
    width: numWidth,
    ...restProps,
    zIndex,
    getContainer: getContainer === void 0 ? getContextPopupContainer : getContainer,
    prefixCls,
    rootClassName: clsx(hashId, rootClassName, cssVarCls, rootCls, mergedClassNames.root),
    rootStyle: mergedStyles.root,
    footer: dialogFooter,
    visible: open3,
    mousePosition: customizeMousePosition ?? mousePosition,
    onClose: handleCancel,
    closable: mergedClosable,
    closeIcon: mergedCloseIcon,
    focusTriggerAfterClose,
    transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
    maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
    mask: mergedMask,
    className: clsx(hashId, className, contextClassName),
    style: {
      ...contextStyle,
      ...style,
      ...responsiveWidthVars
    },
    classNames: {
      ...mergedClassNames,
      wrapper: clsx(mergedClassNames.wrapper, wrapClassNameExtended)
    },
    styles: mergedStyles,
    panelRef: mergedPanelRef,
    destroyOnHidden: destroyOnHidden ?? destroyOnClose,
    modalRender: mergedModalRender
  }, loading ? React46.createElement(skeleton_default, {
    active: true,
    title: false,
    paragraph: {
      rows: 4
    },
    className: `${prefixCls}-body-skeleton`
  }) : children)));
};
var Modal_default = Modal;

// node_modules/antd/es/modal/style/confirm.js
var genModalConfirmStyle = (token) => {
  const {
    componentCls,
    titleFontSize,
    titleLineHeight,
    modalConfirmIconSize,
    fontSize,
    lineHeight,
    modalTitleHeight,
    fontHeight,
    confirmBodyPadding
  } = token;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [confirmComponentCls]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${token.antCls}-modal-header`]: {
        display: "none"
      },
      [`${confirmComponentCls}-body-wrapper`]: {
        ...clearFix()
      },
      [`&${componentCls} ${componentCls}-body`]: {
        padding: confirmBodyPadding
      },
      // ====================== Body ======================
      [`${confirmComponentCls}-body`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${token.iconCls}`]: {
          flex: "none",
          fontSize: modalConfirmIconSize,
          marginInlineEnd: token.confirmIconMarginInlineEnd,
          marginTop: token.calc(token.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        },
        [`&-has-title > ${token.iconCls}`]: {
          marginTop: token.calc(token.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        }
      },
      [`${confirmComponentCls}-paragraph`]: {
        display: "flex",
        flexDirection: "column",
        flex: "auto",
        rowGap: token.marginXS,
        // https://github.com/ant-design/ant-design/issues/51912
        maxWidth: `calc(100% - ${unit(token.marginSM)})`
      },
      // https://github.com/ant-design/ant-design/issues/48159
      [`${token.iconCls} + ${confirmComponentCls}-paragraph`]: {
        maxWidth: `calc(100% - ${unit(token.calc(token.modalConfirmIconSize).add(token.marginSM).equal())})`
      },
      [`${confirmComponentCls}-title`]: {
        color: token.colorTextHeading,
        fontWeight: token.fontWeightStrong,
        fontSize: titleFontSize,
        lineHeight: titleLineHeight
      },
      [`${confirmComponentCls}-container`]: {
        color: token.colorText,
        fontSize,
        lineHeight
      },
      // ===================== Footer =====================
      [`${confirmComponentCls}-btns`]: {
        textAlign: "end",
        marginTop: token.confirmBtnsMarginTop,
        [`${token.antCls}-btn + ${token.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: token.marginXS
        }
      }
    },
    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token.iconCls}`]: {
      color: token.colorError
    },
    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token.iconCls}`]: {
      color: token.colorWarning
    },
    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token.iconCls}`]: {
      color: token.colorInfo
    },
    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token.iconCls}`]: {
      color: token.colorSuccess
    }
  };
};
var confirm_default = genSubStyleComponent(["Modal", "confirm"], (token) => {
  const modalToken = prepareToken2(token);
  return genModalConfirmStyle(modalToken);
}, prepareComponentToken7, {
  // confirm is weak than modal since no conflict here
  order: -1e3
});

// node_modules/antd/es/modal/ConfirmDialog.js
var ConfirmContent = (props) => {
  const {
    prefixCls,
    icon,
    okText,
    cancelText,
    confirmPrefixCls,
    type,
    okCancel,
    footer,
    // Legacy for static function usage
    locale: staticLocale,
    ...restProps
  } = props;
  if (true) {
    const warning2 = devUseWarning("Modal");
    true ? warning2(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  let mergedIcon = icon;
  if (!icon && icon !== null) {
    switch (type) {
      case "info":
        mergedIcon = React47.createElement(InfoCircleFilled_default, null);
        break;
      case "success":
        mergedIcon = React47.createElement(CheckCircleFilled_default, null);
        break;
      case "error":
        mergedIcon = React47.createElement(CloseCircleFilled_default, null);
        break;
      default:
        mergedIcon = React47.createElement(ExclamationCircleFilled_default, null);
    }
  }
  const mergedOkCancel = okCancel ?? type === "confirm";
  const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
  const [locale2] = useLocale_default("Modal");
  const mergedLocale = staticLocale || locale2;
  const okTextLocale = okText || (mergedOkCancel ? mergedLocale?.okText : mergedLocale?.justOkText);
  const cancelTextLocale = cancelText || mergedLocale?.cancelText;
  const {
    closable
  } = restProps;
  const {
    onClose
  } = closable && typeof closable === "object" ? closable : {};
  const memoizedValue = React47.useMemo(() => {
    return {
      autoFocusButton,
      cancelTextLocale,
      okTextLocale,
      mergedOkCancel,
      onClose,
      ...restProps
    };
  }, [autoFocusButton, cancelTextLocale, okTextLocale, mergedOkCancel, onClose, restProps]);
  const footerOriginNode = React47.createElement(React47.Fragment, null, React47.createElement(ConfirmCancelBtn_default, null), React47.createElement(ConfirmOkBtn_default, null));
  const hasTitle = props.title !== void 0 && props.title !== null;
  const bodyCls = `${confirmPrefixCls}-body`;
  return React47.createElement("div", {
    className: `${confirmPrefixCls}-body-wrapper`
  }, React47.createElement("div", {
    className: clsx(bodyCls, {
      [`${bodyCls}-has-title`]: hasTitle
    })
  }, mergedIcon, React47.createElement("div", {
    className: `${confirmPrefixCls}-paragraph`
  }, hasTitle && React47.createElement("span", {
    className: `${confirmPrefixCls}-title`
  }, props.title), React47.createElement("div", {
    className: `${confirmPrefixCls}-content`
  }, props.content))), footer === void 0 || typeof footer === "function" ? React47.createElement(ModalContextProvider, {
    value: memoizedValue
  }, React47.createElement("div", {
    className: `${confirmPrefixCls}-btns`
  }, typeof footer === "function" ? footer(footerOriginNode, {
    OkBtn: ConfirmOkBtn_default,
    CancelBtn: ConfirmCancelBtn_default
  }) : footerOriginNode)) : footer, React47.createElement(confirm_default, {
    prefixCls
  }));
};
var ConfirmDialog = (props) => {
  const {
    close,
    zIndex,
    maskStyle,
    direction,
    prefixCls,
    wrapClassName,
    rootPrefixCls,
    bodyStyle,
    closable = false,
    onConfirm,
    styles,
    title,
    okButtonProps,
    cancelButtonProps
  } = props;
  const {
    cancelButtonProps: contextCancelButtonProps,
    okButtonProps: contextOkButtonProps
  } = useComponentConfig("modal");
  if (true) {
    const warning2 = devUseWarning("Modal");
    [["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const confirmPrefixCls = `${prefixCls}-confirm`;
  const width = props.width || 416;
  const style = props.style || {};
  const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
  const classString = clsx(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
    [`${confirmPrefixCls}-rtl`]: direction === "rtl"
  }, props.className);
  const [, token] = useToken();
  const mergedZIndex = React47.useMemo(() => {
    if (zIndex !== void 0) {
      return zIndex;
    }
    return token.zIndexPopupBase + CONTAINER_MAX_OFFSET;
  }, [zIndex, token]);
  return React47.createElement(Modal_default, {
    ...props,
    className: classString,
    wrapClassName: clsx({
      [`${confirmPrefixCls}-centered`]: !!props.centered
    }, wrapClassName),
    onCancel: () => {
      close?.({
        triggerCancel: true
      });
      onConfirm?.(false);
    },
    title,
    footer: null,
    transitionName: getTransitionName(rootPrefixCls || "", "zoom", props.transitionName),
    maskTransitionName: getTransitionName(rootPrefixCls || "", "fade", props.maskTransitionName),
    maskClosable,
    style,
    styles: {
      body: bodyStyle,
      mask: maskStyle,
      ...styles
    },
    width,
    zIndex: mergedZIndex,
    closable
  }, React47.createElement(ConfirmContent, {
    ...props,
    confirmPrefixCls,
    okButtonProps: {
      ...contextOkButtonProps,
      ...okButtonProps
    },
    cancelButtonProps: {
      ...contextCancelButtonProps,
      ...cancelButtonProps
    }
  }));
};
var ConfirmDialogWrapper = (props) => {
  const {
    rootPrefixCls,
    iconPrefixCls,
    direction,
    theme
  } = props;
  return React47.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls,
    direction,
    theme
  }, React47.createElement(ConfirmDialog, {
    ...props
  }));
};
if (true) {
  ConfirmDialog.displayName = "ConfirmDialog";
  ConfirmDialogWrapper.displayName = "ConfirmDialogWrapper";
}
var ConfirmDialog_default = ConfirmDialogWrapper;

// node_modules/antd/es/modal/destroyFns.js
var destroyFns = [];
var destroyFns_default = destroyFns;

// node_modules/antd/es/modal/confirm.js
var defaultRootPrefixCls = "";
function getRootPrefixCls() {
  return defaultRootPrefixCls;
}
var ConfirmDialogWrapper2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    getContainer,
    direction
  } = props;
  const runtimeLocale = getConfirmLocale();
  const config = (0, import_react19.useContext)(ConfigContext);
  const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
  const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
  let mergedGetContainer = getContainer;
  if (mergedGetContainer === false) {
    mergedGetContainer = void 0;
    if (true) {
      true ? warning_default2(false, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.") : void 0;
    }
  }
  return import_react19.default.createElement(ConfirmDialog_default, {
    ...props,
    rootPrefixCls,
    prefixCls,
    iconPrefixCls: config.iconPrefixCls,
    theme: config.theme,
    direction: direction ?? config.direction,
    locale: config.locale?.Modal ?? runtimeLocale,
    getContainer: mergedGetContainer
  });
};
function confirm(config) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("Modal");
  }
  const container = document.createDocumentFragment();
  let currentConfig = {
    ...config,
    close,
    open: true
  };
  let timeoutId;
  function destroy3(...args) {
    const triggerCancel = args.some((param) => param?.triggerCancel);
    if (triggerCancel) {
      config.onCancel?.(() => {
      }, ...args.slice(1));
    }
    for (let i = 0; i < destroyFns_default.length; i++) {
      const fn = destroyFns_default[i];
      if (fn === close) {
        destroyFns_default.splice(i, 1);
        break;
      }
    }
    unmount(container).then(() => {
    });
  }
  const scheduleRender = (props) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      const rootPrefixCls = global.getPrefixCls(void 0, getRootPrefixCls());
      const iconPrefixCls = global.getIconPrefixCls();
      const theme = global.getTheme();
      const dom = import_react19.default.createElement(ConfirmDialogWrapper2, {
        ...props
      });
      render(import_react19.default.createElement(config_provider_default, {
        prefixCls: rootPrefixCls,
        iconPrefixCls,
        theme
      }, typeof global.holderRender === "function" ? global.holderRender(dom) : dom), container);
    });
  };
  function close(...args) {
    currentConfig = {
      ...currentConfig,
      open: false,
      afterClose: () => {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy3.apply(this, args);
      }
    };
    scheduleRender(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = {
        ...currentConfig,
        ...configUpdate
      };
    }
    scheduleRender(currentConfig);
  }
  scheduleRender(currentConfig);
  destroyFns_default.push(close);
  return {
    destroy: close,
    update
  };
}
function withWarn(props) {
  return {
    ...props,
    type: "warning"
  };
}
function withInfo(props) {
  return {
    ...props,
    type: "info"
  };
}
function withSuccess(props) {
  return {
    ...props,
    type: "success"
  };
}
function withError(props) {
  return {
    ...props,
    type: "error"
  };
}
function withConfirm(props) {
  return {
    ...props,
    type: "confirm"
  };
}
function modalGlobalConfig({
  rootPrefixCls
}) {
  true ? warning_default2(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.") : void 0;
  defaultRootPrefixCls = rootPrefixCls;
}

// node_modules/antd/es/modal/useModal/HookModal.js
var React49 = __toESM(require_react());
var HookModal = ({
  afterClose: hookAfterClose,
  config,
  ...restProps
}, ref) => {
  const [open3, setOpen] = React49.useState(true);
  const [innerConfig, setInnerConfig] = React49.useState(config);
  const {
    direction,
    getPrefixCls
  } = React49.useContext(ConfigContext);
  const prefixCls = getPrefixCls("modal");
  const rootPrefixCls = getPrefixCls();
  const afterClose = () => {
    hookAfterClose();
    innerConfig.afterClose?.();
  };
  const close = (...args) => {
    setOpen(false);
    const triggerCancel = args.some((param) => param?.triggerCancel);
    if (triggerCancel) {
      innerConfig.onCancel?.(() => {
      }, ...args.slice(1));
    }
  };
  React49.useImperativeHandle(ref, () => ({
    destroy: close,
    update: (newConfig) => {
      setInnerConfig((originConfig) => {
        const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
        return {
          ...originConfig,
          ...nextConfig
        };
      });
    }
  }));
  const mergedOkCancel = innerConfig.okCancel ?? innerConfig.type === "confirm";
  const [contextLocale] = useLocale_default("Modal", en_US_default4.Modal);
  return React49.createElement(ConfirmDialog_default, {
    prefixCls,
    rootPrefixCls,
    ...innerConfig,
    close,
    open: open3,
    afterClose,
    okText: innerConfig.okText || (mergedOkCancel ? contextLocale?.okText : contextLocale?.justOkText),
    direction: innerConfig.direction || direction,
    cancelText: innerConfig.cancelText || contextLocale?.cancelText,
    ...restProps
  });
};
var HookModal_default = React49.forwardRef(HookModal);

// node_modules/antd/es/modal/useModal/index.js
var uuid = 0;
var ElementsHolder = React50.memo(React50.forwardRef((_props, ref) => {
  const [elements, patchElement] = usePatchElement();
  React50.useImperativeHandle(ref, () => ({
    patchElement
  }), [patchElement]);
  return React50.createElement(React50.Fragment, null, elements);
}));
function useModal() {
  const holderRef = React50.useRef(null);
  const [actionQueue, setActionQueue] = React50.useState([]);
  React50.useEffect(() => {
    if (actionQueue.length) {
      const cloneQueue = _toConsumableArray(actionQueue);
      cloneQueue.forEach((action) => {
        action();
      });
      setActionQueue([]);
    }
  }, [actionQueue]);
  const getConfirmFunc = React50.useCallback((withFunc) => function hookConfirm(config) {
    uuid += 1;
    const modalRef = React50.createRef();
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    let silent = false;
    let closeFunc;
    const modal = React50.createElement(HookModal_default, {
      key: `modal-${uuid}`,
      config: withFunc(config),
      ref: modalRef,
      afterClose: () => {
        closeFunc?.();
      },
      isSilent: () => silent,
      onConfirm: (confirmed) => {
        resolvePromise(confirmed);
      }
    });
    closeFunc = holderRef.current?.patchElement(modal);
    if (closeFunc) {
      destroyFns_default.push(closeFunc);
    }
    const instance = {
      destroy: () => {
        function destroyAction() {
          modalRef.current?.destroy();
        }
        if (modalRef.current) {
          destroyAction();
        } else {
          setActionQueue((prev) => [].concat(_toConsumableArray(prev), [destroyAction]));
        }
      },
      update: (newConfig) => {
        function updateAction() {
          modalRef.current?.update(newConfig);
        }
        if (modalRef.current) {
          updateAction();
        } else {
          setActionQueue((prev) => [].concat(_toConsumableArray(prev), [updateAction]));
        }
      },
      then: (resolve) => {
        silent = true;
        return promise.then(resolve);
      }
    };
    return instance;
  }, []);
  const fns = React50.useMemo(() => ({
    info: getConfirmFunc(withInfo),
    success: getConfirmFunc(withSuccess),
    error: getConfirmFunc(withError),
    warning: getConfirmFunc(withWarn),
    confirm: getConfirmFunc(withConfirm)
  }), [getConfirmFunc]);
  return [fns, React50.createElement(ElementsHolder, {
    key: "modal-holder",
    ref: holderRef
  })];
}
var useModal_default = useModal;

// node_modules/antd/es/notification/useNotification.js
var import_react20 = __toESM(require_react());

// node_modules/antd/es/notification/PurePanel.js
var React51 = __toESM(require_react());

// node_modules/antd/es/notification/style/placement.js
var genNotificationPlacementStyle = (token) => {
  const {
    componentCls,
    notificationMarginEdge,
    animationMaxHeight
  } = token;
  const noticeCls = `${componentCls}-notice`;
  const rightFadeIn = new Keyframes_default("antNotificationFadeIn", {
    "0%": {
      transform: `translate3d(100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  const topFadeIn = new Keyframes_default("antNotificationTopFadeIn", {
    "0%": {
      top: -animationMaxHeight,
      opacity: 0
    },
    "100%": {
      top: 0,
      opacity: 1
    }
  });
  const bottomFadeIn = new Keyframes_default("antNotificationBottomFadeIn", {
    "0%": {
      bottom: token.calc(animationMaxHeight).mul(-1).equal(),
      opacity: 0
    },
    "100%": {
      bottom: 0,
      opacity: 1
    }
  });
  const leftFadeIn = new Keyframes_default("antNotificationLeftFadeIn", {
    "0%": {
      transform: `translate3d(-100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  return {
    [componentCls]: {
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        marginInline: 0,
        [noticeCls]: {
          marginInline: "auto auto"
        }
      },
      [`&${componentCls}-top`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: topFadeIn
        }
      },
      [`&${componentCls}-bottom`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: bottomFadeIn
        }
      },
      [`&${componentCls}-topRight, &${componentCls}-bottomRight`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: rightFadeIn
        }
      },
      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
        marginRight: {
          value: 0,
          _skip_check_: true
        },
        marginLeft: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [noticeCls]: {
          marginInlineEnd: "auto",
          marginInlineStart: 0
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: leftFadeIn
        }
      }
    }
  };
};
var placement_default = genNotificationPlacementStyle;

// node_modules/antd/es/notification/interface.js
var NotificationPlacements = ["top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"];

// node_modules/antd/es/notification/style/stack.js
var placementAlignProperty = {
  topLeft: "left",
  topRight: "right",
  bottomLeft: "left",
  bottomRight: "right",
  top: "left",
  bottom: "left"
};
var genPlacementStackStyle = (token, placement) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-${placement}`]: {
      [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
        [placement.startsWith("top") ? "top" : "bottom"]: 0,
        [placementAlignProperty[placement]]: {
          value: 0,
          _skip_check_: true
        }
      }
    }
  };
};
var genStackChildrenStyle = (token) => {
  const childrenStyle = {};
  for (let i = 1; i < token.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      overflow: "hidden",
      [`& > ${token.componentCls}-notice`]: {
        opacity: 0,
        transition: `opacity ${token.motionDurationMid}`
      }
    };
  }
  return {
    [`&:not(:nth-last-child(-n+${token.notificationStackLayer}))`]: {
      opacity: 0,
      overflow: "hidden",
      color: "transparent",
      pointerEvents: "none"
    },
    ...childrenStyle
  };
};
var genStackedNoticeStyle = (token) => {
  const childrenStyle = {};
  for (let i = 1; i < token.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      background: token.colorBgBlur,
      backdropFilter: "blur(10px)",
      "-webkit-backdrop-filter": "blur(10px)"
    };
  }
  return {
    ...childrenStyle
  };
};
var genStackStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-stack`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        transition: `transform ${token.motionDurationSlow}, backdrop-filter 0s`,
        willChange: "transform, opacity",
        position: "absolute",
        ...genStackChildrenStyle(token)
      }
    },
    [`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        ...genStackedNoticeStyle(token)
      }
    },
    [`${componentCls}-stack${componentCls}-stack-expanded`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        "&:not(:nth-last-child(-n + 1))": {
          opacity: 1,
          overflow: "unset",
          color: "inherit",
          pointerEvents: "auto",
          [`& > ${token.componentCls}-notice`]: {
            opacity: 1
          }
        },
        "&:after": {
          content: '""',
          position: "absolute",
          height: token.margin,
          width: "100%",
          insetInline: 0,
          bottom: token.calc(token.margin).mul(-1).equal(),
          background: "transparent",
          pointerEvents: "auto"
        }
      }
    },
    ...NotificationPlacements.map((placement) => genPlacementStackStyle(token, placement)).reduce((acc, cur) => ({
      ...acc,
      ...cur
    }), {})
  };
};
var stack_default = genStackStyle;

// node_modules/antd/es/notification/style/index.js
var genNoticeStyle = (token) => {
  const {
    iconCls,
    componentCls,
    // .ant-notification
    boxShadow,
    fontSizeLG,
    notificationMarginBottom,
    borderRadiusLG,
    colorSuccess,
    colorInfo,
    colorWarning,
    colorError,
    colorTextHeading,
    notificationBg,
    notificationPadding,
    notificationMarginEdge,
    progressBg,
    notificationProgressHeight,
    fontSize,
    lineHeight,
    width,
    notificationIconSize,
    colorText,
    colorSuccessBg,
    colorErrorBg,
    colorInfoBg,
    colorWarningBg
  } = token;
  const noticeCls = `${componentCls}-notice`;
  return {
    position: "relative",
    marginBottom: notificationMarginBottom,
    marginInlineStart: "auto",
    background: notificationBg,
    borderRadius: borderRadiusLG,
    boxShadow,
    [noticeCls]: {
      padding: notificationPadding,
      width,
      maxWidth: `calc(100vw - ${unit(token.calc(notificationMarginEdge).mul(2).equal())})`,
      lineHeight,
      wordWrap: "break-word",
      borderRadius: borderRadiusLG,
      overflow: "hidden",
      // Type-specific background colors
      "&-success": colorSuccessBg ? {
        background: colorSuccessBg
      } : {},
      "&-error": colorErrorBg ? {
        background: colorErrorBg
      } : {},
      "&-info": colorInfoBg ? {
        background: colorInfoBg
      } : {},
      "&-warning": colorWarningBg ? {
        background: colorWarningBg
      } : {}
    },
    [`${noticeCls}-title`]: {
      marginBottom: token.marginXS,
      color: colorTextHeading,
      fontSize: fontSizeLG,
      lineHeight: token.lineHeightLG
    },
    [`${noticeCls}-description`]: {
      fontSize,
      color: colorText,
      marginTop: token.marginXS
    },
    [`${noticeCls}-closable ${noticeCls}-title`]: {
      paddingInlineEnd: token.paddingLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-title`]: {
      marginBottom: token.marginXS,
      marginInlineStart: token.calc(token.marginSM).add(notificationIconSize).equal(),
      fontSize: fontSizeLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-description`]: {
      marginInlineStart: token.calc(token.marginSM).add(notificationIconSize).equal(),
      fontSize
    },
    // Icon & color style in different selector level
    // https://github.com/ant-design/ant-design/issues/16503
    // https://github.com/ant-design/ant-design/issues/15512
    [`${noticeCls}-icon`]: {
      position: "absolute",
      fontSize: notificationIconSize,
      lineHeight: 1,
      // icon-font
      [`&-success${iconCls}`]: {
        color: colorSuccess
      },
      [`&-info${iconCls}`]: {
        color: colorInfo
      },
      [`&-warning${iconCls}`]: {
        color: colorWarning
      },
      [`&-error${iconCls}`]: {
        color: colorError
      }
    },
    [`${noticeCls}-close`]: {
      position: "absolute",
      top: token.notificationPaddingVertical,
      insetInlineEnd: token.notificationPaddingHorizontal,
      color: token.colorIcon,
      outline: "none",
      width: token.notificationCloseButtonSize,
      height: token.notificationCloseButtonSize,
      borderRadius: token.borderRadiusSM,
      transition: `background-color ${token.motionDurationMid}, color ${token.motionDurationMid}`,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "none",
      border: "none",
      "&:hover": {
        color: token.colorIconHover,
        backgroundColor: token.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token.colorBgTextActive
      },
      ...genFocusStyle(token)
    },
    [`${noticeCls}-progress`]: {
      position: "absolute",
      display: "block",
      appearance: "none",
      inlineSize: `calc(100% - ${unit(borderRadiusLG)} * 2)`,
      left: {
        _skip_check_: true,
        value: borderRadiusLG
      },
      right: {
        _skip_check_: true,
        value: borderRadiusLG
      },
      bottom: 0,
      blockSize: notificationProgressHeight,
      border: 0,
      "&, &::-webkit-progress-bar": {
        borderRadius: borderRadiusLG,
        backgroundColor: `rgba(0, 0, 0, 0.04)`
      },
      "&::-moz-progress-bar": {
        background: progressBg
      },
      "&::-webkit-progress-value": {
        borderRadius: borderRadiusLG,
        background: progressBg
      }
    },
    [`${noticeCls}-actions`]: {
      float: "right",
      marginTop: token.marginSM
    }
  };
};
var genNotificationStyle = (token) => {
  const {
    componentCls,
    // .ant-notification
    notificationMarginBottom,
    notificationMarginEdge,
    motionDurationMid,
    motionEaseInOut
  } = token;
  const noticeCls = `${componentCls}-notice`;
  const fadeOut = new Keyframes_default("antNotificationFadeOut", {
    "0%": {
      maxHeight: token.animationMaxHeight,
      marginBottom: notificationMarginBottom
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token),
        position: "fixed",
        zIndex: token.zIndexPopup,
        marginRight: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [`${componentCls}-hook-holder`]: {
          position: "relative"
        },
        //  animation
        [`${componentCls}-fade-appear-prepare`]: {
          opacity: "0 !important"
        },
        [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
          animationDuration: token.motionDurationMid,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-leave`]: {
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          animationDuration: motionDurationMid,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationPlayState: "running"
        },
        [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
          animationName: fadeOut,
          animationPlayState: "running"
        },
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${noticeCls}-actions`]: {
            float: "left"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: genNoticeStyle(token)
      }
    }
  ];
};
var prepareComponentToken8 = (token) => ({
  zIndexPopup: token.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
  width: 384,
  progressBg: `linear-gradient(90deg, ${token.colorPrimaryBorderHover}, ${token.colorPrimary})`,
  // Fix notification background color issue
  // https://github.com/ant-design/ant-design/issues/55649
  // https://github.com/ant-design/ant-design/issues/56055
  colorSuccessBg: void 0,
  colorErrorBg: void 0,
  colorInfoBg: void 0,
  colorWarningBg: void 0
});
var prepareNotificationToken = (token) => {
  const notificationPaddingVertical = token.paddingMD;
  const notificationPaddingHorizontal = token.paddingLG;
  const notificationToken = merge(token, {
    notificationBg: token.colorBgElevated,
    notificationPaddingVertical,
    notificationPaddingHorizontal,
    notificationIconSize: token.calc(token.fontSizeLG).mul(token.lineHeightLG).equal(),
    notificationCloseButtonSize: token.calc(token.controlHeightLG).mul(0.55).equal(),
    notificationMarginBottom: token.margin,
    notificationPadding: `${unit(token.paddingMD)} ${unit(token.paddingContentHorizontalLG)}`,
    notificationMarginEdge: token.marginLG,
    animationMaxHeight: 150,
    notificationStackLayer: 3,
    notificationProgressHeight: 2
  });
  return notificationToken;
};
var style_default11 = genStyleHooks("Notification", (token) => {
  const notificationToken = prepareNotificationToken(token);
  return [genNotificationStyle(notificationToken), placement_default(notificationToken), stack_default(notificationToken)];
}, prepareComponentToken8);

// node_modules/antd/es/notification/style/pure-panel.js
var pure_panel_default = genSubStyleComponent(["Notification", "PurePanel"], (token) => {
  const noticeCls = `${token.componentCls}-notice`;
  const notificationToken = prepareNotificationToken(token);
  return {
    [`${noticeCls}-pure-panel`]: {
      ...genNoticeStyle(notificationToken),
      width: notificationToken.width,
      maxWidth: `calc(100vw - ${unit(token.calc(notificationToken.notificationMarginEdge).mul(2).equal())})`,
      margin: 0
    }
  };
}, prepareComponentToken8);

// node_modules/antd/es/notification/PurePanel.js
var TypeIcon2 = {
  info: React51.createElement(InfoCircleFilled_default, null),
  success: React51.createElement(CheckCircleFilled_default, null),
  error: React51.createElement(CloseCircleFilled_default, null),
  warning: React51.createElement(ExclamationCircleFilled_default, null),
  loading: React51.createElement(LoadingOutlined_default, null)
};
function getCloseIcon(prefixCls, closeIcon) {
  if (closeIcon === null || closeIcon === false) {
    return null;
  }
  return closeIcon || React51.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  });
}
var typeToIcon = {
  success: CheckCircleFilled_default,
  info: InfoCircleFilled_default,
  error: CloseCircleFilled_default,
  warning: ExclamationCircleFilled_default
};
var PureContent2 = (props) => {
  const {
    prefixCls,
    icon,
    type,
    title,
    description,
    actions,
    role = "alert",
    styles,
    classNames: pureContentCls
  } = props;
  let iconNode = null;
  if (icon) {
    iconNode = React51.createElement("span", {
      className: clsx(`${prefixCls}-icon`, pureContentCls.icon),
      style: styles.icon
    }, icon);
  } else if (type) {
    iconNode = React51.createElement(typeToIcon[type] || null, {
      className: clsx(`${prefixCls}-icon`, pureContentCls.icon, `${prefixCls}-icon-${type}`),
      style: styles.icon
    });
  }
  return React51.createElement("div", {
    className: clsx({
      [`${prefixCls}-with-icon`]: iconNode
    }),
    role
  }, iconNode, React51.createElement("div", {
    className: clsx(`${prefixCls}-title`, pureContentCls.title),
    style: styles.title
  }, title), description && React51.createElement("div", {
    className: clsx(`${prefixCls}-description`, pureContentCls.description),
    style: styles.description
  }, description), actions && React51.createElement("div", {
    className: clsx(`${prefixCls}-actions`, pureContentCls.actions),
    style: styles.actions
  }, actions));
};
var PurePanel2 = (props) => {
  const {
    prefixCls: staticPrefixCls,
    icon,
    type,
    message: message2,
    title,
    description,
    btn,
    actions,
    closeIcon: _closeIcon,
    className: notificationClassName,
    style,
    styles,
    classNames: notificationClassNames,
    closable,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("notification");
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, notificationClassNames], [contextStyles, styles], {
    props
  });
  const {
    notification: notificationContext
  } = React51.useContext(ConfigContext);
  const mergedActions = actions ?? btn;
  if (true) {
    const warning2 = devUseWarning("Notification");
    [["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const mergedTitle = title ?? message2;
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const noticePrefixCls = `${prefixCls}-notice`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default11(prefixCls, rootCls);
  const [rawClosable, mergedCloseIcon, , ariaProps] = useClosable(pickClosable(props), pickClosable(notificationContext), {
    closable: true,
    closeIcon: React51.createElement(CloseOutlined_default, {
      className: `${prefixCls}-close-icon`
    }),
    closeIconRender: (icon2) => getCloseIcon(prefixCls, icon2)
  });
  const mergedClosable = rawClosable ? {
    onClose: closable && typeof closable === "object" ? closable?.onClose : void 0,
    closeIcon: mergedCloseIcon,
    ...ariaProps
  } : false;
  return React51.createElement("div", {
    className: clsx(`${noticePrefixCls}-pure-panel`, hashId, notificationClassName, cssVarCls, rootCls, mergedClassNames.root),
    style: mergedStyles.root
  }, React51.createElement(pure_panel_default, {
    prefixCls
  }), React51.createElement(Notice_default, {
    style: {
      ...contextStyle,
      ...style
    },
    ...restProps,
    prefixCls,
    eventKey: "pure",
    duration: null,
    closable: mergedClosable,
    className: clsx(notificationClassName, contextClassName),
    content: React51.createElement(PureContent2, {
      classNames: mergedClassNames,
      styles: mergedStyles,
      prefixCls: noticePrefixCls,
      icon,
      type,
      title: mergedTitle,
      description,
      actions: mergedActions
    })
  }));
};
var PurePanel_default4 = PurePanel2;

// node_modules/antd/es/notification/util.js
function getPlacementStyle(placement, top, bottom) {
  let style;
  switch (placement) {
    case "top":
      style = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style;
}
function getMotion2(prefixCls) {
  return {
    motionName: `${prefixCls}-fade`
  };
}
function getCloseIconConfig(closeIcon, notificationConfig, notification2) {
  if (typeof closeIcon !== "undefined") {
    return closeIcon;
  }
  if (typeof notificationConfig?.closeIcon !== "undefined") {
    return notificationConfig.closeIcon;
  }
  return notification2?.closeIcon;
}

// node_modules/antd/es/notification/useNotification.js
var DEFAULT_OFFSET3 = 24;
var DEFAULT_DURATION2 = 4.5;
var DEFAULT_PLACEMENT = "topRight";
var Wrapper2 = ({
  children,
  prefixCls
}) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default11(prefixCls, rootCls);
  return import_react20.default.createElement(NotificationProvider_default, {
    classNames: {
      list: clsx(hashId, cssVarCls, rootCls)
    }
  }, children);
};
var renderNotifications2 = (node, {
  prefixCls,
  key
}) => import_react20.default.createElement(Wrapper2, {
  prefixCls,
  key
}, node);
var Holder2 = import_react20.default.forwardRef((props, ref) => {
  const {
    top,
    bottom,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    rtl,
    onAllRemoved,
    stack,
    duration = DEFAULT_DURATION2,
    pauseOnHover = true,
    showProgress
  } = props;
  const {
    getPrefixCls,
    getPopupContainer,
    direction
  } = useComponentConfig("notification");
  const {
    notification: notification2
  } = (0, import_react20.useContext)(ConfigContext);
  const [, token] = useToken();
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const mergedDuration = (0, import_react20.useMemo)(() => typeof duration === "number" && duration > 0 ? duration : false, [duration]);
  const getStyle3 = (placement) => getPlacementStyle(placement, top ?? DEFAULT_OFFSET3, bottom ?? DEFAULT_OFFSET3);
  const getClassName = () => clsx({
    [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
  });
  const getNotificationMotion = () => getMotion2(prefixCls);
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle3,
    className: getClassName,
    motion: getNotificationMotion,
    closable: {
      closeIcon: getCloseIcon(prefixCls)
    },
    duration: mergedDuration,
    getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
    maxCount,
    pauseOnHover,
    showProgress,
    onAllRemoved,
    renderNotifications: renderNotifications2,
    stack: stack === false ? false : {
      threshold: typeof stack === "object" ? stack?.threshold : void 0,
      offset: 8,
      gap: token.margin
    }
  });
  const [mergedClassNames, mergedStyles] = useMergeSemantic([notification2?.classNames, props?.classNames], [notification2?.styles, props?.styles], {
    props
  });
  import_react20.default.useImperativeHandle(ref, () => ({
    ...api,
    prefixCls,
    notification: notification2,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  return holder;
});
function useInternalNotification(notificationConfig) {
  const holderRef = import_react20.default.useRef(null);
  const warning2 = devUseWarning("Notification");
  const {
    notification: notificationContext
  } = import_react20.default.useContext(ConfigContext);
  const wrapAPI = import_react20.default.useMemo(() => {
    const open3 = (config) => {
      if (!holderRef.current) {
        true ? warning2(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
        return;
      }
      const {
        open: originOpen,
        prefixCls,
        notification: notification2,
        classNames: originClassNames,
        styles: originStyles
      } = holderRef.current;
      const contextClassName = notification2?.className || {};
      const contextStyle = notification2?.style || {};
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        title,
        message: message2,
        description,
        icon,
        type,
        btn,
        actions,
        className,
        style,
        role = "alert",
        closeIcon,
        closable,
        classNames: configClassNames = {},
        styles = {},
        ...restConfig
      } = config;
      if (true) {
        [["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
          warning2.deprecated(!(deprecatedName in config), deprecatedName, newName);
        });
      }
      const mergedTitle = title ?? message2;
      const mergedActions = actions ?? btn;
      const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification2));
      const [rawClosable, mergedCloseIcon, , ariaProps] = computeClosable(pickClosable({
        ...notificationConfig || {},
        ...config
      }), pickClosable(notificationContext), {
        closable: true,
        closeIcon: realCloseIcon
      });
      const mergedClosable = rawClosable ? {
        onClose: closable && typeof closable === "object" ? closable.onClose : void 0,
        closeIcon: mergedCloseIcon,
        ...ariaProps
      } : false;
      const semanticClassNames = resolveStyleOrClass(configClassNames, {
        props: config
      });
      const semanticStyles = resolveStyleOrClass(styles, {
        props: config
      });
      const mergedClassNames = mergeClassNames(void 0, originClassNames, semanticClassNames);
      const mergedStyles = mergeStyles(originStyles, semanticStyles);
      return originOpen({
        // use placement from props instead of hard-coding "topRight"
        placement: notificationConfig?.placement ?? DEFAULT_PLACEMENT,
        ...restConfig,
        content: import_react20.default.createElement(PureContent2, {
          prefixCls: noticePrefixCls,
          icon,
          type,
          title: mergedTitle,
          description,
          actions: mergedActions,
          role,
          classNames: mergedClassNames,
          styles: mergedStyles
        }),
        className: clsx({
          [`${noticePrefixCls}-${type}`]: type
        }, className, contextClassName, mergedClassNames.root),
        style: {
          ...contextStyle,
          ...mergedStyles.root,
          ...style
        },
        closable: mergedClosable
      });
    };
    const destroy3 = (key) => {
      if (key !== void 0) {
        holderRef.current?.close(key);
      } else {
        holderRef.current?.destroy();
      }
    };
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys = ["success", "info", "warning", "error"];
    keys.forEach((type) => {
      clone[type] = (config) => open3({
        ...config,
        type
      });
    });
    return clone;
  }, [notificationConfig, notificationContext]);
  return [wrapAPI, import_react20.default.createElement(Holder2, {
    key: "notification-holder",
    ...notificationConfig,
    ref: holderRef
  })];
}
function useNotification2(notificationConfig) {
  return useInternalNotification(notificationConfig);
}

// node_modules/antd/es/app/context.js
var import_react21 = __toESM(require_react());
var AppConfigContext = import_react21.default.createContext({});
var AppContext = import_react21.default.createContext({
  message: {},
  notification: {},
  modal: {}
});
var context_default3 = AppContext;

// node_modules/antd/es/app/style/index.js
var genBaseStyle3 = (token) => {
  const {
    componentCls,
    colorText,
    fontSize,
    lineHeight,
    fontFamily
  } = token;
  return {
    [componentCls]: {
      color: colorText,
      fontSize,
      lineHeight,
      fontFamily,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken9 = () => ({});
var style_default12 = genStyleHooks("App", genBaseStyle3, prepareComponentToken9);

// node_modules/antd/es/app/App.js
var App = (props) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    className,
    rootClassName,
    message: message2,
    notification: notification2,
    style,
    component = "div"
  } = props;
  const {
    direction,
    getPrefixCls
  } = (0, import_react22.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("app", customizePrefixCls);
  const [hashId, cssVarCls] = style_default12(prefixCls);
  const customClassName = clsx(hashId, prefixCls, className, rootClassName, cssVarCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const appConfig = (0, import_react22.useContext)(AppConfigContext);
  const mergedAppConfig = import_react22.default.useMemo(() => ({
    message: {
      ...appConfig.message,
      ...message2
    },
    notification: {
      ...appConfig.notification,
      ...notification2
    }
  }), [message2, notification2, appConfig.message, appConfig.notification]);
  const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
  const [notificationApi, notificationContextHolder] = useNotification2(mergedAppConfig.notification);
  const [ModalApi, ModalContextHolder] = useModal_default();
  const memoizedContextValue = import_react22.default.useMemo(() => ({
    message: messageApi,
    notification: notificationApi,
    modal: ModalApi
  }), [messageApi, notificationApi, ModalApi]);
  devUseWarning("App")(!(cssVarCls && component === false), "usage", "When using cssVar, ensure `component` is assigned a valid React component string.");
  const Component6 = component === false ? import_react22.default.Fragment : component;
  const rootProps = {
    className: customClassName,
    style
  };
  return import_react22.default.createElement(context_default3.Provider, {
    value: memoizedContextValue
  }, import_react22.default.createElement(AppConfigContext.Provider, {
    value: mergedAppConfig
  }, import_react22.default.createElement(Component6, {
    ...component === false ? void 0 : rootProps
  }, ModalContextHolder, messageContextHolder, notificationContextHolder, children)));
};
if (true) {
  App.displayName = "App";
}
var App_default = App;

// node_modules/antd/es/app/useApp.js
var import_react23 = __toESM(require_react());
var useApp = () => import_react23.default.useContext(context_default3);
var useApp_default = useApp;

// node_modules/antd/es/app/index.js
var App2 = App_default;
App2.useApp = useApp_default;
var app_default = App2;

// node_modules/antd/es/auto-complete/AutoComplete.js
var React56 = __toESM(require_react());
var {
  Option
} = select_default;
function isSelectOptionOrSelectOptGroup(child) {
  return child?.type && (child.type.isSelectOption || child.type.isSelectOptGroup);
}
var AutoComplete = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style,
    popupClassName,
    dropdownClassName,
    children,
    dataSource,
    rootClassName,
    dropdownStyle,
    dropdownRender,
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    styles,
    classNames
  } = props;
  const childNodes = toArray(children);
  const mergedPopupRender = popupRender || dropdownRender;
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  let customizeInput;
  if (childNodes.length === 1 && React56.isValidElement(childNodes[0]) && !isSelectOptionOrSelectOptGroup(childNodes[0])) {
    [customizeInput] = childNodes;
  }
  const getInputElement = customizeInput ? () => customizeInput : void 0;
  let optionChildren;
  if (childNodes.length && isSelectOptionOrSelectOptGroup(childNodes[0])) {
    optionChildren = children;
  } else {
    optionChildren = dataSource ? dataSource.map((item) => {
      if (React56.isValidElement(item)) {
        return item;
      }
      switch (typeof item) {
        case "string":
          return React56.createElement(Option, {
            key: item,
            value: item
          }, item);
        case "object": {
          const {
            value: optionValue
          } = item;
          return React56.createElement(Option, {
            key: optionValue,
            value: optionValue
          }, item.text);
        }
        default:
          return void 0;
      }
    }) : [];
  }
  if (true) {
    const warning2 = devUseWarning("AutoComplete");
    true ? warning2(!customizeInput || !("size" in props), "usage", "You need to control style self instead of setting `size` when using customize input.") : void 0;
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      dataSource: "options"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning2.deprecated(!(oldProp in props), oldProp, newProp);
    });
  }
  const {
    getPrefixCls
  } = React56.useContext(ConfigContext);
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const mergedProps = {
    ...props,
    dataSource,
    status: props.status,
    popupMatchSelectWidth: props.popupMatchSelectWidth || props.dropdownMatchSelectWidth,
    popupRender: mergedPopupRender,
    onOpenChange: mergedOnOpenChange
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const finalClassNames = React56.useMemo(() => ({
    root: clsx(`${prefixCls}-auto-complete`, className, rootClassName, mergedClassNames.root, {
      [`${prefixCls}-customize`]: customizeInput
    }),
    prefix: mergedClassNames.prefix,
    input: mergedClassNames.input,
    placeholder: mergedClassNames.placeholder,
    content: mergedClassNames.content,
    popup: {
      root: clsx(popupClassName, dropdownClassName, mergedClassNames.popup?.root),
      list: mergedClassNames.popup?.list,
      listItem: mergedClassNames.popup?.listItem
    }
  }), [prefixCls, className, rootClassName, mergedClassNames, popupClassName, dropdownClassName]);
  const finalStyles = React56.useMemo(() => ({
    root: {
      ...mergedStyles.root,
      ...style
    },
    input: mergedStyles.input,
    prefix: mergedStyles.prefix,
    placeholder: mergedStyles.placeholder,
    content: mergedStyles.content,
    popup: {
      root: {
        ...dropdownStyle,
        ...mergedStyles.popup?.root
      },
      list: mergedStyles.popup?.list,
      listItem: mergedStyles.popup?.listItem
    }
  }), [mergedStyles, style, dropdownStyle]);
  return React56.createElement(select_default, {
    ref,
    suffixIcon: null,
    ...omit(props, ["dataSource", "dropdownClassName", "popupClassName"]),
    prefixCls,
    classNames: finalClassNames,
    styles: finalStyles,
    mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange,
    // Internal api
    getInputElement
  }, optionChildren);
};
var RefAutoComplete = React56.forwardRef(AutoComplete);
if (true) {
  RefAutoComplete.displayName = "AutoComplete";
}
var AutoComplete_default = RefAutoComplete;

// node_modules/antd/es/auto-complete/index.js
var {
  Option: Option2
} = select_default;
var PurePanel3 = PurePanel_default(AutoComplete_default, "popupAlign", (props) => omit(props, ["visible"]));
var AutoComplete2 = AutoComplete_default;
AutoComplete2.Option = Option2;
AutoComplete2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel3;
var auto_complete_default = AutoComplete2;

// node_modules/antd/es/avatar/Avatar.js
var React59 = __toESM(require_react());

// node_modules/antd/es/_util/responsiveObserver.js
var import_react24 = __toESM(require_react());
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var getResponsiveMap = (token) => ({
  xs: `(max-width: ${token.screenXSMax}px)`,
  sm: `(min-width: ${token.screenSM}px)`,
  md: `(min-width: ${token.screenMD}px)`,
  lg: `(min-width: ${token.screenLG}px)`,
  xl: `(min-width: ${token.screenXL}px)`,
  xxl: `(min-width: ${token.screenXXL}px)`
});
var validateBreakpoints = (token) => {
  const indexableToken = token;
  const revBreakpoints = [].concat(responsiveArray).reverse();
  revBreakpoints.forEach((breakpoint, i) => {
    const breakpointUpper = breakpoint.toUpperCase();
    const screenMin = `screen${breakpointUpper}Min`;
    const screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen])) {
      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
    }
    if (i < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax])) {
        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
      }
      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
      }
    }
  });
  return token;
};
var matchScreen = (screens, screenSizes) => {
  if (!screenSizes) {
    return;
  }
  for (const breakpoint of responsiveArray) {
    if (screens[breakpoint] && screenSizes?.[breakpoint] !== void 0) {
      return screenSizes[breakpoint];
    }
  }
};
var useResponsiveObserver = () => {
  const [, token] = useToken();
  const responsiveMap = getResponsiveMap(validateBreakpoints(token));
  return import_react24.default.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      responsiveMap,
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size) {
          this.register();
        }
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size) {
          this.unregister();
        }
      },
      register() {
        Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
          const listener = ({
            matches
          }) => {
            this.dispatch({
              ...screens,
              [screen]: matches
            });
          };
          const mql = window.matchMedia(mediaQuery);
          if (typeof mql?.addEventListener === "function") {
            mql.addEventListener("change", listener);
          }
          this.matchHandlers[mediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      unregister() {
        Object.values(responsiveMap).forEach((mediaQuery) => {
          const handler = this.matchHandlers[mediaQuery];
          if (typeof handler?.mql?.removeEventListener === "function") {
            handler.mql.removeEventListener("change", handler?.listener);
          }
        });
        subscribers.clear();
      }
    };
  }, [responsiveMap]);
};
var responsiveObserver_default = useResponsiveObserver;

// node_modules/antd/es/grid/hooks/useBreakpoint.js
var import_react25 = __toESM(require_react());
function useBreakpoint(refreshOnChange = true, defaultScreens = {}) {
  const screensRef = (0, import_react25.useRef)(defaultScreens);
  const [, forceUpdate] = useForceUpdate();
  const responsiveObserver = responsiveObserver_default();
  useLayoutEffect_default(() => {
    const token = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return () => responsiveObserver.unsubscribe(token);
  }, []);
  return screensRef.current;
}
var useBreakpoint_default = useBreakpoint;

// node_modules/antd/es/avatar/AvatarContext.js
var React58 = __toESM(require_react());
var AvatarContext = React58.createContext({});
var AvatarContext_default = AvatarContext;

// node_modules/antd/es/avatar/style/index.js
var genBaseStyle4 = (token) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    iconFontSize,
    iconFontSizeLG,
    iconFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token;
  const avatarSizeStyle = (size, fontSize, iconFontSize2, radius2) => ({
    width: size,
    height: size,
    borderRadius: "50%",
    fontSize,
    [`&${componentCls}-square`]: {
      borderRadius: radius2
    },
    [`&${componentCls}-icon`]: {
      fontSize: iconFontSize2,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${unit(lineWidth)} ${lineType} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      },
      ...avatarSizeStyle(containerSize, textFontSize, iconFontSize, borderRadius),
      "&-lg": {
        ...avatarSizeStyle(containerSizeLG, textFontSizeLG, iconFontSizeLG, borderRadiusLG)
      },
      "&-sm": {
        ...avatarSizeStyle(containerSizeSM, textFontSizeSM, iconFontSizeSM, borderRadiusSM)
      },
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    }
  };
};
var genGroupStyle2 = (token) => {
  const {
    componentCls,
    groupBorderColor,
    groupOverlapping,
    groupSpace
  } = token;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [componentCls]: {
        borderColor: groupBorderColor
      },
      "> *:not(:first-child)": {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
};
var prepareComponentToken10 = (token) => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: fontSize,
    textFontSizeLG: fontSize,
    textFontSizeSM: fontSize,
    iconFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    iconFontSizeLG: fontSizeHeading3,
    iconFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
};
var style_default13 = genStyleHooks("Avatar", (token) => {
  const {
    colorTextLightSolid,
    colorTextPlaceholder
  } = token;
  const avatarToken = merge(token, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid
  });
  return [genBaseStyle4(avatarToken), genGroupStyle2(avatarToken)];
}, prepareComponentToken10);

// node_modules/antd/es/avatar/Avatar.js
var Avatar = React59.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    shape,
    size: customSize,
    src,
    srcSet,
    icon,
    className,
    rootClassName,
    style,
    alt,
    draggable,
    children,
    crossOrigin,
    gap = 4,
    onError,
    ...others
  } = props;
  const [scale, setScale] = React59.useState(1);
  const [mounted, setMounted] = React59.useState(false);
  const [isImgExist, setIsImgExist] = React59.useState(true);
  const avatarNodeRef = React59.useRef(null);
  const avatarChildrenRef = React59.useRef(null);
  const avatarNodeMergedRef = composeRef(ref, avatarNodeRef);
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("avatar");
  const avatarCtx = React59.useContext(AvatarContext_default);
  const setScaleParam = () => {
    if (!avatarChildrenRef.current || !avatarNodeRef.current) {
      return;
    }
    const childrenWidth = avatarChildrenRef.current.offsetWidth;
    const nodeWidth = avatarNodeRef.current.offsetWidth;
    if (childrenWidth !== 0 && nodeWidth !== 0) {
      if (gap * 2 < nodeWidth) {
        setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
      }
    }
  };
  React59.useEffect(() => {
    setMounted(true);
  }, []);
  React59.useEffect(() => {
    setIsImgExist(true);
    setScale(1);
  }, [src]);
  React59.useEffect(setScaleParam, [gap]);
  const handleImgLoadError = () => {
    const errorFlag = onError?.();
    if (errorFlag !== false) {
      setIsImgExist(false);
    }
  };
  const size = useSize_default((ctxSize) => customSize ?? avatarCtx?.size ?? ctxSize ?? "default");
  const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint_default(needResponsive);
  const responsiveSizeStyle = React59.useMemo(() => {
    if (typeof size !== "object") {
      return {};
    }
    const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
    const currentSize = size[currentBreakpoint];
    return currentSize ? {
      width: currentSize,
      height: currentSize,
      fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
    } : {};
  }, [screens, size, icon, children]);
  if (true) {
    const warning2 = devUseWarning("Avatar");
    true ? warning2(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const sizeCls = clsx({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const hasImageElement = React59.isValidElement(src);
  const mergedShape = shape || avatarCtx?.shape || "circle";
  const classString = clsx(prefixCls, sizeCls, contextClassName, `${prefixCls}-${mergedShape}`, {
    [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
    [`${prefixCls}-icon`]: !!icon
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const sizeStyle = typeof size === "number" ? {
    width: size,
    height: size,
    fontSize: icon ? size / 2 : 18
  } : {};
  let childrenToRender;
  if (typeof src === "string" && isImgExist) {
    childrenToRender = React59.createElement("img", {
      src,
      draggable,
      srcSet,
      onError: handleImgLoadError,
      alt,
      crossOrigin
    });
  } else if (hasImageElement) {
    childrenToRender = src;
  } else if (icon) {
    childrenToRender = icon;
  } else if (mounted || scale !== 1) {
    const transformString = `scale(${scale})`;
    const childrenStyle = {
      msTransform: transformString,
      WebkitTransform: transformString,
      transform: transformString
    };
    childrenToRender = React59.createElement(es_default3, {
      onResize: setScaleParam
    }, React59.createElement("span", {
      className: `${prefixCls}-string`,
      ref: avatarChildrenRef,
      style: childrenStyle
    }, children));
  } else {
    childrenToRender = React59.createElement("span", {
      className: `${prefixCls}-string`,
      style: {
        opacity: 0
      },
      ref: avatarChildrenRef
    }, children);
  }
  return React59.createElement("span", {
    ...others,
    style: {
      ...sizeStyle,
      ...responsiveSizeStyle,
      ...contextStyle,
      ...style
    },
    className: classString,
    ref: avatarNodeMergedRef
  }, childrenToRender);
});
if (true) {
  Avatar.displayName = "Avatar";
}
var Avatar_default2 = Avatar;

// node_modules/antd/es/avatar/AvatarGroup.js
var React60 = __toESM(require_react());
var AvatarContextProvider = (props) => {
  const {
    size,
    shape
  } = React60.useContext(AvatarContext_default);
  const avatarContextValue = React60.useMemo(() => ({
    size: props.size || size,
    shape: props.shape || shape
  }), [props.size, props.shape, size, shape]);
  return React60.createElement(AvatarContext_default.Provider, {
    value: avatarContextValue
  }, props.children);
};
var AvatarGroup = (props) => {
  const {
    getPrefixCls,
    direction
  } = React60.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    maxCount,
    maxStyle,
    size,
    shape,
    maxPopoverPlacement,
    maxPopoverTrigger,
    children,
    max
  } = props;
  if (true) {
    const warning2 = devUseWarning("Avatar.Group");
    [["maxCount", "max={{ count: number }}"], ["maxStyle", "max={{ style: CSSProperties }}"], ["maxPopoverPlacement", "max={{ popover: PopoverProps }}"], ["maxPopoverTrigger", "max={{ popover: PopoverProps }}"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const cls = clsx(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const childrenWithProps = toArray(children).map((child, index2) => cloneElement(child, {
    // eslint-disable-next-line react/no-array-index-key
    key: `avatar-key-${index2}`
  }));
  const mergeCount = max?.count || maxCount;
  const numOfChildren = childrenWithProps.length;
  if (mergeCount && mergeCount < numOfChildren) {
    const childrenShow = childrenWithProps.slice(0, mergeCount);
    const childrenHidden = childrenWithProps.slice(mergeCount, numOfChildren);
    const mergeStyle = max?.style || maxStyle;
    const mergePopoverTrigger = max?.popover?.trigger || maxPopoverTrigger || "hover";
    const mergePopoverPlacement = max?.popover?.placement || maxPopoverPlacement || "top";
    const popoverProps = {
      content: childrenHidden,
      ...max?.popover,
      placement: mergePopoverPlacement,
      trigger: mergePopoverTrigger,
      rootClassName: clsx(`${groupPrefixCls}-popover`, max?.popover?.rootClassName)
    };
    childrenShow.push(React60.createElement(popover_default, {
      key: "avatar-popover-key",
      destroyOnHidden: true,
      ...popoverProps
    }, React60.createElement(Avatar_default2, {
      style: mergeStyle
    }, `+${numOfChildren - mergeCount}`)));
    return React60.createElement(AvatarContextProvider, {
      shape,
      size
    }, React60.createElement("div", {
      className: cls,
      style
    }, childrenShow));
  }
  return React60.createElement(AvatarContextProvider, {
    shape,
    size
  }, React60.createElement("div", {
    className: cls,
    style
  }, childrenWithProps));
};
var AvatarGroup_default = AvatarGroup;

// node_modules/antd/es/avatar/index.js
var Avatar2 = Avatar_default2;
Avatar2.Group = AvatarGroup_default;
var avatar_default = Avatar2;

// node_modules/antd/es/back-top/index.js
var import_react26 = __toESM(require_react());

// node_modules/antd/es/back-top/style/index.js
var genSharedBackTopStyle = (token) => {
  const {
    componentCls,
    backTopFontSize,
    backTopSize,
    zIndexPopup
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "fixed",
      insetInlineEnd: token.backTopInlineEnd,
      insetBlockEnd: token.backTopBlockEnd,
      zIndex: zIndexPopup,
      width: 40,
      height: 40,
      cursor: "pointer",
      "&:empty": {
        display: "none"
      },
      [`${componentCls}-content`]: {
        width: backTopSize,
        height: backTopSize,
        overflow: "hidden",
        color: token.backTopColor,
        textAlign: "center",
        backgroundColor: token.backTopBackground,
        borderRadius: backTopSize,
        transition: `all ${token.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token.backTopHoverBackground,
          transition: `all ${token.motionDurationMid}`
        }
      },
      // change to .backtop .backtop-icon
      [`${componentCls}-icon`]: {
        fontSize: backTopFontSize,
        lineHeight: unit(backTopSize)
      }
    }
  };
};
var genMediaBackTopStyle = (token) => {
  const {
    componentCls,
    screenMD,
    screenXS,
    backTopInlineEndMD,
    backTopInlineEndXS
  } = token;
  return {
    [`@media (max-width: ${unit(screenMD)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndMD
      }
    },
    [`@media (max-width: ${unit(screenXS)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndXS
      }
    }
  };
};
var prepareComponentToken11 = (token) => ({
  zIndexPopup: token.zIndexBase + 10
});
var style_default14 = genStyleHooks("BackTop", (token) => {
  const {
    fontSizeHeading3,
    colorTextDescription,
    colorTextLightSolid,
    colorText,
    controlHeightLG,
    calc
  } = token;
  const backTopToken = merge(token, {
    backTopBackground: colorTextDescription,
    backTopColor: colorTextLightSolid,
    backTopHoverBackground: colorText,
    backTopFontSize: fontSizeHeading3,
    backTopSize: controlHeightLG,
    backTopBlockEnd: calc(controlHeightLG).mul(1.25).equal(),
    backTopInlineEnd: calc(controlHeightLG).mul(2.5).equal(),
    backTopInlineEndMD: calc(controlHeightLG).mul(1.5).equal(),
    backTopInlineEndXS: calc(controlHeightLG).mul(0.5).equal()
  });
  return [genSharedBackTopStyle(backTopToken), genMediaBackTopStyle(backTopToken)];
}, prepareComponentToken11);

// node_modules/antd/es/back-top/index.js
var BackTop = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    visibilityHeight = 400,
    target,
    onClick,
    duration = 450,
    children
  } = props;
  const [visible, setVisible] = import_react26.default.useState(visibilityHeight === 0);
  const ref = import_react26.default.useRef(null);
  const getDefaultTarget2 = () => ref.current?.ownerDocument || window;
  const handleScroll = throttleByAnimationFrame_default((e3) => {
    const scrollTop = getScroll_default(e3.target);
    setVisible(scrollTop >= visibilityHeight);
  });
  if (true) {
    const warning2 = devUseWarning("BackTop");
    warning2.deprecated(false, "BackTop", "FloatButton.BackTop");
  }
  import_react26.default.useEffect(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({
      target: container
    });
    container?.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container?.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = (e3) => {
    scrollTo(0, {
      getContainer: target || getDefaultTarget2,
      duration
    });
    onClick?.(e3);
  };
  const {
    getPrefixCls,
    direction
  } = import_react26.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("back-top", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default14(prefixCls, rootCls);
  const classString = clsx(hashId, cssVarCls, prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName);
  const divProps = omit(props, ["prefixCls", "className", "rootClassName", "children", "visibilityHeight", "target"]);
  const defaultElement = import_react26.default.createElement("div", {
    className: `${prefixCls}-content`
  }, import_react26.default.createElement("div", {
    className: `${prefixCls}-icon`
  }, import_react26.default.createElement(VerticalAlignTopOutlined_default, null)));
  return import_react26.default.createElement("div", {
    ...divProps,
    className: classString,
    onClick: scrollToTop,
    ref
  }, import_react26.default.createElement(es_default4, {
    visible,
    motionName: `${rootPrefixCls}-fade`
  }, ({
    className: motionClassName
  }) => cloneElement(children || defaultElement, ({
    className: cloneCls
  }) => ({
    className: clsx(motionClassName, cloneCls)
  }))));
};
if (true) {
  BackTop.displayName = "Deprecated.BackTop";
}
var back_top_default = BackTop;

// node_modules/antd/es/badge/Badge.js
var React64 = __toESM(require_react());
var import_react27 = __toESM(require_react());

// node_modules/antd/es/badge/ScrollNumber.js
var React63 = __toESM(require_react());

// node_modules/antd/es/badge/SingleNumber.js
var React62 = __toESM(require_react());
var UnitNumber = (props) => {
  const {
    prefixCls,
    value,
    current,
    offset: offset3 = 0
  } = props;
  let style;
  if (offset3) {
    style = {
      position: "absolute",
      top: `${offset3}00%`,
      left: 0
    };
  }
  return React62.createElement("span", {
    style,
    className: clsx(`${prefixCls}-only-unit`, {
      current
    })
  }, value);
};
function getOffset(start, end, unit2) {
  let index2 = start;
  let offset3 = 0;
  while ((index2 + 10) % 10 !== end) {
    index2 += unit2;
    offset3 += unit2;
  }
  return offset3;
}
var SingleNumber = (props) => {
  const {
    prefixCls,
    count: originCount,
    value: originValue
  } = props;
  const value = Number(originValue);
  const count = Math.abs(originCount);
  const [prevValue, setPrevValue] = React62.useState(value);
  const [prevCount, setPrevCount] = React62.useState(count);
  const onTransitionEnd = () => {
    setPrevValue(value);
    setPrevCount(count);
  };
  React62.useEffect(() => {
    const timer = setTimeout(onTransitionEnd, 1e3);
    return () => clearTimeout(timer);
  }, [value]);
  let unitNodes;
  let offsetStyle;
  if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
    unitNodes = [React62.createElement(UnitNumber, {
      ...props,
      key: value,
      current: true
    })];
    offsetStyle = {
      transition: "none"
    };
  } else {
    unitNodes = [];
    const end = value + 10;
    const unitNumberList = [];
    for (let index2 = value; index2 <= end; index2 += 1) {
      unitNumberList.push(index2);
    }
    const unit2 = prevCount < count ? 1 : -1;
    const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
    const cutUnitNumberList = unit2 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex);
    unitNodes = cutUnitNumberList.map((n2, index2) => {
      const singleUnit = n2 % 10;
      return React62.createElement(UnitNumber, {
        ...props,
        key: n2,
        value: singleUnit,
        offset: unit2 < 0 ? index2 - prevIndex : index2,
        current: index2 === prevIndex
      });
    });
    offsetStyle = {
      transform: `translateY(${-getOffset(prevValue, value, unit2)}00%)`
    };
  }
  return React62.createElement("span", {
    className: `${prefixCls}-only`,
    style: offsetStyle,
    onTransitionEnd
  }, unitNodes);
};
var SingleNumber_default = SingleNumber;

// node_modules/antd/es/badge/ScrollNumber.js
var ScrollNumber = React63.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    count,
    className,
    motionClassName,
    style,
    title,
    show,
    component: Component6 = "sup",
    children,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React63.useContext(ConfigContext);
  const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
  const newProps = {
    ...restProps,
    "data-show": show,
    style,
    className: clsx(prefixCls, className, motionClassName),
    title
  };
  let numberNodes = count;
  if (count && Number(count) % 1 === 0) {
    const numberList = String(count).split("");
    numberNodes = React63.createElement("bdi", null, numberList.map((num, i) => React63.createElement(SingleNumber_default, {
      prefixCls,
      count: Number(count),
      value: num,
      // eslint-disable-next-line react/no-array-index-key
      key: numberList.length - i
    })));
  }
  if (style?.borderColor) {
    newProps.style = {
      ...style,
      boxShadow: `0 0 0 1px ${style.borderColor} inset`
    };
  }
  if (children) {
    return cloneElement(children, (oriProps) => ({
      className: clsx(`${prefixCls}-custom-component`, oriProps?.className, motionClassName)
    }));
  }
  return React63.createElement(Component6, {
    ...newProps,
    ref
  }, numberNodes);
});
var ScrollNumber_default = ScrollNumber;

// node_modules/antd/es/badge/style/index.js
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
});
var genSharedBadgeStyle = (token) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeShadowSize,
    textFontSize,
    textFontSizeSM,
    statusSize,
    dotSize,
    textFontWeight,
    indicatorHeight,
    indicatorHeightSM,
    marginXS,
    calc
  } = token;
  const numberPrefixCls = `${antCls}-scroll-number`;
  const colorPreset = genPresetColor(token, (colorKey, {
    darkColor
  }) => ({
    [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
      background: darkColor,
      [`&:not(${componentCls}-count)`]: {
        color: darkColor
      },
      "a:hover &": {
        background: darkColor
      }
    }
  }));
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        display: "inline-flex",
        justifyContent: "center",
        zIndex: token.indicatorZIndex,
        minWidth: indicatorHeight,
        height: indicatorHeight,
        color: token.badgeTextColor,
        fontWeight: textFontWeight,
        fontSize: textFontSize,
        lineHeight: unit(indicatorHeight),
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token.badgeColor,
        borderRadius: calc(indicatorHeight).div(2).equal(),
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token.badgeShadowColor}`,
        transition: `background ${token.motionDurationMid}`,
        a: {
          color: token.badgeTextColor
        },
        "a:hover": {
          color: token.badgeTextColor
        },
        "a:hover &": {
          background: token.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: indicatorHeightSM,
        height: indicatorHeightSM,
        fontSize: textFontSizeSM,
        lineHeight: unit(indicatorHeightSM),
        borderRadius: calc(indicatorHeightSM).div(2).equal()
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${unit(token.paddingXS)}`,
        bdi: {
          unicodeBidi: "plaintext"
        }
      },
      [`${componentCls}-dot`]: {
        zIndex: token.indicatorZIndex,
        width: dotSize,
        minWidth: dotSize,
        height: dotSize,
        background: token.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token.badgeShadowColor}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          // Magic number, but seems better experience
          display: "inline-block",
          width: statusSize,
          height: statusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token.colorInfo,
          backgroundColor: token.colorInfo,
          borderColor: "currentcolor",
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token.colorText,
          fontSize: token.fontSize
        }
      },
      ...colorPreset,
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token.motionDurationSlow,
          animationTimingFunction: token.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token.motionDurationSlow,
          animationTimingFunction: token.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [numberPrefixCls]: {
        overflow: "hidden",
        transition: `all ${token.motionDurationMid} ${token.motionEaseOutBack}`,
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: indicatorHeight,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: indicatorHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }
  };
};
var prepareToken3 = (token) => {
  const {
    fontHeight,
    lineWidth,
    marginXS,
    colorBorderBg
  } = token;
  const badgeFontHeight = fontHeight;
  const badgeShadowSize = lineWidth;
  const badgeTextColor = token.colorTextLightSolid;
  const badgeColor = token.colorError;
  const badgeColorHover = token.colorErrorHover;
  const badgeToken = merge(token, {
    badgeFontHeight,
    badgeShadowSize,
    badgeTextColor,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: `brightness(75%)`
  });
  return badgeToken;
};
var prepareComponentToken12 = (token) => {
  const {
    fontSize,
    lineHeight,
    fontSizeSM,
    lineWidth
  } = token;
  return {
    indicatorZIndex: "auto",
    indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
    indicatorHeightSM: fontSize,
    dotSize: fontSizeSM / 2,
    textFontSize: fontSizeSM,
    textFontSizeSM: fontSizeSM,
    textFontWeight: "normal",
    statusSize: fontSizeSM / 2
  };
};
var style_default15 = genStyleHooks("Badge", (token) => {
  const badgeToken = prepareToken3(token);
  return genSharedBadgeStyle(badgeToken);
}, prepareComponentToken12);

// node_modules/antd/es/badge/Badge.js
var Badge = React64.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
    children,
    status,
    text,
    color,
    count = null,
    overflowCount = 99,
    dot = false,
    size = "default",
    title,
    offset: offset3,
    style,
    className,
    rootClassName,
    classNames,
    styles,
    showZero = false,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("badge");
  const prefixCls = getPrefixCls("badge", customizePrefixCls);
  const [hashId, cssVarCls] = style_default15(prefixCls);
  const mergedProps = {
    ...props,
    overflowCount,
    size,
    dot,
    showZero
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
  const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0 || text === "0" || text === 0;
  const ignoreCount = count === null || isZero && !showZero;
  const hasStatus = (isNonNullable_default(status) || isNonNullable_default(color)) && ignoreCount;
  const hasStatusValue = isNonNullable_default(status) || !isZero;
  const showAsDot = dot && !isZero;
  const mergedCount = showAsDot ? "" : numberedDisplayCount;
  const isHidden = (0, import_react27.useMemo)(() => {
    const isEmpty = (!isNonNullable_default(mergedCount) || mergedCount === "") && (!isNonNullable_default(text) || text === "");
    return (isEmpty || isZero && !showZero) && !showAsDot;
  }, [mergedCount, isZero, showZero, showAsDot, text]);
  const countRef = (0, import_react27.useRef)(count);
  if (!isHidden) {
    countRef.current = count;
  }
  const livingCount = countRef.current;
  const displayCountRef = (0, import_react27.useRef)(mergedCount);
  if (!isHidden) {
    displayCountRef.current = mergedCount;
  }
  const displayCount = displayCountRef.current;
  const isDotRef = (0, import_react27.useRef)(showAsDot);
  if (!isHidden) {
    isDotRef.current = showAsDot;
  }
  const mergedStyle = (0, import_react27.useMemo)(() => {
    if (!offset3) {
      return {
        ...contextStyle,
        ...style
      };
    }
    const horizontalOffset = Number.parseInt(offset3[0], 10);
    const offsetStyle = {
      marginTop: offset3[1],
      insetInlineEnd: -horizontalOffset
    };
    return {
      ...offsetStyle,
      ...contextStyle,
      ...style
    };
  }, [offset3, style, contextStyle]);
  const titleNode = title ?? (typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0);
  const showStatusTextNode = !isHidden && (text === 0 ? showZero : !!text && text !== true);
  const statusTextNode = !showStatusTextNode ? null : React64.createElement("span", {
    className: `${prefixCls}-status-text`
  }, text);
  const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
    style: {
      ...mergedStyle,
      ...oriProps.style
    }
  }));
  const isInternalColor = isPresetColor(color, false);
  const statusCls = clsx(mergedClassNames.indicator, {
    [`${prefixCls}-status-dot`]: hasStatus,
    [`${prefixCls}-status-${status}`]: !!status,
    [`${prefixCls}-color-${color}`]: isInternalColor
  });
  const statusStyle = {};
  if (color && !isInternalColor) {
    statusStyle.color = color;
    statusStyle.background = color;
  }
  const badgeClassName = clsx(prefixCls, {
    [`${prefixCls}-status`]: hasStatus,
    [`${prefixCls}-not-a-wrapper`]: !children,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, contextClassName, mergedClassNames.root, hashId, cssVarCls);
  if (!children && hasStatus && (text || hasStatusValue || !ignoreCount)) {
    const statusTextColor = mergedStyle.color;
    return React64.createElement("span", {
      ...restProps,
      className: badgeClassName,
      style: {
        ...mergedStyles.root,
        ...mergedStyle
      }
    }, React64.createElement("span", {
      className: statusCls,
      style: {
        ...mergedStyles.indicator,
        ...statusStyle
      }
    }), showStatusTextNode && React64.createElement("span", {
      style: {
        color: statusTextColor
      },
      className: `${prefixCls}-status-text`
    }, text));
  }
  return React64.createElement("span", {
    ref,
    ...restProps,
    className: badgeClassName,
    style: mergedStyles.root
  }, children, React64.createElement(es_default4, {
    visible: !isHidden,
    motionName: `${prefixCls}-zoom`,
    motionAppear: false,
    motionDeadline: 1e3
  }, ({
    className: motionClassName
  }) => {
    const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
    const isDot = isDotRef.current;
    const scrollNumberCls = clsx(mergedClassNames.indicator, {
      [`${prefixCls}-dot`]: isDot,
      [`${prefixCls}-count`]: !isDot,
      [`${prefixCls}-count-sm`]: size === "small",
      [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color}`]: isInternalColor
    });
    let scrollNumberStyle = {
      ...mergedStyles.indicator,
      ...mergedStyle
    };
    if (color && !isInternalColor) {
      scrollNumberStyle = scrollNumberStyle || {};
      scrollNumberStyle.background = color;
    }
    return React64.createElement(ScrollNumber_default, {
      prefixCls: scrollNumberPrefixCls,
      show: !isHidden,
      motionClassName,
      className: scrollNumberCls,
      count: displayCount,
      title: titleNode,
      style: scrollNumberStyle,
      key: "scrollNumber"
    }, displayNode);
  }), statusTextNode);
});
if (true) {
  Badge.displayName = "Badge";
}
var Badge_default = Badge;

// node_modules/antd/es/badge/Ribbon.js
var React65 = __toESM(require_react());

// node_modules/antd/es/badge/style/ribbon.js
var genRibbonStyle = (token) => {
  const {
    antCls,
    badgeFontHeight,
    marginXS,
    badgeRibbonOffset,
    calc
  } = token;
  const ribbonPrefixCls = `${antCls}-ribbon`;
  const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
  const statusRibbonPreset = genPresetColor(token, (colorKey, {
    darkColor
  }) => ({
    [`&${ribbonPrefixCls}-color-${colorKey}`]: {
      background: darkColor,
      color: darkColor
    }
  }));
  return {
    [ribbonWrapperPrefixCls]: {
      position: "relative"
    },
    [ribbonPrefixCls]: {
      ...resetComponent(token),
      position: "absolute",
      top: marginXS,
      padding: `0 ${unit(token.paddingXS)}`,
      color: token.colorPrimary,
      lineHeight: unit(badgeFontHeight),
      whiteSpace: "nowrap",
      backgroundColor: token.colorPrimary,
      borderRadius: token.borderRadiusSM,
      [`${ribbonPrefixCls}-content`]: {
        color: token.badgeTextColor
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${unit(calc(badgeRibbonOffset).div(2).equal())} solid`,
        transform: token.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token.badgeRibbonCornerFilter
      },
      ...statusRibbonPreset,
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var ribbon_default = genStyleHooks(["Badge", "Ribbon"], (token) => {
  const badgeToken = prepareToken3(token);
  return genRibbonStyle(badgeToken);
}, prepareComponentToken12);

// node_modules/antd/es/badge/Ribbon.js
var Ribbon = (props) => {
  const {
    className,
    prefixCls: customizePrefixCls,
    style,
    color,
    children,
    text,
    placement = "end",
    rootClassName,
    styles,
    classNames: ribbonClassNames
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("ribbon");
  const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
  const wrapperCls = `${prefixCls}-wrapper`;
  const [hashId, cssVarCls] = ribbon_default(prefixCls, wrapperCls);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, ribbonClassNames], [contextStyles, styles], {
    props: mergedProps
  });
  const colorInPreset = isPresetColor(color, false);
  const ribbonCls = clsx(prefixCls, `${prefixCls}-placement-${placement}`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-color-${color}`]: colorInPreset
  }, className, contextClassName, mergedClassNames.indicator);
  const colorStyle = {};
  const cornerColorStyle = {};
  if (color && !colorInPreset) {
    colorStyle.background = color;
    cornerColorStyle.color = color;
  }
  return React65.createElement("div", {
    className: clsx(wrapperCls, rootClassName, hashId, cssVarCls, mergedClassNames.root),
    style: mergedStyles.root
  }, children, React65.createElement("div", {
    className: clsx(ribbonCls, hashId),
    style: {
      ...colorStyle,
      ...mergedStyles.indicator,
      ...contextStyle,
      ...style
    }
  }, React65.createElement("span", {
    className: clsx(`${prefixCls}-content`, mergedClassNames.content),
    style: mergedStyles.content
  }, text), React65.createElement("div", {
    className: `${prefixCls}-corner`,
    style: cornerColorStyle
  })));
};
if (true) {
  Ribbon.displayName = "Ribbon";
}
var Ribbon_default = Ribbon;

// node_modules/antd/es/badge/index.js
var Badge2 = Badge_default;
Badge2.Ribbon = Ribbon_default;
var badge_default = Badge2;

// node_modules/antd/es/breadcrumb/Breadcrumb.js
var React102 = __toESM(require_react());

// node_modules/antd/es/breadcrumb/BreadcrumbContext.js
var import_react28 = __toESM(require_react());
var BreadcrumbContext = import_react28.default.createContext({});
var BreadcrumbContext_default = BreadcrumbContext;

// node_modules/antd/es/breadcrumb/BreadcrumbItem.js
var React101 = __toESM(require_react());

// node_modules/antd/es/dropdown/dropdown.js
var React98 = __toESM(require_react());

// node_modules/@rc-component/dropdown/es/Dropdown.js
var import_react30 = __toESM(require_react());

// node_modules/@rc-component/dropdown/es/hooks/useAccessibility.js
var React67 = __toESM(require_react());
var {
  ESC,
  TAB
} = KeyCode_default;
function useAccessibility({
  visible,
  triggerRef,
  onVisibleChange,
  autoFocus,
  overlayRef
}) {
  const focusMenuRef = React67.useRef(false);
  const handleCloseMenuAndReturnFocus = () => {
    if (visible) {
      triggerRef.current?.focus?.();
      onVisibleChange?.(false);
    }
  };
  const focusMenu = () => {
    if (overlayRef.current?.focus) {
      overlayRef.current.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  const handleKeyDown = (event) => {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        let focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  React67.useEffect(() => {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        raf_default(focusMenu, 3);
      }
      return () => {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return () => {
      focusMenuRef.current = false;
    };
  }, [visible]);
}

// node_modules/@rc-component/dropdown/es/Overlay.js
var import_react29 = __toESM(require_react());
var Overlay = (0, import_react29.forwardRef)((props, ref) => {
  const {
    overlay,
    arrow,
    prefixCls
  } = props;
  const overlayNode = (0, import_react29.useMemo)(() => {
    let overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  }, [overlay]);
  const composedRef = composeRef(ref, getNodeRef(overlayNode));
  return import_react29.default.createElement(import_react29.default.Fragment, null, arrow && import_react29.default.createElement("div", {
    className: `${prefixCls}-arrow`
  }), import_react29.default.cloneElement(overlayNode, {
    ref: supportRef(overlayNode) ? composedRef : void 0
  }));
});
var Overlay_default = Overlay;

// node_modules/@rc-component/dropdown/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  }
};
var placements_default = placements;

// node_modules/@rc-component/dropdown/es/Dropdown.js
function _extends9() {
  _extends9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
var Dropdown = import_react30.default.forwardRef((props, ref) => {
  const {
    arrow = false,
    prefixCls = "rc-dropdown",
    transitionName,
    animation,
    align,
    placement = "bottomLeft",
    placements: placements4 = placements_default,
    getPopupContainer,
    showAction,
    hideAction,
    overlayClassName,
    overlayStyle,
    visible,
    trigger = ["hover"],
    autoFocus,
    overlay,
    children,
    onVisibleChange,
    ...otherProps
  } = props;
  const [triggerVisible, setTriggerVisible] = import_react30.default.useState();
  const mergedVisible = "visible" in props ? visible : triggerVisible;
  const mergedMotionName = animation ? `${prefixCls}-${animation}` : transitionName;
  const triggerRef = import_react30.default.useRef(null);
  const overlayRef = import_react30.default.useRef(null);
  const childRef = import_react30.default.useRef(null);
  import_react30.default.useImperativeHandle(ref, () => triggerRef.current);
  const handleVisibleChange = (newVisible) => {
    setTriggerVisible(newVisible);
    onVisibleChange?.(newVisible);
  };
  useAccessibility({
    visible: mergedVisible,
    triggerRef: childRef,
    onVisibleChange: handleVisibleChange,
    autoFocus,
    overlayRef
  });
  const onClick = (e3) => {
    const {
      onOverlayClick
    } = props;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e3);
    }
  };
  const getMenuElement = () => import_react30.default.createElement(Overlay_default, {
    ref: overlayRef,
    overlay,
    prefixCls,
    arrow
  });
  const getMenuElementOrLambda = () => {
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  const getMinOverlayWidthMatchTrigger = () => {
    const {
      minOverlayWidthMatchTrigger,
      alignPoint
    } = props;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint;
  };
  const getOpenClassName = () => {
    const {
      openClassName
    } = props;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return `${prefixCls}-open`;
  };
  const childrenNode = import_react30.default.cloneElement(children, {
    className: clsx(children.props?.className, mergedVisible && getOpenClassName()),
    ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
  });
  let triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return import_react30.default.createElement(es_default5, _extends9({
    builtinPlacements: placements4
  }, otherProps, {
    prefixCls,
    ref: triggerRef,
    popupClassName: clsx(overlayClassName, {
      [`${prefixCls}-show-arrow`]: arrow
    }),
    popupStyle: overlayStyle,
    action: trigger,
    showAction,
    hideAction: triggerHideAction,
    popupPlacement: placement,
    popupAlign: align,
    popupMotion: {
      motionName: mergedMotionName
    },
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onOpenChange: handleVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), childrenNode);
});
var Dropdown_default = Dropdown;

// node_modules/@rc-component/dropdown/es/index.js
var es_default9 = Dropdown_default;

// node_modules/antd/es/_util/isPrimitive.js
var isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
var isPrimitive_default = isPrimitive;

// node_modules/antd/es/menu/index.js
var React97 = __toESM(require_react());
var import_react36 = __toESM(require_react());

// node_modules/@rc-component/menu/es/Menu.js
var React89 = __toESM(require_react());
var import_react32 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@rc-component/menu/es/context/IdContext.js
var React70 = __toESM(require_react());
var IdContext = React70.createContext(null);
function getMenuId(uuid3, eventKey) {
  return `${uuid3}-${eventKey}`;
}
function useMenuId(eventKey) {
  const id = React70.useContext(IdContext);
  return getMenuId(id, eventKey);
}

// node_modules/@rc-component/menu/es/context/MenuContext.js
var React71 = __toESM(require_react());
var MenuContext = React71.createContext(null);
function mergeProps(origin, target) {
  const clone = {
    ...origin
  };
  Object.keys(target).forEach((key) => {
    const value = target[key];
    if (value !== void 0) {
      clone[key] = value;
    }
  });
  return clone;
}
function InheritableContextProvider({
  children,
  locked,
  ...restProps
}) {
  const context = React71.useContext(MenuContext);
  const inheritableContext = useMemo(() => mergeProps(context, restProps), [context, restProps], (prev, next) => !locked && (prev[0] !== next[0] || !isEqual_default(prev[1], next[1], true)));
  return React71.createElement(MenuContext.Provider, {
    value: inheritableContext
  }, children);
}

// node_modules/@rc-component/menu/es/context/PathContext.js
var React72 = __toESM(require_react());
var EmptyList = [];
var PathRegisterContext = React72.createContext(null);
function useMeasure() {
  return React72.useContext(PathRegisterContext);
}
var PathTrackerContext = React72.createContext(EmptyList);
function useFullPath(eventKey) {
  const parentKeyPath = React72.useContext(PathTrackerContext);
  return React72.useMemo(() => eventKey !== void 0 ? [...parentKeyPath, eventKey] : parentKeyPath, [parentKeyPath, eventKey]);
}
var PathUserContext = React72.createContext(null);

// node_modules/@rc-component/menu/es/context/PrivateContext.js
var React73 = __toESM(require_react());
var PrivateContext = React73.createContext({});
var PrivateContext_default = PrivateContext;

// node_modules/@rc-component/menu/es/hooks/useAccessibility.js
var React74 = __toESM(require_react());
var {
  LEFT,
  RIGHT,
  UP,
  DOWN,
  ENTER,
  ESC: ESC2,
  HOME,
  END
} = KeyCode_default;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset2(mode, isRootLevel, isRtl, which) {
  const prev = "prev";
  const next = "next";
  const children = "children";
  const parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  const inline = {
    [UP]: prev,
    [DOWN]: next
  };
  const horizontal = {
    [LEFT]: isRtl ? next : prev,
    [RIGHT]: isRtl ? prev : next,
    [DOWN]: children,
    [ENTER]: children
  };
  const vertical = {
    [UP]: prev,
    [DOWN]: next,
    [ENTER]: children,
    [ESC2]: parent,
    [LEFT]: isRtl ? children : parent,
    [RIGHT]: isRtl ? parent : children
  };
  const offsets = {
    inline,
    horizontal,
    vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  const type = offsets[`${mode}${isRootLevel ? "" : "Sub"}`]?.[which];
  switch (type) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };
    case next:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  let current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  let current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  const list = getFocusNodeList(container, true);
  return list.filter((ele) => elements.has(ele));
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset3 = 1) {
  if (!parentQueryContainer) {
    return null;
  }
  const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  const count = sameLevelFocusableMenuElementList.length;
  let focusIndex = sameLevelFocusableMenuElementList.findIndex((ele) => focusMenuElement === ele);
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
var refreshElements = (keys, id) => {
  const elements = /* @__PURE__ */ new Set();
  const key2element = /* @__PURE__ */ new Map();
  const element2key = /* @__PURE__ */ new Map();
  keys.forEach((key) => {
    const element = document.querySelector(`[data-menu-id='${getMenuId(id, key)}']`);
    if (element) {
      elements.add(element);
      element2key.set(element, key);
      key2element.set(key, element);
    }
  });
  return {
    elements,
    key2element,
    element2key
  };
};
function useAccessibility2(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  const rafRef = React74.useRef();
  const activeRef = React74.useRef();
  activeRef.current = activeKey;
  const cleanRaf = () => {
    raf_default.cancel(rafRef.current);
  };
  React74.useEffect(() => () => {
    cleanRaf();
  }, []);
  return (e3) => {
    const {
      which
    } = e3;
    if ([...ArrowKeys, ENTER, ESC2, HOME, END].includes(which)) {
      const keys = getKeys();
      let refreshedElements = refreshElements(keys, id);
      const {
        elements,
        key2element,
        element2key
      } = refreshedElements;
      const activeElement = key2element.get(activeKey);
      const focusMenuElement = getFocusElement(activeElement, elements);
      const focusMenuKey = element2key.get(focusMenuElement);
      const offsetObj = getOffset2(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e3.preventDefault();
      }
      const tryFocus = (menuElement) => {
        if (menuElement) {
          let focusTargetElement = menuElement;
          const link = menuElement.querySelector("a");
          if (link?.getAttribute("href")) {
            focusTargetElement = link;
          }
          const targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = raf_default(() => {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        let parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        let targetElement;
        const focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = raf_default(() => {
          refreshedElements = refreshElements(keys, id);
          const controlId = focusMenuElement.getAttribute("aria-controls");
          const subQueryContainer = document.getElementById(controlId);
          const targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);
          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        const keyPath = getKeyPath(focusMenuKey, true);
        const parentKey = keyPath[keyPath.length - 2];
        const parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown?.(e3);
  };
}

// node_modules/@rc-component/menu/es/hooks/useKeyRecords.js
var React75 = __toESM(require_react());
var import_react31 = __toESM(require_react());

// node_modules/@rc-component/menu/es/utils/timeUtil.js
function nextSlice(callback) {
  Promise.resolve().then(callback);
}

// node_modules/@rc-component/menu/es/hooks/useKeyRecords.js
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = (keyPath) => keyPath.join(PATH_SPLIT);
var getPathKeys = (keyPathStr) => keyPathStr.split(PATH_SPLIT);
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  const [, internalForceUpdate] = React75.useState({});
  const key2pathRef = (0, import_react31.useRef)(/* @__PURE__ */ new Map());
  const path2keyRef = (0, import_react31.useRef)(/* @__PURE__ */ new Map());
  const [overflowKeys, setOverflowKeys] = React75.useState([]);
  const updateRef = (0, import_react31.useRef)(0);
  const destroyRef = (0, import_react31.useRef)(false);
  const forceUpdate = () => {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  const registerPath = (0, import_react31.useCallback)((key, keyPath) => {
    if (true) {
      warning_default(!key2pathRef.current.has(key), `Duplicated key '${key}' used in Menu by path [${keyPath.join(" > ")}]`);
    }
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    const id = updateRef.current;
    nextSlice(() => {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  const unregisterPath = (0, import_react31.useCallback)((key, keyPath) => {
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  const refreshOverflowKeys = (0, import_react31.useCallback)((keys) => {
    setOverflowKeys(keys);
  }, []);
  const getKeyPath = (0, import_react31.useCallback)((eventKey, includeOverflow) => {
    const fullPath = key2pathRef.current.get(eventKey) || "";
    const keys = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys[0])) {
      keys.unshift(OVERFLOW_KEY);
    }
    return keys;
  }, [overflowKeys]);
  const isSubPathKey = (0, import_react31.useCallback)((pathKeys, eventKey) => pathKeys.filter((item) => item !== void 0).some((pathKey) => {
    const pathKeyList = getKeyPath(pathKey, true);
    return pathKeyList.includes(eventKey);
  }), [getKeyPath]);
  const getKeys = () => {
    const keys = [...key2pathRef.current.keys()];
    if (overflowKeys.length) {
      keys.push(OVERFLOW_KEY);
    }
    return keys;
  };
  const getSubPathKeys = (0, import_react31.useCallback)((key) => {
    const connectedPath = `${key2pathRef.current.get(key)}${PATH_SPLIT}`;
    const pathKeys = /* @__PURE__ */ new Set();
    [...path2keyRef.current.keys()].forEach((pathKey) => {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  React75.useEffect(() => () => {
    destroyRef.current = true;
  }, []);
  return {
    // Register
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    // Util
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}

// node_modules/@rc-component/menu/es/hooks/useMemoCallback.js
var React76 = __toESM(require_react());
function useMemoCallback(func) {
  const funRef = React76.useRef(func);
  funRef.current = func;
  const callback = React76.useCallback((...args) => funRef.current?.(...args), []);
  return func ? callback : void 0;
}

// node_modules/@rc-component/menu/es/MenuItem.js
var React80 = __toESM(require_react());

// node_modules/@rc-component/menu/es/hooks/useActive.js
var React77 = __toESM(require_react());
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  const {
    // Active
    activeKey,
    onActive,
    onInactive
  } = React77.useContext(MenuContext);
  const ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = (domEvent) => {
      onMouseEnter?.({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = (domEvent) => {
      onMouseLeave?.({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}

// node_modules/@rc-component/menu/es/hooks/useDirectionStyle.js
var React78 = __toESM(require_react());
function useDirectionStyle(level) {
  const {
    mode,
    rtl,
    inlineIndent
  } = React78.useContext(MenuContext);
  if (mode !== "inline") {
    return null;
  }
  const len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}

// node_modules/@rc-component/menu/es/Icon.js
var React79 = __toESM(require_react());
function Icon({
  icon,
  props,
  children
}) {
  let iconNode;
  if (icon === null || icon === false) {
    return null;
  }
  if (typeof icon === "function") {
    iconNode = React79.createElement(icon, {
      ...props
    });
  } else if (typeof icon !== "boolean") {
    iconNode = icon;
  }
  return iconNode || children || null;
}

// node_modules/@rc-component/menu/es/utils/warnUtil.js
function warnItemProp({
  item,
  ...restInfo
}) {
  Object.defineProperty(restInfo, "item", {
    get: () => {
      warning_default(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}

// node_modules/@rc-component/menu/es/MenuItem.js
function _extends10() {
  _extends10 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends10.apply(this, arguments);
}
var LegacyMenuItem = class extends React80.Component {
  render() {
    const {
      title,
      attribute,
      elementRef,
      ...restProps
    } = this.props;
    const passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
    warning_default(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
    return React80.createElement(es_default6.Item, _extends10({}, attribute, {
      title: typeof title === "string" ? title : void 0
    }, passedProps, {
      ref: elementRef
    }));
  }
};
var InternalMenuItem = React80.forwardRef((props, ref) => {
  const {
    style,
    className,
    eventKey,
    warnKey,
    disabled,
    itemIcon,
    children,
    // Aria
    role,
    // Active
    onMouseEnter,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onFocus,
    ...restProps
  } = props;
  const domDataId = useMenuId(eventKey);
  const {
    prefixCls,
    onItemClick,
    disabled: contextDisabled,
    overflowDisabled,
    // Icon
    itemIcon: contextItemIcon,
    // Select
    selectedKeys,
    // Active
    onActive
  } = React80.useContext(MenuContext);
  const {
    _internalRenderMenuItem
  } = React80.useContext(PrivateContext_default);
  const itemCls = `${prefixCls}-item`;
  const legacyMenuItemRef = React80.useRef();
  const elementRef = React80.useRef();
  const mergedDisabled = contextDisabled || disabled;
  const mergedEleRef = useComposeRef(ref, elementRef);
  const connectedKeys = useFullPath(eventKey);
  if (warnKey) {
    warning_default(false, "MenuItem should not leave undefined `key`.");
  }
  const getEventInfo = (e3) => {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: [...connectedKeys].reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e3
    };
  };
  const mergedItemIcon = itemIcon || contextItemIcon;
  const {
    active,
    ...activeProps
  } = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave);
  const selected = selectedKeys.includes(eventKey);
  const directionStyle = useDirectionStyle(connectedKeys.length);
  const onInternalClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    const info = getEventInfo(e3);
    onClick?.(warnItemProp(info));
    onItemClick(info);
  };
  const onInternalKeyDown = (e3) => {
    onKeyDown2?.(e3);
    if (e3.which === KeyCode_default.ENTER) {
      const info = getEventInfo(e3);
      onClick?.(warnItemProp(info));
      onItemClick(info);
    }
  };
  const onInternalFocus = (e3) => {
    onActive(eventKey);
    onFocus?.(e3);
  };
  const optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  let renderNode = React80.createElement(LegacyMenuItem, _extends10({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: {
      ...directionStyle,
      ...style
    },
    className: clsx(itemCls, {
      [`${itemCls}-active`]: active,
      [`${itemCls}-selected`]: selected,
      [`${itemCls}-disabled`]: mergedDisabled
    }, className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, React80.createElement(Icon, {
    props: {
      ...props,
      isSelected: selected
    },
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
});
function MenuItem(props, ref) {
  const {
    eventKey
  } = props;
  const measure = useMeasure();
  const connectedKeyPath = useFullPath(eventKey);
  React80.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return React80.createElement(InternalMenuItem, _extends10({}, props, {
    ref
  }));
}
var MenuItem_default = React80.forwardRef(MenuItem);

// node_modules/@rc-component/menu/es/SubMenu/index.js
var React85 = __toESM(require_react());

// node_modules/@rc-component/menu/es/SubMenu/SubMenuList.js
var React81 = __toESM(require_react());
function _extends11() {
  _extends11 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends11.apply(this, arguments);
}
var InternalSubMenuList = ({
  className,
  children,
  ...restProps
}, ref) => {
  const {
    prefixCls,
    mode,
    rtl
  } = React81.useContext(MenuContext);
  return React81.createElement("ul", _extends11({
    className: clsx(prefixCls, rtl && `${prefixCls}-rtl`, `${prefixCls}-sub`, `${prefixCls}-${mode === "inline" ? "inline" : "vertical"}`, className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref
  }), children);
};
var SubMenuList = React81.forwardRef(InternalSubMenuList);
if (true) {
  SubMenuList.displayName = "SubMenuList";
}
var SubMenuList_default = SubMenuList;

// node_modules/@rc-component/menu/es/utils/commonUtil.js
var React82 = __toESM(require_react());
function parseChildren(children, keyPath) {
  return toArray(children).map((child, index2) => {
    if (React82.isValidElement(child)) {
      const {
        key
      } = child;
      let eventKey = child.props?.eventKey ?? key;
      const emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = `tmp_key-${[...keyPath, index2].join("-")}`;
      }
      const cloneProps = {
        key: eventKey,
        eventKey
      };
      if (emptyKey) {
        cloneProps.warnKey = true;
      }
      return React82.cloneElement(child, cloneProps);
    }
    return child;
  });
}

// node_modules/@rc-component/menu/es/SubMenu/PopupTrigger.js
var React83 = __toESM(require_react());

// node_modules/@rc-component/menu/es/placements.js
var autoAdjustOverflow2 = {
  adjustX: 1,
  adjustY: 1
};
var placements2 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};

// node_modules/@rc-component/menu/es/utils/motionUtil.js
function getMotion3(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}

// node_modules/@rc-component/menu/es/SubMenu/PopupTrigger.js
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger({
  prefixCls,
  visible,
  children,
  popup,
  popupStyle,
  popupClassName,
  popupOffset,
  disabled,
  mode,
  onVisibleChange
}) {
  const {
    getPopupContainer,
    rtl,
    subMenuOpenDelay,
    subMenuCloseDelay,
    builtinPlacements,
    triggerSubMenuAction,
    forceSubMenuRender,
    rootClassName,
    // Motion
    motion: motion2,
    defaultMotions
  } = React83.useContext(MenuContext);
  const [innerVisible, setInnerVisible] = React83.useState(false);
  const placement = rtl ? {
    ...placementsRtl,
    ...builtinPlacements
  } : {
    ...placements2,
    ...builtinPlacements
  };
  const popupPlacement = popupPlacementMap[mode];
  const targetMotion = getMotion3(mode, motion2, defaultMotions);
  const targetMotionRef = React83.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  const mergedMotion = {
    ...targetMotionRef.current,
    leavedClassName: `${prefixCls}-hidden`,
    removeOnLeave: false,
    motionAppear: true
  };
  const visibleRef = React83.useRef();
  React83.useEffect(() => {
    visibleRef.current = raf_default(() => {
      setInnerVisible(visible);
    });
    return () => {
      raf_default.cancel(visibleRef.current);
    };
  }, [visible]);
  return React83.createElement(es_default5, {
    prefixCls,
    popupClassName: clsx(`${prefixCls}-popup`, {
      [`${prefixCls}-rtl`]: rtl
    }, popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupStyle,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    fresh: true
  }, children);
}

// node_modules/@rc-component/menu/es/SubMenu/InlineSubMenuList.js
var React84 = __toESM(require_react());
function _extends12() {
  _extends12 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends12.apply(this, arguments);
}
function InlineSubMenuList({
  id,
  open: open3,
  keyPath,
  children
}) {
  const fixedMode = "inline";
  const {
    prefixCls,
    forceSubMenuRender,
    motion: motion2,
    defaultMotions,
    mode
  } = React84.useContext(MenuContext);
  const sameModeRef = React84.useRef(false);
  sameModeRef.current = mode === fixedMode;
  const [destroy3, setDestroy] = React84.useState(!sameModeRef.current);
  const mergedOpen = sameModeRef.current ? open3 : false;
  React84.useEffect(() => {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  const mergedMotion = {
    ...getMotion3(fixedMode, motion2, defaultMotions)
  };
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  const originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = (newVisible) => {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged?.(newVisible);
  };
  if (destroy3) {
    return null;
  }
  return React84.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, React84.createElement(es_default4, _extends12({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: `${prefixCls}-hidden`
  }), ({
    className: motionClassName,
    style: motionStyle
  }) => {
    return React84.createElement(SubMenuList_default, {
      id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}

// node_modules/@rc-component/menu/es/SubMenu/index.js
function _extends13() {
  _extends13 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends13.apply(this, arguments);
}
var InternalSubMenu = React85.forwardRef((props, ref) => {
  const {
    style,
    className,
    styles,
    classNames: menuClassNames,
    title,
    eventKey,
    warnKey,
    disabled,
    internalPopupClose,
    children,
    // Icons
    itemIcon,
    expandIcon,
    // Popup
    popupClassName,
    popupOffset,
    popupStyle,
    // Events
    onClick,
    onMouseEnter,
    onMouseLeave,
    onTitleClick,
    onTitleMouseEnter,
    onTitleMouseLeave,
    popupRender: propsPopupRender,
    ...restProps
  } = props;
  const domDataId = useMenuId(eventKey);
  const {
    prefixCls,
    mode,
    openKeys,
    // Disabled
    disabled: contextDisabled,
    overflowDisabled,
    // ActiveKey
    activeKey,
    // SelectKey
    selectedKeys,
    // Icon
    itemIcon: contextItemIcon,
    expandIcon: contextExpandIcon,
    // Events
    onItemClick,
    onOpenChange,
    onActive,
    popupRender: contextPopupRender
  } = React85.useContext(MenuContext);
  const {
    _internalRenderSubMenuItem
  } = React85.useContext(PrivateContext_default);
  const {
    isSubPathKey
  } = React85.useContext(PathUserContext);
  const connectedPath = useFullPath();
  const subMenuPrefixCls = `${prefixCls}-submenu`;
  const mergedDisabled = contextDisabled || disabled;
  const elementRef = React85.useRef();
  const popupRef = React85.useRef();
  if (warnKey) {
    warning_default(false, "SubMenu should not leave undefined `key`.");
  }
  const mergedItemIcon = itemIcon ?? contextItemIcon;
  const mergedExpandIcon = expandIcon ?? contextExpandIcon;
  const originOpen = openKeys.includes(eventKey);
  const open3 = !overflowDisabled && originOpen;
  const childrenSelected = isSubPathKey(selectedKeys, eventKey);
  const {
    active,
    ...activeProps
  } = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave);
  const [childrenActive, setChildrenActive] = React85.useState(false);
  const triggerChildrenActive = (newActive) => {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  const onInternalMouseEnter = (domEvent) => {
    triggerChildrenActive(true);
    onMouseEnter?.({
      key: eventKey,
      domEvent
    });
  };
  const onInternalMouseLeave = (domEvent) => {
    triggerChildrenActive(false);
    onMouseLeave?.({
      key: eventKey,
      domEvent
    });
  };
  const mergedActive = React85.useMemo(() => {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  const directionStyle = useDirectionStyle(connectedPath.length);
  const onInternalTitleClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    onTitleClick?.({
      key: eventKey,
      domEvent: e3
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  const onMergedItemClick = useMemoCallback((info) => {
    onClick?.(warnItemProp(info));
    onItemClick(info);
  });
  const onPopupVisibleChange = (newVisible) => {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  const onInternalFocus = () => {
    onActive(eventKey);
  };
  const popupId = domDataId && `${domDataId}-popup`;
  const expandIconNode = React85.useMemo(() => React85.createElement(Icon, {
    icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
    props: {
      ...props,
      isOpen: open3,
      // [Legacy] Not sure why need this mark
      isSubMenu: true
    }
  }, React85.createElement("i", {
    className: `${subMenuPrefixCls}-arrow`
  })), [mode, mergedExpandIcon, props, open3, subMenuPrefixCls]);
  let titleNode = React85.createElement("div", _extends13({
    role: "menuitem",
    style: directionStyle,
    className: `${subMenuPrefixCls}-title`,
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open3,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, expandIconNode);
  const triggerModeRef = React85.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1) {
    triggerModeRef.current = "vertical";
  } else {
    triggerModeRef.current = mode;
  }
  const popupContentTriggerMode = triggerModeRef.current;
  const renderPopupContent = React85.useMemo(() => {
    const originNode = React85.createElement(InheritableContextProvider, {
      classNames: menuClassNames,
      styles,
      mode: popupContentTriggerMode === "horizontal" ? "vertical" : popupContentTriggerMode
    }, React85.createElement(SubMenuList_default, {
      id: popupId,
      ref: popupRef
    }, children));
    const mergedPopupRender = propsPopupRender || contextPopupRender;
    if (mergedPopupRender) {
      const node = mergedPopupRender(originNode, {
        item: props,
        keys: connectedPath
      });
      return node;
    }
    return originNode;
  }, [propsPopupRender, contextPopupRender, connectedPath, popupId, children, props, popupContentTriggerMode]);
  if (!overflowDisabled) {
    const triggerMode = triggerModeRef.current;
    titleNode = React85.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open3 && mode !== "inline",
      popupClassName,
      popupOffset,
      popupStyle,
      popup: renderPopupContent,
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  let listNode = React85.createElement(es_default6.Item, _extends13({
    ref,
    role: "none"
  }, restProps, {
    component: "li",
    style,
    className: clsx(subMenuPrefixCls, `${subMenuPrefixCls}-${mode}`, className, {
      [`${subMenuPrefixCls}-open`]: open3,
      [`${subMenuPrefixCls}-active`]: mergedActive,
      [`${subMenuPrefixCls}-selected`]: childrenSelected,
      [`${subMenuPrefixCls}-disabled`]: mergedDisabled
    }),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && React85.createElement(InlineSubMenuList, {
    id: popupId,
    open: open3,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open3,
      disabled: mergedDisabled
    });
  }
  return React85.createElement(InheritableContextProvider, {
    classNames: menuClassNames,
    styles,
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
});
var SubMenu = React85.forwardRef((props, ref) => {
  const {
    eventKey,
    children
  } = props;
  const connectedKeyPath = useFullPath(eventKey);
  const childList = parseChildren(children, connectedKeyPath);
  const measure = useMeasure();
  React85.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  let renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = React85.createElement(InternalSubMenu, _extends13({
      ref
    }, props), childList);
  }
  return React85.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
});
if (true) {
  SubMenu.displayName = "SubMenu";
}
var SubMenu_default = SubMenu;

// node_modules/@rc-component/menu/es/utils/nodeUtil.js
var React88 = __toESM(require_react());

// node_modules/@rc-component/menu/es/Divider.js
var React86 = __toESM(require_react());
function Divider({
  className,
  style
}) {
  const {
    prefixCls
  } = React86.useContext(MenuContext);
  const measure = useMeasure();
  if (measure) {
    return null;
  }
  return React86.createElement("li", {
    role: "separator",
    className: clsx(`${prefixCls}-item-divider`, className),
    style
  });
}

// node_modules/@rc-component/menu/es/MenuItemGroup.js
var React87 = __toESM(require_react());
function _extends14() {
  _extends14 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends14.apply(this, arguments);
}
var InternalMenuItemGroup = React87.forwardRef((props, ref) => {
  const {
    className,
    title,
    eventKey,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    classNames: menuClassNames,
    styles
  } = React87.useContext(MenuContext);
  const groupPrefixCls = `${prefixCls}-item-group`;
  return React87.createElement("li", _extends14({
    ref,
    role: "presentation"
  }, restProps, {
    onClick: (e3) => e3.stopPropagation(),
    className: clsx(groupPrefixCls, className)
  }), React87.createElement("div", {
    role: "presentation",
    className: clsx(`${groupPrefixCls}-title`, menuClassNames?.listTitle),
    style: styles?.listTitle,
    title: typeof title === "string" ? title : void 0
  }, title), React87.createElement("ul", {
    role: "group",
    className: clsx(`${groupPrefixCls}-list`, menuClassNames?.list),
    style: styles?.list
  }, children));
});
var MenuItemGroup = React87.forwardRef((props, ref) => {
  const {
    eventKey,
    children
  } = props;
  const connectedKeyPath = useFullPath(eventKey);
  const childList = parseChildren(children, connectedKeyPath);
  const measure = useMeasure();
  if (measure) {
    return childList;
  }
  return React87.createElement(InternalMenuItemGroup, _extends14({
    ref
  }, omit(props, ["warnKey"])), childList);
});
if (true) {
  MenuItemGroup.displayName = "MenuItemGroup";
}
var MenuItemGroup_default = MenuItemGroup;

// node_modules/@rc-component/menu/es/utils/nodeUtil.js
function _extends15() {
  _extends15 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends15.apply(this, arguments);
}
function convertItemsToNodes(list, components, prefixCls) {
  const {
    item: MergedMenuItem,
    group: MergedMenuItemGroup,
    submenu: MergedSubMenu,
    divider: MergedDivider
  } = components;
  return (list || []).map((opt, index2) => {
    if (opt && typeof opt === "object") {
      const {
        label,
        children,
        key,
        type,
        extra,
        ...restProps
      } = opt;
      const mergedKey = key ?? `tmp-${index2}`;
      if (children || type === "group") {
        if (type === "group") {
          return React88.createElement(MergedMenuItemGroup, _extends15({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children, components, prefixCls));
        }
        return React88.createElement(MergedSubMenu, _extends15({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes(children, components, prefixCls));
      }
      if (type === "divider") {
        return React88.createElement(MergedDivider, _extends15({
          key: mergedKey
        }, restProps));
      }
      return React88.createElement(MergedMenuItem, _extends15({
        key: mergedKey
      }, restProps, {
        extra
      }), label, (!!extra || extra === 0) && React88.createElement("span", {
        className: `${prefixCls}-item-extra`
      }, extra));
    }
    return null;
  }).filter((opt) => opt);
}
function parseItems(children, items, keyPath, components, prefixCls) {
  let childNodes = children;
  const mergedComponents = {
    divider: Divider,
    item: MenuItem_default,
    group: MenuItemGroup_default,
    submenu: SubMenu_default,
    ...components
  };
  if (items) {
    childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
  }
  return parseChildren(childNodes, keyPath);
}

// node_modules/@rc-component/menu/es/Menu.js
function _extends16() {
  _extends16 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends16.apply(this, arguments);
}
var EMPTY_LIST = [];
var Menu = React89.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-menu",
    rootClassName,
    style,
    className,
    styles,
    classNames: menuClassNames,
    tabIndex = 0,
    items,
    children,
    direction,
    id,
    // Mode
    mode = "vertical",
    inlineCollapsed,
    // Disabled
    disabled,
    disabledOverflow,
    // Open
    subMenuOpenDelay = 0.1,
    subMenuCloseDelay = 0.1,
    forceSubMenuRender,
    defaultOpenKeys,
    openKeys,
    // Active
    activeKey,
    defaultActiveFirst,
    // Selection
    selectable = true,
    multiple = false,
    defaultSelectedKeys,
    selectedKeys,
    onSelect,
    onDeselect,
    // Level
    inlineIndent = 24,
    // Motion
    motion: motion2,
    defaultMotions,
    // Popup
    triggerSubMenuAction = "hover",
    builtinPlacements,
    // Icon
    itemIcon,
    expandIcon,
    overflowedIndicator = "...",
    overflowedIndicatorPopupClassName,
    // Function
    getPopupContainer,
    // Events
    onClick,
    onOpenChange,
    onKeyDown: onKeyDown2,
    // Deprecated
    openAnimation,
    openTransitionName,
    // Internal
    _internalRenderMenuItem,
    _internalRenderSubMenuItem,
    _internalComponents,
    popupRender,
    ...restProps
  } = props;
  const [childList, measureChildList] = React89.useMemo(() => [parseItems(children, items, EMPTY_LIST, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST, {}, prefixCls)], [children, items, _internalComponents]);
  const [mounted, setMounted] = React89.useState(false);
  const containerRef = React89.useRef();
  const uuid3 = useId_default(id ? `rc-menu-uuid-${id}` : "rc-menu-uuid");
  const isRtl = direction === "rtl";
  if (true) {
    warning_default(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  }
  const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);
  const mergedOpenKeys = innerOpenKeys || EMPTY_LIST;
  const triggerOpenKeys = (keys, forceFlush = false) => {
    function doUpdate() {
      setMergedOpenKeys(keys);
      onOpenChange?.(keys);
    }
    if (forceFlush) {
      (0, import_react_dom2.flushSync)(doUpdate);
    } else {
      doUpdate();
    }
  };
  const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = React89.useState(mergedOpenKeys);
  const mountRef = React89.useRef(false);
  const [mergedMode, mergedInlineCollapsed] = React89.useMemo(() => {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]);
  const isInlineMode = mergedMode === "inline";
  const [internalMode, setInternalMode] = React89.useState(mergedMode);
  const [internalInlineCollapsed, setInternalInlineCollapsed] = React89.useState(mergedInlineCollapsed);
  React89.useEffect(() => {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  const [lastVisibleIndex, setLastVisibleIndex] = React89.useState(0);
  const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React89.useEffect(() => {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  React89.useEffect(() => {
    mountRef.current = true;
    return () => {
      mountRef.current = false;
    };
  }, []);
  const {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  } = useKeyRecords();
  const registerPathContext = React89.useMemo(() => ({
    registerPath,
    unregisterPath
  }), [registerPath, unregisterPath]);
  const pathUserContext = React89.useMemo(() => ({
    isSubPathKey
  }), [isSubPathKey]);
  React89.useEffect(() => {
    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map((child) => child.key));
  }, [lastVisibleIndex, allVisible]);
  const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && childList[0]?.key, activeKey);
  const onActive = useMemoCallback((key) => {
    setMergedActiveKey(key);
  });
  const onInactive = useMemoCallback(() => {
    setMergedActiveKey(void 0);
  });
  (0, import_react32.useImperativeHandle)(ref, () => {
    return {
      list: containerRef.current,
      focus: (options) => {
        const keys = getKeys();
        const {
          elements,
          key2element,
          element2key
        } = refreshElements(keys, uuid3);
        const focusableElements = getFocusableElements(containerRef.current, elements);
        let shouldFocusKey;
        if (mergedActiveKey && keys.includes(mergedActiveKey)) {
          shouldFocusKey = mergedActiveKey;
        } else {
          shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find((node) => !node.props.disabled)?.key;
        }
        const elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          elementToFocus?.focus?.(options);
        }
      },
      findItem: ({
        key: itemKey2
      }) => {
        const keys = getKeys();
        const {
          key2element
        } = refreshElements(keys, uuid3);
        return key2element.get(itemKey2) || null;
      }
    };
  });
  const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);
  const mergedSelectKeys = React89.useMemo(() => {
    if (Array.isArray(internalSelectKeys)) {
      return internalSelectKeys;
    }
    if (internalSelectKeys === null || internalSelectKeys === void 0) {
      return EMPTY_LIST;
    }
    return [internalSelectKeys];
  }, [internalSelectKeys]);
  const triggerSelection = (info) => {
    if (selectable) {
      const {
        key: targetKey
      } = info;
      const exist = mergedSelectKeys.includes(targetKey);
      let newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter((key) => key !== targetKey);
        } else {
          newSelectKeys = [...mergedSelectKeys, targetKey];
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      const selectInfo = {
        ...info,
        selectedKeys: newSelectKeys
      };
      if (exist) {
        onDeselect?.(selectInfo);
      } else {
        onSelect?.(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST);
    }
  };
  const onInternalClick = useMemoCallback((info) => {
    onClick?.(warnItemProp(info));
    triggerSelection(info);
  });
  const onInternalOpenChange = useMemoCallback((key, open3) => {
    let newOpenKeys = mergedOpenKeys.filter((k) => k !== key);
    if (open3) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      const subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter((k) => !subPathKeys.has(k));
    }
    if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  const triggerAccessibilityOpen = (key, open3) => {
    const nextOpen = open3 ?? !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  const onInternalKeyDown = useAccessibility2(internalMode, mergedActiveKey, isRtl, uuid3, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  React89.useEffect(() => {
    setMounted(true);
  }, []);
  const privateContext = React89.useMemo(() => ({
    _internalRenderMenuItem,
    _internalRenderSubMenuItem
  }), [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  const wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
    // Need wrap for overflow dropdown that do not response for open
    childList.map((child, index2) => (
      // Always wrap provider to avoid sub node re-mount
      React89.createElement(InheritableContextProvider, {
        key: child.key,
        overflowDisabled: index2 > lastVisibleIndex,
        classNames: menuClassNames,
        styles
      }, child)
    ))
  );
  const container = React89.createElement(es_default6, _extends16({
    id,
    ref: containerRef,
    prefixCls: `${prefixCls}-overflow`,
    component: "ul",
    itemComponent: MenuItem_default,
    className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {
      [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,
      [`${prefixCls}-rtl`]: isRtl
    }, rootClassName),
    dir: direction,
    style,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: (node) => node,
    renderRawRest: (omitItems) => {
      const len = omitItems.length;
      const originOmitItems = len ? childList.slice(-len) : null;
      return React89.createElement(SubMenu_default, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default6.INVALIDATE : es_default6.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: (newLastIndex) => {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return React89.createElement(PrivateContext_default.Provider, {
    value: privateContext
  }, React89.createElement(IdContext.Provider, {
    value: uuid3
  }, React89.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    classNames: menuClassNames,
    styles,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion2 : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange,
    popupRender
  }, React89.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), React89.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, React89.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, measureChildList)))));
});
var Menu_default = Menu;

// node_modules/@rc-component/menu/es/index.js
var ExportMenu = Menu_default;
ExportMenu.Item = MenuItem_default;
ExportMenu.SubMenu = SubMenu_default;
ExportMenu.ItemGroup = MenuItemGroup_default;
ExportMenu.Divider = Divider;
var es_default10 = ExportMenu;

// node_modules/antd/es/layout/Sider.js
var React91 = __toESM(require_react());
var import_react33 = __toESM(require_react());

// node_modules/antd/es/layout/context.js
var React90 = __toESM(require_react());
var LayoutContext = React90.createContext({
  siderHook: {
    addSider: () => null,
    removeSider: () => null
  }
});

// node_modules/antd/es/layout/style/index.js
var genLayoutStyle = (token) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    footerBg,
    headerHeight,
    headerPadding,
    headerColor,
    footerPadding,
    fontSize,
    bodyBg,
    headerBg
  } = token;
  return {
    [componentCls]: {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: bodyBg,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // ==================== Header ====================
    [`${componentCls}-header`]: {
      height: headerHeight,
      padding: headerPadding,
      color: headerColor,
      lineHeight: unit(headerHeight),
      background: headerBg,
      // Other components/menu/style/index.less line:686
      // Integration with header element so menu items have the same height
      [`${antCls}-menu`]: {
        lineHeight: "inherit"
      }
    },
    // ==================== Footer ====================
    [`${componentCls}-footer`]: {
      padding: footerPadding,
      color: colorText,
      fontSize,
      background: footerBg
    },
    // =================== Content ====================
    [`${componentCls}-content`]: {
      flex: "auto",
      color: colorText,
      // fix firefox can't set height smaller than content on flex item
      minHeight: 0
    }
  };
};
var prepareComponentToken13 = (token) => {
  const {
    colorBgLayout,
    controlHeight,
    controlHeightLG,
    colorText,
    controlHeightSM,
    marginXXS,
    colorTextLightSolid,
    colorBgContainer
  } = token;
  const paddingInline = controlHeightLG * 1.25;
  return {
    // Deprecated
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140",
    bodyBg: colorBgLayout,
    headerBg: "#001529",
    headerHeight: controlHeight * 2,
    headerPadding: `0 ${paddingInline}px`,
    headerColor: colorText,
    footerPadding: `${controlHeightSM}px ${paddingInline}px`,
    footerBg: colorBgLayout,
    siderBg: "#001529",
    triggerHeight: controlHeightLG + marginXXS * 2,
    triggerBg: "#002140",
    triggerColor: colorTextLightSolid,
    zeroTriggerWidth: controlHeightLG,
    zeroTriggerHeight: controlHeightLG,
    lightSiderBg: colorBgContainer,
    lightTriggerBg: colorBgContainer,
    lightTriggerColor: colorText
  };
};
var DEPRECATED_TOKENS = [["colorBgBody", "bodyBg"], ["colorBgHeader", "headerBg"], ["colorBgTrigger", "triggerBg"]];
var style_default16 = genStyleHooks("Layout", genLayoutStyle, prepareComponentToken13, {
  deprecatedTokens: DEPRECATED_TOKENS
});

// node_modules/antd/es/layout/style/sider.js
var genSiderStyle = (token) => {
  const {
    componentCls,
    siderBg,
    motionDurationMid,
    motionDurationSlow,
    antCls,
    triggerHeight,
    triggerColor,
    triggerBg,
    headerHeight,
    zeroTriggerWidth,
    zeroTriggerHeight,
    borderRadiusLG,
    lightSiderBg,
    lightTriggerColor,
    lightTriggerBg,
    bodyBg
  } = token;
  return {
    [componentCls]: {
      position: "relative",
      // fix firefox can't set width smaller than content on flex item
      minWidth: 0,
      background: siderBg,
      transition: `all ${motionDurationMid}, background 0s`,
      "&-has-trigger": {
        paddingBottom: triggerHeight
      },
      "&-right": {
        order: 1
      },
      [`${componentCls}-children`]: {
        height: "100%",
        // Hack for fixing margin collapse bug
        // https://github.com/ant-design/ant-design/issues/7967
        // solution from https://stackoverflow.com/a/33132624/3040605
        marginTop: -0.1,
        paddingTop: 0.1,
        [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
          width: "auto"
        }
      },
      [`&-zero-width ${componentCls}-children`]: {
        overflow: "hidden"
      },
      [`${componentCls}-trigger`]: {
        position: "fixed",
        bottom: 0,
        zIndex: 1,
        height: triggerHeight,
        color: triggerColor,
        lineHeight: unit(triggerHeight),
        textAlign: "center",
        background: triggerBg,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-zero-width-trigger`]: {
        position: "absolute",
        top: headerHeight,
        insetInlineEnd: token.calc(zeroTriggerWidth).mul(-1).equal(),
        zIndex: 1,
        width: zeroTriggerWidth,
        height: zeroTriggerHeight,
        color: triggerColor,
        fontSize: token.fontSizeXL,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: siderBg,
        borderRadius: `0 ${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0`,
        cursor: "pointer",
        transition: `background ${motionDurationSlow} ease`,
        "&::after": {
          position: "absolute",
          inset: 0,
          background: "transparent",
          transition: `all ${motionDurationSlow}`,
          content: '""'
        },
        "&:hover::after": {
          background: `rgba(255, 255, 255, 0.2)`
        },
        "&-right": {
          insetInlineStart: token.calc(zeroTriggerWidth).mul(-1).equal(),
          borderRadius: `${unit(borderRadiusLG)} 0 0 ${unit(borderRadiusLG)}`
        }
      },
      // Light
      "&-light": {
        background: lightSiderBg,
        [`${componentCls}-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg
        },
        [`${componentCls}-zero-width-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg,
          border: `1px solid ${bodyBg}`,
          // Safe to modify to any other color
          borderInlineStart: 0
        }
      }
    }
  };
};
var sider_default = genStyleHooks(["Layout", "Sider"], genSiderStyle, prepareComponentToken13, {
  deprecatedTokens: DEPRECATED_TOKENS
});

// node_modules/antd/es/layout/Sider.js
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
};
var isNumeric = (val) => !Number.isNaN(Number.parseFloat(val)) && Number.isFinite(Number(val));
var SiderContext = React91.createContext({});
var generateId = /* @__PURE__ */ (() => {
  let i = 0;
  return (prefix = "") => {
    i += 1;
    return `${prefix}${i}`;
  };
})();
var Sider = React91.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    trigger,
    children,
    defaultCollapsed = false,
    theme = "dark",
    style = {},
    collapsible = false,
    reverseArrow = false,
    width = 200,
    collapsedWidth = 80,
    zeroWidthTriggerStyle,
    breakpoint,
    onCollapse,
    onBreakpoint,
    ...otherProps
  } = props;
  const {
    siderHook
  } = (0, import_react33.useContext)(LayoutContext);
  const [collapsed, setCollapsed] = (0, import_react33.useState)("collapsed" in props ? props.collapsed : defaultCollapsed);
  const [below, setBelow] = (0, import_react33.useState)(false);
  (0, import_react33.useEffect)(() => {
    if ("collapsed" in props) {
      setCollapsed(props.collapsed);
    }
  }, [props.collapsed]);
  const handleSetCollapsed = (value, type) => {
    if (!("collapsed" in props)) {
      setCollapsed(value);
    }
    onCollapse?.(value, type);
  };
  const {
    getPrefixCls,
    direction
  } = (0, import_react33.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
  const [hashId, cssVarCls] = sider_default(prefixCls);
  const responsiveHandlerRef = (0, import_react33.useRef)(null);
  responsiveHandlerRef.current = (mql) => {
    setBelow(mql.matches);
    onBreakpoint?.(mql.matches);
    if (collapsed !== mql.matches) {
      handleSetCollapsed(mql.matches, "responsive");
    }
  };
  (0, import_react33.useEffect)(() => {
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.current?.(mql2);
    }
    let mql;
    if (typeof window?.matchMedia !== "undefined" && breakpoint && breakpoint in dimensionMaxMap) {
      mql = window.matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
      if (typeof mql?.addEventListener === "function") {
        mql.addEventListener("change", responsiveHandler);
      }
      responsiveHandler(mql);
    }
    return () => {
      if (typeof mql?.removeEventListener === "function") {
        mql.removeEventListener("change", responsiveHandler);
      }
    };
  }, [breakpoint]);
  (0, import_react33.useEffect)(() => {
    const uniqueId = generateId("ant-sider-");
    siderHook.addSider(uniqueId);
    return () => siderHook.removeSider(uniqueId);
  }, []);
  const toggle = () => {
    handleSetCollapsed(!collapsed, "clickTrigger");
  };
  const divProps = omit(otherProps, ["collapsed"]);
  const rawWidth = collapsed ? collapsedWidth : width;
  const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
  const zeroWidthTrigger = Number.parseFloat(String(collapsedWidth || 0)) === 0 ? React91.createElement("span", {
    onClick: toggle,
    className: clsx(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
    style: zeroWidthTriggerStyle
  }, trigger || React91.createElement(BarsOutlined_default, null)) : null;
  const reverseIcon = direction === "rtl" === !reverseArrow;
  const iconObj = {
    expanded: reverseIcon ? React91.createElement(RightOutlined_default, null) : React91.createElement(LeftOutlined_default, null),
    collapsed: reverseIcon ? React91.createElement(LeftOutlined_default, null) : React91.createElement(RightOutlined_default, null)
  };
  const status = collapsed ? "collapsed" : "expanded";
  const defaultTrigger = iconObj[status];
  const triggerDom = trigger !== null ? zeroWidthTrigger || React91.createElement("div", {
    className: `${prefixCls}-trigger`,
    onClick: toggle,
    style: {
      width: siderWidth
    }
  }, trigger || defaultTrigger) : null;
  const divStyle = {
    ...style,
    flex: `0 0 ${siderWidth}`,
    maxWidth: siderWidth,
    // Fix width transition bug in IE11
    minWidth: siderWidth,
    // https://github.com/ant-design/ant-design/issues/6349
    width: siderWidth
  };
  const siderCls = clsx(prefixCls, `${prefixCls}-${theme}`, {
    [`${prefixCls}-collapsed`]: !!collapsed,
    [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
    [`${prefixCls}-below`]: !!below,
    [`${prefixCls}-zero-width`]: Number.parseFloat(siderWidth) === 0
  }, className, hashId, cssVarCls);
  const contextValue = React91.useMemo(() => ({
    siderCollapsed: collapsed
  }), [collapsed]);
  return React91.createElement(SiderContext.Provider, {
    value: contextValue
  }, React91.createElement("aside", {
    className: siderCls,
    ...divProps,
    style: divStyle,
    ref
  }, React91.createElement("div", {
    className: `${prefixCls}-children`
  }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null));
});
if (true) {
  Sider.displayName = "Sider";
}
var Sider_default = Sider;

// node_modules/antd/es/menu/menu.js
var React96 = __toESM(require_react());
var import_react35 = __toESM(require_react());

// node_modules/antd/es/menu/MenuContext.js
var import_react34 = __toESM(require_react());
var MenuContext2 = (0, import_react34.createContext)({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false,
  styles: null,
  classNames: null
});
var MenuContext_default = MenuContext2;

// node_modules/antd/es/menu/MenuDivider.js
var React92 = __toESM(require_react());
var MenuDivider = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    dashed,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React92.useContext(ConfigContext);
  const prefixCls = getPrefixCls("menu", customizePrefixCls);
  const classString = clsx({
    [`${prefixCls}-item-divider-dashed`]: !!dashed
  }, className);
  return React92.createElement(Divider, {
    className: classString,
    ...restProps
  });
};
var MenuDivider_default = MenuDivider;

// node_modules/antd/es/menu/MenuItem.js
var React93 = __toESM(require_react());
var MenuItem2 = (props) => {
  const {
    className,
    children,
    icon,
    title,
    danger,
    extra
  } = props;
  const {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed,
    styles,
    classNames
  } = React93.useContext(MenuContext_default);
  const renderItemChildren = (inlineCollapsed) => {
    const label = children?.[0];
    const wrapNode = React93.createElement("span", {
      className: clsx(`${prefixCls}-title-content`, firstLevel ? classNames.itemContent : classNames.subMenu.itemContent, {
        [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
      }),
      style: firstLevel ? styles.itemContent : styles.subMenu.itemContent
    }, children);
    if (!icon || React93.isValidElement(children) && children.type === "span") {
      if (children && inlineCollapsed && firstLevel && typeof label === "string") {
        return React93.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, label.charAt(0));
      }
    }
    return wrapNode;
  };
  const {
    siderCollapsed
  } = React93.useContext(SiderContext);
  let tooltipTitle = title;
  if (typeof title === "undefined") {
    tooltipTitle = firstLevel ? children : "";
  } else if (title === false) {
    tooltipTitle = "";
  }
  const tooltipProps = {
    title: tooltipTitle
  };
  if (!siderCollapsed && !isInlineCollapsed) {
    tooltipProps.title = null;
    tooltipProps.open = false;
  }
  const childrenLength = toArray(children).length;
  let returnNode = React93.createElement(MenuItem_default, {
    ...omit(props, ["title", "icon", "danger"]),
    className: clsx(firstLevel ? classNames.item : classNames.subMenu.item, {
      [`${prefixCls}-item-danger`]: danger,
      [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
    }, className),
    style: {
      ...firstLevel ? styles.item : styles.subMenu.item,
      ...props.style
    },
    title: typeof title === "string" ? title : void 0
  }, cloneElement(icon, (oriProps) => ({
    className: clsx(`${prefixCls}-item-icon`, firstLevel ? classNames.itemIcon : classNames.subMenu.itemIcon, oriProps.className),
    style: {
      ...firstLevel ? styles.itemIcon : styles.subMenu.itemIcon,
      ...oriProps.style
    }
  })), renderItemChildren(isInlineCollapsed));
  if (!disableMenuItemTitleTooltip) {
    returnNode = React93.createElement(tooltip_default, {
      ...tooltipProps,
      placement: direction === "rtl" ? "left" : "right",
      classNames: {
        root: `${prefixCls}-inline-collapsed-tooltip`
      }
    }, returnNode);
  }
  return returnNode;
};
var MenuItem_default2 = MenuItem2;

// node_modules/antd/es/menu/OverrideContext.js
var React94 = __toESM(require_react());
var OverrideContext = React94.createContext(null);
var OverrideProvider = React94.forwardRef((props, ref) => {
  const {
    children,
    ...restProps
  } = props;
  const override = React94.useContext(OverrideContext);
  const context = React94.useMemo(() => ({
    ...override,
    ...restProps
  }), [
    override,
    restProps.prefixCls,
    // restProps.expandIcon, Not mark as deps since this is a ReactNode
    restProps.mode,
    restProps.selectable,
    restProps.rootClassName
    // restProps.validator, Not mark as deps since this is a function
  ]);
  const canRef = supportNodeRef(children);
  const mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
  return React94.createElement(OverrideContext.Provider, {
    value: context
  }, React94.createElement(ContextIsolator_default, {
    space: true
  }, canRef ? React94.cloneElement(children, {
    ref: mergedRef
  }) : children));
});
var OverrideContext_default = OverrideContext;

// node_modules/antd/es/menu/style/horizontal.js
var getHorizontalStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    horizontalLineHeight,
    colorSplit,
    lineWidth,
    lineType,
    itemPaddingInline
  } = token;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: horizontalLineHeight,
      border: 0,
      borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: itemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
};
var horizontal_default = getHorizontalStyle;

// node_modules/antd/es/menu/style/rtl.js
var getRTLStyle = ({
  componentCls,
  menuArrowOffset,
  calc
}) => ({
  [`${componentCls}-rtl`]: {
    direction: "rtl"
  },
  [`${componentCls}-submenu-rtl`]: {
    transformOrigin: "100% 0"
  },
  // Vertical Arrow
  [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
    [`${componentCls}-submenu-arrow`]: {
      "&::before": {
        transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})`
      },
      "&::after": {
        transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})`
      }
    }
  }
});
var rtl_default = getRTLStyle;

// node_modules/antd/es/menu/style/theme.js
var accessibilityFocus = (token) => genFocusOutline(token);
var getThemeStyle = (token, themeSuffix) => {
  const {
    componentCls,
    itemColor,
    itemSelectedColor,
    subMenuItemSelectedColor,
    groupTitleColor,
    itemBg,
    subMenuItemBg,
    itemSelectedBg,
    activeBarHeight,
    activeBarWidth,
    activeBarBorderWidth,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    itemPaddingInline,
    motionDurationMid,
    itemHoverColor,
    lineType,
    colorSplit,
    // Disabled
    itemDisabledColor,
    // Danger
    dangerItemColor,
    dangerItemHoverColor,
    dangerItemSelectedColor,
    dangerItemActiveBg,
    dangerItemSelectedBg,
    // Bg
    popupBg,
    itemHoverBg,
    itemActiveBg,
    menuSubMenuBg,
    // Horizontal
    horizontalItemSelectedColor,
    horizontalItemSelectedBg,
    horizontalItemBorderRadius,
    horizontalItemHoverBg
  } = token;
  return {
    [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
      color: itemColor,
      background: itemBg,
      [`&${componentCls}-root:focus-visible`]: {
        ...accessibilityFocus(token)
      },
      // ======================== Item ========================
      [`${componentCls}-item`]: {
        "&-group-title, &-extra": {
          color: groupTitleColor
        }
      },
      [`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: {
        color: subMenuItemSelectedColor
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        color: itemColor,
        [`&:not(${componentCls}-item-disabled):focus-visible`]: {
          ...accessibilityFocus(token)
        }
      },
      // Disabled
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${itemDisabledColor} !important`
      },
      // Hover
      [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
        [`&:hover, > ${componentCls}-submenu-title:hover`]: {
          color: itemHoverColor
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        }
      },
      // Danger - only Item has
      [`${componentCls}-item-danger`]: {
        color: dangerItemColor,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: dangerItemHoverColor
          }
        },
        [`&${componentCls}-item:active`]: {
          background: dangerItemActiveBg
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: itemSelectedColor,
        // Danger
        [`&${componentCls}-item-danger`]: {
          color: dangerItemSelectedColor
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: itemSelectedBg,
        // Danger
        [`&${componentCls}-item-danger`]: {
          backgroundColor: dangerItemSelectedBg
        }
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      // =====  =======
      // dark popupBg rest  darkPopupBg
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      [`&${componentCls}-submenu-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      // =====  end =======
      // ====================== Horizontal ======================
      [`&${componentCls}-horizontal`]: {
        ...themeSuffix === "dark" ? {
          borderBottom: 0
        } : {},
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: activeBarBorderWidth,
          marginTop: token.calc(activeBarBorderWidth).mul(-1).equal(),
          marginBottom: 0,
          borderRadius: horizontalItemBorderRadius,
          "&::after": {
            position: "absolute",
            insetInline: itemPaddingInline,
            bottom: 0,
            borderBottom: `${unit(activeBarHeight)} solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            background: horizontalItemHoverBg,
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          },
          "&-selected": {
            color: horizontalItemSelectedColor,
            backgroundColor: horizontalItemSelectedBg,
            "&:hover": {
              backgroundColor: horizontalItemSelectedBg
            },
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          }
        }
      },
      // ================== Inline & Vertical ===================
      //
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}`
        }
      },
      // ======================== Inline ========================
      [`&${componentCls}-inline`]: {
        // Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: subMenuItemBg
        },
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          // Danger
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: dangerItemSelectedColor
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
};
var theme_default2 = getThemeStyle;

// node_modules/antd/es/menu/style/vertical.js
var getVerticalInlineStyle = (token) => {
  const {
    componentCls,
    itemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    itemMarginBlock,
    itemWidth,
    itemPaddingInline
  } = token;
  const paddingWithArrow = token.calc(menuArrowSize).add(padding).add(marginXS).equal();
  return {
    [`${componentCls}-item`]: {
      position: "relative",
      overflow: "hidden"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight),
      paddingInline: itemPaddingInline,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: itemMarginBlock,
      width: itemWidth
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight)
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
};
var getVerticalStyle = (token) => {
  const {
    componentCls,
    iconCls,
    itemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionEaseOut,
    paddingXL,
    itemMarginInline,
    fontSizeLG,
    motionDurationFast,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary,
    collapsedWidth,
    collapsedIconSize
  } = token;
  const inlineItemStyle = {
    height: itemHeight,
    lineHeight: unit(itemHeight),
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        "&-inline, &-vertical": {
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          },
          ...getVerticalInlineStyle(token)
        }
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: {
          ...getVerticalInlineStyle(token),
          boxShadow: boxShadowSecondary
        }
      }
    },
    // Vertical only
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${unit(token.calc(controlHeightLG).mul(2.5).equal())})`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        // >>>>> Item
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    // Inline Collapse Only
    {
      [`${componentCls}-inline-collapsed`]: {
        width: collapsedWidth,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${unit(token.calc(collapsedIconSize).div(2).equal())} - ${unit(itemMarginInline)})`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: collapsedIconSize,
            lineHeight: unit(itemHeight),
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: {
          ...textEllipsis,
          paddingInline: paddingXS
        }
      }
    }
  ];
};
var vertical_default = getVerticalStyle;

// node_modules/antd/es/menu/style/index.js
var genMenuItemStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    iconSize,
    iconMarginInlineEnd
  } = token;
  return {
    // >>>>> Item
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: iconSize,
        fontSize: iconSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: iconMarginInlineEnd,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: {
        ...resetIcon()
      },
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important",
        cursor: "not-allowed",
        pointerEvents: "none"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
};
var genSubMenuArrowStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token;
  return {
    [`${componentCls}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        // 
        "&::before, &::after": {
          position: "absolute",
          width: token.calc(menuArrowSize).mul(0.6).equal(),
          height: token.calc(menuArrowSize).mul(0.15).equal(),
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(${unit(token.calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})`
        }
      }
    }
  };
};
var getBaseStyle = (token) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    subMenuItemBorderRadius,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    groupTitleLineHeight,
    groupTitleFontSize
  } = token;
  return [
    // Misc
    {
      "": {
        [componentCls]: {
          ...clearFix(),
          // Hidden
          "&-hidden": {
            display: "none"
          }
        }
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: {
        ...resetComponent(token),
        ...clearFix(),
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize,
        lineHeight: 0,
        // Fix display inline-block gap
        listStyle: "none",
        outline: "none",
        // Magic cubic here but smooth transition
        transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token.itemBorderRadius
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${unit(paddingXS)} ${unit(padding)}`,
          fontSize: groupTitleFontSize,
          lineHeight: groupTitleLineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`,
          "&-with-extra": {
            display: "inline-flex",
            alignItems: "center",
            width: "100%"
          },
          // https://github.com/ant-design/ant-design/issues/41143
          [`> ${antCls}-typography-ellipsis-single-line`]: {
            display: "inline",
            verticalAlign: "unset"
          },
          [`${componentCls}-item-extra`]: {
            marginInlineStart: "auto",
            paddingInlineStart: token.padding
          }
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        },
        // Item
        ...genMenuItemStyle(token),
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${unit(token.calc(fontSize).mul(2).equal())} ${unit(padding)}`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            [`&${componentCls}-submenu`]: {
              background: "transparent"
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: 0,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            },
            [`> ${componentCls}`]: {
              borderRadius: borderRadiusLG,
              ...genMenuItemStyle(token),
              ...genSubMenuArrowStyle(token),
              [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                borderRadius: subMenuItemBorderRadius
              },
              [`${componentCls}-submenu-title::after`]: {
                transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
              }
            }
          },
          [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
            transformOrigin: "100% 0"
          },
          [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
            transformOrigin: "100% 100%"
          },
          [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
            transformOrigin: "0 100%"
          },
          [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
            transformOrigin: "0 0"
          },
          [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
            paddingInlineEnd: token.paddingXS
          },
          [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
            paddingInlineStart: token.paddingXS
          },
          [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
            paddingBottom: token.paddingXS
          },
          [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
            paddingTop: token.paddingXS
          }
        },
        ...genSubMenuArrowStyle(token),
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          // 
          "&::before": {
            transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(${unit(token.calc(menuArrowOffset).mul(-1).equal())})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          // 
          transform: `translateY(${unit(token.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
          "&::after": {
            transform: `rotate(-45deg) translateX(${unit(token.calc(menuArrowOffset).mul(-1).equal())})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})`
          }
        }
      }
    },
    // Integration with header element so menu items have the same height
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
};
var prepareComponentToken14 = (token) => {
  const {
    colorPrimary,
    colorError,
    colorTextDisabled,
    colorErrorBg,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorFillAlter,
    colorFillContent,
    lineWidth,
    lineWidthBold,
    controlItemBgActive,
    colorBgTextHover,
    controlHeightLG,
    lineHeight,
    colorBgElevated,
    marginXXS,
    padding,
    fontSize,
    controlHeightSM,
    fontSizeLG,
    colorTextLightSolid,
    colorErrorHover
  } = token;
  const activeBarWidth = token.activeBarWidth ?? 0;
  const activeBarBorderWidth = token.activeBarBorderWidth ?? lineWidth;
  const itemMarginInline = token.itemMarginInline ?? token.marginXXS;
  const colorTextDark = new FastColor(colorTextLightSolid).setA(0.65).toRgbString();
  return {
    dropdownWidth: 160,
    zIndexPopup: token.zIndexPopupBase + 50,
    radiusItem: token.borderRadiusLG,
    itemBorderRadius: token.borderRadiusLG,
    radiusSubMenuItem: token.borderRadiusSM,
    subMenuItemBorderRadius: token.borderRadiusSM,
    colorItemText: colorText,
    itemColor: colorText,
    colorItemTextHover: colorText,
    itemHoverColor: colorText,
    colorItemTextHoverHorizontal: colorPrimary,
    horizontalItemHoverColor: colorPrimary,
    colorGroupTitle: colorTextDescription,
    groupTitleColor: colorTextDescription,
    colorItemTextSelected: colorPrimary,
    itemSelectedColor: colorPrimary,
    subMenuItemSelectedColor: colorPrimary,
    colorItemTextSelectedHorizontal: colorPrimary,
    horizontalItemSelectedColor: colorPrimary,
    colorItemBg: colorBgContainer,
    itemBg: colorBgContainer,
    colorItemBgHover: colorBgTextHover,
    itemHoverBg: colorBgTextHover,
    colorItemBgActive: colorFillContent,
    itemActiveBg: controlItemBgActive,
    colorSubItemBg: colorFillAlter,
    subMenuItemBg: colorFillAlter,
    colorItemBgSelected: controlItemBgActive,
    itemSelectedBg: controlItemBgActive,
    colorItemBgSelectedHorizontal: "transparent",
    horizontalItemSelectedBg: "transparent",
    colorActiveBarWidth: 0,
    activeBarWidth,
    colorActiveBarHeight: lineWidthBold,
    activeBarHeight: lineWidthBold,
    colorActiveBarBorderSize: lineWidth,
    activeBarBorderWidth,
    // Disabled
    colorItemTextDisabled: colorTextDisabled,
    itemDisabledColor: colorTextDisabled,
    // Danger
    colorDangerItemText: colorError,
    dangerItemColor: colorError,
    colorDangerItemTextHover: colorError,
    dangerItemHoverColor: colorError,
    colorDangerItemTextSelected: colorError,
    dangerItemSelectedColor: colorError,
    colorDangerItemBgActive: colorErrorBg,
    dangerItemActiveBg: colorErrorBg,
    colorDangerItemBgSelected: colorErrorBg,
    dangerItemSelectedBg: colorErrorBg,
    itemMarginInline,
    horizontalItemBorderRadius: 0,
    horizontalItemHoverBg: "transparent",
    itemHeight: controlHeightLG,
    groupTitleLineHeight: lineHeight,
    collapsedWidth: controlHeightLG * 2,
    popupBg: colorBgElevated,
    itemMarginBlock: marginXXS,
    itemPaddingInline: padding,
    horizontalLineHeight: `${controlHeightLG * 1.15}px`,
    iconSize: fontSize,
    iconMarginInlineEnd: controlHeightSM - fontSize,
    collapsedIconSize: fontSizeLG,
    groupTitleFontSize: fontSize,
    // Disabled
    darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(0.25).toRgbString(),
    // Dark
    darkItemColor: colorTextDark,
    darkDangerItemColor: colorError,
    darkItemBg: "#001529",
    darkPopupBg: "#001529",
    darkSubMenuItemBg: "#000c17",
    darkItemSelectedColor: colorTextLightSolid,
    darkItemSelectedBg: colorPrimary,
    darkDangerItemSelectedBg: colorError,
    darkItemHoverBg: "transparent",
    darkGroupTitleColor: colorTextDark,
    darkItemHoverColor: colorTextLightSolid,
    darkDangerItemHoverColor: colorErrorHover,
    darkDangerItemSelectedColor: colorTextLightSolid,
    darkDangerItemActiveBg: colorError,
    // internal
    itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
  };
};
var style_default17 = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
  const useStyle = genStyleHooks("Menu", (token) => {
    const {
      colorBgElevated,
      controlHeightLG,
      fontSize,
      darkItemColor,
      darkDangerItemColor,
      darkItemBg,
      darkSubMenuItemBg,
      darkItemSelectedColor,
      darkItemSelectedBg,
      darkDangerItemSelectedBg,
      darkItemHoverBg,
      darkGroupTitleColor,
      darkItemHoverColor,
      darkItemDisabledColor,
      darkDangerItemHoverColor,
      darkDangerItemSelectedColor,
      darkDangerItemActiveBg,
      popupBg,
      darkPopupBg
    } = token;
    const menuArrowSize = token.calc(fontSize).div(7).mul(5).equal();
    const menuToken = merge(token, {
      menuArrowSize,
      menuHorizontalHeight: token.calc(controlHeightLG).mul(1.15).equal(),
      menuArrowOffset: token.calc(menuArrowSize).mul(0.25).equal(),
      menuSubMenuBg: colorBgElevated,
      calc: token.calc,
      popupBg
    });
    const menuDarkToken = merge(menuToken, {
      itemColor: darkItemColor,
      itemHoverColor: darkItemHoverColor,
      groupTitleColor: darkGroupTitleColor,
      itemSelectedColor: darkItemSelectedColor,
      subMenuItemSelectedColor: darkItemSelectedColor,
      itemBg: darkItemBg,
      popupBg: darkPopupBg,
      subMenuItemBg: darkSubMenuItemBg,
      itemActiveBg: "transparent",
      itemSelectedBg: darkItemSelectedBg,
      activeBarHeight: 0,
      activeBarBorderWidth: 0,
      itemHoverBg: darkItemHoverBg,
      // Disabled
      itemDisabledColor: darkItemDisabledColor,
      // Danger
      dangerItemColor: darkDangerItemColor,
      dangerItemHoverColor: darkDangerItemHoverColor,
      dangerItemSelectedColor: darkDangerItemSelectedColor,
      dangerItemActiveBg: darkDangerItemActiveBg,
      dangerItemSelectedBg: darkDangerItemSelectedBg,
      menuSubMenuBg: darkSubMenuItemBg,
      // Horizontal
      horizontalItemSelectedColor: darkItemSelectedColor,
      horizontalItemSelectedBg: darkItemSelectedBg
    });
    return [
      // Basic
      getBaseStyle(menuToken),
      // Horizontal
      horizontal_default(menuToken),
      // Hard code for some light style
      // Vertical
      vertical_default(menuToken),
      // Hard code for some light style
      // Theme
      theme_default2(menuToken, "light"),
      theme_default2(menuDarkToken, "dark"),
      // RTL
      rtl_default(menuToken),
      // Motion
      collapse_default(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, prepareComponentToken14, {
    deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
    // Dropdown will handle menu style self. We do not need to handle this.
    injectStyle,
    unitless: {
      groupTitleLineHeight: true
    }
  });
  return useStyle(prefixCls, rootCls);
};

// node_modules/antd/es/menu/SubMenu.js
var React95 = __toESM(require_react());
var SubMenu2 = (props) => {
  const {
    popupClassName,
    icon,
    title,
    theme: customTheme
  } = props;
  const context = React95.useContext(MenuContext_default);
  const {
    prefixCls,
    inlineCollapsed,
    theme: contextTheme,
    classNames,
    styles
  } = context;
  const parentPath = useFullPath();
  let titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? React95.createElement("div", {
      className: `${prefixCls}-inline-collapsed-noicon`
    }, title.charAt(0)) : React95.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title);
  } else {
    const titleIsSpan = React95.isValidElement(title) && title.type === "span";
    titleNode = React95.createElement(React95.Fragment, null, cloneElement(icon, (oriProps) => ({
      className: clsx(oriProps.className, `${prefixCls}-item-icon`, classNames.itemIcon),
      style: {
        ...oriProps.style,
        ...styles.itemIcon
      }
    })), titleIsSpan ? title : React95.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title));
  }
  const contextValue = React95.useMemo(() => ({
    ...context,
    firstLevel: false
  }), [context]);
  const [zIndex] = useZIndex("Menu");
  return React95.createElement(MenuContext_default.Provider, {
    value: contextValue
  }, React95.createElement(SubMenu_default, {
    ...omit(props, ["icon"]),
    title: titleNode,
    classNames: {
      list: classNames.subMenu.list,
      listTitle: classNames.subMenu.itemTitle
    },
    styles: {
      list: styles.subMenu.list,
      listTitle: styles.subMenu.itemTitle
    },
    popupClassName: clsx(prefixCls, popupClassName, classNames.popup.root, `${prefixCls}-${customTheme || contextTheme}`),
    popupStyle: {
      zIndex,
      // fix: https://github.com/ant-design/ant-design/issues/47826#issuecomment-2360737237
      ...props.popupStyle,
      ...styles.popup.root
    }
  }));
};
var SubMenu_default2 = SubMenu2;

// node_modules/antd/es/menu/menu.js
function isEmptyIcon(icon) {
  return icon === null || icon === false;
}
var MENU_COMPONENTS = {
  item: MenuItem_default2,
  submenu: SubMenu_default2,
  divider: MenuDivider_default
};
var InternalMenu = (0, import_react35.forwardRef)((props, ref) => {
  const override = React96.useContext(OverrideContext_default);
  const overrideObj = override || {};
  const {
    prefixCls: customizePrefixCls,
    className,
    style,
    theme = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    rootClassName,
    mode,
    selectable,
    onClick,
    overflowedIndicatorPopupClassName,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    menu
  } = React96.useContext(ConfigContext);
  const {
    getPrefixCls,
    getPopupContainer,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("menu");
  const rootPrefixCls = getPrefixCls();
  const passedProps = omit(restProps, ["collapsedWidth"]);
  if (true) {
    const warning2 = devUseWarning("Menu");
    true ? warning2(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline.") : void 0;
    warning2.deprecated("items" in props && !props.children, "children", "items");
  }
  overrideObj.validator?.({
    mode
  });
  const onItemClick = useEvent_default((...args) => {
    onClick?.(...args);
    overrideObj.onClick?.();
  });
  const mergedMode = overrideObj.mode || mode;
  const mergedSelectable = selectable ?? overrideObj.selectable;
  const mergedInlineCollapsed = inlineCollapsed ?? siderCollapsed;
  const mergedProps = {
    ...props,
    mode: mergedMode,
    inlineCollapsed: mergedInlineCollapsed,
    selectable: mergedSelectable,
    theme
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    },
    subMenu: {
      _default: "item"
    }
  });
  const defaultMotions = {
    horizontal: {
      motionName: `${rootPrefixCls}-slide-up`
    },
    inline: motion_default(rootPrefixCls),
    other: {
      motionName: `${rootPrefixCls}-zoom-big`
    }
  };
  const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default17(prefixCls, rootCls, !override);
  const menuClassName = clsx(`${prefixCls}-${theme}`, contextClassName, className);
  const mergedExpandIcon = React96.useMemo(() => {
    if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
      return expandIcon || null;
    }
    if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
      return overrideObj.expandIcon || null;
    }
    if (typeof menu?.expandIcon === "function" || isEmptyIcon(menu?.expandIcon)) {
      return menu?.expandIcon || null;
    }
    const mergedIcon = expandIcon ?? overrideObj?.expandIcon ?? menu?.expandIcon;
    return cloneElement(mergedIcon, {
      className: clsx(`${prefixCls}-submenu-expand-icon`, React96.isValidElement(mergedIcon) ? mergedIcon.props?.className : void 0)
    });
  }, [expandIcon, overrideObj?.expandIcon, menu?.expandIcon, prefixCls]);
  const contextValue = React96.useMemo(() => ({
    prefixCls,
    inlineCollapsed: mergedInlineCollapsed || false,
    direction,
    firstLevel: true,
    theme,
    mode: mergedMode,
    disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme, mergedMode, mergedClassNames, mergedStyles]);
  return React96.createElement(OverrideContext_default.Provider, {
    value: null
  }, React96.createElement(MenuContext_default.Provider, {
    value: contextValue
  }, React96.createElement(es_default10, {
    getPopupContainer,
    overflowedIndicator: React96.createElement(EllipsisOutlined_default, null),
    overflowedIndicatorPopupClassName: clsx(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
    classNames: {
      list: mergedClassNames.list,
      listTitle: mergedClassNames.itemTitle
    },
    styles: {
      list: mergedStyles.list,
      listTitle: mergedStyles.itemTitle
    },
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick,
    ...passedProps,
    inlineCollapsed: mergedInlineCollapsed,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    className: menuClassName,
    prefixCls,
    direction,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref,
    rootClassName: clsx(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls, mergedClassNames.root),
    _internalComponents: MENU_COMPONENTS
  })));
});
var menu_default = InternalMenu;

// node_modules/antd/es/menu/index.js
var Menu2 = (0, import_react36.forwardRef)((props, ref) => {
  const menuRef = (0, import_react36.useRef)(null);
  const context = React97.useContext(SiderContext);
  (0, import_react36.useImperativeHandle)(ref, () => ({
    menu: menuRef.current,
    focus: (options) => {
      menuRef.current?.focus(options);
    }
  }));
  return React97.createElement(menu_default, {
    ref: menuRef,
    ...props,
    ...context
  });
});
Menu2.Item = MenuItem_default2;
Menu2.SubMenu = SubMenu_default2;
Menu2.Divider = MenuDivider_default;
Menu2.ItemGroup = MenuItemGroup_default;
if (true) {
  Menu2.displayName = "Menu";
}
var menu_default2 = Menu2;

// node_modules/antd/es/dropdown/style/status.js
var genStatusStyle = (token) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
};
var status_default = genStatusStyle;

// node_modules/antd/es/dropdown/style/index.js
var genBaseStyle5 = (token) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    paddingBlock,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token;
  return [
    {
      [componentCls]: {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: token.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        // Makes vertical dropdowns have a scrollbar once they become taller than the viewport.
        "&-menu-vertical": {
          maxHeight: "100vh",
          overflowY: "auto"
        },
        [`&-trigger${antCls}-btn`]: {
          [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          }
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      }
    },
    // =============================================================
    // ==                        Arrow style                      ==
    // =============================================================
    getArrowStyle(token, colorBgElevated, {
      arrowPlacement: {
        top: true,
        bottom: true
      }
    }),
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        ...resetComponent(token),
        [menuCls]: {
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token.borderRadiusLG,
          outline: "none",
          boxShadow: token.boxShadowSecondary,
          ...genFocusStyle(token),
          "&:empty": {
            padding: 0,
            boxShadow: "none"
          },
          [`${menuCls}-item-group-title`]: {
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          // ======================= Item Content =======================
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token.marginXS,
            fontSize: token.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "&-with-extra": {
              display: "inline-flex",
              alignItems: "center",
              width: "100%"
            },
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            },
            [`${menuCls}-item-extra`]: {
              paddingInlineStart: token.padding,
              marginInlineStart: "auto",
              fontSize: token.fontSizeSM,
              color: token.colorTextDescription
            }
          },
          // =========================== Item ===========================
          [`${menuCls}-item, ${menuCls}-submenu-title`]: {
            display: "flex",
            margin: 0,
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token.borderRadiusSM,
            "&:hover, &-active": {
              backgroundColor: token.controlItemBgHover
            },
            ...genFocusStyle(token),
            "&-selected": {
              color: token.colorPrimary,
              backgroundColor: token.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              // By design
              margin: `${unit(token.marginXXS)} 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token.colorIcon,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          },
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${unit(token.marginXS)}`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: token.calc(controlPaddingHorizontal).add(token.fontSizeSM).equal()
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token.colorPrimary
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token, "slide-up"), initSlideMotion(token, "slide-down"), initMoveMotion(token, "move-up"), initMoveMotion(token, "move-down"), initZoomMotion(token, "zoom-big")]
  ];
};
var prepareComponentToken15 = (token) => ({
  zIndexPopup: token.zIndexPopupBase + 50,
  paddingBlock: (token.controlHeight - token.fontSize * token.lineHeight) / 2,
  ...getArrowOffsetToken({
    contentRadius: token.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token)
});
var style_default18 = genStyleHooks("Dropdown", (token) => {
  const {
    marginXXS,
    sizePopupArrow,
    paddingXXS,
    componentCls
  } = token;
  const dropdownToken = merge(token, {
    menuCls: `${componentCls}-menu`,
    dropdownArrowDistance: token.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle5(dropdownToken), status_default(dropdownToken)];
}, prepareComponentToken15, {
  resetStyle: false
});

// node_modules/antd/es/dropdown/dropdown.js
var Dropdown2 = (props) => {
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    popupRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    overlayStyle,
    open: open3,
    onOpenChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    placement = "",
    transitionName,
    classNames,
    styles,
    destroyPopupOnHide,
    destroyOnHidden
  } = props;
  const {
    getPrefixCls,
    direction,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("dropdown");
  const mergedProps = {
    ...props,
    mouseEnterDelay,
    mouseLeaveDelay,
    autoAdjustOverflow: autoAdjustOverflow3
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedRootStyles = {
    ...contextStyle,
    ...overlayStyle,
    ...mergedStyles.root
  };
  const mergedPopupRender = popupRender || dropdownRender;
  const warning2 = devUseWarning("Dropdown");
  if (true) {
    const deprecatedProps = {
      dropdownRender: "popupRender",
      destroyPopupOnHide: "destroyOnHidden",
      overlayClassName: "classNames.root",
      overlayStyle: "styles.root"
    };
    Object.entries(deprecatedProps).forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (placement.includes("Center")) {
      warning2.deprecated(!placement.includes("Center"), `placement: ${placement}`, `placement: ${placement.slice(0, placement.indexOf("Center"))}`);
    }
  }
  const memoTransitionName = React98.useMemo(() => {
    const rootPrefixCls = getPrefixCls();
    if (transitionName !== void 0) {
      return transitionName;
    }
    if (placement.includes("top")) {
      return `${rootPrefixCls}-slide-down`;
    }
    return `${rootPrefixCls}-slide-up`;
  }, [getPrefixCls, placement, transitionName]);
  const memoPlacement = React98.useMemo(() => {
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      return placement.slice(0, placement.indexOf("Center"));
    }
    return placement;
  }, [placement, direction]);
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default18(prefixCls, rootCls);
  const [, token] = useToken();
  const child = React98.Children.only(isPrimitive_default(children) ? React98.createElement("span", null, children) : children);
  const popupTrigger = cloneElement(child, {
    className: clsx(`${prefixCls}-trigger`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, child.props.className),
    disabled: child.props.disabled ?? disabled
  });
  const triggerActions = disabled ? [] : trigger;
  const alignPoint = !!triggerActions?.includes("contextMenu");
  const [mergedOpen, setOpen] = useControlledState(false, open3);
  const onInnerOpenChange = useEvent_default((nextOpen) => {
    onOpenChange?.(nextOpen, {
      source: "trigger"
    });
    setOpen(nextOpen);
  });
  const overlayClassNameCustomized = clsx(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow3,
    offset: token.marginXXS,
    arrowWidth: arrow ? token.sizePopupArrow : 0,
    borderRadius: token.borderRadius
  });
  const onMenuClick = useEvent_default(() => {
    if (menu?.selectable && menu?.multiple) {
      return;
    }
    onOpenChange?.(false, {
      source: "menu"
    });
    setOpen(false);
  });
  const renderOverlay = () => {
    const menuClassNames = omit(mergedClassNames, ["root"]);
    const menuStyles = omit(mergedStyles, ["root"]);
    let overlayNode;
    if (menu?.items) {
      overlayNode = React98.createElement(menu_default2, {
        ...menu,
        classNames: {
          ...menuClassNames,
          subMenu: {
            ...menuClassNames
          }
        },
        styles: {
          ...menuStyles,
          subMenu: {
            ...menuStyles
          }
        }
      });
    }
    if (mergedPopupRender) {
      overlayNode = mergedPopupRender(overlayNode);
    }
    overlayNode = React98.Children.only(typeof overlayNode === "string" ? React98.createElement("span", null, overlayNode) : overlayNode);
    return React98.createElement(OverrideProvider, {
      prefixCls: `${prefixCls}-menu`,
      rootClassName: clsx(cssVarCls, rootCls),
      expandIcon: React98.createElement("span", {
        className: `${prefixCls}-menu-submenu-arrow`
      }, direction === "rtl" ? React98.createElement(LeftOutlined_default, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      }) : React98.createElement(RightOutlined_default, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      })),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: ({
        mode
      }) => {
        true ? warning2(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`) : void 0;
      }
    }, overlayNode);
  };
  const [zIndex, contextZIndex] = useZIndex("Dropdown", mergedRootStyles.zIndex);
  let renderNode = React98.createElement(es_default9, {
    alignPoint,
    ...omit(props, ["rootClassName", "onOpenChange"]),
    mouseEnterDelay,
    mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: memoTransitionName,
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: memoPlacement,
    onVisibleChange: onInnerOpenChange,
    overlayStyle: {
      ...mergedRootStyles,
      zIndex
    },
    autoDestroy: destroyOnHidden ?? destroyPopupOnHide
  }, popupTrigger);
  if (zIndex) {
    renderNode = React98.createElement(zindexContext_default.Provider, {
      value: contextZIndex
    }, renderNode);
  }
  return renderNode;
};
var PurePanel4 = PurePanel_default(Dropdown2, "align", void 0, "dropdown", (prefixCls) => prefixCls);
var WrapPurePanel = (props) => React98.createElement(PurePanel4, {
  ...props
}, React98.createElement("span", null));
Dropdown2._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
if (true) {
  Dropdown2.displayName = "Dropdown";
}
var dropdown_default = Dropdown2;

// node_modules/antd/es/breadcrumb/BreadcrumbSeparator.js
var React99 = __toESM(require_react());
var BreadcrumbSeparator = ({
  children
}) => {
  const {
    getPrefixCls
  } = React99.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb");
  const breadcrumbContext = React99.useContext(BreadcrumbContext_default);
  const {
    classNames: mergedClassNames,
    styles: mergedStyles
  } = breadcrumbContext;
  return React99.createElement("li", {
    className: clsx(`${prefixCls}-separator`, mergedClassNames?.separator),
    style: mergedStyles?.separator,
    "aria-hidden": "true"
  }, children === "" ? children : children || "/");
};
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator_default = BreadcrumbSeparator;

// node_modules/antd/es/breadcrumb/useItemRender.js
var React100 = __toESM(require_react());
function getBreadcrumbName(route, params) {
  if (!isNonNullable_default(route.title)) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
}
function renderItem(prefixCls, item, children, href) {
  if (!isNonNullable_default(children)) {
    return null;
  }
  const {
    className,
    onClick,
    ...restItem
  } = item;
  const passedProps = {
    ...pickAttrs(restItem, {
      data: true,
      aria: true
    }),
    onClick
  };
  if (href !== void 0) {
    return React100.createElement("a", {
      ...passedProps,
      className: clsx(`${prefixCls}-link`, className),
      href
    }, children);
  }
  return React100.createElement("span", {
    ...passedProps,
    className: clsx(`${prefixCls}-link`, className)
  }, children);
}
function useItemRender(prefixCls, itemRender) {
  const mergedItemRender = (item, params, routes, path2, href) => {
    if (itemRender) {
      return itemRender(item, params, routes, path2);
    }
    const name = getBreadcrumbName(item, params);
    return renderItem(prefixCls, item, name, href);
  };
  return mergedItemRender;
}

// node_modules/antd/es/breadcrumb/BreadcrumbItem.js
var InternalBreadcrumbItem = (props) => {
  const {
    prefixCls,
    separator = "/",
    children,
    menu,
    dropdownProps,
    href
  } = props;
  const breadcrumbContext = React101.useContext(BreadcrumbContext_default);
  const {
    classNames: mergedClassNames,
    styles: mergedStyles
  } = breadcrumbContext;
  const renderBreadcrumbNode = (breadcrumbItem) => {
    if (menu) {
      const mergeDropDownProps = {
        ...dropdownProps
      };
      if (menu) {
        const {
          items,
          ...menuProps
        } = menu || {};
        mergeDropDownProps.menu = {
          ...menuProps,
          items: items?.map(({
            key,
            title,
            label,
            path: path2,
            ...itemProps
          }, index2) => {
            let mergedLabel = label ?? title;
            if (path2) {
              mergedLabel = React101.createElement("a", {
                href: `${href}${path2}`
              }, mergedLabel);
            }
            return {
              ...itemProps,
              key: key ?? index2,
              label: mergedLabel
            };
          })
        };
      }
      return React101.createElement(dropdown_default, {
        placement: "bottom",
        ...mergeDropDownProps
      }, React101.createElement("span", {
        className: `${prefixCls}-overlay-link`
      }, breadcrumbItem, React101.createElement(DownOutlined_default, null)));
    }
    return breadcrumbItem;
  };
  const link = renderBreadcrumbNode(children);
  if (isNonNullable_default(link)) {
    return React101.createElement(React101.Fragment, null, React101.createElement("li", {
      className: mergedClassNames?.item,
      style: mergedStyles?.item
    }, link), separator && React101.createElement(BreadcrumbSeparator_default, null, separator));
  }
  return null;
};
var BreadcrumbItem = (props) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    href,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React101.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  return React101.createElement(InternalBreadcrumbItem, {
    ...restProps,
    prefixCls
  }, renderItem(prefixCls, restProps, children, href));
};
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/antd/es/breadcrumb/style/index.js
var genBreadcrumbStyle = (token) => {
  const {
    componentCls,
    iconCls,
    calc
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      color: token.itemColor,
      fontSize: token.fontSize,
      [iconCls]: {
        fontSize: token.iconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`a${componentCls}-link, ${componentCls}-link a`]: {
        color: token.linkColor,
        transition: `color ${token.motionDurationMid}`,
        padding: `0 ${unit(token.paddingXXS)}`,
        borderRadius: token.borderRadiusSM,
        height: token.fontHeight,
        display: "inline-block",
        marginInline: calc(token.marginXXS).mul(-1).equal(),
        "&:hover": {
          color: token.linkHoverColor,
          backgroundColor: token.colorBgTextHover
        },
        ...genFocusStyle(token)
      },
      "li:last-child": {
        color: token.lastItemColor
      },
      [`${componentCls}-separator`]: {
        marginInline: token.separatorMargin,
        color: token.separatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token.borderRadiusSM,
        height: token.fontHeight,
        display: "inline-block",
        padding: `0 ${unit(token.paddingXXS)}`,
        marginInline: calc(token.marginXXS).mul(-1).equal(),
        [`> ${iconCls}`]: {
          marginInlineStart: token.marginXXS,
          fontSize: token.fontSizeIcon
        },
        "&:hover": {
          color: token.linkHoverColor,
          backgroundColor: token.colorBgTextHover,
          a: {
            color: token.linkHoverColor
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${token.componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken16 = (token) => ({
  itemColor: token.colorTextDescription,
  lastItemColor: token.colorText,
  iconFontSize: token.fontSize,
  linkColor: token.colorTextDescription,
  linkHoverColor: token.colorText,
  separatorColor: token.colorTextDescription,
  separatorMargin: token.marginXS
});
var style_default19 = genStyleHooks("Breadcrumb", (token) => {
  const breadcrumbToken = merge(token, {});
  return genBreadcrumbStyle(breadcrumbToken);
}, prepareComponentToken16);

// node_modules/antd/es/breadcrumb/useItems.js
var import_react37 = __toESM(require_react());
function route2item(route) {
  const {
    breadcrumbName,
    children,
    ...rest
  } = route;
  const clone = {
    title: breadcrumbName,
    ...rest
  };
  if (children) {
    clone.menu = {
      items: children.map(({
        breadcrumbName: itemBreadcrumbName,
        ...itemProps
      }) => ({
        ...itemProps,
        title: itemBreadcrumbName
      }))
    };
  }
  return clone;
}
function useItems(items, routes) {
  return (0, import_react37.useMemo)(() => {
    if (items) {
      return items;
    }
    if (routes) {
      return routes.map(route2item);
    }
    return null;
  }, [items, routes]);
}

// node_modules/antd/es/breadcrumb/Breadcrumb.js
var getPath = (params, path2) => {
  if (path2 === void 0) {
    return path2;
  }
  let mergedPath = (path2 || "").replace(/^\//, "");
  Object.keys(params).forEach((key) => {
    mergedPath = mergedPath.replace(`:${key}`, params[key]);
  });
  return mergedPath;
};
var Breadcrumb = (props) => {
  const {
    prefixCls: customizePrefixCls,
    separator,
    style,
    className,
    rootClassName,
    routes: legacyRoutes,
    items,
    children,
    itemRender,
    params = {},
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    separator: contextSeparator
  } = useComponentConfig("breadcrumb");
  const mergedSeparator = separator ?? contextSeparator ?? "/";
  let crumbs;
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  const [hashId, cssVarCls] = style_default19(prefixCls);
  const mergedItems = useItems(items, legacyRoutes);
  const mergedProps = React102.useMemo(() => {
    return {
      ...props,
      separator: mergedSeparator
    };
  }, [props, mergedSeparator]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning2 = devUseWarning("Breadcrumb");
    warning2.deprecated(!legacyRoutes, "routes", "items");
    if (!mergedItems || mergedItems.length === 0) {
      const childList = toArray(children);
      warning2.deprecated(childList.length === 0, "Breadcrumb.Item and Breadcrumb.Separator", "items");
      childList.forEach((element) => {
        if (element) {
          true ? warning2(element.type && (element.type.__ANT_BREADCRUMB_ITEM === true || element.type.__ANT_BREADCRUMB_SEPARATOR === true), "usage", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children") : void 0;
        }
      });
    }
  }
  const mergedItemRender = useItemRender(prefixCls, itemRender);
  if (mergedItems && mergedItems.length > 0) {
    const paths = [];
    const itemRenderRoutes = items || legacyRoutes;
    crumbs = mergedItems.map((item, index2) => {
      const {
        path: path2,
        key,
        type,
        menu,
        onClick,
        className: itemClassName,
        style: style2,
        separator: itemSeparator,
        dropdownProps
      } = item;
      const mergedPath = getPath(params, path2);
      if (mergedPath !== void 0) {
        paths.push(mergedPath);
      }
      const mergedKey = key ?? index2;
      if (type === "separator") {
        return React102.createElement(BreadcrumbSeparator_default, {
          key: mergedKey
        }, itemSeparator);
      }
      const itemProps = {};
      const isLastItem = index2 === mergedItems.length - 1;
      if (menu) {
        itemProps.menu = menu;
      }
      let {
        href
      } = item;
      if (paths.length && mergedPath !== void 0) {
        href = `#/${paths.join("/")}`;
      }
      return React102.createElement(InternalBreadcrumbItem, {
        key: mergedKey,
        ...itemProps,
        ...pickAttrs(item, {
          data: true,
          aria: true
        }),
        className: itemClassName,
        style: style2,
        dropdownProps,
        href,
        separator: isLastItem ? "" : mergedSeparator,
        onClick,
        prefixCls
      }, mergedItemRender(item, params, itemRenderRoutes, paths, href));
    });
  } else if (children) {
    const childrenLength = toArray(children).length;
    crumbs = toArray(children).map((element, index2) => {
      if (!element) {
        return element;
      }
      const isLastItem = index2 === childrenLength - 1;
      return cloneElement(element, {
        separator: isLastItem ? "" : mergedSeparator,
        // eslint-disable-next-line react/no-array-index-key
        key: index2
      });
    });
  }
  const breadcrumbClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const memoizedValue = React102.useMemo(() => ({
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [mergedClassNames, mergedStyles]);
  return React102.createElement(BreadcrumbContext_default.Provider, {
    value: memoizedValue
  }, React102.createElement("nav", {
    className: breadcrumbClassName,
    style: mergedStyle,
    ...restProps
  }, React102.createElement("ol", null, crumbs)));
};
Breadcrumb.Item = BreadcrumbItem_default;
Breadcrumb.Separator = BreadcrumbSeparator_default;
if (true) {
  Breadcrumb.displayName = "Breadcrumb";
}
var Breadcrumb_default = Breadcrumb;

// node_modules/antd/es/breadcrumb/index.js
var breadcrumb_default = Breadcrumb_default;

// node_modules/antd/es/button/index.js
var button_default = Button_default;

// node_modules/@rc-component/picker/es/generate/dayjs.js
var import_dayjs = __toESM(require_dayjs_min());
var import_weekday = __toESM(require_weekday());
var import_localeData = __toESM(require_localeData());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_weekYear = __toESM(require_weekYear());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_customParseFormat = __toESM(require_customParseFormat());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekday.default);
import_dayjs.default.extend(import_localeData.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend(function(o3, c) {
  var proto = c.prototype;
  var oldFormat = proto.format;
  proto.format = function f(formatStr) {
    var str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
var localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  // todo: dayjs has no fr_BE locale, use fr at present
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = function parseLocale2(locale2) {
  var mapLocale = localeMap[locale2];
  return mapLocale || locale2.split("_")[0];
};
var parseNoMatchNotice = function parseNoMatchNotice2() {
};
var generateConfig = {
  // get
  getNow: function getNow() {
    var now2 = (0, import_dayjs.default)();
    if (typeof now2.tz === "function") {
      return now2.tz();
    }
    return now2;
  },
  getFixedDate: function getFixedDate(string) {
    return (0, import_dayjs.default)(string, ["YYYY-M-DD", "YYYY-MM-DD"]);
  },
  getEndDate: function getEndDate(date) {
    return date.endOf("month");
  },
  getWeekDay: function getWeekDay(date) {
    var clone = date.locale("en");
    return clone.weekday() + clone.localeData().firstDayOfWeek();
  },
  getYear: function getYear(date) {
    return date.year();
  },
  getMonth: function getMonth(date) {
    return date.month();
  },
  getDate: function getDate(date) {
    return date.date();
  },
  getHour: function getHour(date) {
    return date.hour();
  },
  getMinute: function getMinute(date) {
    return date.minute();
  },
  getSecond: function getSecond(date) {
    return date.second();
  },
  getMillisecond: function getMillisecond(date) {
    return date.millisecond();
  },
  // set
  addYear: function addYear(date, diff) {
    return date.add(diff, "year");
  },
  addMonth: function addMonth(date, diff) {
    return date.add(diff, "month");
  },
  addDate: function addDate(date, diff) {
    return date.add(diff, "day");
  },
  setYear: function setYear(date, year) {
    return date.year(year);
  },
  setMonth: function setMonth(date, month) {
    return date.month(month);
  },
  setDate: function setDate(date, num) {
    return date.date(num);
  },
  setHour: function setHour(date, hour) {
    return date.hour(hour);
  },
  setMinute: function setMinute(date, minute) {
    return date.minute(minute);
  },
  setSecond: function setSecond(date, second) {
    return date.second(second);
  },
  setMillisecond: function setMillisecond(date, milliseconds) {
    return date.millisecond(milliseconds);
  },
  // Compare
  isAfter: function isAfter(date1, date2) {
    return date1.isAfter(date2);
  },
  isValidate: function isValidate(date) {
    return date.isValid();
  },
  locale: {
    getWeekFirstDay: function getWeekFirstDay(locale2) {
      return (0, import_dayjs.default)().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
    },
    getWeekFirstDate: function getWeekFirstDate(locale2, date) {
      return date.locale(parseLocale(locale2)).weekday(0);
    },
    getWeek: function getWeek(locale2, date) {
      return date.locale(parseLocale(locale2)).week();
    },
    getShortWeekDays: function getShortWeekDays(locale2) {
      return (0, import_dayjs.default)().locale(parseLocale(locale2)).localeData().weekdaysMin();
    },
    getShortMonths: function getShortMonths(locale2) {
      return (0, import_dayjs.default)().locale(parseLocale(locale2)).localeData().monthsShort();
    },
    format: function format(locale2, date, _format) {
      return date.locale(parseLocale(locale2)).format(_format);
    },
    parse: function parse(locale2, text, formats) {
      var localeStr = parseLocale(locale2);
      for (var i = 0; i < formats.length; i += 1) {
        var format2 = formats[i];
        var formatText = text;
        if (format2.includes("wo") || format2.includes("Wo")) {
          var year = formatText.split("-")[0];
          var weekStr = formatText.split("-")[1];
          var firstWeek = (0, import_dayjs.default)(year, "YYYY").startOf("year").locale(localeStr);
          for (var j = 0; j <= 52; j += 1) {
            var nextWeek = firstWeek.add(j, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        var date = (0, import_dayjs.default)(formatText, format2, true).locale(localeStr);
        if (date.isValid()) {
          return date;
        }
      }
      if (text) {
        parseNoMatchNotice();
      }
      return null;
    }
  }
};
var dayjs_default = generateConfig;

// node_modules/antd/es/calendar/generateCalendar.js
var React156 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/RangePicker.js
var React144 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerTrigger/index.js
var React104 = __toESM(require_react());

// node_modules/@rc-component/picker/es/utils/uiUtil.js
function getRealPlacement(placement, rtl) {
  if (placement !== void 0) {
    return placement;
  }
  return rtl ? "bottomRight" : "bottomLeft";
}

// node_modules/@rc-component/picker/es/PickerInput/context.js
var React103 = __toESM(require_react());
var PickerContext = React103.createContext(null);
var context_default4 = PickerContext;

// node_modules/@rc-component/picker/es/PickerTrigger/index.js
function _typeof2(o3) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof2(o3);
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == _typeof2(i) ? i : String(i);
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof2(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(_ref) {
  var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
  var _React$useContext = React104.useContext(context_default4), prefixCls = _React$useContext.prefixCls;
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var realPlacement = getRealPlacement(placement, direction === "rtl");
  return React104.createElement(es_default5, {
    showAction: [],
    hideAction: ["click"],
    popupPlacement: realPlacement,
    builtinPlacements,
    prefixCls: dropdownPrefixCls,
    popupMotion: {
      motionName: transitionName
    },
    popup: popupElement,
    popupAlign,
    popupVisible: visible,
    popupClassName: clsx(popupClassName, _defineProperty2(_defineProperty2({}, "".concat(dropdownPrefixCls, "-range"), range), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
    popupStyle,
    stretch: "minWidth",
    getPopupContainer,
    onPopupVisibleChange: function onPopupVisibleChange(nextVisible) {
      if (!nextVisible) {
        onClose();
      }
    }
  }, children);
}
var PickerTrigger_default = PickerTrigger;

// node_modules/@rc-component/picker/es/utils/miscUtil.js
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o3, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function leftPad(str, length) {
  var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  var current = String(str);
  while (current.length < length) {
    current = "".concat(fill).concat(current);
  }
  return current;
}
function toArray2(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function fillIndex(ori, index2, value) {
  var clone = _toConsumableArray2(ori);
  clone[index2] = value;
  return clone;
}
function pickProps(props, keys) {
  var clone = {};
  var mergedKeys = keys || Object.keys(props);
  mergedKeys.forEach(function(key) {
    if (props[key] !== void 0) {
      clone[key] = props[key];
    }
  });
  return clone;
}
function getRowFormat(picker, locale2, format2) {
  if (format2) {
    return format2;
  }
  switch (picker) {
    // All from the `locale.fieldXXXFormat` first
    case "time":
      return locale2.fieldTimeFormat;
    case "datetime":
      return locale2.fieldDateTimeFormat;
    case "month":
      return locale2.fieldMonthFormat;
    case "year":
      return locale2.fieldYearFormat;
    case "quarter":
      return locale2.fieldQuarterFormat;
    case "week":
      return locale2.fieldWeekFormat;
    default:
      return locale2.fieldDateFormat;
  }
}
function getFromDate(calendarValues, activeIndexList, activeIndex) {
  var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
  var firstValuedIndex = activeIndexList.find(function(index2) {
    return calendarValues[index2];
  });
  return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}

// node_modules/@rc-component/picker/es/PickerTrigger/util.js
function pickTriggerProps(props) {
  return pickProps(props, ["placement", "builtinPlacements", "popupAlign", "getPopupContainer", "transitionName", "direction"]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useCellRender.js
var React105 = __toESM(require_react());
function _typeof3(o3) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof3(o3);
}
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty3(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(t2) {
  var i = _toPrimitive2(t2, "string");
  return "symbol" == _typeof3(i) ? i : String(i);
}
function _toPrimitive2(t2, r2) {
  if ("object" != _typeof3(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof3(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useCellRender(cellRender, dateRender, monthCellRender, range) {
  if (true) {
    warning_default(!dateRender, "'dateRender' is deprecated. Please use 'cellRender' instead.");
    warning_default(!monthCellRender, "'monthCellRender' is deprecated. Please use 'cellRender' instead.");
  }
  var mergedCellRender = React105.useMemo(function() {
    if (cellRender) {
      return cellRender;
    }
    return function(current, info) {
      var date = current;
      if (dateRender && info.type === "date") {
        return dateRender(date, info.today);
      }
      if (monthCellRender && info.type === "month") {
        return monthCellRender(date, info.locale);
      }
      return info.originNode;
    };
  }, [cellRender, monthCellRender, dateRender]);
  var onInternalCellRender = React105.useCallback(function(date, info) {
    return mergedCellRender(date, _objectSpread(_objectSpread({}, info), {}, {
      range
    }));
  }, [mergedCellRender, range]);
  return onInternalCellRender;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldsInvalidate.js
var React106 = __toESM(require_react());
function _slicedToArray2(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray3(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray2(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray2(o3, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var _React$useState = React106.useState([false, false]), _React$useState2 = _slicedToArray2(_React$useState, 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
  var onSelectorInvalid = function onSelectorInvalid2(invalid, index2) {
    setFieldsInvalidates(function(ori) {
      return fillIndex(ori, index2, invalid);
    });
  };
  var submitInvalidates = React106.useMemo(function() {
    return fieldsInvalidates.map(function(invalid, index2) {
      if (invalid) {
        return true;
      }
      var current = calendarValue[index2];
      if (!current) {
        return false;
      }
      if (!allowEmpty[index2] && !current) {
        return true;
      }
      if (current && isInvalidateDate(current, {
        activeIndex: index2
      })) {
        return true;
      }
      return false;
    });
  }, [calendarValue, fieldsInvalidates, isInvalidateDate, allowEmpty]);
  return [submitInvalidates, onSelectorInvalid];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFilledProps.js
var React110 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useLocale.js
var import_react38 = __toESM(require_react());
function _typeof4(o3) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof4(o3);
}
function ownKeys2(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread3(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
      _defineProperty4(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(t2) {
  var i = _toPrimitive3(t2, "string");
  return "symbol" == _typeof4(i) ? i : String(i);
}
function _toPrimitive3(t2, r2) {
  if ("object" != _typeof4(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof4(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
  var timeFormat = "";
  var cells = [];
  if (showHour) {
    cells.push(showMeridiem ? "hh" : "HH");
  }
  if (showMinute) {
    cells.push("mm");
  }
  if (showSecond) {
    cells.push("ss");
  }
  timeFormat = cells.join(":");
  if (showMillisecond) {
    timeFormat += ".SSS";
  }
  if (showMeridiem) {
    timeFormat += " A";
  }
  return timeFormat;
}
function fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
  var fieldDateTimeFormat = locale2.fieldDateTimeFormat, fieldDateFormat = locale2.fieldDateFormat, fieldTimeFormat = locale2.fieldTimeFormat, fieldMonthFormat = locale2.fieldMonthFormat, fieldYearFormat = locale2.fieldYearFormat, fieldWeekFormat = locale2.fieldWeekFormat, fieldQuarterFormat = locale2.fieldQuarterFormat, yearFormat = locale2.yearFormat, cellYearFormat = locale2.cellYearFormat, cellQuarterFormat = locale2.cellQuarterFormat, dayFormat = locale2.dayFormat, cellDateFormat = locale2.cellDateFormat;
  var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
  return _objectSpread3(_objectSpread3({}, locale2), {}, {
    fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
    fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
    fieldTimeFormat: fieldTimeFormat || timeFormat,
    fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
    fieldYearFormat: fieldYearFormat || "YYYY",
    fieldWeekFormat: fieldWeekFormat || "gggg-wo",
    fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
    yearFormat: yearFormat || "YYYY",
    cellYearFormat: cellYearFormat || "YYYY",
    cellQuarterFormat: cellQuarterFormat || "[Q]Q",
    cellDateFormat: cellDateFormat || dayFormat || "D"
  });
}
function useLocale(locale2, showProps) {
  var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
  return import_react38.default.useMemo(function() {
    return fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours);
  }, [locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours]);
}

// node_modules/@rc-component/picker/es/hooks/useTimeConfig.js
function ownKeys3(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread4(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t2), true).forEach(function(r3) {
      _defineProperty5(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty5(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey4(t2) {
  var i = _toPrimitive4(t2, "string");
  return "symbol" == _typeof5(i) ? i : String(i);
}
function _toPrimitive4(t2, r2) {
  if ("object" != _typeof5(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof5(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray3(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray4(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray4(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray3(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray3(o3, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof5(o3) {
  "@babel/helpers - typeof";
  return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof5(o3);
}
function checkShow(format2, keywords, show) {
  return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
    return format2.includes(keyword);
  });
}
var showTimeKeys = [
  // 'format',
  "showNow",
  "showHour",
  "showMinute",
  "showSecond",
  "showMillisecond",
  "use12Hours",
  "hourStep",
  "minuteStep",
  "secondStep",
  "millisecondStep",
  "hideDisabledOptions",
  "defaultValue",
  "disabledHours",
  "disabledMinutes",
  "disabledSeconds",
  "disabledMilliseconds",
  "disabledTime",
  "changeOnScroll",
  "defaultOpenValue"
];
function pickTimeProps(props) {
  var timeProps = pickProps(props, showTimeKeys);
  var format2 = props.format, picker = props.picker;
  var propFormat = null;
  if (format2) {
    propFormat = format2;
    if (Array.isArray(propFormat)) {
      propFormat = propFormat[0];
    }
    propFormat = _typeof5(propFormat) === "object" ? propFormat.format : propFormat;
  }
  if (picker === "time") {
    timeProps.format = propFormat;
  }
  return [timeProps, propFormat];
}
function isStringFormat(format2) {
  return format2 && typeof format2 === "string";
}
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
  return [showHour, showMinute, showSecond, showMillisecond].some(function(show) {
    return show !== void 0;
  });
}
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
  var parsedShowHour = showHour;
  var parsedShowMinute = showMinute;
  var parsedShowSecond = showSecond;
  if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
    parsedShowHour = true;
    parsedShowMinute = true;
    parsedShowSecond = true;
  } else if (hasShowConfig) {
    var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
    var existFalse = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === false;
    });
    var existTrue = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === true;
    });
    var defaultShow = existFalse ? true : !existTrue;
    parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
    parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
    parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
  }
  return [parsedShowHour, parsedShowMinute, parsedShowSecond, showMillisecond];
}
function getTimeProps(componentProps) {
  var showTime = componentProps.showTime;
  var _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray3(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
  var showTimeConfig = showTime && _typeof5(showTime) === "object" ? showTime : {};
  var timeConfig = _objectSpread4(_objectSpread4({
    defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue
  }, pickedProps), showTimeConfig);
  var showMillisecond = timeConfig.showMillisecond;
  var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
  var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
  var _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
  var _fillShowConfig2 = _slicedToArray3(_fillShowConfig, 3);
  showHour = _fillShowConfig2[0];
  showMinute = _fillShowConfig2[1];
  showSecond = _fillShowConfig2[2];
  return [timeConfig, _objectSpread4(_objectSpread4({}, timeConfig), {}, {
    showHour,
    showMinute,
    showSecond,
    showMillisecond
  }), timeConfig.format, propFormat];
}
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale2) {
  var isTimePicker = picker === "time";
  if (picker === "datetime" || isTimePicker) {
    var pickedProps = timeConfig;
    var defaultLocaleFormat = getRowFormat(picker, locale2, null);
    var baselineFormat = defaultLocaleFormat;
    var formatList = [showTimeFormat, propFormat];
    for (var i = 0; i < formatList.length; i += 1) {
      var format2 = toArray2(formatList[i])[0];
      if (isStringFormat(format2)) {
        baselineFormat = format2;
        break;
      }
    }
    var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
    var use12Hours = pickedProps.use12Hours;
    var showMeridiem = checkShow(baselineFormat, ["a", "A", "LT", "LLL", "LTS"], use12Hours);
    var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
    if (!hasShowConfig) {
      showHour = checkShow(baselineFormat, ["H", "h", "k", "LT", "LLL"]);
      showMinute = checkShow(baselineFormat, ["m", "LT", "LLL"]);
      showSecond = checkShow(baselineFormat, ["s", "LTS"]);
      showMillisecond = checkShow(baselineFormat, ["SSS"]);
    }
    var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
    var _fillShowConfig4 = _slicedToArray3(_fillShowConfig3, 3);
    showHour = _fillShowConfig4[0];
    showMinute = _fillShowConfig4[1];
    showSecond = _fillShowConfig4[2];
    var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
    return _objectSpread4(_objectSpread4({}, pickedProps), {}, {
      // Format
      format: timeFormat,
      // Show Config
      showHour,
      showMinute,
      showSecond,
      showMillisecond,
      use12Hours: showMeridiem
    });
  }
  return null;
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useClearIcon.js
var React108 = __toESM(require_react());
function _typeof6(o3) {
  "@babel/helpers - typeof";
  return _typeof6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof6(o3);
}
function fillClearIcon(prefixCls, allowClear, clearIcon) {
  if (clearIcon) {
    warning_default(false, "`clearIcon` will be removed in future. Please use `allowClear` instead.");
  }
  if (allowClear === false) {
    return null;
  }
  var config = allowClear && _typeof6(allowClear) === "object" ? allowClear : {};
  return config.clearIcon || clearIcon || React108.createElement("span", {
    className: "".concat(prefixCls, "-clear-btn")
  });
}

// node_modules/@rc-component/picker/es/utils/dateUtil.js
var WEEK_DAY_COUNT = 7;
function nullableCompare(value1, value2, oriCompareFn) {
  if (!value1 && !value2 || value1 === value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return oriCompareFn();
}
function isSameDecade(generateConfig2, decade1, decade2) {
  return nullableCompare(decade1, decade2, function() {
    var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
    var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
    return num1 === num2;
  });
}
function isSameYear(generateConfig2, year1, year2) {
  return nullableCompare(year1, year2, function() {
    return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
  });
}
function getQuarter(generateConfig2, date) {
  var quota = Math.floor(generateConfig2.getMonth(date) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  return nullableCompare(quarter1, quarter2, function() {
    return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
  });
}
function isSameMonth(generateConfig2, month1, month2) {
  return nullableCompare(month1, month2, function() {
    return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
  });
}
function isSameDate(generateConfig2, date1, date2) {
  return nullableCompare(date1, date2, function() {
    return isSameYear(generateConfig2, date1, date2) && isSameMonth(generateConfig2, date1, date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
  });
}
function isSameTime(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
  });
}
function isSameTimestamp(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return isSameDate(generateConfig2, time1, time2) && isSameTime(generateConfig2, time1, time2) && generateConfig2.getMillisecond(time1) === generateConfig2.getMillisecond(time2);
  });
}
function isSameWeek(generateConfig2, locale2, date1, date2) {
  return nullableCompare(date1, date2, function() {
    var weekStartDate1 = generateConfig2.locale.getWeekFirstDate(locale2, date1);
    var weekStartDate2 = generateConfig2.locale.getWeekFirstDate(locale2, date2);
    return isSameYear(generateConfig2, weekStartDate1, weekStartDate2) && generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date2);
  });
}
function isSame(generateConfig2, locale2, source, target, type) {
  switch (type) {
    case "date":
      return isSameDate(generateConfig2, source, target);
    case "week":
      return isSameWeek(generateConfig2, locale2.locale, source, target);
    case "month":
      return isSameMonth(generateConfig2, source, target);
    case "quarter":
      return isSameQuarter(generateConfig2, source, target);
    case "year":
      return isSameYear(generateConfig2, source, target);
    case "decade":
      return isSameDecade(generateConfig2, source, target);
    case "time":
      return isSameTime(generateConfig2, source, target);
    default:
      return isSameTimestamp(generateConfig2, source, target);
  }
}
function isInRange(generateConfig2, startDate, endDate, current) {
  if (!startDate || !endDate || !current) {
    return false;
  }
  return generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
function isSameOrAfter(generateConfig2, locale2, date1, date2, type) {
  if (isSame(generateConfig2, locale2, date1, date2, type)) {
    return true;
  }
  return generateConfig2.isAfter(date1, date2);
}
function getWeekStartDate(locale2, generateConfig2, value) {
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
  var monthStartDate = generateConfig2.setDate(value, 1);
  var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function formatValue(value, _ref) {
  var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
  if (!value) {
    return "";
  }
  return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
}
function fillTime(generateConfig2, date, time) {
  var tmpDate = date;
  var getFn = ["getHour", "getMinute", "getSecond", "getMillisecond"];
  var setFn = ["setHour", "setMinute", "setSecond", "setMillisecond"];
  setFn.forEach(function(fn, index2) {
    if (time) {
      tmpDate = generateConfig2[fn](tmpDate, generateConfig2[getFn[index2]](time));
    } else {
      tmpDate = generateConfig2[fn](tmpDate, 0);
    }
  });
  return tmpDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useDisabledBoundary.js
function useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate) {
  var mergedDisabledDate = useEvent_default(function(date, info) {
    if (disabledDate && disabledDate(date, info)) {
      return true;
    }
    if (minDate && generateConfig2.isAfter(minDate, date) && !isSame(generateConfig2, locale2, minDate, date, info.type)) {
      return true;
    }
    if (maxDate && generateConfig2.isAfter(date, maxDate) && !isSame(generateConfig2, locale2, maxDate, date, info.type)) {
      return true;
    }
    return false;
  });
  return mergedDisabledDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldFormat.js
var React109 = __toESM(require_react());
function _typeof7(o3) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof7(o3);
}
function useFieldFormat(picker, locale2, format2) {
  return React109.useMemo(function() {
    var rawFormat = getRowFormat(picker, locale2, format2);
    var formatList = toArray2(rawFormat);
    var firstFormat = formatList[0];
    var maskFormat = _typeof7(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
    return [
      // Format list
      formatList.map(function(config) {
        return typeof config === "string" || typeof config === "function" ? config : config.format;
      }),
      // Mask Format
      maskFormat
    ];
  }, [picker, locale2, format2]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useInputReadOnly.js
function useInputReadOnly(formatList, inputReadOnly, multiple) {
  if (typeof formatList[0] === "function" || multiple) {
    return true;
  }
  return inputReadOnly;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useInvalidate.js
function _typeof8(o3) {
  "@babel/helpers - typeof";
  return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof8(o3);
}
function ownKeys4(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread5(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys4(Object(t2), true).forEach(function(r3) {
      _defineProperty6(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey5(t2) {
  var i = _toPrimitive5(t2, "string");
  return "symbol" == _typeof8(i) ? i : String(i);
}
function _toPrimitive5(t2, r2) {
  if ("object" != _typeof8(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof8(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useInvalidate(generateConfig2, picker, disabledDate, showTime) {
  var isInvalidate = useEvent_default(function(date, info) {
    var outsideInfo = _objectSpread5({
      type: picker
    }, info);
    delete outsideInfo.activeIndex;
    if (
      // Date object is invalid
      !generateConfig2.isValidate(date) || // Date is disabled by `disabledDate`
      disabledDate && disabledDate(date, outsideInfo)
    ) {
      return true;
    }
    if ((picker === "date" || picker === "time") && showTime) {
      var _showTime$disabledTim;
      var range = info && info.activeIndex === 1 ? "end" : "start";
      var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date, range, {
        from: outsideInfo.from
      })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
      var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
      var mergedDisabledHours = disabledHours || legacyDisabledHours;
      var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
      var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
      var hour = generateConfig2.getHour(date);
      var minute = generateConfig2.getMinute(date);
      var second = generateConfig2.getSecond(date);
      var millisecond = generateConfig2.getMillisecond(date);
      if (mergedDisabledHours && mergedDisabledHours().includes(hour)) {
        return true;
      }
      if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) {
        return true;
      }
      if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) {
        return true;
      }
      if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) {
        return true;
      }
    }
    return false;
  });
  return isInvalidate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFilledProps.js
function _typeof9(o3) {
  "@babel/helpers - typeof";
  return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof9(o3);
}
function ownKeys5(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread6(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys5(Object(t2), true).forEach(function(r3) {
      _defineProperty7(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys5(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty7(obj, key, value) {
  key = _toPropertyKey6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey6(t2) {
  var i = _toPrimitive6(t2, "string");
  return "symbol" == _typeof9(i) ? i : String(i);
}
function _toPrimitive6(t2, r2) {
  if ("object" != _typeof9(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof9(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray4(arr, i) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i) || _unsupportedIterableToArray5(arr, i) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray5(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray4(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray4(o3, minLen);
}
function _arrayLikeToArray4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit3(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr)) return arr;
}
function useList(value) {
  var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var values = React110.useMemo(function() {
    var list = value ? toArray2(value) : value;
    if (fillMode && list) {
      list[1] = list[1] || list[0];
    }
    return list;
  }, [value, fillMode]);
  return values;
}
function useFilledProps(props, updater) {
  var generateConfig2 = props.generateConfig, locale2 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$previewValue = props.previewValue, previewValue = _props$previewValue === void 0 ? "hover" : _props$previewValue, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format2 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
  var values = useList(value);
  var defaultValues = useList(defaultValue);
  var pickerValues = useList(pickerValue);
  var defaultPickerValues = useList(defaultPickerValue);
  var internalPicker = picker === "date" && showTime ? "datetime" : picker;
  var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
  var complexPicker = multipleInteractivePicker || multiple;
  var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
  var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray4(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
  var mergedLocale = useLocale(locale2, localeTimeProps);
  var mergedShowTime = React110.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale]);
  if (picker === "time") {
    if (["disabledHours", "disabledMinutes", "disabledSeconds"].some(function(key) {
      return props[key];
    })) {
      warning_default(false, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
    }
  }
  var filledProps = React110.useMemo(function() {
    return _objectSpread6(_objectSpread6({}, props), {}, {
      previewValue,
      prefixCls,
      locale: mergedLocale,
      picker,
      styles,
      classNames,
      order,
      components: _objectSpread6({
        input: inputRender
      }, components),
      clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
      showTime: mergedShowTime,
      value: values,
      defaultValue: defaultValues,
      pickerValue: pickerValues,
      defaultPickerValue: defaultPickerValues
    }, updater === null || updater === void 0 ? void 0 : updater());
  }, [props]);
  var _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format2), _useFieldFormat2 = _slicedToArray4(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
  var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
  var disabledBoundaryDate = useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate);
  var isInvalidateDate = useInvalidate(generateConfig2, picker, disabledBoundaryDate, mergedShowTime);
  var mergedProps = React110.useMemo(function() {
    return _objectSpread6(_objectSpread6({}, filledProps), {}, {
      needConfirm: mergedNeedConfirm,
      inputReadOnly: mergedInputReadOnly,
      disabledDate: disabledBoundaryDate
    });
  }, [filledProps, mergedNeedConfirm, mergedInputReadOnly, disabledBoundaryDate]);
  return [mergedProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useDelayState.js
var import_react39 = __toESM(require_react());
function _slicedToArray5(arr, i) {
  return _arrayWithHoles4(arr) || _iterableToArrayLimit4(arr, i) || _unsupportedIterableToArray6(arr, i) || _nonIterableRest4();
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray6(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray5(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray5(o3, minLen);
}
function _arrayLikeToArray5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit4(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles4(arr) {
  if (Array.isArray(arr)) return arr;
}
function useDelayState(value, defaultValue, onChange) {
  var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray5(_useControlledState, 2), state = _useControlledState2[0], setState = _useControlledState2[1];
  var _React$useState = import_react39.default.useState({}), _React$useState2 = _slicedToArray5(_React$useState, 2), forceUpdate = _React$useState2[1];
  var triggerUpdate = useEvent_default(function(nextState) {
    setState(nextState);
    forceUpdate({});
  });
  var nextValueRef = import_react39.default.useRef(value);
  var rafRef = import_react39.default.useRef();
  var cancelRaf = function cancelRaf2() {
    raf_default.cancel(rafRef.current);
  };
  var doUpdate = useEvent_default(function() {
    triggerUpdate(nextValueRef.current);
    if (onChange && state !== nextValueRef.current) {
      onChange(nextValueRef.current);
    }
  });
  var updateValue = useEvent_default(function(next, immediately) {
    cancelRaf();
    nextValueRef.current = next;
    if (next || immediately) {
      doUpdate();
    } else {
      rafRef.current = raf_default(doUpdate);
    }
  });
  import_react39.default.useEffect(function() {
    return cancelRaf;
  }, []);
  return [state, updateValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useOpen.js
function _slicedToArray6(arr, i) {
  return _arrayWithHoles5(arr) || _iterableToArrayLimit5(arr, i) || _unsupportedIterableToArray7(arr, i) || _nonIterableRest5();
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray7(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray6(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray6(o3, minLen);
}
function _arrayLikeToArray6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit5(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles5(arr) {
  if (Array.isArray(arr)) return arr;
}
function useOpen(open3, defaultOpen) {
  var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
  var mergedOpen = disabledList.every(function(disabled) {
    return disabled;
  }) ? false : open3;
  var _useDelayState = useDelayState(mergedOpen, defaultOpen || false, onOpenChange), _useDelayState2 = _slicedToArray6(_useDelayState, 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
  function setOpen(next) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!config.inherit || rafOpen) {
      setRafOpen(next, config.force);
    }
  }
  return [rafOpen, setOpen];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/usePickerRef.js
var React112 = __toESM(require_react());
function usePickerRef(ref) {
  var selectorRef = React112.useRef();
  React112.useImperativeHandle(ref, function() {
    var _selectorRef$current;
    return {
      nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
      focus: function focus(options) {
        var _selectorRef$current2;
        (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
      },
      blur: function blur() {
        var _selectorRef$current3;
        (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
      }
    };
  });
  return selectorRef;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/usePresets.js
var React113 = __toESM(require_react());
function _slicedToArray7(arr, i) {
  return _arrayWithHoles6(arr) || _iterableToArrayLimit6(arr, i) || _unsupportedIterableToArray8(arr, i) || _nonIterableRest6();
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray8(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray7(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray7(o3, minLen);
}
function _arrayLikeToArray7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit6(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles6(arr) {
  if (Array.isArray(arr)) return arr;
}
function usePresets(presets, legacyRanges) {
  return React113.useMemo(function() {
    if (presets) {
      return presets;
    }
    if (legacyRanges) {
      warning_default(false, "`ranges` is deprecated. Please use `presets` instead.");
      return Object.entries(legacyRanges).map(function(_ref) {
        var _ref2 = _slicedToArray7(_ref, 2), label = _ref2[0], value = _ref2[1];
        return {
          label,
          value
        };
      });
    }
    return [];
  }, [presets, legacyRanges]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeActive.js
var React115 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/hooks/useLockEffect.js
var React114 = __toESM(require_react());
function useLockEffect(condition, callback) {
  var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var callbackRef = React114.useRef(callback);
  callbackRef.current = callback;
  useLayoutUpdateEffect(function() {
    if (condition) {
      callbackRef.current(condition);
    } else {
      var id = raf_default(function() {
        callbackRef.current(condition);
      }, delayFrames);
      return function() {
        raf_default.cancel(id);
      };
    }
  }, [condition]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeActive.js
function _slicedToArray8(arr, i) {
  return _arrayWithHoles7(arr) || _iterableToArrayLimit7(arr, i) || _unsupportedIterableToArray9(arr, i) || _nonIterableRest7();
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray9(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray8(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray8(o3, minLen);
}
function _arrayLikeToArray8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit7(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles7(arr) {
  if (Array.isArray(arr)) return arr;
}
function useRangeActive(disabled) {
  var empty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var _React$useState = React115.useState(0), _React$useState2 = _slicedToArray8(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
  var _React$useState3 = React115.useState(false), _React$useState4 = _slicedToArray8(_React$useState3, 2), focused = _React$useState4[0], setFocused = _React$useState4[1];
  var activeListRef = React115.useRef([]);
  var submitIndexRef = React115.useRef(null);
  var lastOperationRef = React115.useRef(null);
  var updateSubmitIndex = function updateSubmitIndex2(index2) {
    submitIndexRef.current = index2;
  };
  var hasActiveSubmitValue = function hasActiveSubmitValue2(index2) {
    return submitIndexRef.current === index2;
  };
  var triggerFocus2 = function triggerFocus3(nextFocus) {
    setFocused(nextFocus);
  };
  var lastOperation = function lastOperation2(type) {
    if (type) {
      lastOperationRef.current = type;
    }
    return lastOperationRef.current;
  };
  var nextActiveIndex = function nextActiveIndex2(nextValue) {
    var list = activeListRef.current;
    var filledActiveSet = new Set(list.filter(function(index2) {
      return nextValue[index2] || empty2[index2];
    }));
    var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
    if (filledActiveSet.size >= 2 || disabled[nextIndex]) {
      return null;
    }
    return nextIndex;
  };
  useLockEffect(focused || mergedOpen, function() {
    if (!focused) {
      activeListRef.current = [];
      updateSubmitIndex(null);
    }
  });
  React115.useEffect(function() {
    if (focused) {
      activeListRef.current.push(activeIndex);
    }
  }, [focused, activeIndex]);
  return [focused, triggerFocus2, lastOperation, activeIndex, setActiveIndex, nextActiveIndex, activeListRef.current, updateSubmitIndex, hasActiveSubmitValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeDisabledDate.js
function _typeof10(o3) {
  "@babel/helpers - typeof";
  return _typeof10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof10(o3);
}
function ownKeys6(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread7(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys6(Object(t2), true).forEach(function(r3) {
      _defineProperty8(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys6(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty8(obj, key, value) {
  key = _toPropertyKey7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey7(t2) {
  var i = _toPrimitive7(t2, "string");
  return "symbol" == _typeof10(i) ? i : String(i);
}
function _toPrimitive7(t2, r2) {
  if ("object" != _typeof10(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof10(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray9(arr, i) {
  return _arrayWithHoles8(arr) || _iterableToArrayLimit8(arr, i) || _unsupportedIterableToArray10(arr, i) || _nonIterableRest8();
}
function _nonIterableRest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray10(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray9(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray9(o3, minLen);
}
function _arrayLikeToArray9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit8(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles8(arr) {
  if (Array.isArray(arr)) return arr;
}
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig2, locale2, disabledDate) {
  var activeIndex = activeIndexList[activeIndexList.length - 1];
  var rangeDisabledDate = function rangeDisabledDate2(date, info) {
    var _values = _slicedToArray9(values, 2), start = _values[0], end = _values[1];
    var mergedInfo = _objectSpread7(_objectSpread7({}, info), {}, {
      from: getFromDate(values, activeIndexList)
    });
    if (activeIndex === 1 && disabled[0] && start && // Same date isOK
    !isSame(generateConfig2, locale2, start, date, mergedInfo.type) && // Before start date
    generateConfig2.isAfter(start, date)) {
      return true;
    }
    if (activeIndex === 0 && disabled[1] && end && // Same date isOK
    !isSame(generateConfig2, locale2, end, date, mergedInfo.type) && // After end date
    generateConfig2.isAfter(date, end)) {
      return true;
    }
    return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date, mergedInfo);
  };
  return rangeDisabledDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangePickerValue.js
var React116 = __toESM(require_react());
function _slicedToArray10(arr, i) {
  return _arrayWithHoles9(arr) || _iterableToArrayLimit9(arr, i) || _unsupportedIterableToArray11(arr, i) || _nonIterableRest9();
}
function _nonIterableRest9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray11(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray10(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray10(o3, minLen);
}
function _arrayLikeToArray10(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit9(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles9(arr) {
  if (Array.isArray(arr)) return arr;
}
function offsetPanelDate(generateConfig2, picker, date, offset3) {
  switch (picker) {
    case "date":
    case "week":
      return generateConfig2.addMonth(date, offset3);
    case "month":
    case "quarter":
      return generateConfig2.addYear(date, offset3);
    case "year":
      return generateConfig2.addYear(date, offset3 * 10);
    case "decade":
      return generateConfig2.addYear(date, offset3 * 100);
    default:
      return date;
  }
}
var EMPTY_LIST2 = [];
function useRangePickerValue(generateConfig2, locale2, calendarValue, modes, open3, activeIndex, pickerMode, multiplePanel) {
  var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST2;
  var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST2;
  var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST2;
  var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
  var minDate = arguments.length > 12 ? arguments[12] : void 0;
  var maxDate = arguments.length > 13 ? arguments[13] : void 0;
  var isTimePicker = pickerMode === "time";
  var mergedActiveIndex = activeIndex || 0;
  var getDefaultPickerValue = function getDefaultPickerValue2(index2) {
    var now2 = generateConfig2.getNow();
    if (isTimePicker) {
      now2 = fillTime(generateConfig2, now2);
    }
    return defaultPickerValue[index2] || calendarValue[index2] || now2;
  };
  var _pickerValue = _slicedToArray10(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
  var _useControlledState = useControlledState(function() {
    return getDefaultPickerValue(0);
  }, startPickerValue), _useControlledState2 = _slicedToArray10(_useControlledState, 2), mergedStartPickerValue = _useControlledState2[0], setStartPickerValue = _useControlledState2[1];
  var _useControlledState3 = useControlledState(function() {
    return getDefaultPickerValue(1);
  }, endPickerValue), _useControlledState4 = _slicedToArray10(_useControlledState3, 2), mergedEndPickerValue = _useControlledState4[0], setEndPickerValue = _useControlledState4[1];
  var currentPickerValue = React116.useMemo(function() {
    var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
    return isTimePicker ? current : fillTime(generateConfig2, current, timeDefaultValue[mergedActiveIndex]);
  }, [isTimePicker, mergedStartPickerValue, mergedEndPickerValue, mergedActiveIndex, generateConfig2, timeDefaultValue]);
  var setCurrentPickerValue = function setCurrentPickerValue2(nextPickerValue) {
    var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
    var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
    updater(nextPickerValue);
    var clone = [mergedStartPickerValue, mergedEndPickerValue];
    clone[mergedActiveIndex] = nextPickerValue;
    if (onPickerValueChange && (!isSame(generateConfig2, locale2, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig2, locale2, mergedEndPickerValue, clone[1], pickerMode))) {
      onPickerValueChange(clone, {
        source,
        range: mergedActiveIndex === 1 ? "end" : "start",
        mode: modes
      });
    }
  };
  var getEndDatePickerValue = function getEndDatePickerValue2(startDate, endDate) {
    if (multiplePanel) {
      var SAME_CHECKER = {
        date: "month",
        week: "month",
        month: "year",
        quarter: "year"
      };
      var mode = SAME_CHECKER[pickerMode];
      if (mode && !isSame(generateConfig2, locale2, startDate, endDate, mode)) {
        return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
      }
      if (pickerMode === "year" && startDate) {
        var srcYear = Math.floor(generateConfig2.getYear(startDate) / 10);
        var tgtYear = Math.floor(generateConfig2.getYear(endDate) / 10);
        if (srcYear !== tgtYear) {
          return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
        }
      }
    }
    return endDate;
  };
  var prevActiveIndexRef = React116.useRef(null);
  useLayoutEffect_default(function() {
    if (open3) {
      if (!defaultPickerValue[mergedActiveIndex]) {
        var nextPickerValue = isTimePicker ? null : generateConfig2.getNow();
        if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) {
          nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
        } else if (calendarValue[mergedActiveIndex]) {
          nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
        } else if (calendarValue[mergedActiveIndex ^ 1]) {
          nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
        }
        if (nextPickerValue) {
          if (minDate && generateConfig2.isAfter(minDate, nextPickerValue)) {
            nextPickerValue = minDate;
          }
          var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, nextPickerValue, 1) : nextPickerValue;
          if (maxDate && generateConfig2.isAfter(offsetPickerValue, maxDate)) {
            nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, maxDate, -1) : maxDate;
          }
          setCurrentPickerValue(nextPickerValue, "reset");
        }
      }
    }
  }, [open3, mergedActiveIndex, calendarValue[mergedActiveIndex]]);
  React116.useEffect(function() {
    if (open3) {
      prevActiveIndexRef.current = mergedActiveIndex;
    } else {
      prevActiveIndexRef.current = null;
    }
  }, [open3, mergedActiveIndex]);
  useLayoutEffect_default(function() {
    if (open3 && defaultPickerValue) {
      if (defaultPickerValue[mergedActiveIndex]) {
        setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
      }
    }
  }, [open3, mergedActiveIndex]);
  return [currentPickerValue, setCurrentPickerValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeValue.js
var React118 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useSyncState.js
var React117 = __toESM(require_react());
function _slicedToArray11(arr, i) {
  return _arrayWithHoles10(arr) || _iterableToArrayLimit10(arr, i) || _unsupportedIterableToArray12(arr, i) || _nonIterableRest10();
}
function _nonIterableRest10() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray12(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray11(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray11(o3, minLen);
}
function _arrayLikeToArray11(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit10(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles10(arr) {
  if (Array.isArray(arr)) return arr;
}
function useSyncState2(defaultValue, controlledValue) {
  var valueRef = React117.useRef(defaultValue);
  var _React$useState = React117.useState({}), _React$useState2 = _slicedToArray11(_React$useState, 2), forceUpdate = _React$useState2[1];
  var getter = function getter2(useControlledValueFirst) {
    return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
  };
  var setter = function setter2(nextValue) {
    valueRef.current = nextValue;
    forceUpdate({});
  };
  return [getter, setter, getter(true)];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeValue.js
function _slicedToArray12(arr, i) {
  return _arrayWithHoles11(arr) || _iterableToArrayLimit11(arr, i) || _unsupportedIterableToArray13(arr, i) || _nonIterableRest11();
}
function _nonIterableRest11() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit11(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles11(arr) {
  if (Array.isArray(arr)) return arr;
}
function _toConsumableArray3(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray13(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray13(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray12(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray12(o3, minLen);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray12(arr);
}
function _arrayLikeToArray12(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var EMPTY_VALUE = [];
function useUtil(generateConfig2, locale2, formatList) {
  var getDateTexts = function getDateTexts2(dates) {
    return dates.map(function(date) {
      return formatValue(date, {
        generateConfig: generateConfig2,
        locale: locale2,
        format: formatList[0]
      });
    });
  };
  var isSameDates = function isSameDates2(source, target) {
    var maxLen = Math.max(source.length, target.length);
    var diffIndex = -1;
    for (var i = 0; i < maxLen; i += 1) {
      var prev = source[i] || null;
      var next = target[i] || null;
      if (prev !== next && !isSameTimestamp(generateConfig2, prev, next)) {
        diffIndex = i;
        break;
      }
    }
    return [diffIndex < 0, diffIndex !== 0];
  };
  return [getDateTexts, isSameDates];
}
function orderDates(dates, generateConfig2) {
  return _toConsumableArray3(dates).sort(function(a, b) {
    return generateConfig2.isAfter(a, b) ? 1 : -1;
  });
}
function useCalendarValue(mergedValue) {
  var _useSyncState = useSyncState2(mergedValue), _useSyncState2 = _slicedToArray12(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
  var syncWithValue = useEvent_default(function() {
    setCalendarValue(mergedValue);
  });
  React118.useEffect(function() {
    syncWithValue();
  }, [mergedValue]);
  return [calendarValue, setCalendarValue];
}
function useInnerValue(generateConfig2, locale2, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
  var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray12(_useControlledState, 2), innerValue = _useControlledState2[0], setInnerValue = _useControlledState2[1];
  var mergedValue = innerValue || EMPTY_VALUE;
  var _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray12(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
  var _useUtil = useUtil(generateConfig2, locale2, formatList), _useUtil2 = _slicedToArray12(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
  var triggerCalendarChange = useEvent_default(function(nextCalendarValues) {
    var clone = _toConsumableArray3(nextCalendarValues);
    if (rangeValue) {
      for (var i = 0; i < 2; i += 1) {
        clone[i] = clone[i] || null;
      }
    } else if (order) {
      clone = orderDates(clone.filter(function(date) {
        return date;
      }), generateConfig2);
    }
    var _isSameDates = isSameDates(calendarValue(), clone), _isSameDates2 = _slicedToArray12(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
    if (!isSameMergedDates) {
      setCalendarValue(clone);
      if (onCalendarChange) {
        var cellTexts = getDateTexts(clone);
        onCalendarChange(clone, cellTexts, {
          range: isSameStart ? "end" : "start"
        });
      }
    }
  });
  var triggerOk = function triggerOk2() {
    if (onOk) {
      onOk(calendarValue());
    }
  };
  return [mergedValue, setInnerValue, calendarValue, triggerCalendarChange, triggerOk];
}
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open3, isInvalidateDate) {
  var generateConfig2 = info.generateConfig, locale2 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
  var orderOnChange = disabled.some(function(d) {
    return d;
  }) ? false : order;
  var _useUtil3 = useUtil(generateConfig2, locale2, formatList), _useUtil4 = _slicedToArray12(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
  var _useSyncState3 = useSyncState2(mergedValue), _useSyncState4 = _slicedToArray12(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
  var syncWithValue = useEvent_default(function() {
    setSubmitValue(mergedValue);
  });
  React118.useEffect(function() {
    syncWithValue();
  }, [mergedValue]);
  var triggerSubmit = useEvent_default(function(nextValue) {
    var isNullValue = nextValue === null;
    var clone = _toConsumableArray3(nextValue || submitValue());
    if (isNullValue) {
      var maxLen = Math.max(disabled.length, clone.length);
      for (var i = 0; i < maxLen; i += 1) {
        if (!disabled[i]) {
          clone[i] = null;
        }
      }
    }
    if (orderOnChange && clone[0] && clone[1]) {
      clone = orderDates(clone, generateConfig2);
    }
    triggerCalendarChange(clone);
    var _clone = clone, _clone2 = _slicedToArray12(_clone, 2), start = _clone2[0], end = _clone2[1];
    var startEmpty = !start;
    var endEmpty = !end;
    var validateEmptyDateRange = allowEmpty ? (
      // Validate empty start
      (!startEmpty || allowEmpty[0]) && // Validate empty end
      (!endEmpty || allowEmpty[1])
    ) : true;
    var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig2, locale2, start, end, picker) || generateConfig2.isAfter(end, start);
    var validateDates = (
      // Validate start
      (disabled[0] || !start || !isInvalidateDate(start, {
        activeIndex: 0
      })) && // Validate end
      (disabled[1] || !end || !isInvalidateDate(end, {
        from: start,
        activeIndex: 1
      }))
    );
    var allPassed = (
      // Null value is from clear button
      isNullValue || // Normal check
      validateEmptyDateRange && validateOrder && validateDates
    );
    if (allPassed) {
      setInnerValue(clone);
      var _isSameDates3 = isSameDates(clone, mergedValue), _isSameDates4 = _slicedToArray12(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
      if (onChange && !isSameMergedDates) {
        var everyEmpty = clone.every(function(val) {
          return !val;
        });
        onChange(
          // Return null directly if all date are empty
          isNullValue && everyEmpty ? null : clone,
          everyEmpty ? null : getDateTexts(clone)
        );
      }
    }
    return allPassed;
  });
  var flushSubmit = useEvent_default(function(index2, needTriggerChange) {
    var nextSubmitValue = fillIndex(submitValue(), index2, getCalendarValue()[index2]);
    setSubmitValue(nextSubmitValue);
    if (needTriggerChange) {
      triggerSubmit();
    }
  });
  var interactiveFinished = !focused && !open3;
  useLockEffect(!interactiveFinished, function() {
    if (interactiveFinished) {
      triggerSubmit();
      triggerCalendarChange(mergedValue);
      syncWithValue();
    }
  }, 2);
  return [flushSubmit, triggerSubmit];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useShowNow.js
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
  if (mode !== "date" && mode !== "time") {
    return false;
  }
  if (showNow !== void 0) {
    return showNow;
  }
  if (showToday !== void 0) {
    return showToday;
  }
  return !rangePicker && (picker === "date" || picker === "time");
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/index.js
var React138 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Popup/Footer.js
var React120 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useTimeInfo.js
var React119 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/util.js
function _toConsumableArray4(arr) {
  return _arrayWithoutHoles3(arr) || _iterableToArray3(arr) || _unsupportedIterableToArray14(arr) || _nonIterableSpread3();
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray14(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray13(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray13(o3, minLen);
}
function _iterableToArray3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles3(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray13(arr);
}
function _arrayLikeToArray13(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function findValidateTime(date, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig2) {
  var nextDate = date;
  function alignValidate(getUnitValue2, setUnitValue, units) {
    var nextValue = generateConfig2[getUnitValue2](nextDate);
    var nextUnit = units.find(function(unit2) {
      return unit2.value === nextValue;
    });
    if (!nextUnit || nextUnit.disabled) {
      var validateUnits = units.filter(function(unit2) {
        return !unit2.disabled;
      });
      var reverseEnabledUnits = _toConsumableArray4(validateUnits).reverse();
      var validateUnit = reverseEnabledUnits.find(function(unit2) {
        return unit2.value <= nextValue;
      }) || validateUnits[0];
      if (validateUnit) {
        nextValue = validateUnit.value;
        nextDate = generateConfig2[setUnitValue](nextDate, nextValue);
      }
    }
    return nextValue;
  }
  var nextHour = alignValidate("getHour", "setHour", getHourUnits());
  var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
  var nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
  alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond));
  return nextDate;
}

// node_modules/@rc-component/picker/es/hooks/useTimeInfo.js
function _typeof11(o3) {
  "@babel/helpers - typeof";
  return _typeof11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof11(o3);
}
function ownKeys7(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread8(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys7(Object(t2), true).forEach(function(r3) {
      _defineProperty9(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys7(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty9(obj, key, value) {
  key = _toPropertyKey8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey8(t2) {
  var i = _toPrimitive8(t2, "string");
  return "symbol" == _typeof11(i) ? i : String(i);
}
function _toPrimitive8(t2, r2) {
  if ("object" != _typeof11(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof11(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray13(arr, i) {
  return _arrayWithHoles12(arr) || _iterableToArrayLimit12(arr, i) || _unsupportedIterableToArray15(arr, i) || _nonIterableRest12();
}
function _nonIterableRest12() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray15(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray14(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray14(o3, minLen);
}
function _arrayLikeToArray14(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit12(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles12(arr) {
  if (Array.isArray(arr)) return arr;
}
function emptyDisabled() {
  return [];
}
function generateUnits(start, end) {
  var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
  var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
  var units = [];
  var integerStep = step >= 1 ? step | 0 : 1;
  for (var i = start; i <= end; i += integerStep) {
    var disabled = disabledUnits.includes(i);
    if (!disabled || !hideDisabledOptions) {
      units.push({
        label: leftPad(i, pad),
        value: i,
        disabled
      });
    }
  }
  return units;
}
function useTimeInfo(generateConfig2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var date = arguments.length > 2 ? arguments[2] : void 0;
  var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
  var mergedDate = React119.useMemo(function() {
    return date || generateConfig2.getNow();
  }, [date, generateConfig2]);
  if (true) {
    var isHourStepValid = 24 % hourStep === 0;
    var isMinuteStepValid = 60 % minuteStep === 0;
    var isSecondStepValid = 60 % secondStep === 0;
    warning_default(isHourStepValid, "`hourStep` ".concat(hourStep, " is invalid. It should be a factor of 24."));
    warning_default(isMinuteStepValid, "`minuteStep` ".concat(minuteStep, " is invalid. It should be a factor of 60."));
    warning_default(isSecondStepValid, "`secondStep` ".concat(secondStep, " is invalid. It should be a factor of 60."));
  }
  var getDisabledTimes = React119.useCallback(function(targetDate) {
    var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
    return [disabledConfig.disabledHours || disabledHours || emptyDisabled, disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled, disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled, disabledConfig.disabledMilliseconds || emptyDisabled];
  }, [disabledTime, disabledHours, disabledMinutes, disabledSeconds]);
  var _React$useMemo = React119.useMemo(function() {
    return getDisabledTimes(mergedDate);
  }, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray13(_React$useMemo, 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
  var getAllUnits = React119.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
    var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
    var rowHourUnits2 = use12Hours ? hours.map(function(unit2) {
      return _objectSpread8(_objectSpread8({}, unit2), {}, {
        label: leftPad(unit2.value % 12 || 12, 2)
      });
    }) : hours;
    var getMinuteUnits2 = function getMinuteUnits3(nextHour) {
      return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
    };
    var getSecondUnits2 = function getSecondUnits3(nextHour, nextMinute) {
      return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
    };
    var getMillisecondUnits2 = function getMillisecondUnits3(nextHour, nextMinute, nextSecond) {
      return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
    };
    return [rowHourUnits2, getMinuteUnits2, getSecondUnits2, getMillisecondUnits2];
  }, [hideDisabledOptions, hourStep, use12Hours, millisecondStep, minuteStep, secondStep]);
  var _React$useMemo3 = React119.useMemo(function() {
    return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
  }, [getAllUnits, mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds]), _React$useMemo4 = _slicedToArray13(_React$useMemo3, 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
  var getValidTime = function getValidTime2(nextTime, certainDate) {
    var getCheckHourUnits = function getCheckHourUnits2() {
      return rowHourUnits;
    };
    var getCheckMinuteUnits = getMinuteUnits;
    var getCheckSecondUnits = getSecondUnits;
    var getCheckMillisecondUnits = getMillisecondUnits;
    if (certainDate) {
      var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray13(_getDisabledTimes, 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
      var _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray13(_getAllUnits, 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
      getCheckHourUnits = function getCheckHourUnits2() {
        return targetRowHourUnits;
      };
      getCheckMinuteUnits = targetGetMinuteUnits;
      getCheckSecondUnits = targetGetSecondUnits;
      getCheckMillisecondUnits = targetGetMillisecondUnits;
    }
    var validateDate = findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig2);
    return validateDate;
  };
  return [
    // getValidTime
    getValidTime,
    // Units
    rowHourUnits,
    getMinuteUnits,
    getSecondUnits,
    getMillisecondUnits
  ];
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/Footer.js
function _slicedToArray14(arr, i) {
  return _arrayWithHoles13(arr) || _iterableToArrayLimit13(arr, i) || _unsupportedIterableToArray16(arr, i) || _nonIterableRest13();
}
function _nonIterableRest13() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray16(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray15(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray15(o3, minLen);
}
function _arrayLikeToArray15(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit13(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles13(arr) {
  if (Array.isArray(arr)) return arr;
}
function Footer2(props) {
  var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig2 = props.generateConfig, disabledDate = props.disabledDate;
  var _React$useContext = React120.useContext(context_default4), prefixCls = _React$useContext.prefixCls, locale2 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button2 = _React$useContext$but === void 0 ? "button" : _React$useContext$but, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var now2 = generateConfig2.getNow();
  var _useTimeInfo = useTimeInfo(generateConfig2, showTime, now2), _useTimeInfo2 = _slicedToArray14(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
  var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
  var nowDisabled = disabledDate(now2, {
    type: mode
  });
  var onInternalNow = function onInternalNow2() {
    if (!nowDisabled) {
      var validateNow = getValidTime(now2);
      onNow(validateNow);
    }
  };
  var nowPrefixCls = "".concat(prefixCls, "-now");
  var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
  var presetNode = showNow && React120.createElement("li", {
    className: nowPrefixCls
  }, React120.createElement("a", {
    className: clsx(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
    "aria-disabled": nowDisabled,
    onClick: onInternalNow
  }, internalMode === "date" ? locale2.today : locale2.now));
  var okNode = needConfirm && React120.createElement("li", {
    className: "".concat(prefixCls, "-ok")
  }, React120.createElement(Button2, {
    disabled: invalid,
    onClick: onSubmit
  }, locale2.ok));
  var rangeNode = (presetNode || okNode) && React120.createElement("ul", {
    className: "".concat(prefixCls, "-ranges")
  }, presetNode, okNode);
  if (!extraNode && !rangeNode) {
    return null;
  }
  return React120.createElement("div", {
    className: clsx("".concat(prefixCls, "-footer"), classNames.popup.footer),
    style: styles.popup.footer
  }, extraNode && React120.createElement("div", {
    className: "".concat(prefixCls, "-footer-extra")
  }, extraNode), rangeNode);
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/PopupPanel.js
var React136 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/index.js
var React135 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useToggleDates.js
function _toConsumableArray5(arr) {
  return _arrayWithoutHoles4(arr) || _iterableToArray4(arr) || _unsupportedIterableToArray17(arr) || _nonIterableSpread4();
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray17(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray16(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray16(o3, minLen);
}
function _iterableToArray4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles4(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray16(arr);
}
function _arrayLikeToArray16(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function useToggleDates(generateConfig2, locale2, panelMode) {
  function toggleDates(list, target) {
    var index2 = list.findIndex(function(date) {
      return isSame(generateConfig2, locale2, date, target, panelMode);
    });
    if (index2 === -1) {
      return [].concat(_toConsumableArray5(list), [target]);
    }
    var sliceList = _toConsumableArray5(list);
    sliceList.splice(index2, 1);
    return sliceList;
  }
  return toggleDates;
}

// node_modules/@rc-component/picker/es/PickerPanel/context.js
var React121 = __toESM(require_react());
var SharedPanelContext = React121.createContext(null);
var PanelContext = React121.createContext(null);
function usePanelContext() {
  return React121.useContext(PanelContext);
}
function useInfo(props, panelType) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
  var _React$useContext = React121.useContext(SharedPanelContext), classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var now2 = generateConfig2.getNow();
  var info = {
    now: now2,
    values,
    pickerValue,
    prefixCls,
    classNames,
    styles,
    disabledDate,
    minDate,
    maxDate,
    cellRender,
    hoverValue,
    hoverRangeValue,
    onHover,
    locale: locale2,
    generateConfig: generateConfig2,
    onSelect,
    panelType,
    // Icons
    prevIcon,
    nextIcon,
    superPrevIcon,
    superNextIcon
  };
  return [info, now2];
}
var PickerHackContext = React121.createContext({});
if (true) {
  PickerHackContext.displayName = "PickerHackContext";
}

// node_modules/@rc-component/picker/es/PickerPanel/DatePanel/index.js
var React124 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/PanelBody.js
var React122 = __toESM(require_react());
function _typeof12(o3) {
  "@babel/helpers - typeof";
  return _typeof12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof12(o3);
}
function ownKeys8(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread9(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys8(Object(t2), true).forEach(function(r3) {
      _defineProperty10(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys8(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty10(obj, key, value) {
  key = _toPropertyKey9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey9(t2) {
  var i = _toPrimitive9(t2, "string");
  return "symbol" == _typeof12(i) ? i : String(i);
}
function _toPrimitive9(t2, r2) {
  if ("object" != _typeof12(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof12(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray15(arr, i) {
  return _arrayWithHoles14(arr) || _iterableToArrayLimit14(arr, i) || _unsupportedIterableToArray18(arr, i) || _nonIterableRest14();
}
function _nonIterableRest14() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray18(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray17(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray17(o3, minLen);
}
function _arrayLikeToArray17(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit14(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles14(arr) {
  if (Array.isArray(arr)) return arr;
}
function PanelBody(props) {
  var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, type = _usePanelContext.panelType, now2 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig2 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
  var mergedDisabledDate = disabledDate || contextDisabledDate;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var _React$useContext = React122.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
  var matchValues = function matchValues2(date) {
    return values.some(function(singleValue) {
      return singleValue && isSame(generateConfig2, locale2, date, singleValue, type);
    });
  };
  var rows = [];
  for (var row = 0; row < rowNum; row += 1) {
    var rowNode = [];
    var rowStartDate = void 0;
    var _loop = function _loop2() {
      var offset3 = row * colNum + col;
      var currentDate = getCellDate(baseDate, offset3);
      var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, {
        type
      });
      if (col === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          rowNode.push(prefixColumn(rowStartDate));
        }
      }
      var inRange = false;
      var rangeStart = false;
      var rangeEnd = false;
      if (cellSelection && hoverRangeValue) {
        var _hoverRangeValue = _slicedToArray15(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
        inRange = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
        rangeStart = isSame(generateConfig2, locale2, currentDate, hoverStart, type);
        rangeEnd = isSame(generateConfig2, locale2, currentDate, hoverEnd, type);
      }
      var title = titleFormat ? formatValue(currentDate, {
        locale: locale2,
        format: titleFormat,
        generateConfig: generateConfig2
      }) : void 0;
      var inner = React122.createElement("div", {
        className: "".concat(cellPrefixCls, "-inner")
      }, getCellText(currentDate));
      rowNode.push(React122.createElement("td", {
        key: col,
        title,
        className: clsx(cellPrefixCls, classNames.item, _objectSpread9(_defineProperty10(_defineProperty10(_defineProperty10(_defineProperty10(_defineProperty10(_defineProperty10({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date) {
          return isSame(generateConfig2, locale2, currentDate, date, type);
        })), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && // WeekPicker use row instead
        type !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
        style: styles.item,
        onClick: function onClick() {
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        onDoubleClick: function onDoubleClick() {
          if (!disabled && onCellDblClick) {
            onCellDblClick();
          }
        },
        onMouseEnter: function onMouseEnter() {
          if (!disabled) {
            onHover === null || onHover === void 0 || onHover(currentDate);
          }
        },
        onMouseLeave: function onMouseLeave() {
          if (!disabled) {
            onHover === null || onHover === void 0 || onHover(null);
          }
        }
      }, cellRender ? cellRender(currentDate, {
        prefixCls,
        originNode: inner,
        today: now2,
        type,
        locale: locale2
      }) : inner));
    };
    for (var col = 0; col < colNum; col += 1) {
      _loop();
    }
    rows.push(React122.createElement("tr", {
      key: row,
      className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
    }, rowNode));
  }
  return React122.createElement("div", {
    className: clsx("".concat(prefixCls, "-body"), classNames.body),
    style: styles.body
  }, React122.createElement("table", {
    className: clsx("".concat(prefixCls, "-content"), classNames.content),
    style: styles.content
  }, headerCells && React122.createElement("thead", null, React122.createElement("tr", null, headerCells)), React122.createElement("tbody", null, rows)));
}

// node_modules/@rc-component/picker/es/PickerPanel/PanelHeader.js
var React123 = __toESM(require_react());
var HIDDEN_STYLE = {
  visibility: "hidden"
};
function PanelHeader(props) {
  var offset3 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type = _usePanelContext.panelType;
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var _React$useContext = React123.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
  var disabledOffsetPrev = React123.useMemo(function() {
    if (!minDate || !offset3 || !getEnd) {
      return false;
    }
    var prevPanelLimitDate = getEnd(offset3(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type);
  }, [minDate, offset3, pickerValue, getEnd, generateConfig2, locale2, type]);
  var disabledSuperOffsetPrev = React123.useMemo(function() {
    if (!minDate || !superOffset || !getEnd) {
      return false;
    }
    var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type);
  }, [minDate, superOffset, pickerValue, getEnd, generateConfig2, locale2, type]);
  var disabledOffsetNext = React123.useMemo(function() {
    if (!maxDate || !offset3 || !getStart) {
      return false;
    }
    var nextPanelLimitDate = getStart(offset3(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type);
  }, [maxDate, offset3, pickerValue, getStart, generateConfig2, locale2, type]);
  var disabledSuperOffsetNext = React123.useMemo(function() {
    if (!maxDate || !superOffset || !getStart) {
      return false;
    }
    var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type);
  }, [maxDate, superOffset, pickerValue, getStart, generateConfig2, locale2, type]);
  var onOffset = function onOffset2(distance) {
    if (offset3) {
      onChange(offset3(distance, pickerValue));
    }
  };
  var onSuperOffset = function onSuperOffset2(distance) {
    if (superOffset) {
      onChange(superOffset(distance, pickerValue));
    }
  };
  if (hideHeader) {
    return null;
  }
  var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
  var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
  var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
  var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
  return React123.createElement("div", {
    className: clsx(headerPrefixCls, classNames.header),
    style: styles.header
  }, superOffset && React123.createElement("button", {
    type: "button",
    "aria-label": locale2.previousYear,
    onClick: function onClick() {
      return onSuperOffset(-1);
    },
    tabIndex: -1,
    className: clsx(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
    disabled: disabledSuperOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE : {}
  }, superPrevIcon), offset3 && React123.createElement("button", {
    type: "button",
    "aria-label": locale2.previousMonth,
    onClick: function onClick() {
      return onOffset(-1);
    },
    tabIndex: -1,
    className: clsx(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
    disabled: disabledOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE : {}
  }, prevIcon), React123.createElement("div", {
    className: "".concat(headerPrefixCls, "-view")
  }, children), offset3 && React123.createElement("button", {
    type: "button",
    "aria-label": locale2.nextMonth,
    onClick: function onClick() {
      return onOffset(1);
    },
    tabIndex: -1,
    className: clsx(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
    disabled: disabledOffsetNext,
    style: hideNext ? HIDDEN_STYLE : {}
  }, nextIcon), superOffset && React123.createElement("button", {
    type: "button",
    "aria-label": locale2.nextYear,
    onClick: function onClick() {
      return onSuperOffset(1);
    },
    tabIndex: -1,
    className: clsx(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
    disabled: disabledSuperOffsetNext,
    style: hideNext ? HIDDEN_STYLE : {}
  }, superNextIcon));
}
var PanelHeader_default = PanelHeader;

// node_modules/@rc-component/picker/es/PickerPanel/DatePanel/index.js
function _typeof13(o3) {
  "@babel/helpers - typeof";
  return _typeof13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof13(o3);
}
function _extends17() {
  _extends17 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends17.apply(this, arguments);
}
function _defineProperty11(obj, key, value) {
  key = _toPropertyKey10(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey10(t2) {
  var i = _toPrimitive10(t2, "string");
  return "symbol" == _typeof13(i) ? i : String(i);
}
function _toPrimitive10(t2, r2) {
  if ("object" != _typeof13(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof13(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray16(arr, i) {
  return _arrayWithHoles15(arr) || _iterableToArrayLimit15(arr, i) || _unsupportedIterableToArray19(arr, i) || _nonIterableRest15();
}
function _nonIterableRest15() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray19(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray18(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray18(o3, minLen);
}
function _arrayLikeToArray18(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit15(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles15(arr) {
  if (Array.isArray(arr)) return arr;
}
function DatePanel(props) {
  var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
  var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var isWeek = mode === "week";
  var _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray16(_useInfo, 2), info = _useInfo2[0], now2 = _useInfo2[1];
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
  var monthStartDate = generateConfig2.setDate(pickerValue, 1);
  var baseDate = getWeekStartDate(locale2.locale, generateConfig2, monthStartDate);
  var month = generateConfig2.getMonth(pickerValue);
  var showPrefixColumn = showWeek === void 0 ? isWeek : showWeek;
  var prefixColumn = showPrefixColumn ? function(date) {
    var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date, {
      type: "week"
    });
    return React124.createElement("td", {
      key: "week",
      className: clsx(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty11({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: function onClick() {
        if (!disabled) {
          onSelect(date);
        }
      },
      onMouseEnter: function onMouseEnter() {
        if (!disabled) {
          onHover === null || onHover === void 0 || onHover(date);
        }
      },
      onMouseLeave: function onMouseLeave() {
        if (!disabled) {
          onHover === null || onHover === void 0 || onHover(null);
        }
      }
    }, React124.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, generateConfig2.locale.getWeek(locale2.locale, date)));
  } : null;
  var headerCells = [];
  var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
  if (prefixColumn) {
    headerCells.push(React124.createElement("th", {
      key: "empty"
    }, React124.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, locale2.week)));
  }
  for (var i = 0; i < WEEK_DAY_COUNT; i += 1) {
    headerCells.push(React124.createElement("th", {
      key: i
    }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
  }
  var getCellDate = function getCellDate2(date, offset3) {
    return generateConfig2.addDate(date, offset3);
  };
  var getCellText = function getCellText2(date) {
    return formatValue(date, {
      locale: locale2,
      format: locale2.cellDateFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2(date) {
    var classObj = _defineProperty11(_defineProperty11({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth(generateConfig2, date, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate(generateConfig2, date, now2));
    return classObj;
  };
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var yearNode = React124.createElement("button", {
    type: "button",
    "aria-label": locale2.yearSelect,
    key: "year",
    onClick: function onClick() {
      onModeChange("year", pickerValue);
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  var monthNode = React124.createElement("button", {
    type: "button",
    "aria-label": locale2.monthSelect,
    key: "month",
    onClick: function onClick() {
      onModeChange("month", pickerValue);
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-month-btn")
  }, locale2.monthFormat ? formatValue(pickerValue, {
    locale: locale2,
    format: locale2.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]);
  var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return React124.createElement(PanelContext.Provider, {
    value: info
  }, React124.createElement("div", {
    className: clsx(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week"))
  }, React124.createElement(PanelHeader_default, {
    offset: function offset3(distance) {
      return generateConfig2.addMonth(pickerValue, distance);
    },
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date) {
      return generateConfig2.setDate(date, 1);
    },
    getEnd: function getEnd(date) {
      var clone = generateConfig2.setDate(date, 1);
      clone = generateConfig2.addMonth(clone, 1);
      return generateConfig2.addDate(clone, -1);
    }
  }, monthYearNodes), React124.createElement(PanelBody, _extends17({
    titleFormat: locale2.fieldDateFormat
  }, props, {
    colNum: WEEK_DAY_COUNT,
    rowNum: 6,
    baseDate,
    headerCells,
    getCellDate,
    getCellText,
    getCellClassName,
    prefixColumn,
    cellSelection: !isWeek
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/DateTimePanel/index.js
var React129 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/index.js
var React128 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
var React127 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
var React126 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/useScrollTo.js
var React125 = __toESM(require_react());
var SPEED_PTG = 1 / 3;
function useScrollTo(ulRef, value) {
  var scrollingRef = React125.useRef(false);
  var scrollRafRef = React125.useRef(null);
  var scrollDistRef = React125.useRef(null);
  var isScrolling = function isScrolling2() {
    return scrollingRef.current;
  };
  var stopScroll = function stopScroll2() {
    raf_default.cancel(scrollRafRef.current);
    scrollingRef.current = false;
  };
  var scrollRafTimesRef = React125.useRef();
  var startScroll = function startScroll2() {
    var ul = ulRef.current;
    scrollDistRef.current = null;
    scrollRafTimesRef.current = 0;
    if (ul) {
      var targetLi = ul.querySelector('[data-value="'.concat(value, '"]'));
      var firstLi = ul.querySelector("li");
      var doScroll = function doScroll2() {
        stopScroll();
        scrollingRef.current = true;
        scrollRafTimesRef.current += 1;
        var currentTop = ul.scrollTop;
        var firstLiTop = firstLi.offsetTop;
        var targetLiTop = targetLi.offsetTop;
        var targetTop = targetLiTop - firstLiTop;
        if (targetLiTop === 0 && targetLi !== firstLi || !isVisible_default(ul)) {
          if (scrollRafTimesRef.current <= 5) {
            scrollRafRef.current = raf_default(doScroll2);
          }
          return;
        }
        var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
        var dist = Math.abs(targetTop - nextTop);
        if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
          stopScroll();
          return;
        }
        scrollDistRef.current = dist;
        if (dist <= 1) {
          ul.scrollTop = targetTop;
          stopScroll();
          return;
        }
        ul.scrollTop = nextTop;
        scrollRafRef.current = raf_default(doScroll2);
      };
      if (targetLi && firstLi) {
        doScroll();
      }
    }
  };
  var syncScroll = useEvent_default(startScroll);
  return [syncScroll, stopScroll, isScrolling];
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
function _typeof14(o3) {
  "@babel/helpers - typeof";
  return _typeof14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof14(o3);
}
function _defineProperty12(obj, key, value) {
  key = _toPropertyKey11(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey11(t2) {
  var i = _toPrimitive11(t2, "string");
  return "symbol" == _typeof14(i) ? i : String(i);
}
function _toPrimitive11(t2, r2) {
  if ("object" != _typeof14(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof14(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toConsumableArray6(arr) {
  return _arrayWithoutHoles5(arr) || _iterableToArray5(arr) || _unsupportedIterableToArray20(arr) || _nonIterableSpread5();
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles5(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray19(arr);
}
function _slicedToArray17(arr, i) {
  return _arrayWithHoles16(arr) || _iterableToArrayLimit16(arr, i) || _unsupportedIterableToArray20(arr, i) || _nonIterableRest16();
}
function _nonIterableRest16() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray20(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray19(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray19(o3, minLen);
}
function _arrayLikeToArray19(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit16(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles16(arr) {
  if (Array.isArray(arr)) return arr;
}
var SCROLL_DELAY = 300;
function flattenUnits(units) {
  return units.map(function(_ref) {
    var value = _ref.value, label = _ref.label, disabled = _ref.disabled;
    return [value, label, disabled].join(",");
  }).join(";");
}
function TimeColumn(props) {
  var units = props.units, value = props.value, optionalValue = props.optionalValue, type = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now2 = _usePanelContext.now, locale2 = _usePanelContext.locale, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
  var ulRef = React126.useRef(null);
  var checkDelayRef = React126.useRef();
  var clearDelayCheck = function clearDelayCheck2() {
    clearTimeout(checkDelayRef.current);
  };
  var _useScrollTo = useScrollTo(ulRef, value !== null && value !== void 0 ? value : optionalValue), _useScrollTo2 = _slicedToArray17(_useScrollTo, 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
  useLayoutEffect_default(function() {
    syncScroll();
    clearDelayCheck();
    return function() {
      stopScroll();
      clearDelayCheck();
    };
  }, [value, optionalValue, flattenUnits(units)]);
  var onInternalScroll = function onInternalScroll2(event) {
    clearDelayCheck();
    var target = event.target;
    if (!isScrolling() && changeOnScroll) {
      checkDelayRef.current = setTimeout(function() {
        var ul = ulRef.current;
        var firstLiTop = ul.querySelector("li").offsetTop;
        var liList = Array.from(ul.querySelectorAll("li"));
        var liTopList = liList.map(function(li) {
          return li.offsetTop - firstLiTop;
        });
        var liDistList = liTopList.map(function(top, index2) {
          if (units[index2].disabled) {
            return Number.MAX_SAFE_INTEGER;
          }
          return Math.abs(top - target.scrollTop);
        });
        var minDist = Math.min.apply(Math, _toConsumableArray6(liDistList));
        var minDistIndex = liDistList.findIndex(function(dist) {
          return dist === minDist;
        });
        var targetUnit = units[minDistIndex];
        if (targetUnit && !targetUnit.disabled) {
          onChange(targetUnit.value);
        }
      }, SCROLL_DELAY);
    }
  };
  var columnPrefixCls = "".concat(panelPrefixCls, "-column");
  return React126.createElement("ul", {
    className: columnPrefixCls,
    ref: ulRef,
    "data-type": type,
    onScroll: onInternalScroll
  }, units.map(function(_ref2) {
    var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
    var inner = React126.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, label);
    return React126.createElement("li", {
      key: unitValue,
      style: styles.item,
      className: clsx(cellPrefixCls, classNames.item, _defineProperty12(_defineProperty12({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: function onClick() {
        if (!disabled) {
          onChange(unitValue);
        }
      },
      onDoubleClick: function onDoubleClick() {
        if (!disabled && onDblClick) {
          onDblClick();
        }
      },
      onMouseEnter: function onMouseEnter() {
        onHover(unitValue);
      },
      onMouseLeave: function onMouseLeave() {
        onHover(null);
      },
      "data-value": unitValue
    }, cellRender ? cellRender(unitValue, {
      prefixCls,
      originNode: inner,
      today: now2,
      type: "time",
      subType: type,
      locale: locale2
    }) : inner);
  }));
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
function _extends18() {
  _extends18 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends18.apply(this, arguments);
}
function _slicedToArray18(arr, i) {
  return _arrayWithHoles17(arr) || _iterableToArrayLimit17(arr, i) || _unsupportedIterableToArray21(arr, i) || _nonIterableRest17();
}
function _nonIterableRest17() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray21(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray20(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray20(o3, minLen);
}
function _arrayLikeToArray20(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit17(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles17(arr) {
  if (Array.isArray(arr)) return arr;
}
function isAM(hour) {
  return hour < 12;
}
function TimePanelBody(props) {
  var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, values = _usePanelContext.values, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {
  } : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
  var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
  var _React$useContext = React127.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
  var _useTimeInfo = useTimeInfo(generateConfig2, props, value), _useTimeInfo2 = _slicedToArray18(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
  var getUnitValue2 = function getUnitValue3(func) {
    var valueUnitVal = value && generateConfig2[func](value);
    var pickerUnitValue = pickerValue && generateConfig2[func](pickerValue);
    return [valueUnitVal, pickerUnitValue];
  };
  var _getUnitValue = getUnitValue2("getHour"), _getUnitValue2 = _slicedToArray18(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
  var _getUnitValue3 = getUnitValue2("getMinute"), _getUnitValue4 = _slicedToArray18(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
  var _getUnitValue5 = getUnitValue2("getSecond"), _getUnitValue6 = _slicedToArray18(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
  var _getUnitValue7 = getUnitValue2("getMillisecond"), _getUnitValue8 = _slicedToArray18(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
  var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
  var hourUnits = React127.useMemo(function() {
    if (!showMeridiem) {
      return rowHourUnits;
    }
    return isAM(hour) ? rowHourUnits.filter(function(h) {
      return isAM(h.value);
    }) : rowHourUnits.filter(function(h) {
      return !isAM(h.value);
    });
  }, [hour, rowHourUnits, showMeridiem]);
  var getEnabled = function getEnabled2(units, val) {
    var _enabledUnits$;
    var enabledUnits = units.filter(function(unit2) {
      return !unit2.disabled;
    });
    return val !== null && val !== void 0 ? val : (
      // Fallback to enabled value
      enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value
    );
  };
  var validHour = getEnabled(rowHourUnits, hour);
  var minuteUnits = React127.useMemo(function() {
    return getMinuteUnits(validHour);
  }, [getMinuteUnits, validHour]);
  var validMinute = getEnabled(minuteUnits, minute);
  var secondUnits = React127.useMemo(function() {
    return getSecondUnits(validHour, validMinute);
  }, [getSecondUnits, validHour, validMinute]);
  var validSecond = getEnabled(secondUnits, second);
  var millisecondUnits = React127.useMemo(function() {
    return getMillisecondUnits(validHour, validMinute, validSecond);
  }, [getMillisecondUnits, validHour, validMinute, validSecond]);
  var validMillisecond = getEnabled(millisecondUnits, millisecond);
  var meridiemUnits = React127.useMemo(function() {
    if (!showMeridiem) {
      return [];
    }
    var base = generateConfig2.getNow();
    var amDate = generateConfig2.setHour(base, 6);
    var pmDate = generateConfig2.setHour(base, 18);
    var formatMeridiem = function formatMeridiem2(date, defaultLabel) {
      var cellMeridiemFormat = locale2.cellMeridiemFormat;
      return cellMeridiemFormat ? formatValue(date, {
        generateConfig: generateConfig2,
        locale: locale2,
        format: cellMeridiemFormat
      }) : defaultLabel;
    };
    return [{
      label: formatMeridiem(amDate, "AM"),
      value: "am",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || !isAM(h.value);
      })
    }, {
      label: formatMeridiem(pmDate, "PM"),
      value: "pm",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || isAM(h.value);
      })
    }];
  }, [rowHourUnits, showMeridiem, generateConfig2, locale2]);
  var triggerChange = function triggerChange2(nextDate) {
    var validateDate = getValidTime(nextDate);
    onSelect(validateDate);
  };
  var triggerDateTmpl = React127.useMemo(function() {
    var tmpl = value || pickerValue || generateConfig2.getNow();
    var isNotNull = function isNotNull2(num) {
      return num !== null && num !== void 0;
    };
    if (isNotNull(hour)) {
      tmpl = generateConfig2.setHour(tmpl, hour);
      tmpl = generateConfig2.setMinute(tmpl, minute);
      tmpl = generateConfig2.setSecond(tmpl, second);
      tmpl = generateConfig2.setMillisecond(tmpl, millisecond);
    } else if (isNotNull(pickerHour)) {
      tmpl = generateConfig2.setHour(tmpl, pickerHour);
      tmpl = generateConfig2.setMinute(tmpl, pickerMinute);
      tmpl = generateConfig2.setSecond(tmpl, pickerSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, pickerMillisecond);
    } else if (isNotNull(validHour)) {
      tmpl = generateConfig2.setHour(tmpl, validHour);
      tmpl = generateConfig2.setMinute(tmpl, validMinute);
      tmpl = generateConfig2.setSecond(tmpl, validSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, validMillisecond);
    }
    return tmpl;
  }, [value, pickerValue, hour, minute, second, millisecond, validHour, validMinute, validSecond, validMillisecond, pickerHour, pickerMinute, pickerSecond, pickerMillisecond, generateConfig2]);
  var fillColumnValue = function fillColumnValue2(val, func) {
    if (val === null) {
      return null;
    }
    return generateConfig2[func](triggerDateTmpl, val);
  };
  var getNextHourTime = function getNextHourTime2(val) {
    return fillColumnValue(val, "setHour");
  };
  var getNextMinuteTime = function getNextMinuteTime2(val) {
    return fillColumnValue(val, "setMinute");
  };
  var getNextSecondTime = function getNextSecondTime2(val) {
    return fillColumnValue(val, "setSecond");
  };
  var getNextMillisecondTime = function getNextMillisecondTime2(val) {
    return fillColumnValue(val, "setMillisecond");
  };
  var getMeridiemTime = function getMeridiemTime2(val) {
    if (val === null) {
      return null;
    }
    if (val === "am" && !isAM(hour)) {
      return generateConfig2.setHour(triggerDateTmpl, hour - 12);
    } else if (val === "pm" && isAM(hour)) {
      return generateConfig2.setHour(triggerDateTmpl, hour + 12);
    }
    return triggerDateTmpl;
  };
  var onHourChange = function onHourChange2(val) {
    triggerChange(getNextHourTime(val));
  };
  var onMinuteChange = function onMinuteChange2(val) {
    triggerChange(getNextMinuteTime(val));
  };
  var onSecondChange = function onSecondChange2(val) {
    triggerChange(getNextSecondTime(val));
  };
  var onMillisecondChange = function onMillisecondChange2(val) {
    triggerChange(getNextMillisecondTime(val));
  };
  var onMeridiemChange = function onMeridiemChange2(val) {
    triggerChange(getMeridiemTime(val));
  };
  var onHourHover = function onHourHover2(val) {
    onHover(getNextHourTime(val));
  };
  var onMinuteHover = function onMinuteHover2(val) {
    onHover(getNextMinuteTime(val));
  };
  var onSecondHover = function onSecondHover2(val) {
    onHover(getNextSecondTime(val));
  };
  var onMillisecondHover = function onMillisecondHover2(val) {
    onHover(getNextMillisecondTime(val));
  };
  var onMeridiemHover = function onMeridiemHover2(val) {
    onHover(getMeridiemTime(val));
  };
  var sharedColumnProps = {
    onDblClick: onCellDblClick,
    changeOnScroll
  };
  return React127.createElement("div", {
    className: clsx("".concat(prefixCls, "-content"), classNames.content),
    style: styles.content
  }, showHour && React127.createElement(TimeColumn, _extends18({
    units: hourUnits,
    value: hour,
    optionalValue: pickerHour,
    type: "hour",
    onChange: onHourChange,
    onHover: onHourHover
  }, sharedColumnProps)), showMinute && React127.createElement(TimeColumn, _extends18({
    units: minuteUnits,
    value: minute,
    optionalValue: pickerMinute,
    type: "minute",
    onChange: onMinuteChange,
    onHover: onMinuteHover
  }, sharedColumnProps)), showSecond && React127.createElement(TimeColumn, _extends18({
    units: secondUnits,
    value: second,
    optionalValue: pickerSecond,
    type: "second",
    onChange: onSecondChange,
    onHover: onSecondHover
  }, sharedColumnProps)), showMillisecond && React127.createElement(TimeColumn, _extends18({
    units: millisecondUnits,
    value: millisecond,
    optionalValue: pickerMillisecond,
    type: "millisecond",
    onChange: onMillisecondChange,
    onHover: onMillisecondHover
  }, sharedColumnProps)), showMeridiem && React127.createElement(TimeColumn, _extends18({
    units: meridiemUnits,
    value: meridiem,
    type: "meridiem",
    onChange: onMeridiemChange,
    onHover: onMeridiemHover
  }, sharedColumnProps)));
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/index.js
function _slicedToArray19(arr, i) {
  return _arrayWithHoles18(arr) || _iterableToArrayLimit18(arr, i) || _unsupportedIterableToArray22(arr, i) || _nonIterableRest18();
}
function _nonIterableRest18() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray22(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray21(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray21(o3, minLen);
}
function _arrayLikeToArray21(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit18(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles18(arr) {
  if (Array.isArray(arr)) return arr;
}
function TimePanel(props) {
  var prefixCls = props.prefixCls, value = props.value, locale2 = props.locale, generateConfig2 = props.generateConfig, showTime = props.showTime;
  var _ref = showTime || {}, format2 = _ref.format;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray19(_useInfo, 1), info = _useInfo2[0];
  return React128.createElement(PanelContext.Provider, {
    value: info
  }, React128.createElement("div", {
    className: clsx(panelPrefixCls)
  }, React128.createElement(PanelHeader_default, null, value ? formatValue(value, {
    locale: locale2,
    format: format2,
    generateConfig: generateConfig2
  }) : ""), React128.createElement(TimePanelBody, showTime)));
}

// node_modules/@rc-component/picker/es/PickerPanel/DateTimePanel/index.js
function _extends19() {
  _extends19 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends19.apply(this, arguments);
}
function _slicedToArray20(arr, i) {
  return _arrayWithHoles19(arr) || _iterableToArrayLimit19(arr, i) || _unsupportedIterableToArray23(arr, i) || _nonIterableRest19();
}
function _nonIterableRest19() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray23(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray22(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray22(o3, minLen);
}
function _arrayLikeToArray22(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit19(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles19(arr) {
  if (Array.isArray(arr)) return arr;
}
function DateTimePanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
  var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
  var _useTimeInfo = useTimeInfo(generateConfig2, showTime), _useTimeInfo2 = _slicedToArray20(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
  var mergeTime = function mergeTime2(date) {
    if (value) {
      return fillTime(generateConfig2, date, value);
    }
    return fillTime(generateConfig2, date, pickerValue);
  };
  var onDateHover = function onDateHover2(date) {
    onHover === null || onHover === void 0 || onHover(date ? mergeTime(date) : date);
  };
  var onDateSelect = function onDateSelect2(date) {
    var cloneDate = mergeTime(date);
    onSelect(getValidTime(cloneDate, cloneDate));
  };
  return React129.createElement("div", {
    className: panelPrefixCls
  }, React129.createElement(DatePanel, _extends19({}, props, {
    onSelect: onDateSelect,
    onHover: onDateHover
  })), React129.createElement(TimePanel, props));
}

// node_modules/@rc-component/picker/es/PickerPanel/DecadePanel/index.js
var React130 = __toESM(require_react());
function _typeof15(o3) {
  "@babel/helpers - typeof";
  return _typeof15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof15(o3);
}
function _extends20() {
  _extends20 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends20.apply(this, arguments);
}
function _defineProperty13(obj, key, value) {
  key = _toPropertyKey12(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey12(t2) {
  var i = _toPrimitive12(t2, "string");
  return "symbol" == _typeof15(i) ? i : String(i);
}
function _toPrimitive12(t2, r2) {
  if ("object" != _typeof15(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof15(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray21(arr, i) {
  return _arrayWithHoles20(arr) || _iterableToArrayLimit20(arr, i) || _unsupportedIterableToArray24(arr, i) || _nonIterableRest20();
}
function _nonIterableRest20() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray24(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray23(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray23(o3, minLen);
}
function _arrayLikeToArray23(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit20(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles20(arr) {
  if (Array.isArray(arr)) return arr;
}
function DecadePanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
  var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
  var _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray21(_useInfo, 1), info = _useInfo2[0];
  var getStartYear = function getStartYear2(date) {
    var startYear = Math.floor(generateConfig2.getYear(date) / 100) * 100;
    return generateConfig2.setYear(date, startYear);
  };
  var getEndYear = function getEndYear2(date) {
    var startYear = getStartYear(date);
    return generateConfig2.addYear(startYear, 99);
  };
  var startYearDate = getStartYear(pickerValue);
  var endYearDate = getEndYear(pickerValue);
  var baseDate = generateConfig2.addYear(startYearDate, -10);
  var getCellDate = function getCellDate2(date, offset3) {
    return generateConfig2.addYear(date, offset3 * 10);
  };
  var getCellText = function getCellText2(date) {
    var cellYearFormat = locale2.cellYearFormat;
    var startYearStr = formatValue(date, {
      locale: locale2,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    var endYearStr = formatValue(generateConfig2.addYear(date, 9), {
      locale: locale2,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    return "".concat(startYearStr, "-").concat(endYearStr);
  };
  var getCellClassName = function getCellClassName2(date) {
    return _defineProperty13({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig2, date, startYearDate) || isSameDecade(generateConfig2, date, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date));
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var baseStartDate = generateConfig2.setDate(currentDate, 1);
    var baseStartMonth = generateConfig2.setMonth(baseStartDate, 0);
    var baseStartYear = generateConfig2.setYear(baseStartMonth, Math.floor(generateConfig2.getYear(baseStartMonth) / 10) * 10);
    var baseEndYear = generateConfig2.addYear(baseStartYear, 10);
    var baseEndDate = generateConfig2.addDate(baseEndYear, -1);
    return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
  } : null;
  var yearNode = "".concat(formatValue(startYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }), "-").concat(formatValue(endYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return React130.createElement(PanelContext.Provider, {
    value: info
  }, React130.createElement("div", {
    className: panelPrefixCls
  }, React130.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance * 100);
    },
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), React130.createElement(PanelBody, _extends20({}, props, {
    disabledDate: mergedDisabledDate,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/MonthPanel/index.js
var React131 = __toESM(require_react());
function _typeof16(o3) {
  "@babel/helpers - typeof";
  return _typeof16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof16(o3);
}
function _extends21() {
  _extends21 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends21.apply(this, arguments);
}
function _defineProperty14(obj, key, value) {
  key = _toPropertyKey13(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey13(t2) {
  var i = _toPrimitive13(t2, "string");
  return "symbol" == _typeof16(i) ? i : String(i);
}
function _toPrimitive13(t2, r2) {
  if ("object" != _typeof16(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof16(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray22(arr, i) {
  return _arrayWithHoles21(arr) || _iterableToArrayLimit21(arr, i) || _unsupportedIterableToArray25(arr, i) || _nonIterableRest21();
}
function _nonIterableRest21() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray25(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray24(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray24(o3, minLen);
}
function _arrayLikeToArray24(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit21(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles21(arr) {
  if (Array.isArray(arr)) return arr;
}
function MonthPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-month-panel");
  var _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray22(_useInfo, 1), info = _useInfo2[0];
  var baseDate = generateConfig2.setMonth(pickerValue, 0);
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var getCellDate = function getCellDate2(date, offset3) {
    return generateConfig2.addMonth(date, offset3);
  };
  var getCellText = function getCellText2(date) {
    var month = generateConfig2.getMonth(date);
    return locale2.monthFormat ? formatValue(date, {
      locale: locale2,
      format: locale2.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[month];
  };
  var getCellClassName = function getCellClassName2() {
    return _defineProperty14({}, "".concat(prefixCls, "-cell-in-view"), true);
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startDate = generateConfig2.setDate(currentDate, 1);
    var nextMonthStartDate = generateConfig2.setMonth(startDate, generateConfig2.getMonth(startDate) + 1);
    var endDate = generateConfig2.addDate(nextMonthStartDate, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null;
  var yearNode = React131.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": locale2.yearSelect,
    onClick: function onClick() {
      onModeChange("year");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return React131.createElement(PanelContext.Provider, {
    value: info
  }, React131.createElement("div", {
    className: panelPrefixCls
  }, React131.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date) {
      return generateConfig2.setMonth(date, 0);
    },
    getEnd: function getEnd(date) {
      return generateConfig2.setMonth(date, 11);
    }
  }, yearNode), React131.createElement(PanelBody, _extends21({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale2.fieldMonthFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/QuarterPanel/index.js
var React132 = __toESM(require_react());
function _typeof17(o3) {
  "@babel/helpers - typeof";
  return _typeof17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof17(o3);
}
function _extends22() {
  _extends22 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends22.apply(this, arguments);
}
function _defineProperty15(obj, key, value) {
  key = _toPropertyKey14(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey14(t2) {
  var i = _toPrimitive14(t2, "string");
  return "symbol" == _typeof17(i) ? i : String(i);
}
function _toPrimitive14(t2, r2) {
  if ("object" != _typeof17(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof17(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray23(arr, i) {
  return _arrayWithHoles22(arr) || _iterableToArrayLimit22(arr, i) || _unsupportedIterableToArray26(arr, i) || _nonIterableRest22();
}
function _nonIterableRest22() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray26(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray25(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray25(o3, minLen);
}
function _arrayLikeToArray25(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit22(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles22(arr) {
  if (Array.isArray(arr)) return arr;
}
function QuarterPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
  var _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray23(_useInfo, 1), info = _useInfo2[0];
  var baseDate = generateConfig2.setMonth(pickerValue, 0);
  var getCellDate = function getCellDate2(date, offset3) {
    return generateConfig2.addMonth(date, offset3 * 3);
  };
  var getCellText = function getCellText2(date) {
    return formatValue(date, {
      locale: locale2,
      format: locale2.cellQuarterFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2() {
    return _defineProperty15({}, "".concat(prefixCls, "-cell-in-view"), true);
  };
  var yearNode = React132.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": locale2.yearSelect,
    onClick: function onClick() {
      onModeChange("year");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return React132.createElement(PanelContext.Provider, {
    value: info
  }, React132.createElement("div", {
    className: panelPrefixCls
  }, React132.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date) {
      return generateConfig2.setMonth(date, 0);
    },
    getEnd: function getEnd(date) {
      return generateConfig2.setMonth(date, 11);
    }
  }, yearNode), React132.createElement(PanelBody, _extends22({}, props, {
    titleFormat: locale2.fieldQuarterFormat,
    colNum: 4,
    rowNum: 1,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/WeekPanel/index.js
var React133 = __toESM(require_react());
function _typeof18(o3) {
  "@babel/helpers - typeof";
  return _typeof18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof18(o3);
}
function _extends23() {
  _extends23 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends23.apply(this, arguments);
}
function _defineProperty16(obj, key, value) {
  key = _toPropertyKey15(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey15(t2) {
  var i = _toPrimitive15(t2, "string");
  return "symbol" == _typeof18(i) ? i : String(i);
}
function _toPrimitive15(t2, r2) {
  if ("object" != _typeof18(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof18(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray24(arr, i) {
  return _arrayWithHoles23(arr) || _iterableToArrayLimit23(arr, i) || _unsupportedIterableToArray27(arr, i) || _nonIterableRest23();
}
function _nonIterableRest23() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray27(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray26(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray26(o3, minLen);
}
function _arrayLikeToArray26(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit23(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles23(arr) {
  if (Array.isArray(arr)) return arr;
}
function WeekPanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
  var localeName = locale2.locale;
  var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
  var rowClassName = function rowClassName2(currentDate) {
    var rangeCls = {};
    if (hoverRangeValue) {
      var _hoverRangeValue = _slicedToArray24(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
      var isRangeStart = isSameWeek(generateConfig2, localeName, rangeStart, currentDate);
      var isRangeEnd = isSameWeek(generateConfig2, localeName, rangeEnd, currentDate);
      rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
      rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
      rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, currentDate);
    }
    if (hoverValue) {
      rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date) {
        return isSameWeek(generateConfig2, localeName, currentDate, date);
      });
    }
    return clsx(
      rowPrefixCls,
      _defineProperty16({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig2, localeName, value, currentDate)),
      // Patch for hover range
      rangeCls
    );
  };
  return React133.createElement(DatePanel, _extends23({}, props, {
    mode: "week",
    panelName: "week",
    rowClassName
  }));
}

// node_modules/@rc-component/picker/es/PickerPanel/YearPanel/index.js
var React134 = __toESM(require_react());
function _typeof19(o3) {
  "@babel/helpers - typeof";
  return _typeof19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof19(o3);
}
function _extends24() {
  _extends24 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends24.apply(this, arguments);
}
function _defineProperty17(obj, key, value) {
  key = _toPropertyKey16(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey16(t2) {
  var i = _toPrimitive16(t2, "string");
  return "symbol" == _typeof19(i) ? i : String(i);
}
function _toPrimitive16(t2, r2) {
  if ("object" != _typeof19(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof19(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray25(arr, i) {
  return _arrayWithHoles24(arr) || _iterableToArrayLimit24(arr, i) || _unsupportedIterableToArray28(arr, i) || _nonIterableRest24();
}
function _nonIterableRest24() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray28(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray27(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray27(o3, minLen);
}
function _arrayLikeToArray27(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit24(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles24(arr) {
  if (Array.isArray(arr)) return arr;
}
function YearPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-year-panel");
  var _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray25(_useInfo, 1), info = _useInfo2[0];
  var getStartYear = function getStartYear2(date) {
    var startYear = Math.floor(generateConfig2.getYear(date) / 10) * 10;
    return generateConfig2.setYear(date, startYear);
  };
  var getEndYear = function getEndYear2(date) {
    var startYear = getStartYear(date);
    return generateConfig2.addYear(startYear, 9);
  };
  var startYearDate = getStartYear(pickerValue);
  var endYearDate = getEndYear(pickerValue);
  var baseDate = generateConfig2.addYear(startYearDate, -1);
  var getCellDate = function getCellDate2(date, offset3) {
    return generateConfig2.addYear(date, offset3);
  };
  var getCellText = function getCellText2(date) {
    return formatValue(date, {
      locale: locale2,
      format: locale2.cellYearFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2(date) {
    return _defineProperty17({}, "".concat(prefixCls, "-cell-in-view"), isSameYear(generateConfig2, date, startYearDate) || isSameYear(generateConfig2, date, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date));
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startMonth = generateConfig2.setMonth(currentDate, 0);
    var startDate = generateConfig2.setDate(startMonth, 1);
    var endMonth = generateConfig2.addYear(startDate, 1);
    var endDate = generateConfig2.addDate(endMonth, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null;
  var yearNode = React134.createElement("button", {
    type: "button",
    key: "decade",
    "aria-label": locale2.decadeSelect,
    onClick: function onClick() {
      onModeChange("decade");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-decade-btn")
  }, formatValue(startYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }), "-", formatValue(endYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return React134.createElement(PanelContext.Provider, {
    value: info
  }, React134.createElement("div", {
    className: panelPrefixCls
  }, React134.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance * 10);
    },
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), React134.createElement(PanelBody, _extends24({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale2.fieldYearFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/index.js
function _typeof20(o3) {
  "@babel/helpers - typeof";
  return _typeof20 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof20(o3);
}
function _extends25() {
  _extends25 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends25.apply(this, arguments);
}
function ownKeys9(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread10(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys9(Object(t2), true).forEach(function(r3) {
      _defineProperty18(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys9(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty18(obj, key, value) {
  key = _toPropertyKey17(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey17(t2) {
  var i = _toPrimitive17(t2, "string");
  return "symbol" == _typeof20(i) ? i : String(i);
}
function _toPrimitive17(t2, r2) {
  if ("object" != _typeof20(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof20(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toConsumableArray7(arr) {
  return _arrayWithoutHoles6(arr) || _iterableToArray6(arr) || _unsupportedIterableToArray29(arr) || _nonIterableSpread6();
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles6(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray28(arr);
}
function _slicedToArray26(arr, i) {
  return _arrayWithHoles25(arr) || _iterableToArrayLimit25(arr, i) || _unsupportedIterableToArray29(arr, i) || _nonIterableRest25();
}
function _nonIterableRest25() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray29(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray28(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray28(o3, minLen);
}
function _arrayLikeToArray28(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit25(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles25(arr) {
  if (Array.isArray(arr)) return arr;
}
var DefaultComponents = {
  date: DatePanel,
  datetime: DateTimePanel,
  week: WeekPanel,
  month: MonthPanel,
  quarter: QuarterPanel,
  year: YearPanel,
  decade: DecadePanel,
  time: TimePanel
};
function PickerPanel(props, ref) {
  var panelClassNames = props.classNames, panelStyles = props.styles, locale2 = props.locale, generateConfig2 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
  var _ref = React135.useContext(context_default4) || {}, contextPrefixCls = _ref.prefixCls, pickerClassNames = _ref.classNames, pickerStyles = _ref.styles;
  var mergedPrefixCls = contextPrefixCls || prefixCls || "rc-picker";
  var rootRef = React135.useRef();
  React135.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current
    };
  });
  var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray26(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
  var filledLocale = useLocale(locale2, localeTimeProps);
  var internalPicker = picker === "date" && showTime ? "datetime" : picker;
  var mergedShowTime = React135.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, filledLocale]);
  var now2 = generateConfig2.getNow();
  var _useControlledState = useControlledState(picker || "date", mode), _useControlledState2 = _slicedToArray26(_useControlledState, 2), mergedMode = _useControlledState2[0], setMergedMode = _useControlledState2[1];
  var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  var toggleDates = useToggleDates(generateConfig2, locale2, internalPicker);
  var _useControlledState3 = useControlledState(defaultValue, value), _useControlledState4 = _slicedToArray26(_useControlledState3, 2), innerValue = _useControlledState4[0], setMergedValue = _useControlledState4[1];
  var mergedValue = React135.useMemo(function() {
    var values = toArray2(innerValue).filter(function(val) {
      return val;
    });
    return multiple ? values : values.slice(0, 1);
  }, [innerValue, multiple]);
  var triggerChange = useEvent_default(function(nextValue) {
    setMergedValue(nextValue);
    if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index2) {
      return !isSame(generateConfig2, locale2, ori, nextValue[index2], internalPicker);
    }))) {
      onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
    }
  });
  var onInternalSelect = useEvent_default(function(newDate) {
    onSelect === null || onSelect === void 0 || onSelect(newDate);
    if (mergedMode === picker) {
      var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
      triggerChange(nextValues);
    }
  });
  var _useControlledState5 = useControlledState(defaultPickerValue || mergedValue[0] || now2, pickerValue), _useControlledState6 = _slicedToArray26(_useControlledState5, 2), mergedPickerValue = _useControlledState6[0], setInternalPickerValue = _useControlledState6[1];
  React135.useEffect(function() {
    if (mergedValue[0] && !pickerValue) {
      setInternalPickerValue(mergedValue[0]);
    }
  }, [mergedValue[0]]);
  var triggerPanelChange = function triggerPanelChange2(viewDate, nextMode) {
    onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
  };
  var setPickerValue = function setPickerValue2(nextPickerValue) {
    var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setInternalPickerValue(nextPickerValue);
    onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
    if (triggerPanelEvent) {
      triggerPanelChange(nextPickerValue);
    }
  };
  var triggerModeChange = function triggerModeChange2(nextMode, viewDate) {
    setMergedMode(nextMode);
    if (viewDate) {
      setPickerValue(viewDate);
    }
    triggerPanelChange(viewDate, nextMode);
  };
  var onPanelValueSelect = function onPanelValueSelect2(nextValue) {
    onInternalSelect(nextValue);
    setPickerValue(nextValue);
    if (mergedMode !== picker) {
      var decadeYearQueue = ["decade", "year"];
      var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
      var pickerQueue = {
        quarter: [].concat(decadeYearQueue, ["quarter"]),
        week: [].concat(_toConsumableArray7(decadeYearMonthQueue), ["week"]),
        date: [].concat(_toConsumableArray7(decadeYearMonthQueue), ["date"])
      };
      var queue = pickerQueue[picker] || decadeYearMonthQueue;
      var index2 = queue.indexOf(mergedMode);
      var nextMode = queue[index2 + 1];
      if (nextMode) {
        triggerModeChange(nextMode, nextValue);
      }
    }
  };
  var hoverRangeDate = React135.useMemo(function() {
    var start;
    var end;
    if (Array.isArray(hoverRangeValue)) {
      var _hoverRangeValue = _slicedToArray26(hoverRangeValue, 2);
      start = _hoverRangeValue[0];
      end = _hoverRangeValue[1];
    } else {
      start = hoverRangeValue;
    }
    if (!start && !end) {
      return null;
    }
    start = start || end;
    end = end || start;
    return generateConfig2.isAfter(start, end) ? [end, start] : [start, end];
  }, [hoverRangeValue, generateConfig2]);
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  var PanelComponent = components[internalMode] || DefaultComponents[internalMode] || DatePanel;
  var sharedPanelContext = React135.useMemo(function() {
    var _ref2, _pickerClassNames$pop, _ref3, _pickerStyles$popup;
    return {
      classNames: (_ref2 = (_pickerClassNames$pop = pickerClassNames === null || pickerClassNames === void 0 ? void 0 : pickerClassNames.popup) !== null && _pickerClassNames$pop !== void 0 ? _pickerClassNames$pop : panelClassNames) !== null && _ref2 !== void 0 ? _ref2 : {},
      styles: (_ref3 = (_pickerStyles$popup = pickerStyles === null || pickerStyles === void 0 ? void 0 : pickerStyles.popup) !== null && _pickerStyles$popup !== void 0 ? _pickerStyles$popup : panelStyles) !== null && _ref3 !== void 0 ? _ref3 : {}
    };
  }, [pickerClassNames, panelClassNames, pickerStyles, panelStyles]);
  var parentHackContext = React135.useContext(PickerHackContext);
  var pickerPanelContext = React135.useMemo(function() {
    return _objectSpread10(_objectSpread10({}, parentHackContext), {}, {
      hideHeader
    });
  }, [parentHackContext, hideHeader]);
  if (true) {
    warning_default(!mergedValue || mergedValue.every(function(val) {
      return generateConfig2.isValidate(val);
    }), "Invalidate date pass to `value` or `defaultValue`.");
  }
  var panelCls = "".concat(mergedPrefixCls, "-panel");
  var panelProps = pickProps(props, [
    // Week
    "showWeek",
    // Icons
    "prevIcon",
    "nextIcon",
    "superPrevIcon",
    "superNextIcon",
    // Disabled
    "disabledDate",
    "minDate",
    "maxDate",
    // Hover
    "onHover"
  ]);
  return React135.createElement(SharedPanelContext.Provider, {
    value: sharedPanelContext
  }, React135.createElement(PickerHackContext.Provider, {
    value: pickerPanelContext
  }, React135.createElement("div", {
    ref: rootRef,
    tabIndex,
    className: clsx(panelCls, _defineProperty18({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
  }, React135.createElement(PanelComponent, _extends25({}, panelProps, {
    // Time
    showTime: mergedShowTime,
    prefixCls: mergedPrefixCls,
    locale: filledLocale,
    generateConfig: generateConfig2,
    onModeChange: triggerModeChange,
    pickerValue: mergedPickerValue,
    onPickerValueChange: function onPickerValueChange2(nextPickerValue) {
      setPickerValue(nextPickerValue, true);
    },
    value: mergedValue[0],
    onSelect: onPanelValueSelect,
    values: mergedValue,
    cellRender: onInternalCellRender,
    hoverRangeValue: hoverRangeDate,
    hoverValue
  })))));
}
var RefPanelPicker = React135.memo(React135.forwardRef(PickerPanel));
if (true) {
  RefPanelPicker.displayName = "PanelPicker";
}
var PickerPanel_default = RefPanelPicker;

// node_modules/@rc-component/picker/es/PickerInput/Popup/PopupPanel.js
function _typeof21(o3) {
  "@babel/helpers - typeof";
  return _typeof21 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof21(o3);
}
function _extends26() {
  _extends26 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends26.apply(this, arguments);
}
function ownKeys10(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread11(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys10(Object(t2), true).forEach(function(r3) {
      _defineProperty19(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys10(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty19(obj, key, value) {
  key = _toPropertyKey18(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey18(t2) {
  var i = _toPrimitive18(t2, "string");
  return "symbol" == _typeof21(i) ? i : String(i);
}
function _toPrimitive18(t2, r2) {
  if ("object" != _typeof21(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof21(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function PopupPanel(props) {
  var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range = props.range, hoverValue = props.hoverValue;
  var _React$useContext = React136.useContext(context_default4), prefixCls = _React$useContext.prefixCls, generateConfig2 = _React$useContext.generateConfig;
  var internalOffsetDate = React136.useCallback(function(date, offset3) {
    return offsetPanelDate(generateConfig2, picker, date, offset3);
  }, [generateConfig2, picker]);
  var nextPickerValue = React136.useMemo(function() {
    return internalOffsetDate(pickerValue, 1);
  }, [pickerValue, internalOffsetDate]);
  var onSecondPickerValueChange = function onSecondPickerValueChange2(nextDate) {
    onPickerValueChange(internalOffsetDate(nextDate, -1));
  };
  var sharedContext = {
    onCellDblClick: function onCellDblClick() {
      if (needConfirm) {
        onSubmit();
      }
    }
  };
  var hideHeader = picker === "time";
  var pickerProps = _objectSpread11(_objectSpread11({}, props), {}, {
    hoverValue: null,
    hoverRangeValue: null,
    hideHeader
  });
  if (range) {
    pickerProps.hoverRangeValue = hoverValue;
  } else {
    pickerProps.hoverValue = hoverValue;
  }
  if (multiplePanel) {
    return React136.createElement("div", {
      className: "".concat(prefixCls, "-panels")
    }, React136.createElement(PickerHackContext.Provider, {
      value: _objectSpread11(_objectSpread11({}, sharedContext), {}, {
        hideNext: true
      })
    }, React136.createElement(PickerPanel_default, pickerProps)), React136.createElement(PickerHackContext.Provider, {
      value: _objectSpread11(_objectSpread11({}, sharedContext), {}, {
        hidePrev: true
      })
    }, React136.createElement(PickerPanel_default, _extends26({}, pickerProps, {
      pickerValue: nextPickerValue,
      onPickerValueChange: onSecondPickerValueChange
    }))));
  }
  return React136.createElement(PickerHackContext.Provider, {
    value: _objectSpread11({}, sharedContext)
  }, React136.createElement(PickerPanel_default, pickerProps));
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/PresetPanel.js
var React137 = __toESM(require_react());
function executeValue(value) {
  return typeof value === "function" ? value() : value;
}
function PresetPanel(props) {
  var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
  if (!presets.length) {
    return null;
  }
  return React137.createElement("div", {
    className: "".concat(prefixCls, "-presets")
  }, React137.createElement("ul", null, presets.map(function(_ref, index2) {
    var label = _ref.label, value = _ref.value;
    return React137.createElement("li", {
      key: index2,
      onClick: function onClick() {
        _onClick(executeValue(value));
      },
      onMouseEnter: function onMouseEnter() {
        onHover(executeValue(value));
      },
      onMouseLeave: function onMouseLeave() {
        onHover(null);
      }
    }, label);
  })));
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/index.js
function _typeof22(o3) {
  "@babel/helpers - typeof";
  return _typeof22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof22(o3);
}
function ownKeys11(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread12(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys11(Object(t2), true).forEach(function(r3) {
      _defineProperty20(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys11(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty20(obj, key, value) {
  key = _toPropertyKey19(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey19(t2) {
  var i = _toPrimitive19(t2, "string");
  return "symbol" == _typeof22(i) ? i : String(i);
}
function _toPrimitive19(t2, r2) {
  if ("object" != _typeof22(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof22(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends27() {
  _extends27 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends27.apply(this, arguments);
}
function _slicedToArray27(arr, i) {
  return _arrayWithHoles26(arr) || _iterableToArrayLimit26(arr, i) || _unsupportedIterableToArray30(arr, i) || _nonIterableRest26();
}
function _nonIterableRest26() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray30(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray29(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray29(o3, minLen);
}
function _arrayLikeToArray29(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit26(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles26(arr) {
  if (Array.isArray(arr)) return arr;
}
function Popup(props) {
  var _classNames$popup, _styles$popup;
  var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [0, 0, 0] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit, classNames = props.classNames, styles = props.styles;
  var _React$useContext = React138.useContext(context_default4), prefixCls = _React$useContext.prefixCls;
  var panelPrefixCls = "".concat(prefixCls, "-panel");
  var rtl = direction === "rtl";
  var arrowRef = React138.useRef(null);
  var wrapperRef = React138.useRef(null);
  var _React$useState = React138.useState(0), _React$useState2 = _slicedToArray27(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
  var _React$useState3 = React138.useState(0), _React$useState4 = _slicedToArray27(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
  var _React$useState5 = React138.useState(0), _React$useState6 = _slicedToArray27(_React$useState5, 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
  var onResize = function onResize2(info) {
    if (info.width) {
      setContainerWidth(info.width);
    }
  };
  var _activeInfo = _slicedToArray27(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
  var _React$useState7 = React138.useState(0), _React$useState8 = _slicedToArray27(_React$useState7, 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
  React138.useEffect(function() {
    setRetryTimes(10);
  }, [activeInputLeft]);
  React138.useEffect(function() {
    if (range && wrapperRef.current) {
      var _arrowRef$current;
      var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
      var wrapperRect = wrapperRef.current.getBoundingClientRect();
      if (!wrapperRect.height || wrapperRect.right < 0) {
        setRetryTimes(function(times) {
          return Math.max(0, times - 1);
        });
        return;
      }
      var nextArrowOffset = (rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left;
      setArrowOffset(nextArrowOffset);
      if (containerWidth && containerWidth < selectorWidth) {
        var offset3 = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
        var safeOffset = Math.max(0, offset3);
        setContainerOffset(safeOffset);
      } else {
        setContainerOffset(0);
      }
    }
  }, [retryTimes, rtl, containerWidth, activeInputLeft, activeInputRight, selectorWidth, range]);
  function filterEmpty(list) {
    return list.filter(function(item) {
      return item;
    });
  }
  var valueList = React138.useMemo(function() {
    return filterEmpty(toArray2(value));
  }, [value]);
  var isTimePickerEmptyValue = picker === "time" && !valueList.length;
  var footerSubmitValue = React138.useMemo(function() {
    if (isTimePickerEmptyValue) {
      return filterEmpty([defaultOpenValue]);
    }
    return valueList;
  }, [isTimePickerEmptyValue, valueList, defaultOpenValue]);
  var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
  var disableSubmit = React138.useMemo(function() {
    if (!footerSubmitValue.length) {
      return true;
    }
    return footerSubmitValue.some(function(val) {
      return isInvalid(val);
    });
  }, [footerSubmitValue, isInvalid]);
  var onFooterSubmit = function onFooterSubmit2() {
    if (isTimePickerEmptyValue) {
      onSelect(defaultOpenValue);
    }
    onOk();
    onSubmit();
  };
  var mergedNodes = React138.createElement("div", {
    className: "".concat(prefixCls, "-panel-layout")
  }, React138.createElement(PresetPanel, {
    prefixCls,
    presets,
    onClick: onPresetSubmit,
    onHover: onPresetHover
  }), React138.createElement("div", null, React138.createElement(PopupPanel, _extends27({}, props, {
    value: popupPanelValue
  })), React138.createElement(Footer2, _extends27({}, props, {
    showNow: multiple ? false : showNow,
    invalid: disableSubmit,
    onSubmit: onFooterSubmit
  }))));
  if (panelRender) {
    mergedNodes = panelRender(mergedNodes);
  }
  var containerPrefixCls = "".concat(panelPrefixCls, "-container");
  var marginLeft = "marginLeft";
  var marginRight = "marginRight";
  var renderNode = React138.createElement("div", {
    onMouseDown: onPanelMouseDown,
    tabIndex: -1,
    className: clsx(
      containerPrefixCls,
      // Used for Today Button style, safe to remove if no need
      "".concat(prefixCls, "-").concat(internalMode, "-panel-container"),
      classNames === null || classNames === void 0 || (_classNames$popup = classNames.popup) === null || _classNames$popup === void 0 ? void 0 : _classNames$popup.container
    ),
    style: _objectSpread12(_defineProperty20(_defineProperty20({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"), styles === null || styles === void 0 || (_styles$popup = styles.popup) === null || _styles$popup === void 0 ? void 0 : _styles$popup.container),
    onFocus,
    onBlur
  }, mergedNodes);
  if (range) {
    renderNode = React138.createElement("div", {
      onMouseDown: onPanelMouseDown,
      ref: wrapperRef,
      className: clsx("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
    }, React138.createElement("div", {
      ref: arrowRef,
      className: "".concat(prefixCls, "-range-arrow"),
      style: {
        left: arrowOffset
      }
    }), React138.createElement(es_default3, {
      onResize
    }, renderNode));
  }
  return renderNode;
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/RangeSelector.js
var React143 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useInputProps.js
var React139 = __toESM(require_react());
function _typeof23(o3) {
  "@babel/helpers - typeof";
  return _typeof23 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof23(o3);
}
function ownKeys12(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread13(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys12(Object(t2), true).forEach(function(r3) {
      _defineProperty21(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys12(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty21(obj, key, value) {
  key = _toPropertyKey20(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey20(t2) {
  var i = _toPrimitive20(t2, "string");
  return "symbol" == _typeof23(i) ? i : String(i);
}
function _toPrimitive20(t2, r2) {
  if ("object" != _typeof23(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof23(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useInputProps(props, postProps) {
  var format2 = props.format, maskFormat = props.maskFormat, generateConfig2 = props.generateConfig, locale2 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open3 = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
  var parseDate = function parseDate2(str, formatStr) {
    var parsed = generateConfig2.locale.parse(locale2.locale, str, [formatStr]);
    return parsed && generateConfig2.isValidate(parsed) ? parsed : null;
  };
  var firstFormat = format2[0];
  var getText = React139.useCallback(function(date) {
    return formatValue(date, {
      locale: locale2,
      format: firstFormat,
      generateConfig: generateConfig2
    });
  }, [locale2, generateConfig2, firstFormat]);
  var valueTexts = React139.useMemo(function() {
    return value.map(getText);
  }, [value, getText]);
  var size = React139.useMemo(function() {
    var defaultSize = picker === "time" ? 8 : 10;
    var length = typeof firstFormat === "function" ? firstFormat(generateConfig2.getNow()).length : firstFormat.length;
    return Math.max(defaultSize, length) + 2;
  }, [firstFormat, picker, generateConfig2]);
  var _validateFormat = function validateFormat(text) {
    for (var i = 0; i < format2.length; i += 1) {
      var singleFormat = format2[i];
      if (typeof singleFormat === "string") {
        var parsed = parseDate(text, singleFormat);
        if (parsed) {
          return parsed;
        }
      }
    }
    return false;
  };
  var getInputProps = function getInputProps2(index2) {
    function getProp(propValue) {
      return index2 !== void 0 ? propValue[index2] : propValue;
    }
    var pickedAttrs = pickAttrs(props, {
      aria: true,
      data: true
    });
    var inputProps = _objectSpread13(_objectSpread13({}, pickedAttrs), {}, {
      // ============== Shared ==============
      format: maskFormat,
      validateFormat: function validateFormat(text) {
        return !!_validateFormat(text);
      },
      preserveInvalidOnBlur,
      readOnly: inputReadOnly,
      required,
      "aria-required": ariaRequired,
      name,
      autoComplete,
      size,
      // ============= By Index =============
      id: getProp(id),
      value: getProp(valueTexts) || "",
      invalid: getProp(invalid),
      placeholder: getProp(placeholder),
      active: activeIndex === index2,
      helped: allHelp || activeHelp && activeIndex === index2,
      disabled: getProp(disabled),
      onFocus: function onFocus(event) {
        _onFocus(event, index2);
      },
      onBlur: function onBlur(event) {
        _onBlur(event, index2);
      },
      onSubmit,
      // Get validate text value
      onChange: function onChange(text) {
        onInputChange();
        var parsed = _validateFormat(text);
        if (parsed) {
          onInvalid(false, index2);
          _onChange(parsed, index2);
          return;
        }
        onInvalid(!!text, index2);
      },
      onHelp: function onHelp() {
        onOpenChange(true, {
          index: index2
        });
      },
      onKeyDown: function onKeyDown2(event) {
        var prevented = false;
        _onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
          if (true) {
            warning_default(false, "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly.");
          }
          prevented = true;
        });
        if (!event.defaultPrevented && !prevented) {
          switch (event.key) {
            case "Escape":
              onOpenChange(false, {
                index: index2
              });
              break;
            case "Enter":
              if (!open3) {
                onOpenChange(true);
              }
              break;
          }
        }
      }
    }, postProps === null || postProps === void 0 ? void 0 : postProps({
      valueTexts
    }));
    Object.keys(inputProps).forEach(function(key) {
      if (inputProps[key] === void 0) {
        delete inputProps[key];
      }
    });
    return inputProps;
  };
  return [getInputProps, getText];
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useRootProps.js
var React140 = __toESM(require_react());
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
  return React140.useMemo(function() {
    return pickProps(props, propNames);
  }, [props]);
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Icon.js
var React141 = __toESM(require_react());
var _excluded = ["icon", "type"];
var _excluded2 = ["onClear"];
function _extends28() {
  _extends28 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends28.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function Icon2(props) {
  var icon = props.icon, type = props.type, restProps = _objectWithoutProperties(props, _excluded);
  var _React$useContext = React141.useContext(context_default4), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  return icon ? React141.createElement("span", _extends28({
    className: clsx("".concat(prefixCls, "-").concat(type), classNames.suffix),
    style: styles.suffix
  }, restProps), icon) : null;
}
function ClearIcon(_ref) {
  var onClear = _ref.onClear, restProps = _objectWithoutProperties(_ref, _excluded2);
  return React141.createElement(Icon2, _extends28({}, restProps, {
    type: "clear",
    role: "button",
    onMouseDown: function onMouseDown(e3) {
      e3.preventDefault();
    },
    onClick: function onClick(e3) {
      e3.stopPropagation();
      onClear();
    }
  }));
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Input.js
var React142 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/MaskFormat.js
function _typeof24(o3) {
  "@babel/helpers - typeof";
  return _typeof24 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof24(o3);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey21(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty22(obj, key, value) {
  key = _toPropertyKey21(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey21(t2) {
  var i = _toPrimitive21(t2, "string");
  return "symbol" == _typeof24(i) ? i : String(i);
}
function _toPrimitive21(t2, r2) {
  if ("object" != _typeof24(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof24(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var FORMAT_KEYS = ["YYYY", "MM", "DD", "HH", "mm", "ss", "SSS"];
var REPLACE_KEY = "";
var MaskFormat = (function() {
  function MaskFormat2(format2) {
    _classCallCheck2(this, MaskFormat2);
    _defineProperty22(this, "format", void 0);
    _defineProperty22(this, "maskFormat", void 0);
    _defineProperty22(this, "cells", void 0);
    _defineProperty22(this, "maskCells", void 0);
    this.format = format2;
    var replaceKeys = FORMAT_KEYS.map(function(key) {
      return "(".concat(key, ")");
    }).join("|");
    var replaceReg = new RegExp(replaceKeys, "g");
    this.maskFormat = format2.replace(
      replaceReg,
      // Use Chinese character to avoid user use it in format
      function(key) {
        return REPLACE_KEY.repeat(key.length);
      }
    );
    var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
    var strCells = (format2.split(cellReg) || []).filter(function(str) {
      return str;
    });
    var offset3 = 0;
    this.cells = strCells.map(function(text) {
      var mask = FORMAT_KEYS.includes(text);
      var start = offset3;
      var end = offset3 + text.length;
      offset3 = end;
      return {
        text,
        mask,
        start,
        end
      };
    });
    this.maskCells = this.cells.filter(function(cell) {
      return cell.mask;
    });
  }
  _createClass2(MaskFormat2, [{
    key: "getSelection",
    value: function getSelection(maskCellIndex) {
      var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
      return [start || 0, end || 0];
    }
    /** Check given text match format */
  }, {
    key: "match",
    value: function match(text) {
      for (var i = 0; i < this.maskFormat.length; i += 1) {
        var maskChar = this.maskFormat[i];
        var textChar = text[i];
        if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {
          return false;
        }
      }
      return true;
    }
    /** Get mask cell count */
  }, {
    key: "size",
    value: function size() {
      return this.maskCells.length;
    }
  }, {
    key: "getMaskCellIndex",
    value: function getMaskCellIndex(anchorIndex) {
      var closetDist = Number.MAX_SAFE_INTEGER;
      var closetIndex = 0;
      for (var i = 0; i < this.maskCells.length; i += 1) {
        var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
        if (anchorIndex >= start && anchorIndex <= end) {
          return i;
        }
        var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
        if (dist < closetDist) {
          closetDist = dist;
          closetIndex = i;
        }
      }
      return closetIndex;
    }
  }]);
  return MaskFormat2;
})();

// node_modules/@rc-component/picker/es/PickerInput/Selector/util.js
function getMaskRange(key) {
  var PresetRange = {
    YYYY: [0, 9999, (/* @__PURE__ */ new Date()).getFullYear()],
    MM: [1, 12],
    DD: [1, 31],
    HH: [0, 23],
    mm: [0, 59],
    ss: [0, 59],
    SSS: [0, 999]
  };
  return PresetRange[key];
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Input.js
function _typeof25(o3) {
  "@babel/helpers - typeof";
  return _typeof25 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof25(o3);
}
var _excluded3 = ["className", "active", "showActiveCls", "suffixIcon", "format", "validateFormat", "onChange", "onInput", "helped", "onHelp", "onSubmit", "onKeyDown", "preserveInvalidOnBlur", "invalid", "clearIcon"];
function _extends29() {
  _extends29 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends29.apply(this, arguments);
}
function _defineProperty23(obj, key, value) {
  key = _toPropertyKey22(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey22(t2) {
  var i = _toPrimitive22(t2, "string");
  return "symbol" == _typeof25(i) ? i : String(i);
}
function _toPrimitive22(t2, r2) {
  if ("object" != _typeof25(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof25(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray28(arr, i) {
  return _arrayWithHoles27(arr) || _iterableToArrayLimit27(arr, i) || _unsupportedIterableToArray31(arr, i) || _nonIterableRest27();
}
function _nonIterableRest27() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray31(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray30(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray30(o3, minLen);
}
function _arrayLikeToArray30(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit27(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles27(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Input = React142.forwardRef(function(props, ref) {
  var className = props.className, active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format2 = props.format, validateFormat = props.validateFormat, onChange = props.onChange, onInput = props.onInput, helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown2 = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties2(props, _excluded3);
  var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
  var _React$useContext = React142.useContext(context_default4), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component6 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var inputPrefixCls = "".concat(prefixCls, "-input");
  var _React$useState = React142.useState(false), _React$useState2 = _slicedToArray28(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
  var _React$useState3 = React142.useState(value), _React$useState4 = _slicedToArray28(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
  var _React$useState5 = React142.useState(""), _React$useState6 = _slicedToArray28(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
  var _React$useState7 = React142.useState(null), _React$useState8 = _slicedToArray28(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
  var _React$useState9 = React142.useState(null), _React$useState10 = _slicedToArray28(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
  var inputValue = internalInputValue || "";
  React142.useEffect(function() {
    setInputValue(value);
  }, [value]);
  var holderRef = React142.useRef(null);
  var inputRef = React142.useRef(null);
  React142.useImperativeHandle(ref, function() {
    return {
      nativeElement: holderRef.current,
      inputElement: inputRef.current,
      focus: function focus(options) {
        inputRef.current.focus(options);
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  });
  var maskFormat = React142.useMemo(function() {
    return new MaskFormat(format2 || "");
  }, [format2]);
  var _React$useMemo = React142.useMemo(function() {
    if (helped) {
      return [0, 0];
    }
    return maskFormat.getSelection(focusCellIndex);
  }, [maskFormat, focusCellIndex, helped]), _React$useMemo2 = _slicedToArray28(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
  var onModify = function onModify2(text) {
    if (text && text !== format2 && text !== value) {
      onHelp();
    }
  };
  var triggerInputChange = useEvent_default(function(text) {
    if (validateFormat(text)) {
      onChange(text);
    }
    setInputValue(text);
    onModify(text);
  });
  var onInternalChange = function onInternalChange2(event) {
    if (!format2) {
      var text = event.target.value;
      onModify(text);
      setInputValue(text);
      onChange(text);
    }
  };
  var onFormatPaste = function onFormatPaste2(event) {
    var pasteText = event.clipboardData.getData("text");
    if (validateFormat(pasteText)) {
      triggerInputChange(pasteText);
    }
  };
  var mouseDownRef = React142.useRef(false);
  var onFormatMouseDown = function onFormatMouseDown2() {
    mouseDownRef.current = true;
  };
  var onFormatMouseUp = function onFormatMouseUp2(event) {
    var _ref = event.target, start = _ref.selectionStart;
    var closeMaskIndex = maskFormat.getMaskCellIndex(start);
    setFocusCellIndex(closeMaskIndex);
    forceSelectionSync({});
    onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
    mouseDownRef.current = false;
  };
  var onFormatFocus = function onFormatFocus2(event) {
    setFocused(true);
    setFocusCellIndex(0);
    setFocusCellText("");
    onFocus(event);
  };
  var onSharedBlur = function onSharedBlur2(event) {
    onBlur(event);
  };
  var onFormatBlur = function onFormatBlur2(event) {
    setFocused(false);
    onSharedBlur(event);
  };
  useLockEffect(active, function() {
    if (!active && !preserveInvalidOnBlur) {
      setInputValue(value);
    }
  });
  var onSharedKeyDown = function onSharedKeyDown2(event) {
    if (event.key === "Enter" && validateFormat(inputValue)) {
      onSubmit();
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event);
  };
  var onFormatKeyDown = function onFormatKeyDown2(event) {
    onSharedKeyDown(event);
    var key = event.key;
    var nextCellText = null;
    var nextFillText = null;
    var maskCellLen = selectionEnd - selectionStart;
    var cellFormat = format2.slice(selectionStart, selectionEnd);
    var offsetCellIndex = function offsetCellIndex2(offset3) {
      setFocusCellIndex(function(idx) {
        var nextIndex = idx + offset3;
        nextIndex = Math.max(nextIndex, 0);
        nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
        return nextIndex;
      });
    };
    var offsetCellValue = function offsetCellValue2(offset3) {
      var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray28(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
      var currentText = inputValue.slice(selectionStart, selectionEnd);
      var currentTextNum = Number(currentText);
      if (isNaN(currentTextNum)) {
        return String(rangeDefault ? rangeDefault : offset3 > 0 ? rangeStart : rangeEnd);
      }
      var num = currentTextNum + offset3;
      var range = rangeEnd - rangeStart + 1;
      return String(rangeStart + (range + num - rangeStart) % range);
    };
    switch (key) {
      // =============== Remove ===============
      case "Backspace":
      case "Delete":
        nextCellText = "";
        nextFillText = cellFormat;
        break;
      // =============== Arrows ===============
      // Left key
      case "ArrowLeft":
        nextCellText = "";
        offsetCellIndex(-1);
        break;
      // Right key
      case "ArrowRight":
        nextCellText = "";
        offsetCellIndex(1);
        break;
      // Up key
      case "ArrowUp":
        nextCellText = "";
        nextFillText = offsetCellValue(1);
        break;
      // Down key
      case "ArrowDown":
        nextCellText = "";
        nextFillText = offsetCellValue(-1);
        break;
      // =============== Number ===============
      default:
        if (!isNaN(Number(key))) {
          nextCellText = focusCellText + key;
          nextFillText = nextCellText;
        }
        break;
    }
    if (nextCellText !== null) {
      setFocusCellText(nextCellText);
      if (nextCellText.length >= maskCellLen) {
        offsetCellIndex(1);
        setFocusCellText("");
      }
    }
    if (nextFillText !== null) {
      var nextFocusValue = (
        // before
        inputValue.slice(0, selectionStart) + // replace
        leftPad(nextFillText, maskCellLen) + // after
        inputValue.slice(selectionEnd)
      );
      triggerInputChange(nextFocusValue.slice(0, format2.length));
    }
    forceSelectionSync({});
  };
  var rafRef = React142.useRef();
  useLayoutEffect_default(function() {
    if (!focused || !format2 || mouseDownRef.current) {
      return;
    }
    if (!maskFormat.match(inputValue)) {
      triggerInputChange(format2);
      return;
    }
    inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    rafRef.current = raf_default(function() {
      inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    });
    return function() {
      raf_default.cancel(rafRef.current);
    };
  }, [maskFormat, format2, focused, inputValue, focusCellIndex, selectionStart, selectionEnd, forceSelectionSyncMark, triggerInputChange]);
  var inputProps = format2 ? {
    onFocus: onFormatFocus,
    onBlur: onFormatBlur,
    onKeyDown: onFormatKeyDown,
    onMouseDown: onFormatMouseDown,
    onMouseUp: onFormatMouseUp,
    onPaste: onFormatPaste
  } : {};
  return React142.createElement("div", {
    ref: holderRef,
    className: clsx(inputPrefixCls, _defineProperty23(_defineProperty23({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped), className)
  }, React142.createElement(Component6, _extends29({
    ref: inputRef,
    "aria-invalid": invalid,
    autoComplete: "off"
  }, restProps, {
    onKeyDown: onSharedKeyDown,
    onBlur: onSharedBlur
    // Replace with format
  }, inputProps, {
    // Value
    value: inputValue,
    onChange: onInternalChange,
    className: classNames.input,
    style: styles.input
  })), React142.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), clearIcon);
});
if (true) {
  Input.displayName = "Input";
}
var Input_default3 = Input;

// node_modules/@rc-component/picker/es/PickerInput/Selector/RangeSelector.js
var _excluded4 = ["id", "prefix", "clearIcon", "suffixIcon", "separator", "activeIndex", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "value", "onChange", "onSubmit", "onInputChange", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onActiveInfo", "placement", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex"];
var _excluded22 = ["index"];
function _extends30() {
  _extends30 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends30.apply(this, arguments);
}
function ownKeys13(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread14(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys13(Object(t2), true).forEach(function(r3) {
      _defineProperty24(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys13(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty24(obj, key, value) {
  key = _toPropertyKey23(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey23(t2) {
  var i = _toPrimitive23(t2, "string");
  return "symbol" == _typeof26(i) ? i : String(i);
}
function _toPrimitive23(t2, r2) {
  if ("object" != _typeof26(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof26(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray29(arr, i) {
  return _arrayWithHoles28(arr) || _iterableToArrayLimit28(arr, i) || _unsupportedIterableToArray32(arr, i) || _nonIterableRest28();
}
function _nonIterableRest28() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray32(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray31(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray31(o3, minLen);
}
function _arrayLikeToArray31(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit28(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles28(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof26(o3) {
  "@babel/helpers - typeof";
  return _typeof26 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof26(o3);
}
function _objectWithoutProperties3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function RangeSelector(props, ref) {
  var id = props.id, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex, activeHelp = props.activeHelp, allHelp = props.allHelp, focused = props.focused, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown2 = props.onKeyDown, locale2 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit, onInputChange = props.onInputChange, format2 = props.format, maskFormat = props.maskFormat, preserveInvalidOnBlur = props.preserveInvalidOnBlur, onInvalid = props.onInvalid, disabled = props.disabled, invalid = props.invalid, inputReadOnly = props.inputReadOnly, direction = props.direction, onOpenChange = props.onOpenChange, onActiveInfo = props.onActiveInfo, placement = props.placement, _onMouseDown = props.onMouseDown, required = props.required, ariaRequired = props["aria-required"], autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties3(props, _excluded4);
  var rtl = direction === "rtl";
  var _React$useContext = React143.useContext(context_default4), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var ids = React143.useMemo(function() {
    if (typeof id === "string") {
      return [id];
    }
    var mergedId = id || {};
    return [mergedId.start, mergedId.end];
  }, [id]);
  var rootRef = React143.useRef();
  var inputStartRef = React143.useRef();
  var inputEndRef = React143.useRef();
  var getInput = function getInput2(index2) {
    var _index;
    return (_index = [inputStartRef, inputEndRef][index2]) === null || _index === void 0 ? void 0 : _index.current;
  };
  React143.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: function focus(options) {
        if (_typeof26(options) === "object") {
          var _getInput;
          var _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties3(_ref, _excluded22);
          (_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
        } else {
          var _getInput2;
          (_getInput2 = getInput(options !== null && options !== void 0 ? options : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
        }
      },
      blur: function blur() {
        var _getInput3, _getInput4;
        (_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
        (_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
      }
    };
  });
  var rootProps = useRootProps(restProps);
  var mergedPlaceholder = React143.useMemo(function() {
    return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
  }, [placeholder]);
  var _useInputProps = useInputProps(_objectSpread14(_objectSpread14({}, props), {}, {
    id: ids,
    placeholder: mergedPlaceholder
  })), _useInputProps2 = _slicedToArray29(_useInputProps, 1), getInputProps = _useInputProps2[0];
  var _React$useState = React143.useState({
    position: "absolute",
    width: 0
  }), _React$useState2 = _slicedToArray29(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
  var syncActiveOffset = useEvent_default(function() {
    var input = getInput(activeIndex);
    if (input) {
      var inputRect = input.nativeElement.getBoundingClientRect();
      var parentRect = rootRef.current.getBoundingClientRect();
      var rectOffset = inputRect.left - parentRect.left;
      setActiveBarStyle(function(ori) {
        return _objectSpread14(_objectSpread14({}, ori), {}, {
          width: inputRect.width,
          left: rectOffset
        });
      });
      onActiveInfo([inputRect.left, inputRect.right, parentRect.width]);
    }
  });
  React143.useEffect(function() {
    syncActiveOffset();
  }, [activeIndex]);
  var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
  var startAutoFocus = autoFocus && !disabled[0];
  var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
  return React143.createElement(es_default3, {
    onResize: syncActiveOffset
  }, React143.createElement("div", _extends30({}, rootProps, {
    className: clsx(prefixCls, "".concat(prefixCls, "-range"), _defineProperty24(_defineProperty24(_defineProperty24(_defineProperty24({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
      return i;
    })), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
      return i;
    })), "".concat(prefixCls, "-rtl"), rtl), className),
    style,
    ref: rootRef,
    onClick,
    onMouseDown: function onMouseDown(e3) {
      var target = e3.target;
      if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) {
        e3.preventDefault();
      }
      _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e3);
    }
  }), prefix && React143.createElement("div", {
    className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
    style: styles.prefix
  }, prefix), React143.createElement(Input_default3, _extends30({
    ref: inputStartRef
  }, getInputProps(0), {
    className: "".concat(prefixCls, "-input-start"),
    autoFocus: startAutoFocus,
    tabIndex,
    "date-range": "start"
  })), React143.createElement("div", {
    className: "".concat(prefixCls, "-range-separator")
  }, separator), React143.createElement(Input_default3, _extends30({
    ref: inputEndRef
  }, getInputProps(1), {
    className: "".concat(prefixCls, "-input-end"),
    autoFocus: endAutoFocus,
    tabIndex,
    "date-range": "end"
  })), React143.createElement("div", {
    className: "".concat(prefixCls, "-active-bar"),
    style: activeBarStyle
  }), React143.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && React143.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })));
}
var RefRangeSelector = React143.forwardRef(RangeSelector);
if (true) {
  RefRangeSelector.displayName = "RangeSelector";
}
var RangeSelector_default = RefRangeSelector;

// node_modules/@rc-component/picker/es/hooks/useSemantic.js
var import_react40 = __toESM(require_react());
function _typeof27(o3) {
  "@babel/helpers - typeof";
  return _typeof27 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof27(o3);
}
function ownKeys14(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread15(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys14(Object(t2), true).forEach(function(r3) {
      _defineProperty25(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys14(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty25(obj, key, value) {
  key = _toPropertyKey24(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey24(t2) {
  var i = _toPrimitive24(t2, "string");
  return "symbol" == _typeof27(i) ? i : String(i);
}
function _toPrimitive24(t2, r2) {
  if ("object" != _typeof27(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof27(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useSemantic(classNames, styles) {
  return (0, import_react40.useMemo)(function() {
    var mergedClassNames = _objectSpread15(_objectSpread15({}, classNames), {}, {
      popup: (classNames === null || classNames === void 0 ? void 0 : classNames.popup) || {}
    });
    var mergedStyles = _objectSpread15(_objectSpread15({}, styles), {}, {
      popup: (styles === null || styles === void 0 ? void 0 : styles.popup) || {}
    });
    return [mergedClassNames, mergedStyles];
  }, [classNames, styles]);
}

// node_modules/@rc-component/picker/es/PickerInput/RangePicker.js
function _typeof28(o3) {
  "@babel/helpers - typeof";
  return _typeof28 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof28(o3);
}
function _extends31() {
  _extends31 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends31.apply(this, arguments);
}
function _toConsumableArray8(arr) {
  return _arrayWithoutHoles7(arr) || _iterableToArray7(arr) || _unsupportedIterableToArray33(arr) || _nonIterableSpread7();
}
function _nonIterableSpread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles7(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray32(arr);
}
function ownKeys15(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread16(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys15(Object(t2), true).forEach(function(r3) {
      _defineProperty26(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys15(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty26(obj, key, value) {
  key = _toPropertyKey25(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey25(t2) {
  var i = _toPrimitive25(t2, "string");
  return "symbol" == _typeof28(i) ? i : String(i);
}
function _toPrimitive25(t2, r2) {
  if ("object" != _typeof28(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof28(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray30(arr, i) {
  return _arrayWithHoles29(arr) || _iterableToArrayLimit29(arr, i) || _unsupportedIterableToArray33(arr, i) || _nonIterableRest29();
}
function _nonIterableRest29() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray33(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray32(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray32(o3, minLen);
}
function _arrayLikeToArray32(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit29(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles29(arr) {
  if (Array.isArray(arr)) return arr;
}
function separateConfig(config, defaultConfig2) {
  var singleConfig = config !== null && config !== void 0 ? config : defaultConfig2;
  if (Array.isArray(singleConfig)) {
    return singleConfig;
  }
  return [singleConfig, singleConfig];
}
function getActiveRange(activeIndex) {
  return activeIndex === 1 ? "end" : "start";
}
function RangePicker(props, ref) {
  var _useFilledProps = useFilledProps(props, function() {
    var disabled2 = props.disabled, allowEmpty2 = props.allowEmpty;
    var mergedDisabled = separateConfig(disabled2, false);
    var mergedAllowEmpty = separateConfig(allowEmpty2, false);
    return {
      disabled: mergedDisabled,
      allowEmpty: mergedAllowEmpty
    };
  }), _useFilledProps2 = _slicedToArray30(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
  var prefixCls = filledProps.prefixCls, rootClassName = filledProps.rootClassName, propStyles = filledProps.styles, propClassNames = filledProps.classNames, previewValue = filledProps.previewValue, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown2 = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open3 = filledProps.open, onOpenChange = filledProps.onOpenChange, locale2 = filledProps.locale, generateConfig2 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
  var selectorRef = usePickerRef(ref);
  var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray30(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
  var _useOpen = useOpen(open3, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray30(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
  var triggerOpen = function triggerOpen2(nextOpen, config) {
    if (disabled.some(function(fieldDisabled) {
      return !fieldDisabled;
    }) || !nextOpen) {
      setMergeOpen(nextOpen, config);
    }
  };
  var _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, true, false, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray30(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
  var calendarValue = getCalendarValue();
  var _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray30(_useRangeActive, 9), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
  var onSharedFocus = function onSharedFocus2(event, index2) {
    triggerFocus2(true);
    onFocus === null || onFocus === void 0 || onFocus(event, {
      range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
    });
  };
  var onSharedBlur = function onSharedBlur2(event, index2) {
    triggerFocus2(false);
    onBlur === null || onBlur === void 0 || onBlur(event, {
      range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
    });
  };
  var mergedShowTime = React144.useMemo(function() {
    if (!showTime) {
      return null;
    }
    var disabledTime = showTime.disabledTime;
    var proxyDisabledTime = disabledTime ? function(date) {
      var range = getActiveRange(activeIndex);
      var fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
      return disabledTime(date, range, {
        from: fromDate
      });
    } : void 0;
    return _objectSpread16(_objectSpread16({}, showTime), {}, {
      disabledTime: proxyDisabledTime
    });
  }, [showTime, activeIndex, calendarValue, activeIndexList]);
  var _useControlledState = useControlledState([picker, picker], mode), _useControlledState2 = _slicedToArray30(_useControlledState, 2), modes = _useControlledState2[0], setModes = _useControlledState2[1];
  var mergedMode = modes[activeIndex] || picker;
  var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  var multiplePanel = internalMode === picker && internalMode !== "time";
  var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
  var _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray30(_useRangeValue, 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
  var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig2, locale2, disabledDate);
  var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray30(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
  var _useRangePickerValue = useRangePickerValue(generateConfig2, locale2, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray30(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
  var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
    var clone = fillIndex(modes, activeIndex, nextMode);
    if (clone[0] !== modes[0] || clone[1] !== modes[1]) {
      setModes(clone);
    }
    if (onPanelChange && triggerEvent !== false) {
      var clonePickerValue = _toConsumableArray8(calendarValue);
      if (nextPickerValue) {
        clonePickerValue[activeIndex] = nextPickerValue;
      }
      onPanelChange(clonePickerValue, clone);
    }
  });
  var fillCalendarValue = function fillCalendarValue2(date, index2) {
    return (
      // Trigger change only when date changed
      fillIndex(calendarValue, index2, date)
    );
  };
  var triggerPartConfirm = function triggerPartConfirm2(date, skipFocus) {
    var nextValue = calendarValue;
    if (date) {
      nextValue = fillCalendarValue(date, activeIndex);
    }
    updateSubmitIndex(activeIndex);
    var nextIndex = nextActiveIndex(nextValue);
    triggerCalendarChange(nextValue);
    flushSubmit(activeIndex, nextIndex === null);
    if (nextIndex === null) {
      triggerOpen(false, {
        force: true
      });
    } else if (!skipFocus) {
      selectorRef.current.focus({
        index: nextIndex
      });
    }
  };
  var onSelectorClick = function onSelectorClick2(event) {
    var _activeElement;
    var rootNode = event.target.getRootNode();
    if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
      var enabledIndex = disabled.findIndex(function(d) {
        return !d;
      });
      if (enabledIndex >= 0) {
        selectorRef.current.focus({
          index: enabledIndex
        });
      }
    }
    triggerOpen(true);
    onClick === null || onClick === void 0 || onClick(event);
  };
  var onSelectorClear = function onSelectorClear2() {
    triggerSubmitChange(null);
    triggerOpen(false, {
      force: true
    });
  };
  var _React$useState = React144.useState(null), _React$useState2 = _slicedToArray30(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
  var _React$useState3 = React144.useState(null), _React$useState4 = _slicedToArray30(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
  var hoverValues = React144.useMemo(function() {
    return internalHoverValues || calendarValue;
  }, [calendarValue, internalHoverValues]);
  React144.useEffect(function() {
    if (!mergedOpen) {
      setInternalHoverValues(null);
    }
  }, [mergedOpen]);
  var _React$useState5 = React144.useState([0, 0, 0]), _React$useState6 = _slicedToArray30(_React$useState5, 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
  var onSetHover = function onSetHover2(date, source) {
    if (previewValue !== "hover") {
      return;
    }
    setInternalHoverValues(date);
    setHoverSource(source);
  };
  var presetList = usePresets(presets, ranges);
  var onPresetHover = function onPresetHover2(nextValues) {
    onSetHover(nextValues, "preset");
  };
  var onPresetSubmit = function onPresetSubmit2(nextValues) {
    var passed = triggerSubmitChange(nextValues);
    if (passed) {
      triggerOpen(false, {
        force: true
      });
    }
  };
  var onNow = function onNow2(now2) {
    triggerPartConfirm(now2);
  };
  var onPanelHover = function onPanelHover2(date) {
    onSetHover(date ? fillCalendarValue(date, activeIndex) : null, "cell");
  };
  var onPanelFocus = function onPanelFocus2(event) {
    triggerOpen(true);
    onSharedFocus(event);
  };
  var onPanelMouseDown = function onPanelMouseDown2() {
    lastOperation("panel");
  };
  var onPanelSelect = function onPanelSelect2(date) {
    var clone = fillIndex(calendarValue, activeIndex, date);
    triggerCalendarChange(clone);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerPartConfirm(date);
    }
  };
  var onPopupClose = function onPopupClose2() {
    triggerOpen(false);
  };
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
  var panelValue = calendarValue[activeIndex] || null;
  var isPopupInvalidateDate = useEvent_default(function(date) {
    return isInvalidateDate(date, {
      activeIndex
    });
  });
  var panelProps = React144.useMemo(function() {
    var domProps = pickAttrs(filledProps, false);
    var restProps = omit(filledProps, [].concat(_toConsumableArray8(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "disabledTime", "classNames", "styles"]));
    return restProps;
  }, [filledProps]);
  var panel = React144.createElement(Popup, _extends31({}, panelProps, {
    showNow: mergedShowNow,
    showTime: mergedShowTime,
    range: true,
    multiplePanel,
    activeInfo,
    disabledDate: mergedDisabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    onPanelMouseDown,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: panelValue,
    isInvalid: isPopupInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: toArray2(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerPartConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  var onSelectorChange = function onSelectorChange2(date, index2) {
    var clone = fillCalendarValue(date, index2);
    triggerCalendarChange(clone);
  };
  var onSelectorInputChange = function onSelectorInputChange2() {
    lastOperation("input");
  };
  var onSelectorFocus = function onSelectorFocus2(event, index2) {
    var activeListLen = activeIndexList.length;
    var lastActiveIndex = activeIndexList[activeListLen - 1];
    if (activeListLen && lastActiveIndex !== index2 && needConfirm && // Not change index if is not filled
    !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
      selectorRef.current.focus({
        index: lastActiveIndex
      });
      return;
    }
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    if (activeIndex !== index2 && mergedOpen && !needConfirm && complexPicker) {
      triggerPartConfirm(null, true);
    }
    setActiveIndex(index2);
    onSharedFocus(event, index2);
  };
  var onSelectorBlur = function onSelectorBlur2(event, index2) {
    triggerOpen(false);
    if (!needConfirm && lastOperation() === "input") {
      var nextIndex = nextActiveIndex(calendarValue);
      flushSubmit(activeIndex, nextIndex === null);
    }
    onSharedBlur(event, index2);
  };
  var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
    if (event.key === "Tab") {
      triggerPartConfirm(null, true);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event, preventDefault);
  };
  var context = React144.useMemo(function() {
    return {
      prefixCls,
      locale: locale2,
      generateConfig: generateConfig2,
      button: components.button,
      input: components.input,
      classNames: mergedClassNames,
      styles: mergedStyles
    };
  }, [prefixCls, locale2, generateConfig2, components.button, components.input, mergedClassNames, mergedStyles]);
  useLayoutEffect_default(function() {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(function() {
    var lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerPartConfirm(null, true);
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerOpen(true);
      triggerPartConfirm();
    }
  }, [mergedOpen]);
  if (true) {
    var isIndexEmpty = function isIndexEmpty2(index2) {
      return (
        // Value is empty
        !(value !== null && value !== void 0 && value[index2]) && // DefaultValue is empty
        !(defaultValue !== null && defaultValue !== void 0 && defaultValue[index2])
      );
    };
    if (disabled.some(function(fieldDisabled, index2) {
      return fieldDisabled && isIndexEmpty(index2) && !allowEmpty[index2];
    })) {
      warning_default(false, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
    }
  }
  return React144.createElement(context_default4.Provider, {
    value: context
  }, React144.createElement(PickerTrigger_default, _extends31({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: mergedStyles.popup.root,
    popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
    visible: mergedOpen,
    onClose: onPopupClose,
    range: true
  }), React144.createElement(
    RangeSelector_default,
    _extends31({}, filledProps, {
      // Ref
      ref: selectorRef,
      className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
      style: _objectSpread16(_objectSpread16({}, mergedStyles.root), filledProps.style),
      suffixIcon,
      activeIndex: focused || mergedOpen ? activeIndex : null,
      activeHelp: !!internalHoverValues,
      allHelp: !!internalHoverValues && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerPartConfirm,
      value: hoverValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidates,
      onInvalid: onSelectorInvalid,
      onActiveInfo: setActiveInfo
    })
  )));
}
var RefRangePicker = React144.forwardRef(RangePicker);
if (true) {
  RefRangePicker.displayName = "RefRangePicker";
}
var RangePicker_default = RefRangePicker;

// node_modules/@rc-component/picker/es/PickerInput/SinglePicker.js
var React147 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/index.js
var React146 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/MultipleDates.js
var React145 = __toESM(require_react());
function MultipleDates(props) {
  var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
  var selectorCls = "".concat(prefixCls, "-selector");
  var selectionCls = "".concat(prefixCls, "-selection");
  var overflowCls = "".concat(selectionCls, "-overflow");
  function renderSelector(content, onClose) {
    return React145.createElement("span", {
      className: clsx("".concat(selectionCls, "-item")),
      title: typeof content === "string" ? content : null
    }, React145.createElement("span", {
      className: "".concat(selectionCls, "-item-content")
    }, content), !disabled && onClose && React145.createElement("span", {
      onMouseDown: function onMouseDown(e3) {
        e3.preventDefault();
      },
      onClick: onClose,
      className: "".concat(selectionCls, "-item-remove")
    }, removeIcon));
  }
  function renderItem2(date) {
    var displayLabel = formatDate(date);
    var onClose = function onClose2(event) {
      if (event) event.stopPropagation();
      onRemove(date);
    };
    return renderSelector(displayLabel, onClose);
  }
  function renderRest(omittedValues) {
    var content = "+ ".concat(omittedValues.length, " ...");
    return renderSelector(content);
  }
  return React145.createElement("div", {
    className: selectorCls
  }, React145.createElement(es_default6, {
    prefixCls: overflowCls,
    data: value,
    renderItem: renderItem2,
    renderRest,
    itemKey: function itemKey2(date) {
      return formatDate(date);
    },
    maxCount: maxTagCount
  }), !value.length && React145.createElement("span", {
    className: "".concat(prefixCls, "-selection-placeholder")
  }, placeholder));
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/index.js
function _typeof29(o3) {
  "@babel/helpers - typeof";
  return _typeof29 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof29(o3);
}
var _excluded5 = ["id", "open", "prefix", "clearIcon", "suffixIcon", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "internalPicker", "value", "onChange", "onSubmit", "onInputChange", "multiple", "maxTagCount", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex", "removeIcon"];
function _extends32() {
  _extends32 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends32.apply(this, arguments);
}
function ownKeys16(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread17(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys16(Object(t2), true).forEach(function(r3) {
      _defineProperty27(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys16(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty27(obj, key, value) {
  key = _toPropertyKey26(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey26(t2) {
  var i = _toPrimitive26(t2, "string");
  return "symbol" == _typeof29(i) ? i : String(i);
}
function _toPrimitive26(t2, r2) {
  if ("object" != _typeof29(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof29(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray31(arr, i) {
  return _arrayWithHoles30(arr) || _iterableToArrayLimit30(arr, i) || _unsupportedIterableToArray34(arr, i) || _nonIterableRest30();
}
function _nonIterableRest30() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray34(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray33(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray33(o3, minLen);
}
function _arrayLikeToArray33(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit30(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles30(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function SingleSelector(props, ref) {
  var id = props.id, open3 = props.open, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, activeHelp = props.activeHelp, allHelp = props.allHelp, focused = props.focused, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown2 = props.onKeyDown, locale2 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit, onInputChange = props.onInputChange, multiple = props.multiple, maxTagCount = props.maxTagCount, format2 = props.format, maskFormat = props.maskFormat, preserveInvalidOnBlur = props.preserveInvalidOnBlur, onInvalid = props.onInvalid, disabled = props.disabled, invalid = props.invalid, inputReadOnly = props.inputReadOnly, direction = props.direction, onOpenChange = props.onOpenChange, _onMouseDown = props.onMouseDown, required = props.required, ariaRequired = props["aria-required"], autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties4(props, _excluded5);
  var rtl = direction === "rtl";
  var _React$useContext = React146.useContext(context_default4), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var rootRef = React146.useRef();
  var inputRef = React146.useRef();
  React146.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: function focus(options) {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
      },
      blur: function blur() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
      }
    };
  });
  var rootProps = useRootProps(restProps);
  var onSingleChange = function onSingleChange2(date) {
    onChange([date]);
  };
  var onMultipleRemove = function onMultipleRemove2(date) {
    var nextValues = value.filter(function(oriDate) {
      return oriDate && !isSame(generateConfig2, locale2, oriDate, date, internalPicker);
    });
    onChange(nextValues);
    if (!open3) {
      onSubmit();
    }
  };
  var _useInputProps = useInputProps(_objectSpread17(_objectSpread17({}, props), {}, {
    onChange: onSingleChange
  }), function(_ref) {
    var valueTexts = _ref.valueTexts;
    return {
      value: valueTexts[0] || "",
      active: focused
    };
  }), _useInputProps2 = _slicedToArray31(_useInputProps, 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
  var showClear = !!(clearIcon && value.length && !disabled);
  var selectorNode = multiple ? React146.createElement(React146.Fragment, null, React146.createElement(MultipleDates, {
    prefixCls,
    value,
    onRemove: onMultipleRemove,
    formatDate: getText,
    maxTagCount,
    disabled,
    removeIcon,
    placeholder
  }), React146.createElement("input", {
    className: "".concat(prefixCls, "-multiple-input"),
    value: value.map(getText).join(","),
    ref: inputRef,
    readOnly: true,
    autoFocus,
    tabIndex
  }), React146.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && React146.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })) : React146.createElement(Input_default3, _extends32({
    ref: inputRef
  }, getInputProps(), {
    autoFocus,
    tabIndex,
    suffixIcon,
    clearIcon: showClear && React146.createElement(ClearIcon, {
      icon: clearIcon,
      onClear
    }),
    showActiveCls: false
  }));
  return React146.createElement("div", _extends32({}, rootProps, {
    className: clsx(prefixCls, _defineProperty27(_defineProperty27(_defineProperty27(_defineProperty27(_defineProperty27({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
    style,
    ref: rootRef,
    onClick,
    onMouseDown: function onMouseDown(e3) {
      var _inputRef$current3;
      var target = e3.target;
      if (target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) {
        e3.preventDefault();
      }
      _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e3);
    }
  }), prefix && React146.createElement("div", {
    className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
    style: styles.prefix
  }, prefix), selectorNode);
}
var RefSingleSelector = React146.forwardRef(SingleSelector);
if (true) {
  RefSingleSelector.displayName = "SingleSelector";
}
var SingleSelector_default = RefSingleSelector;

// node_modules/@rc-component/picker/es/PickerInput/SinglePicker.js
function _typeof30(o3) {
  "@babel/helpers - typeof";
  return _typeof30 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof30(o3);
}
function _extends33() {
  _extends33 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends33.apply(this, arguments);
}
function _toConsumableArray9(arr) {
  return _arrayWithoutHoles8(arr) || _iterableToArray8(arr) || _unsupportedIterableToArray35(arr) || _nonIterableSpread8();
}
function _nonIterableSpread8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles8(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray34(arr);
}
function ownKeys17(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread18(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys17(Object(t2), true).forEach(function(r3) {
      _defineProperty28(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys17(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty28(obj, key, value) {
  key = _toPropertyKey27(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey27(t2) {
  var i = _toPrimitive27(t2, "string");
  return "symbol" == _typeof30(i) ? i : String(i);
}
function _toPrimitive27(t2, r2) {
  if ("object" != _typeof30(t2) || !t2) return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof30(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray32(arr, i) {
  return _arrayWithHoles31(arr) || _iterableToArrayLimit31(arr, i) || _unsupportedIterableToArray35(arr, i) || _nonIterableRest31();
}
function _nonIterableRest31() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray35(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray34(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray34(o3, minLen);
}
function _arrayLikeToArray34(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit31(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles31(arr) {
  if (Array.isArray(arr)) return arr;
}
function Picker(props, ref) {
  var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray32(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
  var _ref = filledProps, prefixCls = _ref.prefixCls, rootClassName = _ref.rootClassName, propStyles = _ref.styles, propClassNames = _ref.classNames, previewValue = _ref.previewValue, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown2 = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open3 = _ref.open, onOpenChange = _ref.onOpenChange, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
  var selectorRef = usePickerRef(ref);
  function pickerParam(values) {
    if (values === null) {
      return null;
    }
    return multiple ? values : values[0];
  }
  var toggleDates = useToggleDates(generateConfig2, locale2, internalPicker);
  var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray32(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
  var _useOpen = useOpen(open3, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray32(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
  var onInternalCalendarChange = function onInternalCalendarChange2(dates, dateStrings, info) {
    if (onCalendarChange) {
      var filteredInfo = _objectSpread18({}, info);
      delete filteredInfo.range;
      onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
    }
  };
  var onInternalOk = function onInternalOk2(dates) {
    onOk === null || onOk === void 0 || onOk(pickerParam(dates));
  };
  var _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, false, order, defaultValue, value, onInternalCalendarChange, onInternalOk), _useInnerValue2 = _slicedToArray32(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
  var calendarValue = getCalendarValue();
  var _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray32(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
  var onSharedFocus = function onSharedFocus2(event) {
    triggerFocus2(true);
    onFocus === null || onFocus === void 0 || onFocus(event, {});
  };
  var onSharedBlur = function onSharedBlur2(event) {
    triggerFocus2(false);
    onBlur === null || onBlur === void 0 || onBlur(event, {});
  };
  var _useControlledState = useControlledState(picker, mode), _useControlledState2 = _slicedToArray32(_useControlledState, 2), mergedMode = _useControlledState2[0], setMode = _useControlledState2[1];
  var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
  var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
  var onInternalChange = onChange && function(dates, dateStrings) {
    onChange(pickerParam(dates), pickerParam(dateStrings));
  };
  var _useRangeValue = useRangeValue(
    _objectSpread18(_objectSpread18({}, filledProps), {}, {
      onChange: onInternalChange
    }),
    mergedValue,
    setInnerValue,
    getCalendarValue,
    triggerCalendarChange,
    [],
    //disabled,
    formatList,
    focused,
    mergedOpen,
    isInvalidateDate
  ), _useRangeValue2 = _slicedToArray32(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1];
  var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray32(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
  var submitInvalidate = React147.useMemo(function() {
    return submitInvalidates.some(function(invalidated) {
      return invalidated;
    });
  }, [submitInvalidates]);
  var onInternalPickerValueChange = function onInternalPickerValueChange2(dates, info) {
    if (onPickerValueChange) {
      var cleanInfo = _objectSpread18(_objectSpread18({}, info), {}, {
        mode: info.mode[0]
      });
      delete cleanInfo.range;
      onPickerValueChange(dates[0], cleanInfo);
    }
  };
  var _useRangePickerValue = useRangePickerValue(
    generateConfig2,
    locale2,
    calendarValue,
    [mergedMode],
    mergedOpen,
    activeIndex,
    internalPicker,
    false,
    // multiplePanel,
    defaultPickerValue,
    pickerValue,
    toArray2(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue),
    onInternalPickerValueChange,
    minDate,
    maxDate
  ), _useRangePickerValue2 = _slicedToArray32(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
  var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
    setMode(nextMode);
    if (onPanelChange && triggerEvent !== false) {
      var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
      onPanelChange(lastPickerValue, nextMode);
    }
  });
  var triggerConfirm = function triggerConfirm2() {
    triggerSubmitChange(getCalendarValue());
    triggerOpen(false, {
      force: true
    });
  };
  var onSelectorClick = function onSelectorClick2(event) {
    if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) {
      selectorRef.current.focus();
    }
    triggerOpen(true);
    onClick === null || onClick === void 0 || onClick(event);
  };
  var onSelectorClear = function onSelectorClear2() {
    triggerSubmitChange(null);
    triggerOpen(false, {
      force: true
    });
  };
  var _React$useState = React147.useState(null), _React$useState2 = _slicedToArray32(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
  var _React$useState3 = React147.useState(null), _React$useState4 = _slicedToArray32(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
  var hoverValues = React147.useMemo(function() {
    var values = [internalHoverValue].concat(_toConsumableArray9(calendarValue)).filter(function(date) {
      return date;
    });
    return multiple ? values : values.slice(0, 1);
  }, [calendarValue, internalHoverValue, multiple]);
  var selectorValues = React147.useMemo(function() {
    if (!multiple && internalHoverValue) {
      return [internalHoverValue];
    }
    return calendarValue.filter(function(date) {
      return date;
    });
  }, [calendarValue, internalHoverValue, multiple]);
  React147.useEffect(function() {
    if (!mergedOpen) {
      setInternalHoverValue(null);
    }
  }, [mergedOpen]);
  var onSetHover = function onSetHover2(date, source) {
    if (previewValue !== "hover") {
      return;
    }
    setInternalHoverValue(date);
    setHoverSource(source);
  };
  var presetList = usePresets(presets);
  var onPresetHover = function onPresetHover2(nextValue) {
    onSetHover(nextValue, "preset");
  };
  var onPresetSubmit = function onPresetSubmit2(nextValue) {
    var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
    var passed = triggerSubmitChange(nextCalendarValues);
    if (passed && !multiple) {
      triggerOpen(false, {
        force: true
      });
    }
  };
  var onNow = function onNow2(now2) {
    onPresetSubmit(now2);
  };
  var onPanelHover = function onPanelHover2(date) {
    onSetHover(date, "cell");
  };
  var onPanelFocus = function onPanelFocus2(event) {
    triggerOpen(true);
    onSharedFocus(event);
  };
  var onPanelSelect = function onPanelSelect2(date) {
    lastOperation("panel");
    if (multiple && internalMode !== picker) {
      return;
    }
    var nextValues = multiple ? toggleDates(getCalendarValue(), date) : [date];
    triggerCalendarChange(nextValues);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerConfirm();
    }
  };
  var onPopupClose = function onPopupClose2() {
    triggerOpen(false);
  };
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  var panelProps = React147.useMemo(function() {
    var domProps = pickAttrs(filledProps, false);
    var restProps = omit(filledProps, [].concat(_toConsumableArray9(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "classNames", "styles"]));
    return _objectSpread18(_objectSpread18({}, restProps), {}, {
      multiple: filledProps.multiple
    });
  }, [filledProps]);
  var panel = React147.createElement(Popup, _extends33({}, panelProps, {
    showNow: mergedShowNow,
    showTime,
    disabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: calendarValue,
    isInvalid: isInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  var onSelectorChange = function onSelectorChange2(date) {
    triggerCalendarChange(date);
  };
  var onSelectorInputChange = function onSelectorInputChange2() {
    lastOperation("input");
  };
  var onSelectorFocus = function onSelectorFocus2(event) {
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    onSharedFocus(event);
  };
  var onSelectorBlur = function onSelectorBlur2(event) {
    triggerOpen(false);
    onSharedBlur(event);
  };
  var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
    if (event.key === "Tab") {
      triggerConfirm();
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event, preventDefault);
  };
  var context = React147.useMemo(function() {
    return {
      prefixCls,
      locale: locale2,
      generateConfig: generateConfig2,
      button: components.button,
      input: components.input,
      classNames: mergedClassNames,
      styles: mergedStyles
    };
  }, [prefixCls, locale2, generateConfig2, components.button, components.input, mergedClassNames, mergedStyles]);
  useLayoutEffect_default(function() {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(function() {
    var lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerConfirm();
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerConfirm();
    }
  }, [mergedOpen]);
  return React147.createElement(context_default4.Provider, {
    value: context
  }, React147.createElement(PickerTrigger_default, _extends33({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: mergedStyles.popup.root,
    popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
    visible: mergedOpen,
    onClose: onPopupClose
  }), React147.createElement(
    SingleSelector_default,
    _extends33({}, filledProps, {
      // Ref
      ref: selectorRef,
      className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
      style: _objectSpread18(_objectSpread18({}, mergedStyles.root), filledProps.style),
      suffixIcon,
      removeIcon,
      activeHelp: !!internalHoverValue,
      allHelp: !!internalHoverValue && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerConfirm,
      value: selectorValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      internalPicker,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidate,
      onInvalid: function onInvalid(invalid) {
        onSelectorInvalid(invalid, 0);
      }
    })
  )));
}
var RefPicker = React147.forwardRef(Picker);
if (true) {
  RefPicker.displayName = "RefPicker";
}
var SinglePicker_default = RefPicker;

// node_modules/@rc-component/picker/es/index.js
var es_default11 = SinglePicker_default;

// node_modules/antd/es/calendar/Header.js
var React155 = __toESM(require_react());
var import_react43 = __toESM(require_react());

// node_modules/antd/es/radio/group.js
var React153 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useForm.js
var React148 = __toESM(require_react());

// node_modules/antd/es/form/util.js
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray3(candidate) {
  if (candidate === void 0 || candidate === false) {
    return [];
  }
  return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
  if (!namePath.length) {
    return void 0;
  }
  const mergedId = namePath.join("_");
  if (formName) {
    return `${formName}_${mergedId}`;
  }
  const isIllegalName = formItemNameBlackList.includes(mergedId);
  return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
  let status = defaultValidateStatus;
  if (validateStatus !== void 0) {
    status = validateStatus;
  } else if (meta.validating) {
    status = "validating";
  } else if (errors.length) {
    status = "error";
  } else if (warnings.length) {
    status = "warning";
  } else if (meta.touched || hasFeedback && meta.validated) {
    status = "success";
  }
  return status;
}

// node_modules/antd/es/form/hooks/useForm.js
function toNamePathStr(name) {
  const namePath = toArray3(name);
  return namePath.join("_");
}
function getFieldDOMNode(name, wrapForm) {
  const field = wrapForm.getFieldInstance(name);
  const fieldDom = getDOM(field);
  if (fieldDom) {
    return fieldDom;
  }
  const fieldId = getFieldId(toArray3(name), wrapForm.__INTERNAL__.name);
  if (fieldId) {
    return document.getElementById(fieldId);
  }
}
function useForm(form) {
  const [rcForm] = useForm_default();
  const itemsRef = React148.useRef({});
  const wrapForm = React148.useMemo(() => form ?? {
    ...rcForm,
    __INTERNAL__: {
      itemRef: (name) => (node) => {
        const namePathStr = toNamePathStr(name);
        if (node) {
          itemsRef.current[namePathStr] = node;
        } else {
          delete itemsRef.current[namePathStr];
        }
      }
    },
    scrollToField: (name, options = {}) => {
      const {
        focus,
        ...restOpt
      } = options;
      const node = getFieldDOMNode(name, wrapForm);
      if (node) {
        e2(node, {
          scrollMode: "if-needed",
          block: "nearest",
          ...restOpt
        });
        if (focus) {
          wrapForm.focusField(name);
        }
      }
    },
    focusField: (name) => {
      const itemRef = wrapForm.getFieldInstance(name);
      if (typeof itemRef?.focus === "function") {
        itemRef.focus();
      } else {
        getFieldDOMNode(name, wrapForm)?.focus?.();
      }
    },
    getFieldInstance: (name) => {
      const namePathStr = toNamePathStr(name);
      return itemsRef.current[namePathStr];
    }
  }, [form, rcForm]);
  return [wrapForm];
}

// node_modules/antd/es/radio/context.js
var React149 = __toESM(require_react());
var RadioGroupContext = React149.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var context_default5 = RadioGroupContext;
var RadioOptionTypeContext = React149.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

// node_modules/antd/es/radio/radio.js
var React152 = __toESM(require_react());

// node_modules/@rc-component/checkbox/es/index.js
var React150 = __toESM(require_react());
var import_react41 = __toESM(require_react());
function _extends34() {
  _extends34 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends34.apply(this, arguments);
}
var Checkbox = (0, import_react41.forwardRef)((props, ref) => {
  const {
    prefixCls = "rc-checkbox",
    className,
    style,
    checked,
    disabled,
    defaultChecked = false,
    type = "checkbox",
    title,
    onChange,
    ...inputProps
  } = props;
  const inputRef = (0, import_react41.useRef)(null);
  const holderRef = (0, import_react41.useRef)(null);
  const [rawValue, setRawValue] = useControlledState(defaultChecked, checked);
  (0, import_react41.useImperativeHandle)(ref, () => ({
    focus: (options) => {
      inputRef.current?.focus(options);
    },
    blur: () => {
      inputRef.current?.blur();
    },
    input: inputRef.current,
    nativeElement: holderRef.current
  }));
  const classString = clsx(prefixCls, className, {
    [`${prefixCls}-checked`]: rawValue,
    [`${prefixCls}-disabled`]: disabled
  });
  const handleChange = (e3) => {
    if (disabled) {
      return;
    }
    if (!("checked" in props)) {
      setRawValue(e3.target.checked);
    }
    onChange?.({
      target: {
        ...props,
        type,
        checked: e3.target.checked
      },
      stopPropagation() {
        e3.stopPropagation();
      },
      preventDefault() {
        e3.preventDefault();
      },
      nativeEvent: e3.nativeEvent
    });
  };
  return React150.createElement("span", {
    className: classString,
    title,
    style,
    ref: holderRef
  }, React150.createElement("input", _extends34({}, inputProps, {
    className: `${prefixCls}-input`,
    ref: inputRef,
    onChange: handleChange,
    disabled,
    checked: !!rawValue,
    type
  })), React150.createElement("span", {
    className: `${prefixCls}-inner`
  }));
});
var es_default12 = Checkbox;

// node_modules/antd/es/checkbox/useBubbleLock.js
var import_react42 = __toESM(require_react());
function useBubbleLock(onOriginInputClick) {
  const labelClickLockRef = import_react42.default.useRef(null);
  const clearLock = () => {
    raf_default.cancel(labelClickLockRef.current);
    labelClickLockRef.current = null;
  };
  const onLabelClick = () => {
    clearLock();
    labelClickLockRef.current = raf_default(() => {
      labelClickLockRef.current = null;
    });
  };
  const onInputClick = (e3) => {
    if (labelClickLockRef.current) {
      e3.stopPropagation();
      clearLock();
    }
    onOriginInputClick?.(e3);
  };
  return [onLabelClick, onInputClick];
}

// node_modules/antd/es/radio/style/index.js
var getGroupRadioStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: {
      ...resetComponent(token),
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${groupPrefixCls}-block`]: {
        display: "flex"
      },
      [`${antCls}-badge ${antCls}-badge-count`]: {
        zIndex: 1
      },
      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
        borderInlineStart: "none"
      },
      "&-vertical": {
        display: "flex",
        flexDirection: "column",
        rowGap: token.marginXS
      }
    }
  };
};
var getRadioBasicStyle = (token) => {
  const {
    componentCls,
    wrapperMarginInlineEnd,
    colorPrimary,
    radioSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOutCirc,
    colorBgContainer,
    colorBorder,
    lineWidth,
    colorBgContainerDisabled,
    colorTextDisabled,
    paddingXS,
    dotColorDisabled,
    lineType,
    radioColor,
    radioBgColor,
    calc
  } = token;
  const radioInnerPrefixCls = `${componentCls}-inner`;
  const dotPadding = 4;
  const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
  const radioSizeCalc = calc(1).mul(radioSize).equal({
    unit: true
  });
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token),
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: wrapperMarginInlineEnd,
      cursor: "pointer",
      "&:last-child": {
        marginInlineEnd: 0
      },
      // RTL
      [`&${componentCls}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: token.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      "&-block": {
        flex: 1,
        justifyContent: "center"
      },
      // hashId  wrapper 
      [`${componentCls}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: "50%",
        visibility: "hidden",
        opacity: 0,
        content: '""'
      },
      [componentCls]: {
        ...resetComponent(token),
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center",
        borderRadius: "50%"
      },
      [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
        borderColor: colorPrimary
      },
      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: genFocusOutline(token),
      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${componentCls}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: radioSizeCalc,
          height: radioSizeCalc,
          marginBlockStart: calc(1).mul(radioSize).div(-2).equal({
            unit: true
          }),
          marginInlineStart: calc(1).mul(radioSize).div(-2).equal({
            unit: true
          }),
          backgroundColor: radioColor,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: radioSizeCalc,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: radioSizeCalc,
        height: radioSizeCalc,
        backgroundColor: colorBgContainer,
        borderColor: colorBorder,
        borderStyle: "solid",
        borderWidth: lineWidth,
        borderRadius: "50%",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-input`]: {
        position: "absolute",
        inset: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 
      [`${componentCls}-checked`]: {
        [radioInnerPrefixCls]: {
          borderColor: colorPrimary,
          backgroundColor: radioBgColor,
          "&::after": {
            transform: `scale(${token.calc(token.dotSize).div(radioSize).equal()})`,
            opacity: 1,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          }
        }
      },
      [`${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [radioInnerPrefixCls]: {
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: dotColorDisabled
          }
        },
        [`${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            "&::after": {
              transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})`
            }
          }
        }
      },
      [`span${componentCls} + *`]: {
        paddingInlineStart: paddingXS,
        paddingInlineEnd: paddingXS
      }
    }
  };
};
var getRadioButtonStyle = (token) => {
  const {
    buttonColor,
    controlHeight,
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    motionDurationMid,
    buttonPaddingInline,
    fontSize,
    buttonBg,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    paddingXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusLG,
    buttonCheckedBg,
    buttonSolidCheckedColor,
    colorTextDisabled,
    colorBgContainerDisabled,
    buttonCheckedBgDisabled,
    buttonCheckedColorDisabled,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    buttonSolidCheckedBg,
    buttonSolidCheckedHoverBg,
    buttonSolidCheckedActiveBg,
    calc
  } = token;
  return {
    [`${componentCls}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: controlHeight,
      margin: 0,
      paddingInline: buttonPaddingInline,
      paddingBlock: 0,
      color: buttonColor,
      fontSize,
      lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
      background: buttonBg,
      border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
      borderInlineEndWidth: lineWidth,
      cursor: "pointer",
      transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
      a: {
        color: buttonColor
      },
      [`> ${componentCls}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:last-child)": {
        marginInlineEnd: calc(lineWidth).mul(-1).equal()
      },
      "&:first-child": {
        borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
        borderStartStartRadius: borderRadius,
        borderEndStartRadius: borderRadius
      },
      "&:last-child": {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      "&:first-child:last-child": {
        borderRadius
      },
      [`${componentCls}-group-large &`]: {
        height: controlHeightLG,
        fontSize: fontSizeLG,
        lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderEndStartRadius: borderRadiusLG
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        }
      },
      [`${componentCls}-group-small &`]: {
        height: controlHeightSM,
        paddingInline: calc(paddingXS).sub(lineWidth).equal(),
        paddingBlock: 0,
        lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        }
      },
      "&:hover": {
        position: "relative",
        color: colorPrimary
      },
      "&:has(:focus-visible)": genFocusOutline(token),
      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: colorPrimary,
        background: buttonCheckedBg,
        borderColor: colorPrimary,
        "&::before": {
          backgroundColor: colorPrimary
        },
        "&:first-child": {
          borderColor: colorPrimary
        },
        "&:hover": {
          color: colorPrimaryHover,
          borderColor: colorPrimaryHover,
          "&::before": {
            backgroundColor: colorPrimaryHover
          }
        },
        "&:active": {
          color: colorPrimaryActive,
          borderColor: colorPrimaryActive,
          "&::before": {
            backgroundColor: colorPrimaryActive
          }
        }
      },
      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        color: buttonSolidCheckedColor,
        background: buttonSolidCheckedBg,
        borderColor: buttonSolidCheckedBg,
        "&:hover": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedHoverBg,
          borderColor: buttonSolidCheckedHoverBg
        },
        "&:active": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedActiveBg,
          borderColor: buttonSolidCheckedActiveBg
        }
      },
      "&-disabled": {
        color: colorTextDisabled,
        backgroundColor: colorBgContainerDisabled,
        borderColor: colorBorder,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder
        }
      },
      [`&-disabled${componentCls}-button-wrapper-checked`]: {
        color: buttonCheckedColorDisabled,
        backgroundColor: buttonCheckedBgDisabled,
        borderColor: colorBorder,
        boxShadow: "none"
      },
      "&-block": {
        flex: 1,
        textAlign: "center"
      }
    }
  };
};
var prepareComponentToken17 = (token) => {
  const {
    wireframe,
    padding,
    marginXS,
    lineWidth,
    fontSizeLG,
    colorText,
    colorBgContainer,
    colorTextDisabled,
    controlItemBgActiveDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    colorWhite
  } = token;
  const dotPadding = 4;
  const radioSize = fontSizeLG;
  const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
  return {
    // Radio
    radioSize,
    dotSize: radioDotSize,
    dotColorDisabled: colorTextDisabled,
    // Radio buttons
    buttonSolidCheckedColor: colorTextLightSolid,
    buttonSolidCheckedBg: colorPrimary,
    buttonSolidCheckedHoverBg: colorPrimaryHover,
    buttonSolidCheckedActiveBg: colorPrimaryActive,
    buttonBg: colorBgContainer,
    buttonCheckedBg: colorBgContainer,
    buttonColor: colorText,
    buttonCheckedBgDisabled: controlItemBgActiveDisabled,
    buttonCheckedColorDisabled: colorTextDisabled,
    buttonPaddingInline: padding - lineWidth,
    wrapperMarginInlineEnd: marginXS,
    // internal
    radioColor: wireframe ? colorPrimary : colorWhite,
    radioBgColor: wireframe ? colorBgContainer : colorPrimary
  };
};
var style_default20 = genStyleHooks("Radio", (token) => {
  const {
    controlOutline,
    controlOutlineWidth
  } = token;
  const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
  const radioButtonFocusShadow = radioFocusShadow;
  const radioToken = merge(token, {
    radioFocusShadow,
    radioButtonFocusShadow
  });
  return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
}, prepareComponentToken17, {
  unitless: {
    radioSize: true,
    dotSize: true
  }
});

// node_modules/antd/es/radio/radio.js
var InternalRadio = (props, ref) => {
  const groupContext = React152.useContext(context_default5);
  const radioOptionTypeContext = React152.useContext(RadioOptionTypeContext);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("radio");
  const innerRef = React152.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  const {
    isFormItemInput
  } = React152.useContext(FormItemInputContext);
  if (true) {
    const warning2 = devUseWarning("Radio");
    true ? warning2(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.") : void 0;
  }
  const onChange = (e3) => {
    props.onChange?.(e3);
    groupContext?.onChange?.(e3);
  };
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    style,
    title,
    classNames,
    styles,
    ...restProps
  } = props;
  const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
  const isButtonType = (groupContext?.optionType || radioOptionTypeContext) === "button";
  const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
  const rootCls = useCSSVarCls_default(radioPrefixCls);
  const [hashId, cssVarCls] = style_default20(radioPrefixCls, rootCls);
  const radioProps = {
    ...restProps
  };
  const disabled = React152.useContext(DisabledContext_default);
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled ?? groupContext.disabled;
  }
  radioProps.disabled = radioProps.disabled ?? disabled;
  const mergedProps = {
    ...props,
    ...radioProps
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const wrapperClassString = clsx(`${prefixCls}-wrapper`, {
    [`${prefixCls}-wrapper-checked`]: radioProps.checked,
    [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
    [`${prefixCls}-wrapper-block`]: !!groupContext?.block
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls);
  const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
  return React152.createElement(wave_default, {
    component: "Radio",
    disabled: radioProps.disabled
  }, React152.createElement("label", {
    className: wrapperClassString,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    title,
    onClick: onLabelClick
  }, React152.createElement(es_default12, {
    ...radioProps,
    className: clsx(mergedClassNames.icon, {
      [TARGET_CLS]: !isButtonType
    }),
    style: mergedStyles.icon,
    type: "radio",
    prefixCls,
    ref: mergedRef,
    onClick: onInputClick
  }), children !== void 0 ? React152.createElement("span", {
    className: clsx(`${prefixCls}-label`, mergedClassNames.label),
    style: mergedStyles.label
  }, children) : null));
};
var Radio = React152.forwardRef(InternalRadio);
if (true) {
  Radio.displayName = "Radio";
}
var radio_default = Radio;

// node_modules/antd/es/radio/group.js
var RadioGroup = React153.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React153.useContext(ConfigContext);
  const {
    name: formItemName
  } = React153.useContext(FormItemInputContext);
  const defaultName = useId_default(toNamePathStr(formItemName));
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    options,
    buttonStyle = "outline",
    disabled,
    children,
    size: customizeSize,
    style,
    id,
    optionType,
    name = defaultName,
    defaultValue,
    value: customizedValue,
    block = false,
    onChange,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    orientation,
    vertical
  } = props;
  const [value, setValue] = useControlledState(defaultValue, customizedValue);
  const onRadioChange = React153.useCallback((event) => {
    const lastValue = value;
    const val = event.target.value;
    if (!("value" in props)) {
      setValue(val);
    }
    if (val !== lastValue) {
      onChange?.(event);
    }
  }, [value, setValue, onChange]);
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default20(prefixCls, rootCls);
  let childrenToRender = children;
  if (options && options.length > 0) {
    childrenToRender = options.map((option) => {
      if (typeof option === "string" || typeof option === "number") {
        return React153.createElement(radio_default, {
          key: option.toString(),
          prefixCls,
          disabled,
          value: option,
          checked: value === option
        }, option);
      }
      return React153.createElement(radio_default, {
        key: `radio-group-value-options-${option.value}`,
        prefixCls,
        disabled: option.disabled || disabled,
        value: option.value,
        checked: value === option.value,
        title: option.title,
        style: option.style,
        className: option.className,
        id: option.id,
        required: option.required
      }, option.label);
    });
  }
  const mergedSize = useSize_default(customizeSize);
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const classString = clsx(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
    [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
    [`${groupPrefixCls}-rtl`]: direction === "rtl",
    [`${groupPrefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls, rootCls);
  const memoizedValue = React153.useMemo(() => ({
    onChange: onRadioChange,
    value,
    disabled,
    name,
    optionType,
    block
  }), [onRadioChange, value, disabled, name, optionType, block]);
  return React153.createElement("div", {
    ...pickAttrs(props, {
      aria: true,
      data: true
    }),
    className: clsx(classString, {
      [`${prefixCls}-group-vertical`]: mergedVertical
    }),
    style,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    id,
    ref
  }, React153.createElement(RadioGroupContextProvider, {
    value: memoizedValue
  }, childrenToRender));
});
var group_default2 = React153.memo(RadioGroup);

// node_modules/antd/es/radio/radioButton.js
var React154 = __toESM(require_react());
var RadioButton = (props, ref) => {
  const {
    getPrefixCls
  } = React154.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    ...radioProps
  } = props;
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  return React154.createElement(RadioOptionTypeContextProvider, {
    value: "button"
  }, React154.createElement(radio_default, {
    prefixCls,
    ...radioProps,
    type: "radio",
    ref
  }));
};
var radioButton_default = React154.forwardRef(RadioButton);

// node_modules/antd/es/radio/index.js
var Radio2 = radio_default;
Radio2.Button = radioButton_default;
Radio2.Group = group_default2;
Radio2.__ANT_RADIO = true;
var radio_default2 = Radio2;

// node_modules/antd/es/calendar/Header.js
var YEAR_SELECT_OFFSET = 10;
var YEAR_SELECT_TOTAL = 20;
function YearSelect(props) {
  const {
    fullscreen,
    validRange,
    generateConfig: generateConfig2,
    locale: locale2,
    prefixCls,
    value,
    onChange,
    divRef
  } = props;
  const year = generateConfig2.getYear(value || generateConfig2.getNow());
  let start = year - YEAR_SELECT_OFFSET;
  let end = start + YEAR_SELECT_TOTAL;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  const suffix = locale2 && locale2.year === "" ? "" : "";
  const options = [];
  for (let index2 = start; index2 < end; index2++) {
    options.push({
      label: `${index2}${suffix}`,
      value: index2
    });
  }
  return React155.createElement(select_default, {
    size: fullscreen ? void 0 : "small",
    options,
    value: year,
    className: `${prefixCls}-year-select`,
    onChange: (numYear) => {
      let newDate = generateConfig2.setYear(value, numYear);
      if (validRange) {
        const [startDate, endDate] = validRange;
        const newYear = generateConfig2.getYear(newDate);
        const newMonth = generateConfig2.getMonth(newDate);
        if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
        }
        if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
        }
      }
      onChange(newDate);
    },
    getPopupContainer: () => divRef.current
  });
}
function MonthSelect(props) {
  const {
    prefixCls,
    fullscreen,
    validRange,
    value,
    generateConfig: generateConfig2,
    locale: locale2,
    onChange,
    divRef
  } = props;
  const month = generateConfig2.getMonth(value || generateConfig2.getNow());
  let start = 0;
  let end = 11;
  if (validRange) {
    const [rangeStart, rangeEnd] = validRange;
    const currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  const months = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
  const options = [];
  for (let index2 = start; index2 <= end; index2 += 1) {
    options.push({
      label: months[index2],
      value: index2
    });
  }
  return React155.createElement(select_default, {
    size: fullscreen ? void 0 : "small",
    className: `${prefixCls}-month-select`,
    value: month,
    options,
    onChange: (newMonth) => {
      onChange(generateConfig2.setMonth(value, newMonth));
    },
    getPopupContainer: () => divRef.current
  });
}
function ModeSwitch(props) {
  const {
    prefixCls,
    locale: locale2,
    mode,
    fullscreen,
    onModeChange
  } = props;
  return React155.createElement(group_default2, {
    onChange: ({
      target: {
        value
      }
    }) => {
      onModeChange(value);
    },
    value: mode,
    size: fullscreen ? void 0 : "small",
    className: `${prefixCls}-mode-switch`
  }, React155.createElement(radioButton_default, {
    value: "month"
  }, locale2.month), React155.createElement(radioButton_default, {
    value: "year"
  }, locale2.year));
}
function CalendarHeader(props) {
  const {
    prefixCls,
    fullscreen,
    mode,
    onChange,
    onModeChange,
    className,
    style
  } = props;
  const divRef = React155.useRef(null);
  const formItemInputContext = (0, import_react43.useContext)(FormItemInputContext);
  const mergedFormItemInputContext = (0, import_react43.useMemo)(() => ({
    ...formItemInputContext,
    isFormItemInput: false
  }), [formItemInputContext]);
  const sharedProps = {
    ...props,
    fullscreen,
    divRef
  };
  return React155.createElement("div", {
    className: clsx(`${prefixCls}-header`, className),
    style,
    ref: divRef
  }, React155.createElement(FormItemInputContext.Provider, {
    value: mergedFormItemInputContext
  }, React155.createElement(YearSelect, {
    ...sharedProps,
    onChange: (v) => {
      onChange(v, "year");
    }
  }), mode === "month" && React155.createElement(MonthSelect, {
    ...sharedProps,
    onChange: (v) => {
      onChange(v, "month");
    }
  })), React155.createElement(ModeSwitch, {
    ...sharedProps,
    onModeChange
  }));
}
var Header_default = CalendarHeader;

// node_modules/antd/es/date-picker/style/util.js
var getMultipleSelectorUnit = (token) => {
  const {
    multipleSelectItemHeight,
    paddingXXS,
    lineWidth,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token;
  const basePadding = token.max(token.calc(paddingXXS).sub(lineWidth).equal(), 0);
  const containerPadding = token.max(token.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
  return {
    basePadding,
    containerPadding,
    itemHeight: unit(multipleSelectItemHeight),
    itemLineHeight: unit(token.calc(multipleSelectItemHeight).sub(token.calc(token.lineWidth).mul(2)).equal())
  };
};
var genOverflowStyle = (token) => {
  const {
    componentCls,
    iconCls,
    borderRadiusSM,
    motionDurationSlow,
    paddingXS,
    multipleItemColorDisabled,
    multipleItemBorderColorDisabled,
    colorIcon,
    colorIconHover,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [selectOverflowPrefixCls]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        // https://github.com/ant-design/ant-design/issues/54179
        maxWidth: "calc(100% - 4px)",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${componentCls}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
        borderRadius: borderRadiusSM,
        cursor: "default",
        transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
        marginInlineEnd: token.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
        paddingInlineStart: paddingXS,
        paddingInlineEnd: token.calc(paddingXS).div(2).equal(),
        [`${componentCls}-disabled&`]: {
          color: multipleItemColorDisabled,
          borderColor: multipleItemBorderColorDisabled,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token.calc(paddingXS).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": {
          ...resetIcon(),
          display: "inline-flex",
          alignItems: "center",
          color: colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: colorIconHover
          }
        }
      }
    }
  };
};

// node_modules/antd/es/date-picker/style/multiple.js
var genSize = (token, suffix) => {
  const {
    componentCls,
    controlHeight
  } = token;
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  const multipleSelectorUnit = getMultipleSelectorUnit(token);
  return [
    // genSelectionStyle(token, suffix),
    {
      [`${componentCls}-multiple${suffixCls}`]: {
        paddingBlock: multipleSelectorUnit.containerPadding,
        paddingInlineStart: multipleSelectorUnit.basePadding,
        minHeight: controlHeight,
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          height: multipleSelectorUnit.itemHeight,
          lineHeight: unit(multipleSelectorUnit.itemLineHeight)
        }
      }
    }
  ];
};
var genPickerMultipleStyle = (token) => {
  const {
    componentCls,
    calc,
    lineWidth
  } = token;
  const smallToken = merge(token, {
    fontHeight: token.fontSize,
    selectHeight: token.controlHeightSM,
    multipleSelectItemHeight: token.multipleItemHeightSM,
    borderRadius: token.borderRadiusSM,
    borderRadiusSM: token.borderRadiusXS,
    controlHeight: token.controlHeightSM
  });
  const largeToken = merge(token, {
    fontHeight: calc(token.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
    fontSize: token.fontSizeLG,
    selectHeight: token.controlHeightLG,
    multipleSelectItemHeight: token.multipleItemHeightLG,
    borderRadius: token.borderRadiusLG,
    borderRadiusSM: token.borderRadius,
    controlHeight: token.controlHeightLG
  });
  return [
    // ======================== Size ========================
    genSize(smallToken, "small"),
    genSize(token),
    genSize(largeToken, "large"),
    // ====================== Selection ======================
    {
      [`${componentCls}${componentCls}-multiple`]: {
        width: "100%",
        cursor: "text",
        // ==================== Selector =====================
        [`${componentCls}-selector`]: {
          flex: "auto",
          padding: 0,
          position: "relative",
          "&:after": {
            margin: 0
          },
          // ================== placeholder ==================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token.inputPaddingHorizontalBase,
            insetInlineEnd: 0,
            transform: "translateY(-50%)",
            transition: `all ${token.motionDurationSlow}`,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            flex: 1,
            color: token.colorTextPlaceholder,
            pointerEvents: "none"
          }
        },
        // ===================== Overflow ====================
        ...genOverflowStyle(token),
        // ====================== Input ======================
        // Input is `readonly`, which is used for a11y only
        [`${componentCls}-multiple-input`]: {
          width: 0,
          height: 0,
          border: 0,
          visibility: "hidden",
          position: "absolute",
          zIndex: -1
        }
      }
    }
  ];
};
var multiple_default = genPickerMultipleStyle;

// node_modules/antd/es/date-picker/style/panel.js
var genPickerCellInnerStyle = (token) => {
  const {
    pickerCellCls,
    pickerCellInnerCls,
    cellHeight,
    borderRadiusSM,
    motionDurationMid,
    cellHoverBg,
    lineWidth,
    lineType,
    colorPrimary,
    cellActiveWithRangeBg,
    colorTextLightSolid,
    colorTextDisabled,
    cellBgDisabled,
    colorFillSecondary
  } = token;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: cellHeight,
      transform: "translateY(-50%)",
      content: '""',
      pointerEvents: "none"
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: cellHeight,
      height: cellHeight,
      lineHeight: unit(cellHeight),
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: {
      [pickerCellInnerCls]: {
        background: cellHoverBg
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      position: "relative",
      [`&:not(${pickerCellCls}-disabled):before`]: {
        background: cellActiveWithRangeBg
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      [`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
        color: colorTextLightSolid,
        background: colorPrimary
      },
      [`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: {
        background: colorFillSecondary
      }
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: {
      insetInlineEnd: "50%"
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      cursor: "not-allowed",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: cellBgDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
};
var genPanelStyle = (token) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    cellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    textHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    cellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    motionDurationSlow,
    withoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    borderRadiusSM,
    colorTextLightSolid,
    cellHoverBg,
    timeColumnHeight,
    timeColumnWidth,
    timeCellHeight,
    controlItemBgActive,
    marginXXS,
    pickerDatePanelPaddingHorizontal,
    pickerControlIconMargin
  } = token;
  const pickerPanelWidth = token.calc(cellWidth).mul(7).add(token.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          },
          [`${componentCls}-time-panel`]: {
            [`${componentCls}-content`]: {
              direction: "ltr",
              "> *": {
                direction: "rtl"
              }
            }
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${unit(paddingXS)}`,
        color: colorTextHeading,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: unit(textHeight),
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          fontSize: "inherit",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          "&:empty": {
            display: "none"
          }
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          },
          "&:disabled": {
            opacity: 0.25,
            pointerEvents: "none"
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: unit(textHeight),
          "> button": {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
        position: "relative",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: `0 solid currentcolor`,
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          content: '""'
        }
      },
      [`&-super-prev-icon,
        &-super-next-icon`]: {
        "&::after": {
          position: "absolute",
          top: pickerControlIconMargin,
          insetInlineStart: pickerControlIconMargin,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          content: '""'
        }
      },
      "&-prev-icon, &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon, &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: cellHeight,
          fontWeight: "normal"
        },
        th: {
          height: token.calc(cellHeight).add(token.calc(pickerCellPaddingVertical).mul(2)).equal(),
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": {
        padding: `${unit(pickerCellPaddingVertical)} 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        },
        ...genPickerCellInnerStyle(token)
      },
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-content`]: {
          height: token.calc(withoutTimeCellHeight).mul(4).equal()
        },
        [pickerCellInnerCls]: {
          padding: `0 ${unit(paddingXS)}`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${unit(token.calc(paddingXS).div(2).equal())}`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-body`]: {
          padding: `0 ${unit(paddingXS)}`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(pickerDatePanelPaddingHorizontal)}`
        },
        [`${componentCls}-content th`]: {
          boxSizing: "border-box",
          padding: 0
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel-row": {
        td: {
          "&:before": {
            transition: `background ${motionDurationMid}`
          },
          "&:first-child:before": {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM
          },
          "&:last-child:before": {
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          }
        },
        "&:hover td:before": {
          background: cellHoverBg
        },
        "&-range-start td, &-range-end td, &-selected td, &-hover td": {
          // Rise priority to override hover style
          [`&${pickerCellCls}`]: {
            "&:before": {
              background: colorPrimary
            },
            [`&${componentCls}-cell-week`]: {
              color: new FastColor(colorTextLightSolid).setA(0.5).toHexString()
            },
            [pickerCellInnerCls]: {
              color: colorTextLightSolid
            }
          }
        },
        "&-range-hover td:before": {
          background: controlItemBgActive
        }
      },
      // >>> ShowWeek
      "&-week-panel, &-date-panel-show-week": {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(paddingSM)}`
        },
        [`${componentCls}-content th`]: {
          width: "auto"
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: timeColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: timeColumnWidth,
          margin: `${unit(paddingXXS)} 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::-webkit-scrollbar": {
            width: 8,
            backgroundColor: "transparent"
          },
          "&::-webkit-scrollbar-thumb": {
            backgroundColor: token.colorTextTertiary,
            borderRadius: token.borderRadiusSM
          },
          // For Firefox
          "&": {
            scrollbarWidth: "thin",
            scrollbarColor: `${token.colorTextTertiary} transparent`
          },
          "&::after": {
            display: "block",
            height: `calc(100% - ${unit(timeCellHeight)})`,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new FastColor(controlItemBgActive).setA(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: token.calc(timeColumnWidth).sub(token.calc(marginXXS).mul(2)).equal(),
                height: timeCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: token.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                color: colorText,
                lineHeight: unit(timeCellHeight),
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: cellHoverBg
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      }
    }
  };
};
var genPickerPanelStyle = (token) => {
  const {
    componentCls,
    textHeight,
    lineWidth,
    paddingSM,
    antCls,
    colorPrimary,
    cellActiveWithRangeBg,
    colorPrimaryBorder,
    lineType,
    colorSplit
  } = token;
  return {
    [`${componentCls}-dropdown`]: {
      // ======================== Footer ========================
      [`${componentCls}-footer`]: {
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-extra": {
          padding: `0 ${unit(paddingSM)}`,
          lineHeight: unit(token.calc(textHeight).sub(token.calc(lineWidth).mul(2)).equal()),
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          }
        }
      },
      // ==================== Footer > Ranges ===================
      [`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: {
        justifyContent: "space-between"
      },
      [`${componentCls}-ranges`]: {
        marginBlock: 0,
        paddingInline: unit(paddingSM),
        overflow: "hidden",
        textAlign: "start",
        listStyle: "none",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        "> li": {
          lineHeight: unit(token.calc(textHeight).sub(token.calc(lineWidth).mul(2)).equal()),
          display: "inline-block"
        },
        [`${componentCls}-now-btn-disabled`]: {
          pointerEvents: "none",
          color: token.colorTextDisabled
        },
        // https://github.com/ant-design/ant-design/issues/23687
        [`${componentCls}-preset > ${antCls}-tag-blue`]: {
          color: colorPrimary,
          background: cellActiveWithRangeBg,
          borderColor: colorPrimaryBorder,
          cursor: "pointer"
        },
        [`${componentCls}-ok`]: {
          paddingBlock: token.calc(lineWidth).mul(2).equal(),
          marginInlineStart: "auto"
        }
      }
    }
  };
};
var panel_default = genPickerPanelStyle;

// node_modules/antd/es/date-picker/style/token.js
var initPickerPanelToken = (token) => {
  const {
    componentCls,
    controlHeightLG,
    paddingXXS,
    padding
  } = token;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerYearMonthCellWidth: token.calc(controlHeightLG).mul(1.5).equal(),
    pickerQuarterPanelContentHeight: token.calc(controlHeightLG).mul(1.4).equal(),
    pickerCellPaddingVertical: token.calc(paddingXXS).add(token.calc(paddingXXS).div(2)).equal(),
    pickerCellBorderGap: 2,
    // Magic for gap between cells
    pickerControlIconSize: 7,
    pickerControlIconMargin: 4,
    pickerControlIconBorderWidth: 1.5,
    pickerDatePanelPaddingHorizontal: token.calc(padding).add(token.calc(paddingXXS).div(2)).equal()
    // 18 in normal
  };
};
var initPanelComponentToken = (token) => {
  const {
    colorBgContainerDisabled,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    lineWidth
  } = token;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
  const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  const filledToken = {
    INTERNAL_FIXED_ITEM_MARGIN,
    cellHoverBg: token.controlItemBgHover,
    cellActiveWithRangeBg: token.controlItemBgActive,
    cellHoverWithRangeBg: new FastColor(token.colorPrimary).lighten(35).toHexString(),
    cellRangeBorderColor: new FastColor(token.colorPrimary).lighten(20).toHexString(),
    cellBgDisabled: colorBgContainerDisabled,
    timeColumnWidth: controlHeightLG * 1.4,
    timeColumnHeight: 28 * 8,
    timeCellHeight: 28,
    cellWidth: controlHeightSM * 1.5,
    cellHeight: controlHeightSM,
    textHeight: controlHeightLG,
    withoutTimeCellHeight: controlHeightLG * 1.65,
    multipleItemBg: token.colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: token.colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent"
  };
  return filledToken;
};
var prepareComponentToken18 = (token) => ({
  ...initComponentToken(token),
  ...initPanelComponentToken(token),
  ...getArrowToken(token),
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token.zIndexPopupBase + 50
});

// node_modules/antd/es/date-picker/style/variants.js
var genVariantsStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: [
      {
        ...genOutlinedStyle(token),
        ...genUnderlinedStyle(token),
        ...genFilledStyle(token),
        ...genBorderlessStyle(token)
      },
      // ========================= Multiple =========================
      {
        "&-outlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token.multipleItemBg,
            border: `${unit(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
          }
        },
        "&-filled": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token.colorBgContainer,
            border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
          }
        },
        "&-borderless": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token.multipleItemBg,
            border: `${unit(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
          }
        },
        "&-underlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token.multipleItemBg,
            border: `${unit(token.lineWidth)} ${token.lineType} ${token.multipleItemBorderColor}`
          }
        }
      }
    ]
  };
};
var variants_default = genVariantsStyle;

// node_modules/antd/es/date-picker/style/index.js
var genPickerPadding = (paddingBlock, paddingInline) => {
  return {
    padding: `${unit(paddingBlock)} ${unit(paddingInline)}`
  };
};
var genPickerStatusStyle = (token) => {
  const {
    componentCls,
    colorError,
    colorWarning
  } = token;
  return {
    [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
      [`&${componentCls}-status-error`]: {
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
};
var genPickerStyle = (token) => {
  const {
    componentCls,
    antCls,
    paddingInline,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorTextDisabled,
    colorTextPlaceholder,
    colorTextQuaternary,
    fontSizeLG,
    inputFontSizeLG,
    fontSizeSM,
    inputFontSizeSM,
    controlHeightSM,
    paddingInlineSM,
    paddingXS,
    marginXS,
    colorIcon,
    lineWidthBold,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    sizePopupArrow,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    cellHoverBg,
    presetsWidth,
    presetsMaxWidth,
    boxShadowPopoverArrow,
    fontHeight,
    lineHeightLG
  } = token;
  return [
    {
      [componentCls]: {
        ...resetComponent(token),
        ...genPickerPadding(token.paddingBlock, token.paddingInline),
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        lineHeight: 1,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
        [`${componentCls}-prefix`]: {
          flex: "0 0 auto",
          marginInlineEnd: token.inputAffixPadding
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": {
            position: "relative",
            display: "inline-block",
            width: "100%",
            color: "inherit",
            fontSize: token.inputFontSize ?? token.fontSize,
            lineHeight: token.lineHeight,
            transition: `all ${motionDurationMid}`,
            ...genPlaceholderStyle(colorTextPlaceholder),
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            fontFamily: "inherit",
            "&:focus": {
              boxShadow: "none",
              outline: 0
            },
            "&[disabled]": {
              background: "transparent",
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": {
          ...genPickerPadding(token.paddingBlockLG, token.paddingInlineLG),
          borderRadius: token.borderRadiusLG,
          [`${componentCls}-input > input`]: {
            fontSize: inputFontSizeLG ?? fontSizeLG,
            lineHeight: lineHeightLG
          }
        },
        "&-small": {
          ...genPickerPadding(token.paddingBlockSM, token.paddingInlineSM),
          borderRadius: token.borderRadiusSM,
          [`${componentCls}-input > input`]: {
            fontSize: inputFontSizeSM ?? fontSizeSM
          }
        },
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: token.calc(paddingXS).div(2).equal(),
          color: colorTextQuaternary,
          lineHeight: 1,
          pointerEvents: "none",
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextQuaternary,
          lineHeight: 1,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorIcon
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          },
          // Should use the following selector, but since `:has` has poor compatibility,
          // we use `:not(:last-child)` instead, which may cause some problems in some cases.
          // [`${componentCls}-suffix:has(+ ${componentCls}-clear)`]: {
          [`${componentCls}-suffix:not(:last-child)`]: {
            opacity: 0
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextQuaternary,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorIcon
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: token.calc(lineWidth).mul(-1).equal(),
            height: lineWidthBold,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${unit(paddingXS)}`,
            lineHeight: 1
          }
        },
        // ======================== Clear =========================
        "&-range, &-multiple": {
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: paddingInline
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: paddingInlineSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": {
          ...resetComponent(token),
          ...genPanelStyle(token),
          pointerEvents: "none",
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          "&-rtl": {
            direction: "rtl"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: {
            [`${componentCls}-range-arrow${componentCls}-range-arrow`]: {
              transition: "none"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          // https://github.com/ant-design/ant-design/issues/48727
          [`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: {
            pointerEvents: "none"
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: {
            position: "absolute",
            zIndex: 1,
            display: "none",
            paddingInline: token.calc(paddingInline).mul(1.5).equal(),
            boxSizing: "content-box",
            transition: `all ${motionDurationSlow} ease-out`,
            ...genRoundedArrow(token, colorBgElevated, boxShadowPopoverArrow),
            "&:before": {
              insetInlineStart: token.calc(paddingInline).mul(1.5).equal()
            }
          },
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            display: "inline-block",
            pointerEvents: "auto",
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
                li: {
                  ...textEllipsis,
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: token.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: cellHoverBg
                  }
                }
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              // [`${componentCls}-panel`]: {
              //   borderWidth: `0 0 ${unit(lineWidth)}`,
              // },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content, table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        },
        "&-dropdown-range": {
          padding: `${unit(token.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "scale(-1, 1)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token, "slide-up"),
    initSlideMotion(token, "slide-down"),
    initMoveMotion(token, "move-up"),
    initMoveMotion(token, "move-down")
  ];
};
var style_default21 = genStyleHooks("DatePicker", (token) => {
  const pickerToken = merge(initInputToken(token), initPickerPanelToken(token), {
    inputPaddingHorizontalBase: token.calc(token.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: token.multipleItemHeight,
    selectHeight: token.controlHeight
  });
  return [
    panel_default(pickerToken),
    genPickerStyle(pickerToken),
    variants_default(pickerToken),
    genPickerStatusStyle(pickerToken),
    multiple_default(pickerToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token, {
      focusElCls: `${token.componentCls}-focused`
    })
  ];
}, prepareComponentToken18);

// node_modules/antd/es/calendar/style/index.js
var genCalendarStyles = (token) => {
  const {
    calendarCls,
    componentCls,
    fullBg,
    fullPanelBg,
    itemActiveBg
  } = token;
  return {
    [calendarCls]: {
      ...genPanelStyle(token),
      ...resetComponent(token),
      background: fullBg,
      "&-rtl": {
        direction: "rtl"
      },
      [`${calendarCls}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${unit(token.paddingSM)} 0`,
        [`${calendarCls}-year-select`]: {
          minWidth: token.yearControlWidth
        },
        [`${calendarCls}-month-select`]: {
          minWidth: token.monthControlWidth,
          marginInlineStart: token.marginXS
        },
        [`${calendarCls}-mode-switch`]: {
          marginInlineStart: token.marginXS
        }
      }
    },
    [`${calendarCls} ${componentCls}-panel`]: {
      background: fullPanelBg,
      border: 0,
      borderTop: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
      borderRadius: 0,
      [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
        width: "auto"
      },
      [`${componentCls}-body`]: {
        padding: `${unit(token.paddingXS)} 0`
      },
      [`${componentCls}-content`]: {
        width: "100%"
      }
    },
    [`${calendarCls}-mini`]: {
      borderRadius: token.borderRadiusLG,
      [`${calendarCls}-header`]: {
        paddingInlineEnd: token.paddingXS,
        paddingInlineStart: token.paddingXS
      },
      [`${componentCls}-panel`]: {
        borderRadius: `0 0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)}`
      },
      [`${componentCls}-content`]: {
        height: token.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: unit(token.weekHeight)
        }
      },
      [`${componentCls}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${calendarCls}${calendarCls}-full`]: {
      [`${componentCls}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: fullBg,
        border: 0,
        [`${componentCls}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: token.paddingSM,
            paddingBottom: token.paddingXXS,
            lineHeight: unit(token.weekHeight)
          }
        }
      },
      [`${componentCls}-cell-week ${componentCls}-cell-inner`]: {
        display: "block",
        borderRadius: 0,
        borderTop: `${unit(token.lineWidthBold)} ${token.lineType} ${token.colorSplit}`,
        width: "100%",
        height: token.calc(token.dateValueHeight).add(token.dateContentHeight).add(token.calc(token.paddingXS).div(2)).add(token.lineWidthBold).equal()
      },
      [`${componentCls}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${calendarCls}-date`]: {
            background: token.controlItemBgHover
          }
        },
        [`${calendarCls}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${componentCls}-cell-selected`]: {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            background: itemActiveBg
          }
        },
        "&-selected, &-selected:hover": {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            [`${calendarCls}-date-value`]: {
              color: token.colorPrimary
            }
          }
        }
      },
      [`${calendarCls}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${unit(token.calc(token.marginXS).div(2).equal())}`,
        padding: `${unit(token.calc(token.paddingXS).div(2).equal())} ${unit(token.paddingXS)} 0`,
        border: 0,
        borderTop: `${unit(token.lineWidthBold)} ${token.lineType} ${token.colorSplit}`,
        borderRadius: 0,
        transition: `background ${token.motionDurationSlow}`,
        "&-value": {
          lineHeight: unit(token.dateValueHeight),
          transition: `color ${token.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: token.dateContentHeight,
          overflowY: "auto",
          color: token.colorText,
          lineHeight: token.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: token.colorPrimary,
          [`${calendarCls}-date-value`]: {
            color: token.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${unit(token.screenXS)}) `]: {
      [calendarCls]: {
        [`${calendarCls}-header`]: {
          display: "block",
          [`${calendarCls}-year-select`]: {
            width: "50%"
          },
          [`${calendarCls}-month-select`]: {
            width: `calc(50% - ${unit(token.paddingXS)})`
          },
          [`${calendarCls}-mode-switch`]: {
            width: "100%",
            marginTop: token.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
};
var prepareComponentToken19 = (token) => ({
  fullBg: token.colorBgContainer,
  fullPanelBg: token.colorBgContainer,
  itemActiveBg: token.controlItemBgActive,
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256,
  ...initPanelComponentToken(token)
});
var style_default22 = genStyleHooks("Calendar", (token) => {
  const calendarCls = `${token.componentCls}-calendar`;
  const calendarToken = merge(token, initPickerPanelToken(token), {
    calendarCls,
    pickerCellInnerCls: `${token.componentCls}-cell-inner`,
    dateValueHeight: token.controlHeightSM,
    weekHeight: token.calc(token.controlHeightSM).mul(0.75).equal(),
    dateContentHeight: token.calc(token.calc(token.fontHeightSM).add(token.marginXS)).mul(3).add(token.calc(token.lineWidth).mul(2)).equal()
  });
  return genCalendarStyles(calendarToken);
}, prepareComponentToken19);

// node_modules/antd/es/calendar/generateCalendar.js
var isSameYear2 = (date1, date2, config) => {
  const {
    getYear: getYear2
  } = config;
  return date1 && date2 && getYear2(date1) === getYear2(date2);
};
var isSameMonth2 = (date1, date2, config) => {
  const {
    getMonth: getMonth2
  } = config;
  return isSameYear2(date1, date2, config) && getMonth2(date1) === getMonth2(date2);
};
var isSameDate2 = (date1, date2, config) => {
  const {
    getDate: getDate2
  } = config;
  return isSameMonth2(date1, date2, config) && getDate2(date1) === getDate2(date2);
};
var generateCalendar = (generateConfig2) => {
  const Calendar2 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style,
      dateFullCellRender,
      dateCellRender,
      monthFullCellRender,
      monthCellRender,
      cellRender,
      fullCellRender,
      headerRender,
      value,
      defaultValue,
      disabledDate,
      mode,
      validRange,
      fullscreen = true,
      showWeek,
      onChange,
      onPanelChange,
      onSelect,
      styles,
      classNames
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("calendar");
    const mergedProps = {
      ...props,
      mode,
      fullscreen,
      showWeek
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const [rootCls, headerCls, panelClassNames, rootStyle, headerStyle, panelStyles] = React156.useMemo(() => {
      const {
        root: nextRootClassName,
        header: nextHeaderClassName,
        ...nextPanelClassNames
      } = mergedClassNames;
      const {
        root: nextRootStyle,
        header: nextHeaderStyle,
        ...nextPanelStyles
      } = mergedStyles;
      return [nextRootClassName, nextHeaderClassName, nextPanelClassNames, nextRootStyle, nextHeaderStyle, nextPanelStyles];
    }, [mergedClassNames, mergedStyles]);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const calendarPrefixCls = `${prefixCls}-calendar`;
    const [hashId, cssVarCls] = style_default22(prefixCls, calendarPrefixCls);
    const today = generateConfig2.getNow();
    if (true) {
      const warning2 = devUseWarning("Calendar");
      [["dateFullCellRender", "fullCellRender"], ["dateCellRender", "cellRender"], ["monthFullCellRender", "fullCellRender"], ["monthCellRender", "cellRender"]].forEach(([deprecatedName, newName]) => {
        warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    const [mergedValue, setMergedValue] = useControlledState(() => defaultValue || generateConfig2.getNow(), value);
    const [mergedMode, setMergedMode] = useControlledState("month", mode);
    const panelMode = React156.useMemo(() => mergedMode === "year" ? "month" : "date", [mergedMode]);
    const mergedDisabledDate = React156.useCallback((date) => {
      const notInRange = validRange ? generateConfig2.isAfter(validRange[0], date) || generateConfig2.isAfter(date, validRange[1]) : false;
      return notInRange || !!disabledDate?.(date);
    }, [disabledDate, validRange]);
    const triggerPanelChange = (date, newMode) => {
      onPanelChange?.(date, newMode);
    };
    const triggerChange = (date) => {
      setMergedValue(date);
      if (!isSameDate2(date, mergedValue, generateConfig2)) {
        if (panelMode === "date" && !isSameMonth2(date, mergedValue, generateConfig2) || panelMode === "month" && !isSameYear2(date, mergedValue, generateConfig2)) {
          triggerPanelChange(date, mergedMode);
        }
        onChange?.(date);
      }
    };
    const triggerModeChange = (newMode) => {
      setMergedMode(newMode);
      triggerPanelChange(mergedValue, newMode);
    };
    const onInternalSelect = (date, source) => {
      triggerChange(date);
      onSelect?.(date, {
        source
      });
    };
    const dateRender = React156.useCallback((date, info) => {
      if (fullCellRender) {
        return fullCellRender(date, info);
      }
      if (dateFullCellRender) {
        return dateFullCellRender(date);
      }
      return React156.createElement("div", {
        className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
          [`${calendarPrefixCls}-date-today`]: isSameDate2(today, date, generateConfig2)
        })
      }, React156.createElement("div", {
        className: `${calendarPrefixCls}-date-value`
      }, String(generateConfig2.getDate(date)).padStart(2, "0")), React156.createElement("div", {
        className: `${calendarPrefixCls}-date-content`
      }, typeof cellRender === "function" ? cellRender(date, info) : dateCellRender?.(date)));
    }, [today, prefixCls, calendarPrefixCls, fullCellRender, dateFullCellRender, cellRender, dateCellRender]);
    const monthRender = React156.useCallback((date, info) => {
      if (fullCellRender) {
        return fullCellRender(date, info);
      }
      if (monthFullCellRender) {
        return monthFullCellRender(date);
      }
      const months = info.locale.shortMonths || generateConfig2.locale.getShortMonths(info.locale.locale);
      return React156.createElement("div", {
        className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
          [`${calendarPrefixCls}-date-today`]: isSameMonth2(today, date, generateConfig2)
        })
      }, React156.createElement("div", {
        className: `${calendarPrefixCls}-date-value`
      }, months[generateConfig2.getMonth(date)]), React156.createElement("div", {
        className: `${calendarPrefixCls}-date-content`
      }, typeof cellRender === "function" ? cellRender(date, info) : monthCellRender?.(date)));
    }, [today, prefixCls, calendarPrefixCls, fullCellRender, monthFullCellRender, cellRender, monthCellRender]);
    const [contextLocale] = useLocale_default("Calendar", en_US_default3);
    const locale2 = {
      ...contextLocale,
      ...props.locale
    };
    const mergedCellRender = (current, info) => {
      if (info.type === "date") {
        return dateRender(current, info);
      }
      if (info.type === "month") {
        return monthRender(current, {
          ...info,
          locale: locale2?.lang
        });
      }
    };
    return React156.createElement("div", {
      className: clsx(calendarPrefixCls, {
        [`${calendarPrefixCls}-full`]: fullscreen,
        [`${calendarPrefixCls}-mini`]: !fullscreen,
        [`${calendarPrefixCls}-rtl`]: direction === "rtl"
      }, contextClassName, className, rootClassName, rootCls, hashId, cssVarCls),
      style: {
        ...rootStyle,
        ...contextStyle,
        ...style
      }
    }, headerRender ? headerRender({
      value: mergedValue,
      type: mergedMode,
      onChange: (nextDate) => {
        onInternalSelect(nextDate, "customize");
      },
      onTypeChange: triggerModeChange
    }) : React156.createElement(Header_default, {
      className: headerCls,
      style: headerStyle,
      prefixCls: calendarPrefixCls,
      value: mergedValue,
      generateConfig: generateConfig2,
      mode: mergedMode,
      fullscreen,
      locale: locale2?.lang,
      validRange,
      onChange: onInternalSelect,
      onModeChange: triggerModeChange
    }), React156.createElement(PickerPanel_default, {
      classNames: panelClassNames,
      styles: panelStyles,
      value: mergedValue,
      prefixCls,
      locale: locale2?.lang,
      generateConfig: generateConfig2,
      cellRender: mergedCellRender,
      onSelect: (nextDate) => {
        onInternalSelect(nextDate, panelMode);
      },
      mode: panelMode,
      picker: panelMode,
      disabledDate: mergedDisabledDate,
      hideHeader: true,
      showWeek
    }));
  };
  if (true) {
    Calendar2.displayName = "Calendar";
  }
  return Calendar2;
};
var generateCalendar_default = generateCalendar;

// node_modules/antd/es/calendar/index.js
var Calendar = generateCalendar_default(dayjs_default);
Calendar.generateCalendar = generateCalendar_default;
var calendar_default = Calendar;

// node_modules/antd/es/card/Card.js
var React172 = __toESM(require_react());

// node_modules/antd/es/tabs/index.js
var React170 = __toESM(require_react());

// node_modules/@rc-component/util/es/isMobile.js
var import_is_mobile = __toESM(require_is_mobile());
var cached;
var isMobile_default = (() => {
  if (typeof cached === "undefined") {
    cached = (0, import_is_mobile.default)();
  }
  return cached;
});

// node_modules/@rc-component/tabs/es/Tabs.js
var React168 = __toESM(require_react());
var import_react52 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabContext.js
var import_react44 = __toESM(require_react());
var TabContext_default = (0, import_react44.createContext)(null);

// node_modules/@rc-component/tabs/es/TabNavList/Wrapper.js
var React165 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabNavList/index.js
var React164 = __toESM(require_react());
var import_react51 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/hooks/useIndicator.js
var import_react45 = __toESM(require_react());
var useIndicator = (options) => {
  const {
    activeTabOffset,
    horizontal,
    rtl,
    indicator = {}
  } = options;
  const {
    size,
    align = "center"
  } = indicator;
  const [inkStyle, setInkStyle] = (0, import_react45.useState)();
  const inkBarRafRef = (0, import_react45.useRef)();
  const getLength = import_react45.default.useCallback((origin) => {
    if (typeof size === "function") {
      return size(origin);
    }
    if (typeof size === "number") {
      return size;
    }
    return origin;
  }, [size]);
  function cleanInkBarRaf() {
    raf_default.cancel(inkBarRafRef.current);
  }
  (0, import_react45.useEffect)(() => {
    const newInkStyle = {};
    if (activeTabOffset) {
      if (horizontal) {
        newInkStyle.width = getLength(activeTabOffset.width);
        const key = rtl ? "right" : "left";
        if (align === "start") {
          newInkStyle[key] = activeTabOffset[key];
        }
        if (align === "center") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
          newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
        }
        if (align === "end") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
          newInkStyle.transform = "translateX(-100%)";
        }
      } else {
        newInkStyle.height = getLength(activeTabOffset.height);
        if (align === "start") {
          newInkStyle.top = activeTabOffset.top;
        }
        if (align === "center") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
          newInkStyle.transform = "translateY(-50%)";
        }
        if (align === "end") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
          newInkStyle.transform = "translateY(-100%)";
        }
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = raf_default(() => {
      const isEqual = inkStyle && newInkStyle && Object.keys(newInkStyle).every((key) => {
        const newValue = newInkStyle[key];
        const oldValue = inkStyle[key];
        return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
      });
      if (!isEqual) {
        setInkStyle(newInkStyle);
      }
    });
    return cleanInkBarRaf;
  }, [JSON.stringify(activeTabOffset), horizontal, rtl, align, getLength]);
  return {
    style: inkStyle
  };
};
var useIndicator_default = useIndicator;

// node_modules/@rc-component/tabs/es/hooks/useOffsets.js
var import_react46 = __toESM(require_react());
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return (0, import_react46.useMemo)(() => {
    const map = /* @__PURE__ */ new Map();
    const lastOffset = tabSizes.get(tabs[0]?.key) || DEFAULT_SIZE;
    const rightOffset = lastOffset.left + lastOffset.width;
    for (let i = 0; i < tabs.length; i += 1) {
      const {
        key
      } = tabs[i];
      let data = tabSizes.get(key);
      if (!data) {
        data = tabSizes.get(tabs[i - 1]?.key) || DEFAULT_SIZE;
      }
      const entity = map.get(key) || {
        ...data
      };
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    return map;
  }, [tabs.map((tab) => tab.key).join("_"), tabSizes, holderScrollWidth]);
}

// node_modules/@rc-component/tabs/es/hooks/useSyncState.js
var React158 = __toESM(require_react());
function useSyncState3(defaultState, onChange) {
  const stateRef = React158.useRef(defaultState);
  const [, forceUpdate] = React158.useState({});
  function setState(updater) {
    const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  return [stateRef.current, setState];
}

// node_modules/@rc-component/tabs/es/hooks/useTouchMove.js
var React159 = __toESM(require_react());
var import_react47 = __toESM(require_react());
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
function useTouchMove(ref, onOffset) {
  const [touchPosition, setTouchPosition] = (0, import_react47.useState)();
  const [lastTimestamp, setLastTimestamp] = (0, import_react47.useState)(0);
  const [lastTimeDiff, setLastTimeDiff] = (0, import_react47.useState)(0);
  const [lastOffset, setLastOffset] = (0, import_react47.useState)();
  const motionRef = (0, import_react47.useRef)();
  function onTouchStart(e3) {
    const {
      screenX,
      screenY
    } = e3.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }
  function onTouchMove(e3) {
    if (!touchPosition) return;
    const {
      screenX,
      screenY
    } = e3.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    const offsetX = screenX - touchPosition.x;
    const offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    const now2 = Date.now();
    setLastTimestamp(now2);
    setLastTimeDiff(now2 - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition) return;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffset) {
      const distanceX = lastOffset.x / lastTimeDiff;
      const distanceY = lastOffset.y / lastTimeDiff;
      const absX = Math.abs(distanceX);
      const absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
      let currentX = distanceX;
      let currentY = distanceY;
      motionRef.current = window.setInterval(() => {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  const lastWheelDirectionRef = (0, import_react47.useRef)();
  function onWheel(e3) {
    const {
      deltaX,
      deltaY
    } = e3;
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e3.preventDefault();
    }
  }
  const touchEventsRef = (0, import_react47.useRef)(null);
  touchEventsRef.current = {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  };
  React159.useEffect(() => {
    function onProxyTouchStart(e3) {
      touchEventsRef.current.onTouchStart(e3);
    }
    function onProxyTouchMove(e3) {
      touchEventsRef.current.onTouchMove(e3);
    }
    function onProxyTouchEnd(e3) {
      touchEventsRef.current.onTouchEnd(e3);
    }
    function onProxyWheel(e3) {
      touchEventsRef.current.onWheel(e3);
    }
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: true
    });
    ref.current.addEventListener("touchstart", onProxyTouchStart, {
      passive: true
    });
    ref.current.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", onProxyTouchMove);
      document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}

// node_modules/@rc-component/tabs/es/hooks/useUpdate.js
var import_react48 = __toESM(require_react());
function useUpdate(callback) {
  const [count, setCount] = (0, import_react48.useState)(0);
  const effectRef = (0, import_react48.useRef)(0);
  const callbackRef = (0, import_react48.useRef)();
  callbackRef.current = callback;
  useLayoutUpdateEffect(() => {
    callbackRef.current?.();
  }, [count]);
  return () => {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
function useUpdateState(defaultState) {
  const batchRef = (0, import_react48.useRef)([]);
  const [, forceUpdate] = (0, import_react48.useState)({});
  const state = (0, import_react48.useRef)(typeof defaultState === "function" ? defaultState() : defaultState);
  const flushUpdate = useUpdate(() => {
    let current = state.current;
    batchRef.current.forEach((callback) => {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  return [state.current, updater];
}

// node_modules/@rc-component/tabs/es/hooks/useVisibleRange.js
var import_react49 = __toESM(require_react());
var DEFAULT_SIZE2 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, {
  tabs,
  tabPosition,
  rtl
}) {
  let charUnit;
  let position2;
  let transformSize;
  if (["top", "bottom"].includes(tabPosition)) {
    charUnit = "width";
    position2 = rtl ? "right" : "left";
    transformSize = Math.abs(transform);
  } else {
    charUnit = "height";
    position2 = "top";
    transformSize = -transform;
  }
  return (0, import_react49.useMemo)(() => {
    if (!tabs.length) {
      return [0, 0];
    }
    const len = tabs.length;
    let endIndex = len;
    for (let i = 0; i < len; i += 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (Math.floor(offset3[position2] + offset3[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
        endIndex = i - 1;
        break;
      }
    }
    let startIndex = 0;
    for (let i = len - 1; i >= 0; i -= 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (offset3[position2] < transformSize) {
        startIndex = i + 1;
        break;
      }
    }
    return startIndex > endIndex ? [0, -1] : [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map((tab) => tab.key).join("_"), rtl]);
}

// node_modules/@rc-component/tabs/es/util.js
function stringify(obj) {
  let tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach((v, k) => {
      tgt[k] = v;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function getRemovable(closable, closeIcon, editable, disabled) {
  if (
    // Only editable tabs can be removed
    !editable || // Tabs cannot be removed when disabled
    disabled || // closable is false
    closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    closable === void 0 && (closeIcon === false || closeIcon === null)
  ) {
    return false;
  }
  return true;
}

// node_modules/@rc-component/tabs/es/TabNavList/AddButton.js
var React160 = __toESM(require_react());
var AddButton = React160.forwardRef((props, ref) => {
  const {
    prefixCls,
    editable,
    locale: locale2,
    style
  } = props;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return React160.createElement("button", {
    ref,
    type: "button",
    className: `${prefixCls}-nav-add`,
    style,
    "aria-label": locale2?.addAriaLabel || "Add tab",
    onClick: (event) => {
      editable.onEdit("add", {
        event
      });
    }
  }, editable.addIcon || "+");
});
var AddButton_default = AddButton;

// node_modules/@rc-component/tabs/es/TabNavList/ExtraContent.js
var React161 = __toESM(require_react());
var ExtraContent = React161.forwardRef((props, ref) => {
  const {
    position: position2,
    prefixCls,
    extra
  } = props;
  if (!extra) {
    return null;
  }
  let content;
  let assertExtra = {};
  if (typeof extra === "object" && !React161.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position2 === "right") {
    content = assertExtra.right;
  }
  if (position2 === "left") {
    content = assertExtra.left;
  }
  return content ? React161.createElement("div", {
    className: `${prefixCls}-extra-content`,
    ref
  }, content) : null;
});
if (true) {
  ExtraContent.displayName = "ExtraContent";
}
var ExtraContent_default = ExtraContent;

// node_modules/@rc-component/tabs/es/TabNavList/OperationNode.js
var React162 = __toESM(require_react());
var import_react50 = __toESM(require_react());
function _extends35() {
  _extends35 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends35.apply(this, arguments);
}
var OperationNode = React162.forwardRef((props, ref) => {
  const {
    prefixCls,
    id,
    tabs,
    locale: locale2,
    mobile,
    more: moreProps = {},
    style,
    className,
    editable,
    tabBarGutter,
    rtl,
    removeAriaLabel,
    onTabClick,
    getPopupContainer,
    popupClassName,
    popupStyle
  } = props;
  const [open3, setOpen] = (0, import_react50.useState)(false);
  const [selectedKey, setSelectedKey] = (0, import_react50.useState)(null);
  const {
    icon: moreIcon = "More"
  } = moreProps;
  const popupId = `${id}-more-popup`;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const selectedItemId = selectedKey !== null ? `${popupId}-${selectedKey}` : null;
  const dropdownAriaLabel = locale2?.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  const menu = React162.createElement(es_default10, {
    onClick: ({
      key,
      domEvent
    }) => {
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: `${dropdownPrefix}-menu`,
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
  }, tabs.map((tab) => {
    const {
      closable,
      disabled,
      closeIcon,
      key,
      label
    } = tab;
    const removable = getRemovable(closable, closeIcon, editable, disabled);
    return React162.createElement(MenuItem_default, {
      key,
      id: `${popupId}-${key}`,
      role: "option",
      "aria-controls": id && `${id}-panel-${key}`,
      disabled
    }, React162.createElement("span", null, label), removable && React162.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: `${dropdownPrefix}-menu-item-remove`,
      onClick: (e3) => {
        e3.stopPropagation();
        onRemoveTab(e3, key);
      }
    }, closeIcon || editable.removeIcon || ""));
  }));
  function selectOffset(offset3) {
    const enabledTabs = tabs.filter((tab) => !tab.disabled);
    let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey) || 0;
    const len = enabledTabs.length;
    for (let i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset3 + len) % len;
      const tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  function onKeyDown2(e3) {
    const {
      which
    } = e3;
    if (!open3) {
      if ([KeyCode_default.DOWN, KeyCode_default.SPACE, KeyCode_default.ENTER].includes(which)) {
        setOpen(true);
        e3.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode_default.UP:
        selectOffset(-1);
        e3.preventDefault();
        break;
      case KeyCode_default.DOWN:
        selectOffset(1);
        e3.preventDefault();
        break;
      case KeyCode_default.ESC:
        setOpen(false);
        break;
      case KeyCode_default.SPACE:
      case KeyCode_default.ENTER:
        if (selectedKey !== null) {
          onTabClick(selectedKey, e3);
        }
        break;
    }
  }
  (0, import_react50.useEffect)(() => {
    const ele = document.getElementById(selectedItemId);
    if (ele?.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedItemId, selectedKey]);
  (0, import_react50.useEffect)(() => {
    if (!open3) {
      setSelectedKey(null);
    }
  }, [open3]);
  const moreStyle = {
    marginInlineStart: tabBarGutter
  };
  if (!tabs.length) {
    moreStyle.visibility = "hidden";
    moreStyle.order = 1;
  }
  const overlayClassName = clsx(popupClassName, {
    [`${dropdownPrefix}-rtl`]: rtl
  });
  const moreNode = mobile ? null : React162.createElement(es_default9, _extends35({
    prefixCls: dropdownPrefix,
    overlay: menu,
    visible: tabs.length ? open3 : false,
    onVisibleChange: setOpen,
    overlayClassName,
    overlayStyle: popupStyle,
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer
  }, moreProps), React162.createElement("button", {
    type: "button",
    className: `${prefixCls}-nav-more`,
    style: moreStyle,
    "aria-haspopup": "listbox",
    "aria-controls": popupId,
    id: `${id}-more`,
    "aria-expanded": open3,
    onKeyDown: onKeyDown2
  }, moreIcon));
  return React162.createElement("div", {
    className: clsx(`${prefixCls}-nav-operations`, className),
    style,
    ref
  }, moreNode, React162.createElement(AddButton_default, {
    prefixCls,
    locale: locale2,
    editable
  }));
});
var OperationNode_default = React162.memo(OperationNode, (_, next) => (
  // https://github.com/ant-design/ant-design/issues/32544
  // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
  next.tabMoving
));

// node_modules/@rc-component/tabs/es/TabNavList/TabNode.js
var React163 = __toESM(require_react());
var TabNode = (props) => {
  const {
    prefixCls,
    id,
    active,
    focus,
    tab: {
      key,
      label,
      disabled,
      closeIcon,
      icon
    },
    closable,
    renderWrapper,
    removeAriaLabel,
    editable,
    onClick,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onMouseDown,
    onMouseUp,
    style,
    className,
    tabCount,
    currentPosition
  } = props;
  const tabPrefix = `${prefixCls}-tab`;
  const removable = getRemovable(closable, closeIcon, editable, disabled);
  function onInternalClick(e3) {
    if (disabled) {
      return;
    }
    onClick(e3);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  const labelNode = React163.useMemo(() => icon && typeof label === "string" ? React163.createElement("span", null, label) : label, [label, icon]);
  const btnRef = React163.useRef(null);
  React163.useEffect(() => {
    if (focus && btnRef.current) {
      btnRef.current.focus();
    }
  }, [focus]);
  const node = React163.createElement("div", {
    key,
    "data-node-key": genDataNodeKey(key),
    className: clsx(tabPrefix, className, {
      [`${tabPrefix}-with-remove`]: removable,
      [`${tabPrefix}-active`]: active,
      [`${tabPrefix}-disabled`]: disabled,
      [`${tabPrefix}-focus`]: focus
    }),
    style,
    onClick: onInternalClick
  }, React163.createElement("div", {
    ref: btnRef,
    role: "tab",
    "aria-selected": active,
    id: id && `${id}-tab-${key}`,
    className: `${tabPrefix}-btn`,
    "aria-controls": id && `${id}-panel-${key}`,
    "aria-disabled": disabled,
    tabIndex: disabled ? null : active ? 0 : -1,
    onClick: (e3) => {
      e3.stopPropagation();
      onInternalClick(e3);
    },
    onKeyDown: onKeyDown2,
    onMouseDown,
    onMouseUp,
    onFocus,
    onBlur
  }, focus && React163.createElement("div", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, `Tab ${currentPosition} of ${tabCount}`), icon && React163.createElement("span", {
    className: `${tabPrefix}-icon`
  }, icon), label && labelNode), removable && React163.createElement("button", {
    type: "button",
    "aria-label": removeAriaLabel || "remove",
    tabIndex: active ? 0 : -1,
    className: `${tabPrefix}-remove`,
    onClick: (e3) => {
      e3.stopPropagation();
      onRemoveTab(e3);
    }
  }, closeIcon || editable.removeIcon || ""));
  return renderWrapper ? renderWrapper(node) : node;
};
var TabNode_default = TabNode;

// node_modules/@rc-component/tabs/es/TabNavList/index.js
function _extends36() {
  _extends36 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends36.apply(this, arguments);
}
var getTabSize = (tab, containerRect) => {
  const {
    offsetWidth,
    offsetHeight,
    offsetTop,
    offsetLeft
  } = tab;
  const {
    width,
    height,
    left,
    top
  } = tab.getBoundingClientRect();
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, left - containerRect.left, top - containerRect.top];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
};
var getSize = (refObj) => {
  const {
    offsetWidth = 0,
    offsetHeight = 0
  } = refObj.current || {};
  if (refObj.current) {
    const {
      width,
      height
    } = refObj.current.getBoundingClientRect();
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height];
    }
  }
  return [offsetWidth, offsetHeight];
};
var getUnitValue = (size, tabPositionTopOrBottom) => {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
var TabNavList = React164.forwardRef((props, ref) => {
  const {
    className,
    style,
    id,
    animated,
    activeKey,
    rtl,
    extra,
    editable,
    locale: locale2,
    tabPosition,
    tabBarGutter,
    children,
    onTabClick,
    onTabScroll,
    indicator,
    classNames: tabsClassNames,
    styles
  } = props;
  const {
    prefixCls,
    tabs
  } = React164.useContext(TabContext_default);
  const containerRef = (0, import_react51.useRef)(null);
  const extraLeftRef = (0, import_react51.useRef)(null);
  const extraRightRef = (0, import_react51.useRef)(null);
  const tabsWrapperRef = (0, import_react51.useRef)(null);
  const tabListRef = (0, import_react51.useRef)(null);
  const operationsRef = (0, import_react51.useRef)(null);
  const innerAddButtonRef = (0, import_react51.useRef)(null);
  const tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
  const [transformLeft, setTransformLeft] = useSyncState3(0, (next, prev) => {
    if (tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next > prev ? "left" : "right"
      });
    }
  });
  const [transformTop, setTransformTop] = useSyncState3(0, (next, prev) => {
    if (!tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next > prev ? "top" : "bottom"
      });
    }
  });
  const [containerExcludeExtraSize, setContainerExcludeExtraSize] = (0, import_react51.useState)([0, 0]);
  const [tabContentSize, setTabContentSize] = (0, import_react51.useState)([0, 0]);
  const [addSize, setAddSize] = (0, import_react51.useState)([0, 0]);
  const [operationSize, setOperationSize] = (0, import_react51.useState)([0, 0]);
  const [tabSizes, setTabSizes] = useUpdateState(/* @__PURE__ */ new Map());
  const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
  const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
  const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
  const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;
  let transformMin = 0;
  let transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
  const touchMovingRef = (0, import_react51.useRef)(null);
  const [lockAnimation, setLockAnimation] = (0, import_react51.useState)();
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    if (touchMovingRef.current) {
      clearTimeout(touchMovingRef.current);
    }
  }
  useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
    function doMove(setState, offset3) {
      setState((value) => {
        const newValue = alignInRange(value + offset3);
        return newValue;
      });
    }
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  (0, import_react51.useEffect)(() => {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = setTimeout(() => {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);
  const [visibleStart, visibleEnd] = useVisibleRange(
    tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue,
    {
      ...props,
      tabs
    }
  );
  const scrollToTab = useEvent_default((key = activeKey) => {
    const tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      let newTransform = transformLeft;
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      let newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(newTransform));
    }
  });
  const [focusKey, setFocusKey] = (0, import_react51.useState)();
  const [isMouse, setIsMouse] = (0, import_react51.useState)(false);
  const enabledTabs = tabs.filter((tab) => !tab.disabled).map((tab) => tab.key);
  const onOffset = (offset3) => {
    const currentIndex = enabledTabs.indexOf(focusKey || activeKey);
    const len = enabledTabs.length;
    const nextIndex = (currentIndex + offset3 + len) % len;
    const newKey = enabledTabs[nextIndex];
    setFocusKey(newKey);
  };
  const handleRemoveTab = (removalTabKey, e3) => {
    const removeIndex = enabledTabs.indexOf(removalTabKey);
    const removeTab = tabs.find((tab) => tab.key === removalTabKey);
    const removable = getRemovable(removeTab?.closable, removeTab?.closeIcon, editable, removeTab?.disabled);
    if (removable) {
      e3.preventDefault();
      e3.stopPropagation();
      editable.onEdit("remove", {
        key: removalTabKey,
        event: e3
      });
      if (removeIndex === enabledTabs.length - 1) {
        onOffset(-1);
      } else {
        onOffset(1);
      }
    }
  };
  const handleMouseDown = (key, e3) => {
    setIsMouse(true);
    if (e3.button === 1) {
      handleRemoveTab(key, e3);
    }
  };
  const handleKeyDown = (e3) => {
    const {
      code
    } = e3;
    const isRTL = rtl && tabPositionTopOrBottom;
    const firstEnabledTab = enabledTabs[0];
    const lastEnabledTab = enabledTabs[enabledTabs.length - 1];
    switch (code) {
      // LEFT
      case "ArrowLeft": {
        if (tabPositionTopOrBottom) {
          onOffset(isRTL ? 1 : -1);
        }
        break;
      }
      // RIGHT
      case "ArrowRight": {
        if (tabPositionTopOrBottom) {
          onOffset(isRTL ? -1 : 1);
        }
        break;
      }
      // UP
      case "ArrowUp": {
        e3.preventDefault();
        if (!tabPositionTopOrBottom) {
          onOffset(-1);
        }
        break;
      }
      // DOWN
      case "ArrowDown": {
        e3.preventDefault();
        if (!tabPositionTopOrBottom) {
          onOffset(1);
        }
        break;
      }
      // HOME
      case "Home": {
        e3.preventDefault();
        setFocusKey(firstEnabledTab);
        break;
      }
      // END
      case "End": {
        e3.preventDefault();
        setFocusKey(lastEnabledTab);
        break;
      }
      // Enter & Space
      case "Enter":
      case "Space": {
        e3.preventDefault();
        onTabClick(focusKey ?? activeKey, e3);
        break;
      }
      // Backspace
      case "Backspace":
      case "Delete": {
        handleRemoveTab(focusKey, e3);
        break;
      }
    }
  };
  const tabNodeStyle = {};
  if (tabPositionTopOrBottom) {
    tabNodeStyle.marginInlineStart = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  const tabNodes = tabs.map((tab, i) => {
    const {
      key
    } = tab;
    return React164.createElement(TabNode_default, {
      id,
      prefixCls,
      key,
      tab,
      className: tabsClassNames?.item,
      style: i === 0 ? styles?.item : {
        ...tabNodeStyle,
        ...styles?.item
      },
      closable: tab.closable,
      editable,
      active: key === activeKey,
      focus: key === focusKey,
      renderWrapper: children,
      removeAriaLabel: locale2?.removeAriaLabel,
      tabCount: enabledTabs.length,
      currentPosition: i + 1,
      onClick: (e3) => {
        onTabClick(key, e3);
      },
      onKeyDown: handleKeyDown,
      onFocus: () => {
        if (!isMouse) {
          setFocusKey(key);
        }
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      },
      onBlur: () => {
        setFocusKey(void 0);
      },
      onMouseDown: (e3) => handleMouseDown(key, e3),
      onMouseUp: () => {
        setIsMouse(false);
      }
    });
  });
  const updateTabSizes = () => setTabSizes(() => {
    const newSizes = /* @__PURE__ */ new Map();
    const listRect = tabListRef.current?.getBoundingClientRect();
    tabs.forEach(({
      key
    }) => {
      const btnNode = tabListRef.current?.querySelector(`[data-node-key="${genDataNodeKey(key)}"]`);
      if (btnNode) {
        const [width, height, left, top] = getTabSize(btnNode, listRect);
        newSizes.set(key, {
          width,
          height,
          left,
          top
        });
      }
    });
    return newSizes;
  });
  (0, import_react51.useEffect)(() => {
    updateTabSizes();
  }, [tabs.map((tab) => tab.key).join("_")]);
  const onListHolderResize = useUpdate(() => {
    const containerSize = getSize(containerRef);
    const extraLeftSize = getSize(extraLeftRef);
    const extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    const newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    const newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);
    const tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
    updateTabSizes();
  });
  const startHiddenTabs = tabs.slice(0, visibleStart);
  const endHiddenTabs = tabs.slice(visibleEnd + 1);
  const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];
  const activeTabOffset = tabOffsets.get(activeKey);
  const {
    style: indicatorStyle
  } = useIndicator_default({
    activeTabOffset,
    horizontal: tabPositionTopOrBottom,
    indicator,
    rtl
  });
  (0, import_react51.useEffect)(() => {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);
  (0, import_react51.useEffect)(() => {
    onListHolderResize();
  }, [rtl]);
  const hasDropdown = !!hiddenTabs.length;
  const wrapPrefix = `${prefixCls}-nav-wrap`;
  let pingLeft;
  let pingRight;
  let pingTop;
  let pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return React164.createElement(es_default3, {
    onResize: onListHolderResize
  }, React164.createElement("div", {
    ref: useComposeRef(ref, containerRef),
    role: "tablist",
    "aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
    className: clsx(`${prefixCls}-nav`, className, tabsClassNames?.header),
    style: {
      ...styles?.header,
      ...style
    },
    onKeyDown: () => {
      doLockAnimation();
    }
  }, React164.createElement(ExtraContent_default, {
    ref: extraLeftRef,
    position: "left",
    extra,
    prefixCls
  }), React164.createElement(es_default3, {
    onResize: onListHolderResize
  }, React164.createElement("div", {
    className: clsx(wrapPrefix, {
      [`${wrapPrefix}-ping-left`]: pingLeft,
      [`${wrapPrefix}-ping-right`]: pingRight,
      [`${wrapPrefix}-ping-top`]: pingTop,
      [`${wrapPrefix}-ping-bottom`]: pingBottom
    }),
    ref: tabsWrapperRef
  }, React164.createElement(es_default3, {
    onResize: onListHolderResize
  }, React164.createElement("div", {
    ref: tabListRef,
    className: `${prefixCls}-nav-list`,
    style: {
      transform: `translate(${transformLeft}px, ${transformTop}px)`,
      transition: lockAnimation ? "none" : void 0
    }
  }, tabNodes, React164.createElement(AddButton_default, {
    ref: innerAddButtonRef,
    prefixCls,
    locale: locale2,
    editable,
    style: {
      ...tabNodes.length === 0 ? void 0 : tabNodeStyle,
      visibility: hasDropdown ? "hidden" : null
    }
  }), React164.createElement("div", {
    className: clsx(`${prefixCls}-ink-bar`, tabsClassNames?.indicator, {
      [`${prefixCls}-ink-bar-animated`]: animated.inkBar
    }),
    style: {
      ...indicatorStyle,
      ...styles?.indicator
    }
  }))))), React164.createElement(OperationNode_default, _extends36({}, props, {
    removeAriaLabel: locale2?.removeAriaLabel,
    ref: operationsRef,
    prefixCls,
    tabs: hiddenTabs,
    className: !hasDropdown && operationsHiddenClassName,
    popupStyle: styles?.popup,
    tabMoving: !!lockAnimation
  })), React164.createElement(ExtraContent_default, {
    ref: extraRightRef,
    position: "right",
    extra,
    prefixCls
  })));
});
var TabNavList_default = TabNavList;

// node_modules/@rc-component/tabs/es/TabNavList/Wrapper.js
var TabNavListWrapper = ({
  renderTabBar,
  ...restProps
}) => {
  if (renderTabBar) {
    return renderTabBar(restProps, TabNavList_default);
  }
  return React165.createElement(TabNavList_default, restProps);
};
if (true) {
  TabNavListWrapper.displayName = "TabNavListWrapper";
}
var Wrapper_default = TabNavListWrapper;

// node_modules/@rc-component/tabs/es/TabPanelList/index.js
var React167 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabPanelList/TabPane.js
var React166 = __toESM(require_react());
var TabPane = React166.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style,
    id,
    active,
    tabKey,
    children
  } = props;
  const hasContent2 = React166.Children.count(children) > 0;
  return React166.createElement("div", {
    id: id && `${id}-panel-${tabKey}`,
    role: "tabpanel",
    tabIndex: active && hasContent2 ? 0 : -1,
    "aria-labelledby": id && `${id}-tab-${tabKey}`,
    "aria-hidden": !active,
    style,
    className: clsx(prefixCls, active && `${prefixCls}-active`, className),
    ref
  }, children);
});
if (true) {
  TabPane.displayName = "TabPane";
}
var TabPane_default = TabPane;

// node_modules/@rc-component/tabs/es/TabPanelList/index.js
function _extends37() {
  _extends37 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends37.apply(this, arguments);
}
var TabPanelList = (props) => {
  const {
    id,
    activeKey,
    animated,
    tabPosition,
    destroyOnHidden,
    contentStyle,
    contentClassName
  } = props;
  const {
    prefixCls,
    tabs
  } = React167.useContext(TabContext_default);
  const tabPaneAnimated = animated.tabPane;
  const tabPanePrefixCls = `${prefixCls}-tabpane`;
  return React167.createElement("div", {
    className: clsx(`${prefixCls}-content-holder`)
  }, React167.createElement("div", {
    className: clsx(`${prefixCls}-content`, `${prefixCls}-content-${tabPosition}`, {
      [`${prefixCls}-content-animated`]: tabPaneAnimated
    })
  }, tabs.map((item) => {
    const {
      key,
      forceRender,
      style: paneStyle,
      className: paneClassName,
      destroyOnHidden: itemDestroyOnHidden,
      ...restTabProps
    } = item;
    const active = key === activeKey;
    return React167.createElement(es_default4, _extends37({
      key,
      visible: active,
      forceRender,
      removeOnLeave: !!(destroyOnHidden ?? itemDestroyOnHidden),
      leavedClassName: `${tabPanePrefixCls}-hidden`
    }, animated.tabPaneMotion), ({
      style: motionStyle,
      className: motionClassName
    }, ref) => React167.createElement(TabPane_default, _extends37({}, restTabProps, {
      prefixCls: tabPanePrefixCls,
      id,
      tabKey: key,
      animated: tabPaneAnimated,
      active,
      style: {
        ...contentStyle,
        ...paneStyle,
        ...motionStyle
      },
      className: clsx(contentClassName, paneClassName, motionClassName),
      ref
    })));
  })));
};
var TabPanelList_default = TabPanelList;

// node_modules/@rc-component/tabs/es/hooks/useAnimateConfig.js
function useAnimateConfig(animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    if (true) {
      warning_default(false, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work.");
    }
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}

// node_modules/@rc-component/tabs/es/Tabs.js
function _extends38() {
  _extends38 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends38.apply(this, arguments);
}
var uuid2 = 0;
var Tabs = React168.forwardRef((props, ref) => {
  const {
    id,
    prefixCls = "rc-tabs",
    className,
    items,
    direction,
    activeKey,
    defaultActiveKey,
    editable,
    animated,
    tabPosition = "top",
    tabBarGutter,
    tabBarStyle,
    tabBarExtraContent,
    locale: locale2,
    more,
    destroyOnHidden,
    renderTabBar,
    onChange,
    onTabClick,
    onTabScroll,
    getPopupContainer,
    popupClassName,
    indicator,
    classNames: tabsClassNames,
    styles,
    ...restProps
  } = props;
  const tabs = React168.useMemo(() => (items || []).filter((item) => item && typeof item === "object" && "key" in item), [items]);
  const rtl = direction === "rtl";
  const mergedAnimated = useAnimateConfig(animated);
  const [mobile, setMobile] = (0, import_react52.useState)(false);
  (0, import_react52.useEffect)(() => {
    setMobile(isMobile_default());
  }, []);
  const [mergedActiveKey, setMergedActiveKey] = useControlledState(defaultActiveKey ?? tabs[0]?.key, activeKey);
  const [activeIndex, setActiveIndex] = (0, import_react52.useState)(() => tabs.findIndex((tab) => tab.key === mergedActiveKey));
  (0, import_react52.useEffect)(() => {
    let newActiveIndex = tabs.findIndex((tab) => tab.key === mergedActiveKey);
    if (newActiveIndex === -1) {
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey(tabs[newActiveIndex]?.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map((tab) => tab.key).join("_"), mergedActiveKey, activeIndex]);
  const [mergedId, setMergedId] = useControlledState(null, id);
  (0, import_react52.useEffect)(() => {
    if (!id) {
      setMergedId(`rc-tabs-${false ? "test" : uuid2}`);
      uuid2 += 1;
    }
  }, []);
  function onInternalTabClick(key, e3) {
    onTabClick?.(key, e3);
    const isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange?.(key);
    }
  }
  const sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  };
  const tabNavBarProps = {
    ...sharedProps,
    editable,
    locale: locale2,
    more,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    getPopupContainer,
    popupClassName: clsx(popupClassName, tabsClassNames?.popup),
    indicator,
    styles,
    classNames: tabsClassNames
  };
  const memoizedValue = React168.useMemo(() => {
    return {
      tabs,
      prefixCls
    };
  }, [tabs, prefixCls]);
  return React168.createElement(TabContext_default.Provider, {
    value: memoizedValue
  }, React168.createElement("div", _extends38({
    ref,
    id,
    className: clsx(prefixCls, `${prefixCls}-${tabPosition}`, {
      [`${prefixCls}-mobile`]: mobile,
      [`${prefixCls}-editable`]: editable,
      [`${prefixCls}-rtl`]: rtl
    }, className)
  }, restProps), React168.createElement(Wrapper_default, _extends38({}, tabNavBarProps, {
    renderTabBar
  })), React168.createElement(TabPanelList_default, _extends38({
    destroyOnHidden
  }, sharedProps, {
    contentStyle: styles?.content,
    contentClassName: tabsClassNames?.content,
    animated: mergedAnimated
  }))));
});
if (true) {
  Tabs.displayName = "Tabs";
}
var Tabs_default = Tabs;

// node_modules/@rc-component/tabs/es/index.js
var es_default13 = Tabs_default;

// node_modules/antd/es/tabs/hooks/useAnimateConfig.js
var motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig2(prefixCls, animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = {
      ...motion,
      motionName: getTransitionName(prefixCls, "switch")
    };
  }
  return mergedAnimated;
}

// node_modules/antd/es/tabs/hooks/useLegacyItems.js
var React169 = __toESM(require_react());
function filter(items) {
  return items.filter((item) => item);
}
function useLegacyItems(items, children) {
  if (true) {
    const warning2 = devUseWarning("Tabs");
    warning2.deprecated(!children, "Tabs.TabPane", "items");
  }
  if (items) {
    return items.map((item) => ({
      ...item,
      destroyOnHidden: item.destroyOnHidden ?? item.destroyInactiveTabPane
    }));
  }
  const childrenItems = toArray(children).map((node) => {
    if (React169.isValidElement(node)) {
      const {
        key,
        props
      } = node;
      const {
        tab,
        ...restProps
      } = props || {};
      const item = {
        key: String(key),
        ...restProps,
        label: tab
      };
      return item;
    }
    return null;
  });
  return filter(childrenItems);
}
var useLegacyItems_default = useLegacyItems;

// node_modules/antd/es/tabs/style/motion.js
var genMotionStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token, "slide-up"), initSlideMotion(token, "slide-down")]
  ];
};
var motion_default2 = genMotionStyle;

// node_modules/antd/es/tabs/style/index.js
var genCardStyle = (token) => {
  const {
    componentCls,
    tabsCardPadding,
    cardBg,
    cardGutter,
    colorBorderSecondary,
    itemSelectedColor
  } = token;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardPadding,
          background: cardBg,
          border: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: itemSelectedColor,
          background: token.colorBgContainer
        },
        [`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token, -3),
        [`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: {
          outline: "none"
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: unit(cardGutter)
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)}`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: unit(cardGutter)
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token.borderRadiusLG)} 0 0 ${unit(token.borderRadiusLG)}`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      }
    }
  };
};
var genDropdownStyle = (token) => {
  const {
    componentCls,
    itemHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token;
  return {
    [`${componentCls}-dropdown`]: {
      ...resetComponent(token),
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token.tabsDropdownHeight,
        margin: 0,
        padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token.borderRadiusLG,
        outline: "none",
        boxShadow: token.boxShadowSecondary,
        "&-item": {
          ...textEllipsis,
          display: "flex",
          alignItems: "center",
          minWidth: token.tabsDropdownWidth,
          margin: 0,
          padding: `${unit(token.paddingXXS)} ${unit(token.paddingSM)}`,
          color: token.colorText,
          fontWeight: "normal",
          fontSize: token.fontSize,
          lineHeight: token.lineHeight,
          cursor: "pointer",
          transition: `all ${token.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token.marginSM
            },
            color: token.colorIcon,
            fontSize: token.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: itemHoverColor
            }
          },
          "&:hover": {
            background: token.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        }
      }
    }
  };
};
var genPositionStyle = (token) => {
  const {
    componentCls,
    margin,
    colorBorderSecondary,
    horizontalMargin,
    verticalItemPadding,
    verticalItemMargin,
    calc
  } = token;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: horizontalMargin,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token.lineWidthBold,
          "&-animated": {
            transition: `width ${token.motionDurationSlow}, left ${token.motionDurationSlow},
            right ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: margin,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: calc(token.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: verticalItemPadding,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: verticalItemMargin
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token.lineWidthBold,
          "&-animated": {
            transition: `height ${token.motionDurationSlow}, top ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: unit(calc(token.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: true,
          value: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: calc(token.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: true,
          value: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    }
  };
};
var genSizeStyle = (token) => {
  const {
    componentCls,
    cardPaddingSM,
    cardPaddingLG,
    cardHeightSM,
    cardHeightLG,
    horizontalItemPaddingSM,
    horizontalItemPaddingLG
  } = token;
  return {
    // >>>>> shared
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingSM,
            fontSize: token.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingLG,
            fontSize: token.titleFontSizeLG,
            lineHeight: token.lineHeightLG
          }
        }
      }
    },
    // >>>>> card
    [`${componentCls}-card`]: {
      // Small
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingSM
          },
          [`${componentCls}-nav-add`]: {
            minWidth: cardHeightSM,
            minHeight: cardHeightSM
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token.borderRadius)} ${unit(token.borderRadius)}`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${unit(token.borderRadius)} ${unit(token.borderRadius)} 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token.borderRadius)} ${unit(token.borderRadius)} 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token.borderRadius)} 0 0 ${unit(token.borderRadius)}`
            }
          }
        }
      },
      // Large
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingLG
          },
          [`${componentCls}-nav-add`]: {
            minWidth: cardHeightLG,
            minHeight: cardHeightLG
          }
        }
      }
    }
  };
};
var genTabStyle = (token) => {
  const {
    componentCls,
    itemActiveColor,
    itemHoverColor,
    iconCls,
    tabsHorizontalItemMargin,
    horizontalItemPadding,
    itemSelectedColor,
    itemColor
  } = token;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: horizontalItemPadding,
      fontSize: token.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: itemColor,
      "&-btn, &-remove": {
        "&:focus:not(:focus-visible), &:active": {
          color: itemActiveColor
        }
      },
      "&-btn": {
        outline: "none",
        transition: `all ${token.motionDurationSlow}`,
        [`${tabCls}-icon:not(:last-child)`]: {
          marginInlineEnd: token.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        lineHeight: 1,
        marginRight: {
          _skip_check_: true,
          value: token.calc(token.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: true,
          value: token.marginXS
        },
        color: token.colorIcon,
        fontSize: token.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token.motionDurationSlow}`,
        "&:hover": {
          color: token.colorTextHeading
        },
        ...genFocusStyle(token)
      },
      "&:hover": {
        color: itemHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: itemSelectedColor
      },
      [`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token),
      [`&${tabCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0,
        verticalAlign: "middle"
      },
      [`${iconCls}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: true,
          value: token.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: tabsHorizontalItemMargin
      }
    }
  };
};
var genRtlStyle = (token) => {
  const {
    componentCls,
    tabsHorizontalItemMarginRTL,
    iconCls,
    cardGutter,
    calc
  } = token;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: tabsHorizontalItemMarginRTL
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(token.marginSM)
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: unit(token.marginXS)
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(calc(token.marginXXS).mul(-1).equal())
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: cardGutter
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
var genTabsStyle = (token) => {
  const {
    componentCls,
    tabsCardPadding,
    cardHeight,
    cardGutter,
    itemHoverColor,
    itemActiveColor,
    colorBorderSecondary
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardPadding,
          background: "transparent",
          border: 0,
          color: token.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.calc(token.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: {
          minWidth: cardHeight,
          minHeight: cardHeight,
          marginLeft: {
            _skip_check_: true,
            value: cardGutter
          },
          background: "transparent",
          border: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token.colorText,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`,
          "&:hover": {
            color: itemHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: itemActiveColor
          },
          ...genFocusStyle(token, -3)
        }
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token.inkBarColor,
        pointerEvents: "none"
      },
      // ============================= Tabs =============================
      ...genTabStyle(token),
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        ...genFocusStyle(token),
        "&-hidden": {
          display: "none"
        }
      }
    },
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
            margin: "auto"
          }
        }
      }
    }
  };
};
var prepareComponentToken20 = (token) => {
  const {
    cardHeight,
    cardHeightSM,
    cardHeightLG,
    controlHeight,
    controlHeightLG
  } = token;
  const mergedCardHeight = cardHeight || controlHeightLG;
  const mergedCardHeightSM = cardHeightSM || controlHeight;
  const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
  return {
    zIndexPopup: token.zIndexPopupBase + 50,
    cardBg: token.colorFillAlter,
    // We can not pass this as valid value,
    // Since `cardHeight` will lock nav add button height.
    cardHeight: mergedCardHeight,
    cardHeightSM: mergedCardHeightSM,
    cardHeightLG: mergedCardHeightLG,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(mergedCardHeight - token.fontHeight) / 2 - token.lineWidth}px ${token.padding}px`,
    cardPaddingSM: `${(mergedCardHeightSM - token.fontHeight) / 2 - token.lineWidth}px ${token.paddingXS}px`,
    cardPaddingLG: `${(mergedCardHeightLG - token.fontHeightLG) / 2 - token.lineWidth}px ${token.padding}px`,
    titleFontSize: token.fontSize,
    titleFontSizeLG: token.fontSizeLG,
    titleFontSizeSM: token.fontSize,
    inkBarColor: token.colorPrimary,
    horizontalMargin: `0 0 ${token.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: ``,
    horizontalItemMarginRTL: ``,
    horizontalItemPadding: `${token.paddingSM}px 0`,
    horizontalItemPaddingSM: `${token.paddingXS}px 0`,
    horizontalItemPaddingLG: `${token.padding}px 0`,
    verticalItemPadding: `${token.paddingXS}px ${token.paddingLG}px`,
    verticalItemMargin: `${token.margin}px 0 0 0`,
    itemColor: token.colorText,
    itemSelectedColor: token.colorPrimary,
    itemHoverColor: token.colorPrimaryHover,
    itemActiveColor: token.colorPrimaryActive,
    cardGutter: token.marginXXS / 2
  };
};
var style_default23 = genStyleHooks("Tabs", (token) => {
  const tabsToken = merge(token, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: token.cardPadding,
    dropdownEdgeChildVerticalPadding: token.paddingXXS,
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${unit(token.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token.horizontalItemGutter)}`
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), motion_default2(tabsToken)];
}, prepareComponentToken20);

// node_modules/antd/es/tabs/TabPane.js
var TabPane2 = () => null;
if (true) {
  TabPane2.displayName = "DeprecatedTabPane";
}
var TabPane_default2 = TabPane2;

// node_modules/antd/es/tabs/index.js
var InternalTabs = React170.forwardRef((props, ref) => {
  const {
    type,
    className,
    rootClassName,
    size: customSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    removeIcon,
    moreIcon,
    more,
    popupClassName,
    children,
    items,
    animated,
    style,
    indicatorSize,
    indicator,
    classNames,
    styles,
    destroyInactiveTabPane,
    destroyOnHidden,
    tabPlacement,
    tabPosition,
    ...restProps
  } = props;
  const {
    prefixCls: customizePrefixCls
  } = restProps;
  const {
    getPrefixCls,
    direction,
    getPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tabs");
  const {
    tabs
  } = React170.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tabs", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default23(prefixCls, rootCls);
  const tabsRef = React170.useRef(null);
  React170.useImperativeHandle(ref, () => ({
    nativeElement: tabsRef.current
  }));
  let editable;
  if (type === "editable-card") {
    editable = {
      onEdit: (editType, {
        key,
        event
      }) => {
        onEdit?.(editType === "add" ? event : key, editType);
      },
      removeIcon: removeIcon ?? tabs?.removeIcon ?? React170.createElement(CloseOutlined_default, null),
      addIcon: (addIcon ?? tabs?.addIcon) || React170.createElement(PlusOutlined_default, null),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  if (true) {
    const warning2 = devUseWarning("Tabs");
    [["popupClassName", "classNames.popup"], ["tabPosition", "tabPlacement"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    true ? warning2(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead.") : void 0;
    true ? warning2(!(indicatorSize || tabs?.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.") : void 0;
    warning2.deprecated(!("destroyInactiveTabPane" in props || items?.some((item) => "destroyInactiveTabPane" in item)), "destroyInactiveTabPane", "destroyOnHidden");
  }
  const size = useSize_default(customSize);
  const mergedItems = useLegacyItems_default(items, children);
  const mergedAnimated = useAnimateConfig2(prefixCls, animated);
  const mergedIndicator = {
    align: indicator?.align ?? tabs?.indicator?.align,
    size: indicator?.size ?? indicatorSize ?? tabs?.indicator?.size ?? tabs?.indicatorSize
  };
  const mergedPlacement = React170.useMemo(() => {
    const placement = tabPlacement ?? tabPosition ?? void 0;
    const isRTL = direction === "rtl";
    switch (placement) {
      case "start":
        return isRTL ? "right" : "left";
      case "end":
        return isRTL ? "left" : "right";
      default:
        return placement;
    }
  }, [tabPlacement, tabPosition, direction]);
  const mergedProps = {
    ...props,
    size,
    tabPlacement: mergedPlacement,
    items: mergedItems
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React170.createElement(es_default13, {
    ref: tabsRef,
    direction,
    getPopupContainer,
    ...restProps,
    items: mergedItems,
    className: clsx({
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-card`]: ["card", "editable-card"].includes(type),
      [`${prefixCls}-editable-card`]: type === "editable-card",
      [`${prefixCls}-centered`]: centered
    }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls),
    classNames: {
      ...mergedClassNames,
      popup: clsx(popupClassName, hashId, cssVarCls, rootCls, mergedClassNames.popup?.root)
    },
    styles: mergedStyles,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    editable,
    more: {
      icon: tabs?.more?.icon ?? tabs?.moreIcon ?? moreIcon ?? React170.createElement(EllipsisOutlined_default, null),
      transitionName: `${rootPrefixCls}-slide-up`,
      ...more
    },
    prefixCls,
    animated: mergedAnimated,
    indicator: mergedIndicator,
    destroyOnHidden: destroyOnHidden ?? destroyInactiveTabPane,
    tabPosition: mergedPlacement
  });
});
var Tabs2 = InternalTabs;
Tabs2.TabPane = TabPane_default2;
if (true) {
  Tabs2.displayName = "Tabs";
}
var tabs_default = Tabs2;

// node_modules/antd/es/card/CardGrid.js
var React171 = __toESM(require_react());
var CardGrid = ({
  prefixCls,
  className,
  hoverable = true,
  ...props
}) => {
  const {
    getPrefixCls
  } = React171.useContext(ConfigContext);
  const prefix = getPrefixCls("card", prefixCls);
  const classString = clsx(`${prefix}-grid`, className, {
    [`${prefix}-grid-hoverable`]: hoverable
  });
  return React171.createElement("div", {
    ...props,
    className: classString
  });
};
if (true) {
  CardGrid.displayName = "CardGrid";
}
var CardGrid_default = CardGrid;

// node_modules/antd/es/card/style/index.js
var genCardHeadStyle = (token) => {
  const {
    antCls,
    componentCls,
    headerHeight,
    headerPadding,
    tabsMarginBottom
  } = token;
  return {
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: headerHeight,
    marginBottom: -1,
    // Fix card grid overflow bug: https://gw.alipayobjects.com/zos/rmsportal/XonYxBikwpgbqIQBeuhk.png
    padding: `0 ${unit(headerPadding)}`,
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.headerFontSize,
    background: token.headerBg,
    borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorderSecondary}`,
    borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0`,
    ...clearFix(),
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": {
      display: "inline-block",
      flex: 1,
      ...textEllipsis,
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    },
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: tabsMarginBottom,
      color: token.colorText,
      fontWeight: "normal",
      fontSize: token.fontSize,
      "&-bar": {
        borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorderSecondary}`
      }
    }
  };
};
var genCardGridStyle = (token) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
var genCardActionsStyle = (token) => {
  const {
    componentCls,
    iconCls,
    actionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary,
    actionsBg
  } = token;
  return {
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: actionsBg,
    borderTop: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)}`,
    ...clearFix(),
    "& > li": {
      margin: actionsLiMargin,
      color: token.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token.calc(token.cardActionsIconSize).mul(2).equal(),
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token.colorPrimary,
          transition: `color ${token.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token.colorIcon,
          lineHeight: unit(token.fontHeight),
          transition: `color ${token.motionDurationMid}`,
          "&:hover": {
            color: token.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: unit(token.calc(cardActionsIconSize).mul(token.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`
      }
    }
  };
};
var genCardMetaStyle = (token) => ({
  margin: `${unit(token.calc(token.marginXXS).mul(-1).equal())} 0`,
  display: "flex",
  ...clearFix(),
  "&-avatar": {
    paddingInlineEnd: token.padding
  },
  "&-section": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token.marginXS
    }
  },
  "&-title": {
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.fontSizeLG,
    ...textEllipsis
  },
  "&-description": {
    color: token.colorTextDescription
  }
});
var genCardTypeInnerStyle = (token) => {
  const {
    componentCls,
    colorFillAlter,
    headerPadding,
    bodyPadding
  } = token;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${unit(headerPadding)}`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${unit(token.padding)} ${unit(bodyPadding)}`
    }
  };
};
var genCardLoadingStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
var genCardStyle2 = (token) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    bodyPadding,
    extraColor
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      background: token.colorBgContainer,
      borderRadius: token.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: extraColor,
        fontWeight: "normal",
        fontSize: token.fontSize
      },
      [`${componentCls}-body`]: {
        padding: bodyPadding,
        borderRadius: `0 0 ${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)}`
      },
      [`${componentCls}-grid`]: genCardGridStyle(token),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%",
          borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token),
      [`${componentCls}-meta`]: genCardMetaStyle(token)
    },
    [`${componentCls}-bordered`]: {
      border: `${unit(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token.motionDurationMid}, border-color ${token.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      borderRadius: `${unit(token.borderRadiusLG)} ${unit(token.borderRadiusLG)} 0 0 `,
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: token.calc(token.lineWidth).mul(-1).equal(),
        marginInlineStart: token.calc(token.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> div${componentCls}-head`]: {
        minHeight: 0,
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token),
    [`${componentCls}-loading`]: genCardLoadingStyle(token),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var genCardSizeStyle = (token) => {
  const {
    componentCls,
    bodyPaddingSM,
    headerPaddingSM,
    headerHeightSM,
    headerFontSizeSM
  } = token;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: headerHeightSM,
        padding: `0 ${unit(headerPaddingSM)}`,
        fontSize: headerFontSizeSM,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: bodyPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
var prepareComponentToken21 = (token) => ({
  headerBg: "transparent",
  headerFontSize: token.fontSizeLG,
  headerFontSizeSM: token.fontSize,
  headerHeight: token.fontSizeLG * token.lineHeightLG + token.padding * 2,
  headerHeightSM: token.fontSize * token.lineHeight + token.paddingXS * 2,
  actionsBg: token.colorBgContainer,
  actionsLiMargin: `${token.paddingSM}px 0`,
  tabsMarginBottom: -token.padding - token.lineWidth,
  extraColor: token.colorText,
  bodyPaddingSM: 12,
  // Fixed padding.
  headerPaddingSM: 12,
  bodyPadding: token.bodyPadding ?? token.paddingLG,
  headerPadding: token.headerPadding ?? token.paddingLG
});
var style_default24 = genStyleHooks("Card", (token) => {
  const cardToken = merge(token, {
    cardShadow: token.boxShadowCard,
    cardHeadPadding: token.padding,
    cardPaddingBase: token.paddingLG,
    cardActionsIconSize: token.fontSize
  });
  return [
    // Style
    genCardStyle2(cardToken),
    // Size
    genCardSizeStyle(cardToken)
  ];
}, prepareComponentToken21);

// node_modules/antd/es/card/Card.js
var ActionNode = (props) => {
  const {
    actionClasses,
    actions = [],
    actionStyle
  } = props;
  return React172.createElement("ul", {
    className: actionClasses,
    style: actionStyle
  }, actions.map((action, index2) => {
    const key = `action-${index2}`;
    return React172.createElement("li", {
      style: {
        width: `${100 / actions.length}%`
      },
      key
    }, React172.createElement("span", null, action));
  }));
};
var Card = React172.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    extra,
    headStyle = {},
    bodyStyle = {},
    title,
    loading,
    bordered,
    variant: customVariant,
    size: customizeSize,
    type,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {},
    classNames,
    styles,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("card");
  const [variant] = useVariants_default("card", customVariant, bordered);
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    variant,
    loading
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning2 = devUseWarning("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"], ["bordered", "variant"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const onTabChange = (key) => {
    props.onTabChange?.(key);
  };
  const isContainGrid = React172.useMemo(() => {
    const childNodes = toArray(children);
    return childNodes.some((child) => React172.isValidElement(child) && child.type === CardGrid_default);
  }, [children]);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const [hashId, cssVarCls] = style_default24(prefixCls);
  const loadingBlock = React172.createElement(skeleton_default, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false
  }, children);
  const hasActiveTabKey = activeTabKey !== void 0;
  const extraProps = {
    ...tabProps,
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  };
  let head;
  const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
  const tabs = tabList ? React172.createElement(tabs_default, {
    size: tabSize,
    ...extraProps,
    className: `${prefixCls}-head-tabs`,
    onChange: onTabChange,
    items: tabList.map(({
      tab,
      ...item
    }) => ({
      label: tab,
      ...item
    }))
  }) : null;
  if (title || extra || tabs) {
    const headClasses = clsx(`${prefixCls}-head`, mergedClassNames.header);
    const titleClasses = clsx(`${prefixCls}-head-title`, mergedClassNames.title);
    const extraClasses = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
    const mergedHeadStyle = {
      ...headStyle,
      ...mergedStyles.header
    };
    head = React172.createElement("div", {
      className: headClasses,
      style: mergedHeadStyle
    }, React172.createElement("div", {
      className: `${prefixCls}-head-wrapper`
    }, title && React172.createElement("div", {
      className: titleClasses,
      style: mergedStyles.title
    }, title), extra && React172.createElement("div", {
      className: extraClasses,
      style: mergedStyles.extra
    }, extra)), tabs);
  }
  const coverClasses = clsx(`${prefixCls}-cover`, mergedClassNames.cover);
  const coverDom = cover ? React172.createElement("div", {
    className: coverClasses,
    style: mergedStyles.cover
  }, cover) : null;
  const bodyClasses = clsx(`${prefixCls}-body`, mergedClassNames.body);
  const mergedBodyStyle = {
    ...bodyStyle,
    ...mergedStyles.body
  };
  const body = React172.createElement("div", {
    className: bodyClasses,
    style: mergedBodyStyle
  }, loading ? loadingBlock : children);
  const actionClasses = clsx(`${prefixCls}-actions`, mergedClassNames.actions);
  const actionDom = actions?.length ? React172.createElement(ActionNode, {
    actionClasses,
    actionStyle: mergedStyles.actions,
    actions
  }) : null;
  const divProps = omit(rest, ["onTabChange"]);
  const classString = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: variant !== "borderless",
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid,
    [`${prefixCls}-contain-tabs`]: tabList?.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type}`]: !!type,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  return React172.createElement("div", {
    ref,
    ...divProps,
    className: classString,
    style: mergedStyle
  }, head, coverDom, body, actionDom);
});
if (true) {
  Card.displayName = "Card";
}
var Card_default = Card;

// node_modules/antd/es/card/CardMeta.js
var React173 = __toESM(require_react());
var CardMeta = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title,
    description,
    style,
    classNames: cardMetaClassNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("cardMeta");
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const metaPrefixCls = `${prefixCls}-meta`;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, cardMetaClassNames], [contextStyles, styles], {
    props
  });
  const rootClassNames = clsx(metaPrefixCls, className, contextClassName, mergedClassNames.root);
  const rootStyles = {
    ...contextStyle,
    ...mergedStyles.root,
    ...style
  };
  const avatarClassNames = clsx(`${metaPrefixCls}-avatar`, mergedClassNames.avatar);
  const titleClassNames = clsx(`${metaPrefixCls}-title`, mergedClassNames.title);
  const descriptionClassNames = clsx(`${metaPrefixCls}-description`, mergedClassNames.description);
  const sectionClassNames = clsx(`${metaPrefixCls}-section`, mergedClassNames.section);
  const avatarDom = avatar ? React173.createElement("div", {
    className: avatarClassNames,
    style: mergedStyles.avatar
  }, avatar) : null;
  const titleDom = title ? React173.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title) : null;
  const descriptionDom = description ? React173.createElement("div", {
    className: descriptionClassNames,
    style: mergedStyles.description
  }, description) : null;
  const MetaDetail = titleDom || descriptionDom ? React173.createElement("div", {
    className: sectionClassNames,
    style: mergedStyles.section
  }, titleDom, descriptionDom) : null;
  return React173.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: rootStyles
  }, avatarDom, MetaDetail);
};
if (true) {
  CardMeta.displayName = "CardMeta";
}
var CardMeta_default = CardMeta;

// node_modules/antd/es/card/index.js
var Card2 = Card_default;
Card2.Grid = CardGrid_default;
Card2.Meta = CardMeta_default;
var card_default = Card2;

// node_modules/antd/es/carousel/index.js
var React181 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/slider.js
var import_react59 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose5(r2, e3) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e3.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties5(e3, t2) {
  if (null == e3) return {};
  var o3, r2, i = _objectWithoutPropertiesLoose5(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++) o3 = n2[r2], -1 === t2.indexOf(o3) && {}.propertyIsEnumerable.call(e3, o3) && (i[o3] = e3[o3]);
  }
  return i;
}

// node_modules/@ant-design/react-slick/es/inner-slider.js
var import_react58 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/initial-state.js
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  // used by swipeEvent. differentites between touch and swipe.
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
var initial_state_default = initialState;

// node_modules/throttle-debounce/esm/index.js
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}

// node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
var import_react54 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/default-props.js
var import_react53 = __toESM(require_react());
var defaultProps = {
  accessibility: true,
  adaptiveHeight: false,
  afterChange: null,
  appendDots: function appendDots(dots) {
    return import_react53.default.createElement("ul", {
      style: {
        display: "block"
      }
    }, dots);
  },
  arrows: true,
  autoplay: false,
  autoplaySpeed: 3e3,
  beforeChange: null,
  centerMode: false,
  centerPadding: "50px",
  className: "",
  cssEase: "ease",
  customPaging: function customPaging(i) {
    return import_react53.default.createElement("button", null, i + 1);
  },
  dots: false,
  dotsClass: "slick-dots",
  draggable: true,
  easing: "linear",
  edgeFriction: 0.35,
  fade: false,
  focusOnSelect: false,
  infinite: true,
  initialSlide: 0,
  lazyLoad: null,
  nextArrow: null,
  onEdge: null,
  onInit: null,
  onLazyLoadError: null,
  onReInit: null,
  pauseOnDotsHover: false,
  pauseOnFocus: false,
  pauseOnHover: true,
  prevArrow: null,
  responsive: null,
  rows: 1,
  rtl: false,
  slide: "div",
  slidesPerRow: 1,
  slidesToScroll: 1,
  slidesToShow: 1,
  speed: 500,
  swipe: true,
  swipeEvent: null,
  swipeToSlide: false,
  touchMove: true,
  touchThreshold: 5,
  useCSS: true,
  useTransform: true,
  variableWidth: false,
  vertical: false,
  verticalSwiping: false,
  waitForAnimate: true,
  asNavFor: null,
  unslick: false
};
var default_props_default = defaultProps;

// node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
function clamp(number, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number, upperBound));
}
var safePreventDefault = function safePreventDefault2(event) {
  var passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
};
var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth2 = function getWidth3(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = function extractObject2(spec, keys) {
  var newObject = {};
  keys.forEach(function(key) {
    return newObject[key] = spec[key];
  });
  return newObject;
};
var initializedState = function initializedState2(spec) {
  var slideCount = import_react54.default.Children.count(spec.children);
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth2(listNode));
  var trackNode = spec.trackRef && spec.trackRef.node;
  var trackWidth = Math.ceil(getWidth2(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = function slideHandler2(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating) return {};
  var animationSlide = index2, finalSlide, animationLeft, finalLeft;
  var state = {}, nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount)) return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite) finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite) finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft) animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = function changeSlide2(spec, options) {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread2(_objectSpread2({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = function keyHandler2(e3, accessibility, rtl) {
  if (e3.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) return "";
  if (e3.keyCode === 37) return rtl ? "next" : "previous";
  if (e3.keyCode === 39) return rtl ? "previous" : "next";
  return "";
};
var swipeStart = function swipeStart2(e3, swipe, draggable) {
  e3.target.tagName === "IMG" && safePreventDefault(e3);
  if (!swipe || !draggable && e3.type.indexOf("mouse") !== -1) return "";
  return {
    dragging: true,
    touchObject: {
      startX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      startY: e3.touches ? e3.touches[0].pageY : e3.clientY,
      curX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      curY: e3.touches ? e3.touches[0].pageY : e3.clientY
    }
  };
};
var swipeMove = function swipeMove2(e3, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling) return;
  if (animating) return safePreventDefault(e3);
  if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e3);
  var swipeLeft, state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e3.touches ? e3.touches[0].pageX : e3.clientX;
  touchObject.curY = e3.touches ? e3.touches[0].pageY : e3.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread2(_objectSpread2({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e3);
  }
  return state;
};
var swipeEnd = function swipeEnd2(e3, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe) safePreventDefault(e3);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e3);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = function getNavigableIndexes2(spec) {
  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
};
var getSlideCount = function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth2(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    keysArray.reduce(function(value, key) {
      return value && spec.hasOwnProperty(key);
    }, true) ? null : console.error("Keys Missing:", spec)
  );
};
var getTrackCSS = function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    var trackChildren = spec.unslick ? spec.slideCount : spec.slideCount + 2 * spec.slidesToShow;
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style = _objectSpread2(_objectSpread2({}, style), {}, {
      WebkitTransform,
      transform,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style["top"] = spec.left;
    } else {
      style["left"] = spec.left;
    }
  }
  if (spec.fade) style = {
    opacity: 1
  };
  if (trackWidth) style.width = trackWidth;
  if (trackHeight) style.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style.marginLeft = spec.left + "px";
    } else {
      style.marginTop = spec.left + "px";
    }
  }
  return style;
};
var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style = getTrackCSS(spec);
  if (spec.useTransform) {
    style.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style;
};
var getTrackLeft = function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getTotalSlides = function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = function slidesOnRight2(_ref) {
  var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0) right += 1;
    if (rtl && slidesToShow % 2 === 0) right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0) left += 1;
    if (!rtl && slidesToShow % 2 === 0) left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var validSettings = Object.keys(default_props_default);
function filterSettings(settings) {
  return validSettings.reduce(function(acc, settingName) {
    if (settings.hasOwnProperty(settingName)) {
      acc[settingName] = settings[settingName];
    }
    return acc;
  }, {});
}

// node_modules/@ant-design/react-slick/es/track.js
var import_react55 = __toESM(require_react());
function _callSuper2(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var getSlideClasses = function getSlideClasses2(spec) {
  var slickActive, slickCenter, slickCloned;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
    // dubious in case of RTL
  };
};
var getSlideStyle = function getSlideStyle2(spec) {
  var style = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style.width = spec.slideWidth;
  }
  if (spec.fade) {
    style.position = "relative";
    if (spec.vertical && spec.slideHeight) {
      style.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style.left = -spec.index * parseInt(spec.slideWidth);
    }
    style.opacity = spec.currentSlide === spec.index ? 1 : 0;
    style.zIndex = spec.currentSlide === spec.index ? 999 : 998;
    if (spec.useCSS) {
      style.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style;
};
var getKey = function getKey2(child, fallbackKey) {
  return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides2(spec) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = import_react55.default.Children.count(spec.children);
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  import_react55.default.Children.forEach(spec.children, function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = import_react55.default.createElement("div", null);
    }
    var childStyle = getSlideStyle(_objectSpread2(_objectSpread2({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.className || "";
    var slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
      index: index2
    }));
    slides.push(import_react55.default.cloneElement(child, {
      key: "original" + getKey(child, index2),
      "data-index": index2,
      className: clsx(slideClasses, slideClass),
      tabIndex: "-1",
      "aria-hidden": !slideClasses["slick-active"],
      style: _objectSpread2(_objectSpread2({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: function onClick(e3) {
        child.props && child.props.onClick && child.props.onClick(e3);
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && childrenCount > 1 && spec.fade === false && !spec.unslick) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec)) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
          index: key
        }));
        preCloneSlides.push(import_react55.default.cloneElement(child, {
          key: "precloned" + getKey(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: clsx(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
          onClick: function onClick(e3) {
            child.props && child.props.onClick && child.props.onClick(e3);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (index2 < getPostClones(spec)) {
        key = childrenCount + index2;
        if (key < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
          index: key
        }));
        postCloneSlides.push(import_react55.default.cloneElement(child, {
          key: "postcloned" + getKey(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: clsx(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
          onClick: function onClick(e3) {
            child.props && child.props.onClick && child.props.onClick(e3);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track = (function(_React$PureComponent) {
  function Track2() {
    var _this;
    _classCallCheck(this, Track2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper2(this, Track2, [].concat(args));
    _defineProperty(_this, "node", null);
    _defineProperty(_this, "handleRef", function(ref) {
      _this.node = ref;
    });
    return _this;
  }
  _inherits(Track2, _React$PureComponent);
  return _createClass(Track2, [{
    key: "render",
    value: function render2() {
      var slides = renderSlides(this.props);
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      return import_react55.default.createElement("div", _extends({
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle
      }, mouseEvents), slides);
    }
  }]);
})(import_react55.default.PureComponent);

// node_modules/@ant-design/react-slick/es/dots.js
var import_react56 = __toESM(require_react());
function _callSuper3(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var getDotCount = function getDotCount2(spec) {
  var dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = (function(_React$PureComponent) {
  function Dots2() {
    _classCallCheck(this, Dots2);
    return _callSuper3(this, Dots2, arguments);
  }
  _inherits(Dots2, _React$PureComponent);
  return _createClass(Dots2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      e3.preventDefault();
      this.props.clickHandler(options);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
      var dotCount = getDotCount({
        slideCount,
        slidesToScroll,
        slidesToShow,
        infinite
      });
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      var dots = [];
      for (var i = 0; i < dotCount; i++) {
        var _rightBound = (i + 1) * slidesToScroll - 1;
        var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
        var _leftBound = rightBound - (slidesToScroll - 1);
        var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
        var className = clsx({
          "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
        });
        var dotOptions = {
          message: "dots",
          index: i,
          slidesToScroll,
          currentSlide
        };
        var onClick = this.clickHandler.bind(this, dotOptions);
        dots = dots.concat(import_react56.default.createElement("li", {
          key: i,
          className
        }, import_react56.default.cloneElement(this.props.customPaging(i), {
          onClick
        })));
      }
      return import_react56.default.cloneElement(this.props.appendDots(dots), _objectSpread2({
        className: this.props.dotsClass
      }, mouseEvents));
    }
  }]);
})(import_react56.default.PureComponent);

// node_modules/@ant-design/react-slick/es/arrows.js
var import_react57 = __toESM(require_react());
function _callSuper4(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var PrevArrow = (function(_React$PureComponent) {
  function PrevArrow2() {
    _classCallCheck(this, PrevArrow2);
    return _callSuper4(this, PrevArrow2, arguments);
  }
  _inherits(PrevArrow2, _React$PureComponent);
  return _createClass(PrevArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      if (e3) {
        e3.preventDefault();
      }
      this.props.clickHandler(options, e3);
    }
  }, {
    key: "render",
    value: function render2() {
      var prevClasses = {
        "slick-arrow": true,
        "slick-prev": true
      };
      var prevHandler = this.clickHandler.bind(this, {
        message: "previous"
      });
      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
        prevClasses["slick-disabled"] = true;
        prevHandler = null;
      }
      var prevArrowProps = {
        key: "0",
        "data-role": "none",
        className: clsx(prevClasses),
        style: {
          display: "block"
        },
        onClick: prevHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var prevArrow;
      if (this.props.prevArrow) {
        prevArrow = import_react57.default.cloneElement(this.props.prevArrow, _objectSpread2(_objectSpread2({}, prevArrowProps), customProps));
      } else {
        prevArrow = import_react57.default.createElement("button", _extends({
          key: "0",
          type: "button"
        }, prevArrowProps), " ", "Previous");
      }
      return prevArrow;
    }
  }]);
})(import_react57.default.PureComponent);
var NextArrow = (function(_React$PureComponent2) {
  function NextArrow2() {
    _classCallCheck(this, NextArrow2);
    return _callSuper4(this, NextArrow2, arguments);
  }
  _inherits(NextArrow2, _React$PureComponent2);
  return _createClass(NextArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      if (e3) {
        e3.preventDefault();
      }
      this.props.clickHandler(options, e3);
    }
  }, {
    key: "render",
    value: function render2() {
      var nextClasses = {
        "slick-arrow": true,
        "slick-next": true
      };
      var nextHandler = this.clickHandler.bind(this, {
        message: "next"
      });
      if (!canGoNext(this.props)) {
        nextClasses["slick-disabled"] = true;
        nextHandler = null;
      }
      var nextArrowProps = {
        key: "1",
        "data-role": "none",
        className: clsx(nextClasses),
        style: {
          display: "block"
        },
        onClick: nextHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var nextArrow;
      if (this.props.nextArrow) {
        nextArrow = import_react57.default.cloneElement(this.props.nextArrow, _objectSpread2(_objectSpread2({}, nextArrowProps), customProps));
      } else {
        nextArrow = import_react57.default.createElement("button", _extends({
          key: "1",
          type: "button"
        }, nextArrowProps), " ", "Next");
      }
      return nextArrow;
    }
  }]);
})(import_react57.default.PureComponent);

// node_modules/@ant-design/react-slick/es/inner-slider.js
var _excluded6 = ["animating"];
function _callSuper5(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var InnerSlider = (function(_React$Component) {
  function InnerSlider2(props) {
    var _this;
    _classCallCheck(this, InnerSlider2);
    _this = _callSuper5(this, InnerSlider2, [props]);
    _defineProperty(_this, "listRefHandler", function(ref) {
      return _this.list = ref;
    });
    _defineProperty(_this, "trackRefHandler", function(ref) {
      return _this.track = ref;
    });
    _defineProperty(_this, "adaptHeight", function() {
      if (_this.props.adaptiveHeight && _this.list) {
        var elem = _this.list.querySelector('[data-index="'.concat(_this.state.currentSlide, '"]'));
        _this.list.style.height = getHeight(elem) + "px";
      }
    });
    _defineProperty(_this, "componentDidMount", function() {
      _this.props.onInit && _this.props.onInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      var spec = _objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props);
      _this.updateState(spec, true, function() {
        _this.adaptHeight();
        _this.props.autoplay && _this.autoPlay("playing");
      });
      if (_this.props.lazyLoad === "progressive") {
        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
      }
      if (typeof ResizeObserver !== "undefined") {
        _this.ro = new ResizeObserver(function() {
          if (_this.state.animating) {
            _this.onWindowResized(false);
            _this.callbackTimers.push(setTimeout(function() {
              return _this.onWindowResized();
            }, _this.props.speed));
          } else {
            _this.onWindowResized();
          }
        });
        _this.ro.observe(_this.list);
      }
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this.onWindowResized);
      } else {
        window.attachEvent("onresize", _this.onWindowResized);
      }
    });
    _defineProperty(_this, "componentWillUnmount", function() {
      var _this$ro;
      if (_this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
      }
      if (_this.lazyLoadTimer) {
        clearInterval(_this.lazyLoadTimer);
      }
      if (_this.callbackTimers.length) {
        _this.callbackTimers.forEach(function(timer) {
          return clearTimeout(timer);
        });
        _this.callbackTimers = [];
      }
      if (window.addEventListener) {
        window.removeEventListener("resize", _this.onWindowResized);
      } else {
        window.detachEvent("onresize", _this.onWindowResized);
      }
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      (_this$ro = _this.ro) === null || _this$ro === void 0 || _this$ro.disconnect();
    });
    _defineProperty(_this, "componentDidUpdate", function(prevProps) {
      _this.checkImagesLoad();
      _this.props.onReInit && _this.props.onReInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      _this.adaptHeight();
      var spec = _objectSpread2(_objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      var setTrackStyle = _this.didPropsChange(prevProps);
      setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
        if (_this.state.currentSlide >= import_react58.default.Children.count(_this.props.children)) {
          _this.changeSlide({
            message: "index",
            index: import_react58.default.Children.count(_this.props.children) - _this.props.slidesToShow,
            currentSlide: _this.state.currentSlide
          });
        }
        if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) {
          if (!prevProps.autoplay && _this.props.autoplay) {
            _this.autoPlay("playing");
          } else if (_this.props.autoplay) {
            _this.autoPlay("update");
          } else {
            _this.pause("paused");
          }
        }
      });
    });
    _defineProperty(_this, "onWindowResized", function(setTrackStyle) {
      if (_this.debouncedResize) _this.debouncedResize.cancel();
      _this.debouncedResize = debounce(50, function() {
        return _this.resizeWindow(setTrackStyle);
      });
      _this.debouncedResize();
    });
    _defineProperty(_this, "resizeWindow", function() {
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(_this.track && _this.track.node);
      if (!isTrackMounted) return;
      var spec = _objectSpread2(_objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      _this.updateState(spec, setTrackStyle, function() {
        if (_this.props.autoplay) _this.autoPlay("update");
        else _this.pause("paused");
      });
      _this.setState({
        animating: false
      });
      clearTimeout(_this.animationEndCallback);
      delete _this.animationEndCallback;
    });
    _defineProperty(_this, "updateState", function(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = _objectSpread2(_objectSpread2(_objectSpread2({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = _objectSpread2(_objectSpread2({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);
      if (setTrackStyle || import_react58.default.Children.count(_this.props.children) !== import_react58.default.Children.count(spec.children)) {
        updatedState["trackStyle"] = trackStyle;
      }
      _this.setState(updatedState, callback);
    });
    _defineProperty(_this, "ssrInit", function() {
      if (_this.props.variableWidth) {
        var _trackWidth = 0, _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        var postClones = getPostClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        _this.props.children.forEach(function(child) {
          childrenWidths.push(child.props.style.width);
          _trackWidth += child.props.style.width;
        });
        for (var i = 0; i < preClones; i++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
        }
        for (var _i = 0; _i < postClones; _i++) {
          _trackWidth += childrenWidths[_i];
        }
        for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {
          _trackLeft += childrenWidths[_i2];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (_this.props.centerMode) {
          var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = import_react58.default.Children.count(_this.props.children);
      var spec = _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        slideCount: childrenCount
      });
      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / _this.props.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
      if (_this.props.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    });
    _defineProperty(_this, "checkImagesLoad", function() {
      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length, loadedCount = 0;
      Array.prototype.forEach.call(images, function(image) {
        var handler = function handler2() {
          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
        };
        if (!image.onclick) {
          image.onclick = function() {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;
          image.onclick = function(e3) {
            prevClickHandler(e3);
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (_this.props.lazyLoad) {
            image.onload = function() {
              _this.adaptHeight();
              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
            };
          } else {
            image.onload = handler;
            image.onerror = function() {
              handler();
              _this.props.onLazyLoadError && _this.props.onLazyLoadError();
            };
          }
        }
      });
    });
    _defineProperty(_this, "progressiveLazyLoad", function() {
      var slidesToLoad = [];
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + getPostClones(spec); index2++) {
        if (_this.state.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index = _this.state.currentSlide - 1; _index >= -getPreClones(spec); _index--) {
        if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        _this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        if (_this.props.onLazyLoad) {
          _this.props.onLazyLoad(slidesToLoad);
        }
      } else {
        if (_this.lazyLoadTimer) {
          clearInterval(_this.lazyLoadTimer);
          delete _this.lazyLoadTimer;
        }
      }
    });
    _defineProperty(_this, "slideHandler", function(index2) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
      var currentSlide = _this.state.currentSlide;
      var _slideHandler = slideHandler(_objectSpread2(_objectSpread2(_objectSpread2({
        index: index2
      }, _this.props), _this.state), {}, {
        trackRef: _this.track,
        useCSS: _this.props.useCSS && !dontAnimate
      })), state = _slideHandler.state, nextState = _slideHandler.nextState;
      if (!state) return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this.state.lazyLoadedList.indexOf(value) < 0;
      });
      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
      if (!_this.props.waitForAnimate && _this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete _this.animationEndCallback;
      }
      _this.setState(state, function() {
        if (asNavFor && _this.asNavForIndex !== index2) {
          _this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState) return;
        _this.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties5(nextState, _excluded6);
          _this.setState(firstBatch, function() {
            _this.callbackTimers.push(setTimeout(function() {
              return _this.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this.animationEndCallback;
          });
        }, speed);
      });
    });
    _defineProperty(_this, "changeSlide", function(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      var targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide) return;
      if (dontAnimate === true) {
        _this.slideHandler(targetSlide, dontAnimate);
      } else {
        _this.slideHandler(targetSlide);
      }
      _this.props.autoplay && _this.autoPlay("update");
      if (_this.props.focusOnSelect) {
        var nodes = _this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    });
    _defineProperty(_this, "clickHandler", function(e3) {
      if (_this.clickable === false) {
        e3.stopPropagation();
        e3.preventDefault();
      }
      _this.clickable = true;
    });
    _defineProperty(_this, "keyHandler", function(e3) {
      var dir = keyHandler(e3, _this.props.accessibility, _this.props.rtl);
      dir !== "" && _this.changeSlide({
        message: dir
      });
    });
    _defineProperty(_this, "selectHandler", function(options) {
      _this.changeSlide(options);
    });
    _defineProperty(_this, "disableBodyScroll", function() {
      var preventDefault = function preventDefault2(e3) {
        e3 = e3 || window.event;
        if (e3.preventDefault) e3.preventDefault();
        e3.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    });
    _defineProperty(_this, "enableBodyScroll", function() {
      window.ontouchmove = null;
    });
    _defineProperty(_this, "swipeStart", function(e3) {
      if (_this.props.verticalSwiping) {
        _this.disableBodyScroll();
      }
      var state = swipeStart(e3, _this.props.swipe, _this.props.draggable);
      state !== "" && _this.setState(state);
    });
    _defineProperty(_this, "swipeMove", function(e3) {
      var state = swipeMove(e3, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state) return;
      if (state["swiping"]) {
        _this.clickable = false;
      }
      _this.setState(state);
    });
    _defineProperty(_this, "swipeEnd", function(e3) {
      var state = swipeEnd(e3, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state) return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      _this.setState(state);
      if (triggerSlideHandler === void 0) return;
      _this.slideHandler(triggerSlideHandler);
      if (_this.props.verticalSwiping) {
        _this.enableBodyScroll();
      }
    });
    _defineProperty(_this, "touchEnd", function(e3) {
      _this.swipeEnd(e3);
      _this.clickable = true;
    });
    _defineProperty(_this, "slickPrev", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "previous"
        });
      }, 0));
    });
    _defineProperty(_this, "slickNext", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "next"
        });
      }, 0));
    });
    _defineProperty(_this, "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide)) return "";
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this.state.currentSlide
        }, dontAnimate);
      }, 0));
    });
    _defineProperty(_this, "play", function() {
      var nextIndex;
      if (_this.props.rtl) {
        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
      } else {
        if (canGoNext(_objectSpread2(_objectSpread2({}, _this.props), _this.state))) {
          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
        } else {
          return false;
        }
      }
      _this.slideHandler(nextIndex);
    });
    _defineProperty(_this, "autoPlay", function(playType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      var autoplaying = _this.state.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
      _this.setState({
        autoplaying: "playing"
      });
    });
    _defineProperty(_this, "pause", function(pauseType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
        _this.autoplayTimer = null;
      }
      var autoplaying = _this.state.autoplaying;
      if (pauseType === "paused") {
        _this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          _this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          _this.setState({
            autoplaying: "hovered"
          });
        }
      }
    });
    _defineProperty(_this, "onDotsOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_this, "onDotsLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_this, "onTrackOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_this, "onTrackLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_this, "onSlideFocus", function() {
      return _this.props.autoplay && _this.pause("focused");
    });
    _defineProperty(_this, "onSlideBlur", function() {
      return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
    });
    _defineProperty(_this, "render", function() {
      var className = clsx("slick-slider", _this.props.className, {
        "slick-vertical": _this.props.vertical,
        "slick-initialized": true
      });
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      var trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
      var pauseOnHover = _this.props.pauseOnHover;
      trackProps = _objectSpread2(_objectSpread2({}, trackProps), {}, {
        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
        onMouseOver: pauseOnHover ? _this.onTrackOver : null,
        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
      });
      var dots;
      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
        var dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]);
        var pauseOnDotsHover = _this.props.pauseOnDotsHover;
        dotProps = _objectSpread2(_objectSpread2({}, dotProps), {}, {
          clickHandler: _this.changeSlide,
          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
        });
        dots = import_react58.default.createElement(Dots, dotProps);
      }
      var prevArrow, nextArrow;
      var arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      arrowProps.clickHandler = _this.changeSlide;
      if (_this.props.arrows) {
        prevArrow = import_react58.default.createElement(PrevArrow, arrowProps);
        nextArrow = import_react58.default.createElement(NextArrow, arrowProps);
      }
      var verticalHeightStyle = null;
      if (_this.props.vertical) {
        verticalHeightStyle = {
          height: _this.state.listHeight
        };
      }
      var centerPaddingStyle = null;
      if (_this.props.vertical === false) {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: "0px " + _this.props.centerPadding
          };
        }
      } else {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: _this.props.centerPadding + " 0px"
          };
        }
      }
      var listStyle = _objectSpread2(_objectSpread2({}, verticalHeightStyle), centerPaddingStyle);
      var touchMove = _this.props.touchMove;
      var listProps = {
        className: "slick-list",
        style: listStyle,
        onClick: _this.clickHandler,
        onMouseDown: touchMove ? _this.swipeStart : null,
        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onMouseUp: touchMove ? _this.swipeEnd : null,
        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onTouchStart: touchMove ? _this.swipeStart : null,
        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onTouchEnd: touchMove ? _this.touchEnd : null,
        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onKeyDown: _this.props.accessibility ? _this.keyHandler : null
      };
      var innerSliderProps = {
        className,
        dir: "ltr",
        style: _this.props.style
      };
      if (_this.props.unslick) {
        listProps = {
          className: "slick-list"
        };
        innerSliderProps = {
          className,
          style: _this.props.style
        };
      }
      return import_react58.default.createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", import_react58.default.createElement("div", _extends({
        ref: _this.listRefHandler
      }, listProps), import_react58.default.createElement(Track, _extends({
        ref: _this.trackRefHandler
      }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
    });
    _this.list = null;
    _this.track = null;
    _this.state = _objectSpread2(_objectSpread2({}, initial_state_default), {}, {
      currentSlide: _this.props.initialSlide,
      targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
      slideCount: import_react58.default.Children.count(_this.props.children)
    });
    _this.callbackTimers = [];
    _this.clickable = true;
    _this.debouncedResize = null;
    var ssrState = _this.ssrInit();
    _this.state = _objectSpread2(_objectSpread2({}, _this.state), ssrState);
    return _this;
  }
  _inherits(InnerSlider2, _React$Component);
  return _createClass(InnerSlider2, [{
    key: "didPropsChange",
    value: function didPropsChange(prevProps) {
      var setTrackStyle = false;
      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];
        if (!prevProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) {
          continue;
        }
        if (prevProps[key] !== this.props[key]) {
          setTrackStyle = true;
          break;
        }
      }
      return setTrackStyle || import_react58.default.Children.count(this.props.children) !== import_react58.default.Children.count(prevProps.children);
    }
  }]);
})(import_react58.default.Component);

// node_modules/@ant-design/react-slick/es/slider.js
var import_json2mq = __toESM(require_json2mq());
function _callSuper6(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var Slider = (function(_React$Component) {
  function Slider2(props) {
    var _this;
    _classCallCheck(this, Slider2);
    _this = _callSuper6(this, Slider2, [props]);
    _defineProperty(_this, "innerSliderRefHandler", function(ref) {
      return _this.innerSlider = ref;
    });
    _defineProperty(_this, "slickPrev", function() {
      return _this.innerSlider.slickPrev();
    });
    _defineProperty(_this, "slickNext", function() {
      return _this.innerSlider.slickNext();
    });
    _defineProperty(_this, "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return _this.innerSlider.slickGoTo(slide, dontAnimate);
    });
    _defineProperty(_this, "slickPause", function() {
      return _this.innerSlider.pause("paused");
    });
    _defineProperty(_this, "slickPlay", function() {
      return _this.innerSlider.autoPlay("play");
    });
    _this.state = {
      breakpoint: null
    };
    _this._responsiveMediaHandlers = [];
    return _this;
  }
  _inherits(Slider2, _React$Component);
  return _createClass(Slider2, [{
    key: "media",
    value: function media(query, handler) {
      var mql = window.matchMedia(query);
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        if (matches) {
          handler();
        }
      };
      mql.addListener(listener);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    }
    // handles responsive breakpoints
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.props.responsive) {
        var breakpoints = this.props.responsive.map(function(breakpt) {
          return breakpt.breakpoint;
        });
        breakpoints.sort(function(x, y) {
          return x - y;
        });
        breakpoints.forEach(function(breakpoint, index2) {
          var bQuery;
          if (index2 === 0) {
            bQuery = (0, import_json2mq.default)({
              minWidth: 0,
              maxWidth: breakpoint
            });
          } else {
            bQuery = (0, import_json2mq.default)({
              minWidth: breakpoints[index2 - 1] + 1,
              maxWidth: breakpoint
            });
          }
          canUseDOM() && _this2.media(bQuery, function() {
            _this2.setState({
              breakpoint
            });
          });
        });
        var query = (0, import_json2mq.default)({
          minWidth: breakpoints.slice(-1)[0]
        });
        canUseDOM() && this.media(query, function() {
          _this2.setState({
            breakpoint: null
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._responsiveMediaHandlers.forEach(function(obj) {
        obj.mql.removeListener(obj.listener);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this3 = this;
      var settings;
      var newProps;
      if (this.state.breakpoint) {
        newProps = this.props.responsive.filter(function(resp) {
          return resp.breakpoint === _this3.state.breakpoint;
        });
        settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2(_objectSpread2({}, default_props_default), this.props), newProps[0].settings);
      } else {
        settings = _objectSpread2(_objectSpread2({}, default_props_default), this.props);
      }
      if (settings.centerMode) {
        if (settings.slidesToScroll > 1 && true) {
          console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
        }
        settings.slidesToScroll = 1;
      }
      if (settings.fade) {
        if (settings.slidesToShow > 1 && true) {
          console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
        }
        if (settings.slidesToScroll > 1 && true) {
          console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
        }
        settings.slidesToShow = 1;
        settings.slidesToScroll = 1;
      }
      var children = import_react59.default.Children.toArray(this.props.children);
      children = children.filter(function(child) {
        if (typeof child === "string") {
          return !!child.trim();
        }
        return !!child;
      });
      if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
        console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
        settings.variableWidth = false;
      }
      var newChildren = [];
      var currentWidth = null;
      for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
        var newSlide = [];
        for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
          var row = [];
          for (var k = j; k < j + settings.slidesPerRow; k += 1) {
            if (settings.variableWidth && children[k].props.style) {
              currentWidth = children[k].props.style.width;
            }
            if (k >= children.length) break;
            row.push(import_react59.default.cloneElement(children[k], {
              key: 100 * i + 10 * j + k,
              tabIndex: -1,
              style: {
                width: "".concat(100 / settings.slidesPerRow, "%"),
                display: "inline-block"
              }
            }));
          }
          newSlide.push(import_react59.default.createElement("div", {
            key: 10 * i + j
          }, row));
        }
        if (settings.variableWidth) {
          newChildren.push(import_react59.default.createElement("div", {
            key: i,
            style: {
              width: currentWidth
            }
          }, newSlide));
        } else {
          newChildren.push(import_react59.default.createElement("div", {
            key: i
          }, newSlide));
        }
      }
      if (settings === "unslick") {
        var className = "regular slider " + (this.props.className || "");
        return import_react59.default.createElement("div", {
          className
        }, children);
      } else if (newChildren.length <= settings.slidesToShow) {
        settings.unslick = true;
      }
      return import_react59.default.createElement(InnerSlider, _extends({
        style: this.props.style,
        ref: this.innerSliderRefHandler
      }, filterSettings(settings)), newChildren);
    }
  }]);
})(import_react59.default.Component);

// node_modules/@ant-design/react-slick/es/index.js
var es_default14 = Slider;

// node_modules/antd/es/carousel/style/index.js
var DotDuration = "--dot-duration";
var genCarouselStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      }
    }
  };
};
var genArrowsStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    arrowSize,
    arrowOffset
  } = token;
  const arrowLength = token.calc(arrowSize).div(Math.SQRT2).equal();
  return {
    [componentCls]: {
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        width: arrowSize,
        height: arrowSize,
        transform: "translateY(-50%)",
        color: "#fff",
        opacity: 0.4,
        background: "transparent",
        padding: 0,
        lineHeight: 0,
        border: 0,
        outline: "none",
        cursor: "pointer",
        zIndex: 1,
        transition: `opacity ${motionDurationSlow}`,
        "&:hover, &:focus": {
          opacity: 1
        },
        "&.slick-disabled": {
          pointerEvents: "none",
          opacity: 0
        },
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          top: token.calc(arrowSize).sub(arrowLength).div(2).equal(),
          insetInlineStart: token.calc(arrowSize).sub(arrowLength).div(2).equal(),
          display: "inline-block",
          width: arrowLength,
          height: arrowLength,
          border: `0 solid currentcolor`,
          borderInlineStartWidth: 2,
          borderBlockStartWidth: 2,
          borderRadius: 1,
          content: '""'
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::after": {
          transform: "rotate(-45deg)"
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::after": {
          transform: "rotate(135deg)"
        }
      }
    }
  };
};
var genDotsStyle = (token) => {
  const {
    componentCls,
    dotOffset,
    dotWidth,
    dotHeight,
    dotGap,
    colorBgContainer,
    motionDurationSlow
  } = token;
  const animation = new Keyframes_default(`${token.prefixCls}-dot-animation`, {
    from: {
      width: 0
    },
    to: {
      width: token.dotActiveWidth
    }
  });
  return {
    [componentCls]: {
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        margin: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: dotOffset
        },
        "&-top": {
          top: dotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: dotWidth,
          height: dotHeight,
          marginInline: dotGap,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${motionDurationSlow}`,
          borderRadius: dotHeight,
          overflow: "hidden",
          "&::after": {
            display: "block",
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: 0,
            height: dotHeight,
            content: '""',
            background: "transparent",
            borderRadius: dotHeight,
            opacity: 1,
            outline: "none",
            cursor: "pointer",
            overflow: "hidden"
          },
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: colorBgContainer,
            border: 0,
            borderRadius: dotHeight,
            outline: "none",
            cursor: "pointer",
            opacity: 0.2,
            transition: `all ${motionDurationSlow}`,
            overflow: "hidden",
            "&:hover": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: token.calc(dotGap).mul(-1).equal(),
              content: '""'
            }
          },
          "&.slick-active": {
            width: token.dotActiveWidth,
            position: "relative",
            "&:hover": {
              opacity: 1
            },
            "&::after": {
              background: colorBgContainer,
              animationName: animation,
              animationDuration: `var(${DotDuration})`,
              animationTimingFunction: "ease-out",
              animationFillMode: "forwards"
            }
          }
        }
      }
    }
  };
};
var genCarouselVerticalStyle = (token) => {
  const {
    componentCls,
    dotOffset,
    arrowOffset,
    marginXXS
  } = token;
  const animation = new Keyframes_default(`${token.prefixCls}-dot-vertical-animation`, {
    from: {
      height: 0
    },
    to: {
      height: token.dotActiveWidth
    }
  });
  const reverseSizeOfDot = {
    width: token.dotHeight,
    height: token.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-prev, .slick-next": {
        insetInlineStart: "50%",
        marginBlockStart: "unset",
        transform: "translateX(-50%)"
      },
      ".slick-prev": {
        insetBlockStart: arrowOffset,
        insetInlineStart: "50%",
        "&::after": {
          transform: "rotate(45deg)"
        }
      },
      ".slick-next": {
        insetBlockStart: "auto",
        insetBlockEnd: arrowOffset,
        "&::after": {
          transform: "rotate(-135deg)"
        }
      },
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-start": {
          insetInlineEnd: "auto",
          insetInlineStart: dotOffset
        },
        "&-end": {
          insetInlineEnd: dotOffset,
          insetInlineStart: "auto"
        },
        li: {
          // reverse width and height in vertical situation
          ...reverseSizeOfDot,
          margin: `${unit(marginXXS)} 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&::after": {
            ...reverseSizeOfDot,
            height: 0
          },
          "&.slick-active": {
            ...reverseSizeOfDot,
            height: token.dotActiveWidth,
            button: {
              ...reverseSizeOfDot,
              height: token.dotActiveWidth
            },
            "&::after": {
              ...reverseSizeOfDot,
              animationName: animation,
              animationDuration: `var(${DotDuration})`,
              animationTimingFunction: "ease-out",
              animationFillMode: "forwards"
            }
          }
        }
      }
    }
  };
};
var genCarouselRtlStyle = (token) => {
  const {
    componentCls
  } = token;
  return [{
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  }, {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
};
var prepareComponentToken22 = (token) => {
  const dotActiveWidth = 24;
  return {
    arrowSize: 16,
    arrowOffset: token.marginXS,
    dotWidth: 16,
    dotHeight: 3,
    dotGap: token.marginXXS,
    dotOffset: 12,
    dotWidthActive: dotActiveWidth,
    dotActiveWidth
  };
};
var style_default25 = genStyleHooks("Carousel", (token) => [genCarouselStyle(token), genArrowsStyle(token), genDotsStyle(token), genCarouselVerticalStyle(token), genCarouselRtlStyle(token)], prepareComponentToken22, {
  deprecatedTokens: [["dotWidthActive", "dotActiveWidth"]]
});

// node_modules/antd/es/carousel/index.js
var dotsClass = "slick-dots";
var ArrowButton = ({
  currentSlide,
  slideCount,
  ...rest
}) => React181.createElement("button", {
  type: "button",
  ...rest
});
var Carousel = React181.forwardRef((props, ref) => {
  const {
    dots = true,
    arrows = false,
    prevArrow,
    nextArrow,
    draggable = false,
    waitForAnimate = false,
    dotPosition,
    dotPlacement,
    vertical,
    rootClassName,
    className: customClassName,
    style,
    id,
    autoplay = false,
    autoplaySpeed = 3e3,
    rtl,
    ...otherProps
  } = props;
  const mergedDotPlacement = React181.useMemo(() => {
    const placement = dotPlacement ?? dotPosition ?? "bottom";
    switch (placement) {
      case "left":
        return "start";
      case "right":
        return "end";
      default:
        return placement;
    }
  }, [dotPosition, dotPlacement]);
  const mergedVertical = vertical ?? (mergedDotPlacement === "start" || mergedDotPlacement === "end");
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("carousel");
  const slickRef = React181.useRef(null);
  const goTo = (slide, dontAnimate = false) => {
    slickRef.current.slickGoTo(slide, dontAnimate);
  };
  React181.useImperativeHandle(ref, () => ({
    goTo,
    autoPlay: slickRef.current.innerSlider.autoPlay,
    innerSlider: slickRef.current.innerSlider,
    prev: slickRef.current.slickPrev,
    next: slickRef.current.slickNext
  }), [slickRef.current]);
  const {
    children,
    initialSlide = 0
  } = props;
  const childNodes = toArray(children);
  const count = childNodes.length;
  const isRTL = (rtl ?? direction === "rtl") && !vertical;
  React181.useEffect(() => {
    if (count > 0) {
      const newIndex = isRTL ? count - initialSlide - 1 : initialSlide;
      goTo(newIndex, false);
    }
  }, [count, initialSlide, isRTL]);
  if (true) {
    const warning2 = devUseWarning("Carousel");
    warning2.deprecated(!dotPosition, "dotPosition", "dotPlacement");
  }
  const newProps = {
    vertical: mergedVertical,
    className: clsx(customClassName, contextClassName),
    style: {
      ...contextStyle,
      ...style
    },
    autoplay: !!autoplay,
    ...otherProps
  };
  if (newProps.effect === "fade") {
    newProps.fade = true;
  }
  const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
  const enableDots = !!dots;
  const dsClass = clsx(dotsClass, `${dotsClass}-${mergedDotPlacement}`, typeof dots === "boolean" ? false : dots?.className);
  const [hashId, cssVarCls] = style_default25(prefixCls);
  const className = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: isRTL,
    [`${prefixCls}-vertical`]: newProps.vertical
  }, hashId, cssVarCls, rootClassName);
  const mergedShowDuration = autoplay && (typeof autoplay === "object" ? autoplay.dotDuration : false);
  const dotDurationStyle = mergedShowDuration ? {
    [DotDuration]: `${autoplaySpeed}ms`
  } : {};
  return React181.createElement("div", {
    className,
    id,
    style: dotDurationStyle
  }, React181.createElement(es_default14, {
    ref: slickRef,
    ...newProps,
    dots: enableDots,
    dotsClass: dsClass,
    arrows,
    prevArrow: prevArrow ?? React181.createElement(ArrowButton, {
      "aria-label": isRTL ? "next" : "prev"
    }),
    nextArrow: nextArrow ?? React181.createElement(ArrowButton, {
      "aria-label": isRTL ? "prev" : "next"
    }),
    draggable,
    verticalSwiping: mergedVertical,
    autoplaySpeed,
    waitForAnimate,
    rtl: isRTL
  }));
});
if (true) {
  Carousel.displayName = "Carousel";
}
var carousel_default = Carousel;

// node_modules/antd/es/cascader/index.js
var React203 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/Cascader.js
var React198 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/context.js
var React182 = __toESM(require_react());
var CascaderContext = React182.createContext({});
var context_default6 = CascaderContext;

// node_modules/@rc-component/cascader/es/hooks/useSearchOptions.js
var React183 = __toESM(require_react());
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = (search, options, {
  label = ""
}) => options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
var defaultRender = (inputValue, path2, prefixCls, fieldNames) => path2.map((opt) => opt[fieldNames.label]).join(" / ");
var useSearchOptions = (search, options, fieldNames, prefixCls, config, enableHalfPath) => {
  const {
    filter: filter2 = defaultFilter,
    render: render2 = defaultRender,
    limit = 50,
    sort
  } = config;
  return React183.useMemo(() => {
    const filteredOptions = [];
    if (!search) {
      return [];
    }
    function dig(list, pathOptions, parentDisabled = false) {
      list.forEach((option) => {
        if (!sort && limit !== false && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.children];
        const mergedDisabled = parentDisabled || option.disabled;
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect or multiple
          enableHalfPath
        ) {
          if (filter2(search, connectedPathOptions, {
            label: fieldNames.label
          })) {
            filteredOptions.push({
              ...option,
              disabled: mergedDisabled,
              [fieldNames.label]: render2(search, connectedPathOptions, prefixCls, fieldNames),
              [SEARCH_MARK]: connectedPathOptions,
              [fieldNames.children]: void 0
            });
          }
        }
        if (children) {
          dig(option[fieldNames.children], connectedPathOptions, mergedDisabled);
        }
      });
    }
    dig(options, []);
    if (sort) {
      filteredOptions.sort((a, b) => {
        return sort(a[SEARCH_MARK], b[SEARCH_MARK], search, fieldNames);
      });
    }
    return limit !== false && limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  }, [search, options, fieldNames, prefixCls, render2, enableHalfPath, filter2, sort, limit]);
};
var useSearchOptions_default = useSearchOptions;

// node_modules/@rc-component/cascader/es/utils/commonUtil.js
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey) {
  return pathKey.split(VALUE_SPLIT);
}
function fillFieldNames(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  return option.isLeaf ?? !option[fieldNames.children]?.length;
}
function scrollIntoParentView(element) {
  const parent = element.parentElement;
  if (!parent) {
    return;
  }
  const elementToParent = element.offsetTop - parent.offsetTop;
  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({
      top: elementToParent + element.offsetHeight - parent.offsetHeight
    });
  }
}
function getFullPathKeys(options, fieldNames) {
  return options.map((item) => item[SEARCH_MARK]?.map((opt) => opt[fieldNames.value]));
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}

// node_modules/@rc-component/cascader/es/utils/treeUtil.js
function formatStrategyValues(pathKeys, getKeyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  const keyPathEntities = getKeyPathEntities();
  return pathKeys.filter((key) => {
    const entity = keyPathEntities[key];
    const parent = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    if (entity && entity.node.disabled) {
      return true;
    }
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
  });
}
function toPathOptions(valueCells, options, fieldNames, stringMode = false) {
  let currentList = options;
  const valueOptions = [];
  for (let i = 0; i < valueCells.length; i += 1) {
    const valueCell = valueCells[i];
    const foundIndex = currentList?.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList?.[foundIndex] : null;
    valueOptions.push({
      value: foundOption?.[fieldNames.value] ?? valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption?.[fieldNames.children];
  }
  return valueOptions;
}

// node_modules/@rc-component/cascader/es/hooks/useDisplayValues.js
var React184 = __toESM(require_react());
var useDisplayValues_default = ((rawValues, options, fieldNames, multiple, displayRender) => {
  return React184.useMemo(() => {
    const mergedDisplayRender = displayRender || // Default displayRender
    ((labels) => {
      const mergedLabels = multiple ? labels.slice(-1) : labels;
      const SPLIT = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT);
      }
      return mergedLabels.reduce((list, label, index2) => {
        const keyedLabel = React184.isValidElement(label) ? React184.cloneElement(label, {
          key: index2
        }) : label;
        if (index2 === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT, keyedLabel];
      }, []);
    });
    return rawValues.map((valueCells) => {
      const valueOptions = toPathOptions(valueCells, options, fieldNames);
      const label = mergedDisplayRender(valueOptions.map(({
        option,
        value: value2
      }) => option?.[fieldNames.label] ?? value2), valueOptions.map(({
        option
      }) => option));
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells,
        disabled: valueOptions[valueOptions.length - 1]?.option?.disabled
      };
    });
  }, [rawValues, options, fieldNames, displayRender, multiple]);
});

// node_modules/@rc-component/cascader/es/hooks/useMissingValues.js
var React185 = __toESM(require_react());
function useMissingValues(options, fieldNames) {
  return React185.useCallback((rawValues) => {
    const missingValues = [];
    const existsValues = [];
    rawValues.forEach((valueCell) => {
      const pathOptions = toPathOptions(valueCell, options, fieldNames);
      if (pathOptions.every((opt) => opt.option)) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  }, [options, fieldNames]);
}

// node_modules/@rc-component/cascader/es/hooks/useOptions.js
var React187 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/hooks/useEntities.js
var React186 = __toESM(require_react());

// node_modules/@rc-component/tree/es/utils/keyUtil.js
function getEntity(keyEntities, key) {
  return keyEntities[key];
}

// node_modules/@rc-component/tree/es/utils/treeUtil.js
function getPosition(level, index2) {
  return `${level}-${index2}`;
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getKey3(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
function fillFieldNames2(fieldNames) {
  const {
    title,
    _title,
    key,
    children
  } = fieldNames || {};
  const mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || "key",
    children: children || "children"
  };
}
function warningWithoutKey(treeData, fieldNames) {
  const keys = /* @__PURE__ */ new Map();
  function dig(list, path2 = "") {
    (list || []).forEach((treeNode) => {
      const key = treeNode[fieldNames.key];
      const children = treeNode[fieldNames.children];
      warning_default(key !== null && key !== void 0, `Tree node must have a certain key: [${path2}${key}]`);
      const recordKey = String(key);
      warning_default(!keys.has(recordKey) || key === null || key === void 0, `Same 'key' exist in the Tree: ${recordKey}`);
      keys.set(recordKey, true);
      dig(children, `${path2}${recordKey} > `);
    });
  }
  dig(treeData);
}
function convertTreeToData(rootNodes) {
  function dig(node) {
    const treeNodes = toArray(node);
    return treeNodes.map((treeNode) => {
      if (!isTreeNode(treeNode)) {
        warning_default(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      const {
        key
      } = treeNode;
      const {
        children,
        ...rest
      } = treeNode.props;
      const dataNode = {
        key,
        ...rest
      };
      const parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter((dataNode) => dataNode);
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  const {
    _title: fieldTitles,
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames2(fieldNames);
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list, parent = null) {
    return list.map((treeNode, index2) => {
      const pos = getPosition(parent ? parent.pos : "0", index2);
      const mergedKey = getKey3(treeNode[fieldKey], pos);
      let mergedTitle;
      for (let i = 0; i < fieldTitles.length; i += 1) {
        const fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      const flattenNode = Object.assign(omit(treeNode, [...fieldTitles, fieldKey, fieldChildren]), {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [...parent ? parent.isStart : [], index2 === 0],
        isEnd: [...parent ? parent.isEnd : [], index2 === list.length - 1]
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  let mergedConfig = {};
  if (typeof config === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  const {
    childrenPropName,
    externalGetKey,
    fieldNames
  } = mergedConfig;
  const {
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames2(fieldNames);
  const mergeChildrenPropName = childrenPropName || fieldChildren;
  let syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = (node) => node[externalGetKey];
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = (node) => externalGetKey(node);
    }
  } else {
    syntheticGetKey = (node, pos) => getKey3(node[fieldKey], pos);
  }
  function processNode(node, index2, parent, pathNodes) {
    const children = node ? node[mergeChildrenPropName] : dataNodes;
    const pos = node ? getPosition(parent.pos, index2) : "0";
    const connectNodes = node ? [...pathNodes, node] : [];
    if (node) {
      const key = syntheticGetKey(node, pos);
      const data = {
        node,
        index: index2,
        pos,
        key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    if (children) {
      children.forEach((subNode, subIndex) => {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes, {
  initWrapper,
  processEntity,
  onProcessFinished,
  externalGetKey,
  childrenPropName,
  fieldNames
} = {}, legacyExternalGetKey) {
  const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  const posEntities = {};
  const keyEntities = {};
  let wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, (item) => {
    const {
      node,
      index: index2,
      pos,
      key,
      parentPos,
      level,
      nodes
    } = item;
    const entity = {
      node,
      nodes,
      index: index2,
      key,
      pos,
      level
    };
    const mergedKey = getKey3(key, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key, {
  expandedKeys,
  selectedKeys,
  loadedKeys,
  loadingKeys,
  checkedKeys,
  halfCheckedKeys,
  dragOverNodeKey,
  dropPosition,
  keyEntities
}) {
  const entity = getEntity(keyEntities, key);
  const treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ""),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  const {
    data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey
  } = props;
  const eventData = {
    ...data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  };
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get() {
        warning_default(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
        return props;
      }
    });
  }
  return eventData;
}

// node_modules/@rc-component/cascader/es/hooks/useEntities.js
var useEntities_default = ((options, fieldNames) => {
  const cacheRef = React186.useRef({
    options: [],
    info: {
      keyEntities: {},
      pathKeyEntities: {}
    }
  });
  const getEntities = React186.useCallback(() => {
    if (cacheRef.current.options !== options) {
      cacheRef.current.options = options;
      cacheRef.current.info = convertDataToEntities(options, {
        fieldNames,
        initWrapper: (wrapper) => ({
          ...wrapper,
          pathKeyEntities: {}
        }),
        processEntity: (entity, wrapper) => {
          const pathKey = entity.nodes.map((node) => node[fieldNames.value]).join(VALUE_SPLIT);
          wrapper.pathKeyEntities[pathKey] = entity;
          entity.key = pathKey;
        }
      });
    }
    return cacheRef.current.info.pathKeyEntities;
  }, [fieldNames, options]);
  return getEntities;
});

// node_modules/@rc-component/cascader/es/hooks/useOptions.js
function useOptions(mergedFieldNames, options) {
  const mergedOptions = React187.useMemo(() => options || [], [options]);
  const getPathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
  const getValueByKeyPath = React187.useCallback((pathKeys) => {
    const keyPathEntities = getPathKeyEntities();
    return pathKeys.map((pathKey) => {
      const {
        nodes
      } = keyPathEntities[pathKey];
      return nodes.map((node) => node[mergedFieldNames.value]);
    });
  }, [getPathKeyEntities, mergedFieldNames]);
  return [mergedOptions, getPathKeyEntities, getValueByKeyPath];
}

// node_modules/@rc-component/cascader/es/hooks/useSearchConfig.js
var React188 = __toESM(require_react());
function useSearchConfig(showSearch, props) {
  const {
    autoClearSearchValue,
    searchValue,
    onSearch
  } = props;
  return React188.useMemo(() => {
    if (!showSearch) {
      return [false, {}];
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50,
      autoClearSearchValue,
      searchValue,
      onSearch
    };
    if (showSearch && typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    if (searchConfig.limit <= 0) {
      searchConfig.limit = false;
      if (true) {
        warning_default(false, "'limit' of showSearch should be positive number or false.");
      }
    }
    return [true, searchConfig];
  }, [showSearch, autoClearSearchValue, searchValue, onSearch]);
}

// node_modules/@rc-component/tree/es/utils/conductUtil.js
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  const filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach((key) => {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  const {
    disabled,
    disableCheckbox,
    checkable
  } = node || {};
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys);
  const halfCheckedKeys = /* @__PURE__ */ new Set();
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key,
        node,
        children = []
      } = entity;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent,
        node
      } = entity;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({
        key
      }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys);
  let halfCheckedKeys = new Set(halfKeys);
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key,
        node,
        children = []
      } = entity;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent,
        node
      } = entity;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({
        key
      }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  const warningMissKeys = [];
  let syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  const keys = new Set(keyList.filter((key) => {
    const hasEntity = !!getEntity(keyEntities, key);
    if (!hasEntity) {
      warningMissKeys.push(key);
    }
    return hasEntity;
  }));
  const levelEntities = /* @__PURE__ */ new Map();
  let maxLevel = 0;
  Object.keys(keyEntities).forEach((key) => {
    const entity = keyEntities[key];
    const {
      level
    } = entity;
    let levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warning_default(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map((key) => `'${key}'`).join(", ")}`);
  let result;
  if (checked === true) {
    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}

// node_modules/@rc-component/cascader/es/hooks/useSelect.js
function useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy) {
  return (valuePath) => {
    if (!multiple) {
      triggerChange(valuePath);
    } else {
      const pathKey = toPathKey(valuePath);
      const checkedPathKeys = toPathKeys(checkedValues);
      const halfCheckedPathKeys = toPathKeys(halfCheckedValues);
      const existInChecked = checkedPathKeys.includes(pathKey);
      const existInMissing = missingCheckedValues.some((valueCells) => toPathKey(valueCells) === pathKey);
      let nextCheckedValues = checkedValues;
      let nextMissingValues = missingCheckedValues;
      if (existInMissing && !existInChecked) {
        nextMissingValues = missingCheckedValues.filter((valueCells) => toPathKey(valueCells) !== pathKey);
      } else {
        const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey) : [...checkedPathKeys, pathKey];
        const pathKeyEntities = getPathKeyEntities();
        let checkedKeys;
        if (existInChecked) {
          ({
            checkedKeys
          } = conductCheck(nextRawCheckedKeys, {
            checked: false,
            halfCheckedKeys: halfCheckedPathKeys
          }, pathKeyEntities));
        } else {
          ({
            checkedKeys
          } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities));
        }
        const deDuplicatedKeys = formatStrategyValues(checkedKeys, getPathKeyEntities, showCheckedStrategy);
        nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
      }
      triggerChange([...nextMissingValues, ...nextCheckedValues]);
    }
  };
}

// node_modules/@rc-component/cascader/es/hooks/useValues.js
var React189 = __toESM(require_react());
function useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues) {
  return React189.useMemo(() => {
    const [existValues, missingValues] = getMissingValues(rawValues);
    if (!multiple || !rawValues.length) {
      return [existValues, [], missingValues];
    }
    const keyPathValues = toPathKeys(existValues);
    const keyPathEntities = getPathKeyEntities();
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(keyPathValues, true, keyPathEntities);
    return [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
  }, [multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues]);
}

// node_modules/@rc-component/cascader/es/OptionList/index.js
var React196 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/List.js
var React195 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/CacheContent.js
var React190 = __toESM(require_react());
var CacheContent = React190.memo(({
  children
}) => children, (_, next) => !next.open);
if (true) {
  CacheContent.displayName = "CacheContent";
}
var CacheContent_default = CacheContent;

// node_modules/@rc-component/cascader/es/OptionList/Column.js
var React192 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/Checkbox.js
var React191 = __toESM(require_react());
function Checkbox2({
  prefixCls,
  checked,
  halfChecked,
  disabled,
  onClick,
  disableCheckbox
}) {
  const {
    checkable
  } = React191.useContext(context_default6);
  const customCheckbox = typeof checkable !== "boolean" ? checkable : null;
  return React191.createElement("span", {
    className: clsx(`${prefixCls}`, {
      [`${prefixCls}-checked`]: checked,
      [`${prefixCls}-indeterminate`]: !checked && halfChecked,
      [`${prefixCls}-disabled`]: disabled || disableCheckbox
    }),
    onClick
  }, customCheckbox);
}

// node_modules/@rc-component/cascader/es/OptionList/Column.js
function _extends39() {
  _extends39 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends39.apply(this, arguments);
}
var FIX_LABEL = "__cascader_fix_label__";
function Column({
  prefixCls,
  multiple,
  options,
  activeValue,
  prevValuePath,
  onToggleOpen,
  onSelect,
  onActive,
  checkedSet,
  halfCheckedSet,
  loadingKeys,
  isSelectable,
  disabled: propsDisabled
}) {
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const menuRef = React192.useRef(null);
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle,
    optionRender,
    classNames,
    styles
  } = React192.useContext(context_default6);
  const hoverOpen = expandTrigger === "hover";
  const isOptionDisabled = (disabled) => propsDisabled || disabled;
  const optionInfoList = React192.useMemo(() => options.map((option) => {
    const {
      disabled,
      disableCheckbox
    } = option;
    const searchOptions = option[SEARCH_MARK];
    const label = option[FIX_LABEL] ?? option[fieldNames.label];
    const value = option[fieldNames.value];
    const isMergedLeaf = isLeaf(option, fieldNames);
    const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value]) : [...prevValuePath, value];
    const fullPathKey = toPathKey(fullPath);
    const isLoading = loadingKeys.includes(fullPathKey);
    const checked = checkedSet.has(fullPathKey);
    const halfChecked = halfCheckedSet.has(fullPathKey);
    return {
      disabled,
      label,
      value,
      isLeaf: isMergedLeaf,
      isLoading,
      checked,
      halfChecked,
      option,
      disableCheckbox,
      fullPath,
      fullPathKey
    };
  }), [options, checkedSet, fieldNames, halfCheckedSet, loadingKeys, prevValuePath]);
  React192.useEffect(() => {
    if (menuRef.current) {
      const selector = `.${menuItemPrefixCls}-active`;
      const activeElement = menuRef.current.querySelector(selector);
      if (activeElement) {
        scrollIntoParentView(activeElement);
      }
    }
  }, [activeValue, menuItemPrefixCls]);
  return React192.createElement("ul", {
    className: clsx(menuPrefixCls, classNames?.popup?.list),
    style: styles?.popup?.list,
    ref: menuRef,
    role: "menu"
  }, optionInfoList.map(({
    disabled,
    label,
    value,
    isLeaf: isMergedLeaf,
    isLoading,
    checked,
    halfChecked,
    option,
    fullPath,
    fullPathKey,
    disableCheckbox
  }) => {
    const ariaProps = pickAttrs(option, {
      aria: true,
      data: true
    });
    const triggerOpenPath = () => {
      if (isOptionDisabled(disabled)) {
        return;
      }
      const nextValueCells = [...fullPath];
      if (hoverOpen && isMergedLeaf) {
        nextValueCells.pop();
      }
      onActive(nextValueCells);
    };
    const triggerSelect = () => {
      if (isSelectable(option) && !isOptionDisabled(disabled)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    let title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return React192.createElement("li", _extends39({
      key: fullPathKey
    }, ariaProps, {
      className: clsx(menuItemPrefixCls, classNames?.popup?.listItem, {
        [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
        [`${menuItemPrefixCls}-active`]: activeValue === value || activeValue === fullPathKey,
        [`${menuItemPrefixCls}-disabled`]: isOptionDisabled(disabled),
        [`${menuItemPrefixCls}-loading`]: isLoading
      }),
      style: {
        ...popupMenuColumnStyle,
        ...styles?.popup?.listItem
      },
      role: "menuitemcheckbox",
      title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      onClick: () => {
        triggerOpenPath();
        if (disableCheckbox) {
          return;
        }
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      onDoubleClick: () => {
        if (changeOnSelect) {
          onToggleOpen(false);
        }
      },
      onMouseEnter: () => {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      onMouseDown: (e3) => {
        e3.preventDefault();
      }
    }), multiple && React192.createElement(Checkbox2, {
      prefixCls: `${prefixCls}-checkbox`,
      checked,
      halfChecked,
      disabled: isOptionDisabled(disabled) || disableCheckbox,
      disableCheckbox,
      onClick: (e3) => {
        if (disableCheckbox) {
          return;
        }
        e3.stopPropagation();
        triggerSelect();
      }
    }), React192.createElement("div", {
      className: `${menuItemPrefixCls}-content`
    }, optionRender ? optionRender(option) : label), !isLoading && expandIcon && !isMergedLeaf && React192.createElement("div", {
      className: `${menuItemPrefixCls}-expand-icon`
    }, expandIcon), isLoading && loadingIcon && React192.createElement("div", {
      className: `${menuItemPrefixCls}-loading-icon`
    }, loadingIcon));
  }));
}

// node_modules/@rc-component/cascader/es/OptionList/useActive.js
var React193 = __toESM(require_react());
var useActive2 = (multiple, open3) => {
  const {
    values
  } = React193.useContext(context_default6);
  const firstValueCells = values[0];
  const [activeValueCells, setActiveValueCells] = React193.useState([]);
  React193.useEffect(
    () => {
      if (!multiple) {
        setActiveValueCells(firstValueCells || []);
      }
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [open3, firstValueCells]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  return [activeValueCells, setActiveValueCells];
};
var useActive_default = useActive2;

// node_modules/@rc-component/cascader/es/OptionList/useKeyboard.js
var React194 = __toESM(require_react());
var useKeyboard_default = ((ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {
  const {
    direction,
    searchValue,
    toggleOpen,
    open: open3
  } = contextProps;
  const rtl = direction === "rtl";
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = React194.useMemo(() => {
    let activeIndex = -1;
    let currentOptions = options;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.length;
    const pathKeys = getFullPathKeys(options, fieldNames);
    for (let i = 0; i < len && currentOptions; i += 1) {
      const nextActiveIndex = currentOptions.findIndex((option, index2) => (pathKeys[index2] ? toPathKey(pathKeys[index2]) : option[fieldNames.value]) === activeValueCells[i]);
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells[i]);
      currentOptions = currentOptions[activeIndex][fieldNames.children];
    }
    let activeOptions = options;
    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];
    }
    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];
  }, [activeValueCells, fieldNames, options]);
  const internalSetActiveValueCells = (next) => {
    setActiveValueCells(next);
  };
  const offsetActiveOption = (offset3) => {
    const len = lastActiveOptions.length;
    let currentIndex = lastActiveIndex;
    if (currentIndex === -1 && offset3 < 0) {
      currentIndex = len;
    }
    for (let i = 0; i < len; i += 1) {
      currentIndex = (currentIndex + offset3 + len) % len;
      const option = lastActiveOptions[currentIndex];
      if (option && !option.disabled) {
        const nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  const prevColumn = () => {
    if (validActiveValueCells.length > 1) {
      const nextActiveCells = validActiveValueCells.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      toggleOpen(false);
    }
  };
  const nextColumn = () => {
    const nextOptions = lastActiveOptions[lastActiveIndex]?.[fieldNames.children] || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells, nextOption[fieldNames.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  React194.useImperativeHandle(ref, () => ({
    // scrollTo: treeRef.current?.scrollTo,
    onKeyDown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        // >>> Arrow keys
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset3 = 0;
          if (which === KeyCode_default.UP) {
            offset3 = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset3 = 1;
          }
          if (offset3 !== 0) {
            offsetActiveOption(offset3);
          }
          break;
        }
        case KeyCode_default.LEFT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.RIGHT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode_default.BACKSPACE: {
          if (!searchValue) {
            prevColumn();
          }
          break;
        }
        // >>> Select
        case KeyCode_default.ENTER: {
          if (validActiveValueCells.length) {
            const option = lastActiveOptions[lastActiveIndex];
            const originOptions = option?.[SEARCH_MARK] || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value]), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);
            }
          }
          break;
        }
        // >>> Close
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open3) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    }
  }));
});

// node_modules/@rc-component/cascader/es/OptionList/List.js
function _extends40() {
  _extends40 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends40.apply(this, arguments);
}
var RawOptionList = React195.forwardRef((props, ref) => {
  const {
    prefixCls,
    multiple,
    searchValue,
    toggleOpen,
    notFoundContent,
    direction,
    open: open3,
    disabled
  } = props;
  const containerRef = React195.useRef(null);
  const rtl = direction === "rtl";
  const {
    options,
    values,
    halfValues,
    fieldNames,
    changeOnSelect,
    onSelect,
    searchOptions,
    popupPrefixCls,
    loadData,
    expandTrigger
  } = React195.useContext(context_default6);
  const mergedPrefixCls = popupPrefixCls || prefixCls;
  const [loadingKeys, setLoadingKeys] = React195.useState([]);
  const internalLoadData = (valueCells) => {
    if (!loadData || searchValue) {
      return;
    }
    const optionList = toPathOptions(valueCells, options, fieldNames);
    const rawOptions = optionList.map(({
      option
    }) => option);
    const lastOption = rawOptions[rawOptions.length - 1];
    if (lastOption && !isLeaf(lastOption, fieldNames)) {
      const pathKey = toPathKey(valueCells);
      setLoadingKeys((keys) => [...keys, pathKey]);
      loadData(rawOptions);
    }
  };
  React195.useEffect(() => {
    if (loadingKeys.length) {
      loadingKeys.forEach((loadingKey) => {
        const valueStrCells = toPathValueStr(loadingKey);
        const optionList = toPathOptions(valueStrCells, options, fieldNames, true).map(({
          option
        }) => option);
        const lastOption = optionList[optionList.length - 1];
        if (!lastOption || lastOption[fieldNames.children] || isLeaf(lastOption, fieldNames)) {
          setLoadingKeys((keys) => keys.filter((key) => key !== loadingKey));
        }
      });
    }
  }, [options, loadingKeys, fieldNames]);
  const checkedSet = React195.useMemo(() => new Set(toPathKeys(values)), [values]);
  const halfCheckedSet = React195.useMemo(() => new Set(toPathKeys(halfValues)), [halfValues]);
  const [activeValueCells, setActiveValueCells] = useActive_default(multiple, open3);
  const onPathOpen = (nextValueCells) => {
    setActiveValueCells(nextValueCells);
    internalLoadData(nextValueCells);
  };
  const isSelectable = (option) => {
    if (disabled) {
      return false;
    }
    const {
      disabled: optionDisabled
    } = option;
    const isMergedLeaf = isLeaf(option, fieldNames);
    return !optionDisabled && (isMergedLeaf || changeOnSelect || multiple);
  };
  const onPathSelect = (valuePath, leaf, fromKeyboard = false) => {
    onSelect(valuePath);
    if (!multiple && (leaf || changeOnSelect && (expandTrigger === "hover" || fromKeyboard))) {
      toggleOpen(false);
    }
  };
  const mergedOptions = React195.useMemo(() => {
    if (searchValue) {
      return searchOptions;
    }
    return options;
  }, [searchValue, searchOptions, options]);
  const optionColumns = React195.useMemo(() => {
    const optionList = [{
      options: mergedOptions
    }];
    let currentList = mergedOptions;
    const fullPathKeys = getFullPathKeys(currentList, fieldNames);
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const activeValueCell = activeValueCells[i];
      const currentOption = currentList.find((option, index2) => (fullPathKeys[index2] ? toPathKey(fullPathKeys[index2]) : option[fieldNames.value]) === activeValueCell);
      const subOptions = currentOption?.[fieldNames.children];
      if (!subOptions?.length) {
        break;
      }
      currentList = subOptions;
      optionList.push({
        options: subOptions
      });
    }
    return optionList;
  }, [mergedOptions, activeValueCells, fieldNames]);
  const onKeyboardSelect = (selectValueCells, option) => {
    if (isSelectable(option)) {
      onPathSelect(selectValueCells, isLeaf(option, fieldNames), true);
    }
  };
  useKeyboard_default(ref, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect, {
    direction,
    searchValue,
    toggleOpen,
    open: open3
  });
  React195.useEffect(() => {
    if (searchValue) {
      return;
    }
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const cellPath = activeValueCells.slice(0, i + 1);
      const cellKeyPath = toPathKey(cellPath);
      const ele = containerRef.current?.querySelector(
        `li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`
        // matches unescaped double quotes
      );
      if (ele) {
        scrollIntoParentView(ele);
      }
    }
  }, [activeValueCells, searchValue]);
  const isEmpty = !optionColumns[0]?.options?.length;
  const emptyList = [{
    [fieldNames.value]: "__EMPTY__",
    [FIX_LABEL]: notFoundContent,
    disabled: true
  }];
  const columnProps = {
    ...props,
    multiple: !isEmpty && multiple,
    onSelect: onPathSelect,
    onActive: onPathOpen,
    onToggleOpen: toggleOpen,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  };
  const mergedOptionColumns = isEmpty ? [{
    options: emptyList
  }] : optionColumns;
  const columnNodes = mergedOptionColumns.map((col, index2) => {
    const prevValuePath = activeValueCells.slice(0, index2);
    const activeValue = activeValueCells[index2];
    return React195.createElement(Column, _extends40({
      key: index2
    }, columnProps, {
      prefixCls: mergedPrefixCls,
      options: col.options,
      prevValuePath,
      activeValue
    }));
  });
  return React195.createElement(CacheContent_default, {
    open: open3
  }, React195.createElement("div", {
    className: clsx(`${mergedPrefixCls}-menus`, {
      [`${mergedPrefixCls}-menu-empty`]: isEmpty,
      [`${mergedPrefixCls}-rtl`]: rtl
    }),
    ref: containerRef
  }, columnNodes));
});
if (true) {
  RawOptionList.displayName = "RawOptionList";
}
var List_default2 = RawOptionList;

// node_modules/@rc-component/cascader/es/OptionList/index.js
function _extends41() {
  _extends41 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends41.apply(this, arguments);
}
var RefOptionList = React196.forwardRef((props, ref) => {
  const baseProps = useBaseProps();
  return React196.createElement(List_default2, _extends41({}, props, baseProps, {
    ref
  }));
});
var OptionList_default = RefOptionList;

// node_modules/@rc-component/cascader/es/Panel.js
var React197 = __toESM(require_react());
function noop() {
}
function Panel2(props) {
  const {
    prefixCls = "rc-cascader",
    style,
    className,
    options,
    checkable,
    defaultValue,
    value,
    fieldNames,
    changeOnSelect,
    onChange,
    showCheckedStrategy,
    loadData,
    expandTrigger,
    expandIcon = ">",
    loadingIcon,
    direction,
    notFoundContent = "Not Found",
    disabled,
    optionRender
  } = props;
  const multiple = !!checkable;
  const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
  const rawValues = toRawValues(interanlRawValues);
  const mergedFieldNames = React197.useMemo(
    () => fillFieldNames(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions(mergedFieldNames, options);
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues);
  const triggerChange = useEvent_default((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
  const onInternalSelect = useEvent_default((valuePath) => {
    handleSelection(valuePath);
  });
  const cascaderContext = React197.useMemo(() => ({
    options: mergedOptions,
    fieldNames: mergedFieldNames,
    values: checkedValues,
    halfValues: halfCheckedValues,
    changeOnSelect,
    onSelect: onInternalSelect,
    checkable,
    searchOptions: [],
    popupPrefixCls: void 0,
    loadData,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle: void 0,
    optionRender
  }), [mergedOptions, mergedFieldNames, checkedValues, halfCheckedValues, changeOnSelect, onInternalSelect, checkable, loadData, expandTrigger, expandIcon, loadingIcon, optionRender]);
  const panelPrefixCls = `${prefixCls}-panel`;
  const isEmpty = !mergedOptions.length;
  return React197.createElement(context_default6.Provider, {
    value: cascaderContext
  }, React197.createElement("div", {
    className: clsx(panelPrefixCls, {
      [`${panelPrefixCls}-rtl`]: direction === "rtl",
      [`${panelPrefixCls}-empty`]: isEmpty
    }, className),
    style
  }, isEmpty ? notFoundContent : React197.createElement(List_default2, {
    prefixCls,
    searchValue: "",
    multiple,
    toggleOpen: noop,
    open: true,
    direction,
    disabled
  })));
}

// node_modules/@rc-component/cascader/es/utils/warningPropsUtil.js
function warningNullOptions(options, fieldNames) {
  if (options) {
    const recursiveOptions = (optionsList) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames?.value] === null) {
          warning_default(false, "`value` in Cascader options should not be `null`.");
          return true;
        }
        if (Array.isArray(option[fieldNames?.children]) && recursiveOptions(option[fieldNames?.children])) {
          return true;
        }
      }
    };
    recursiveOptions(options);
  }
}

// node_modules/@rc-component/cascader/es/Cascader.js
function _extends42() {
  _extends42 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends42.apply(this, arguments);
}
var Cascader = React198.forwardRef((props, ref) => {
  const {
    // MISC
    id,
    prefixCls = "rc-cascader",
    fieldNames,
    // Value
    defaultValue,
    value,
    changeOnSelect,
    onChange,
    displayRender,
    checkable,
    // Search
    showSearch,
    // Trigger
    expandTrigger,
    // Options
    options,
    popupPrefixCls,
    loadData,
    open: open3,
    popupClassName,
    popupMenuColumnStyle,
    popupStyle: customPopupStyle,
    classNames,
    styles,
    placement,
    onPopupVisibleChange,
    // Icon
    expandIcon = ">",
    loadingIcon,
    // Children
    children,
    popupMatchSelectWidth = false,
    showCheckedStrategy = SHOW_PARENT,
    optionRender,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const multiple = !!checkable;
  const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
  const rawValues = toRawValues(interanlRawValues);
  const mergedFieldNames = React198.useMemo(
    () => fillFieldNames(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions(mergedFieldNames, options);
  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, props);
  const {
    autoClearSearchValue = true,
    searchValue,
    onSearch
  } = searchConfig;
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const onInternalSearch = (searchText, info) => {
    setSearchValue(searchText);
    if (info.source !== "blur" && onSearch) {
      onSearch(searchText);
    }
  };
  const searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, popupPrefixCls || prefixCls, searchConfig, changeOnSelect || multiple);
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues);
  const deDuplicatedValues = React198.useMemo(() => {
    const checkedKeys = toPathKeys(checkedValues);
    const deduplicateKeys = formatStrategyValues(checkedKeys, getPathKeyEntities, showCheckedStrategy);
    return [...missingCheckedValues, ...getValueByKeyPath(deduplicateKeys)];
  }, [checkedValues, getPathKeyEntities, getValueByKeyPath, missingCheckedValues, showCheckedStrategy]);
  const displayValues = useDisplayValues_default(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, displayRender);
  const triggerChange = useEvent_default((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
  const onInternalSelect = useEvent_default((valuePath) => {
    if (!multiple || autoClearSearchValue) {
      setSearchValue("");
    }
    handleSelection(valuePath);
  });
  const onDisplayValuesChange = (_, info) => {
    if (info.type === "clear") {
      triggerChange([]);
      return;
    }
    const {
      valueCells
    } = info.values[0];
    onInternalSelect(valueCells);
  };
  const onInternalPopupVisibleChange = (nextVisible) => {
    onPopupVisibleChange?.(nextVisible);
  };
  if (true) {
    warningNullOptions(mergedOptions, mergedFieldNames);
  }
  const cascaderContext = React198.useMemo(() => ({
    classNames,
    styles,
    options: mergedOptions,
    fieldNames: mergedFieldNames,
    values: checkedValues,
    halfValues: halfCheckedValues,
    changeOnSelect,
    onSelect: onInternalSelect,
    checkable,
    searchOptions,
    popupPrefixCls,
    loadData,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle,
    optionRender
  }), [classNames, styles, mergedOptions, mergedFieldNames, checkedValues, halfCheckedValues, changeOnSelect, onInternalSelect, checkable, searchOptions, popupPrefixCls, loadData, expandTrigger, expandIcon, loadingIcon, popupMenuColumnStyle, optionRender]);
  const emptyOptions = !(mergedSearchValue ? searchOptions : mergedOptions).length;
  const popupStyle = (
    // Search to match width
    mergedSearchValue && searchConfig.matchInputWidth || // Empty keep the width
    emptyOptions ? {} : {
      minWidth: "auto"
    }
  );
  return React198.createElement(context_default6.Provider, {
    value: cascaderContext
  }, React198.createElement(BaseSelect_default, _extends42({}, restProps, {
    // MISC
    ref,
    id: mergedId,
    prefixCls,
    autoClearSearchValue,
    popupMatchSelectWidth,
    classNames,
    styles,
    popupStyle: {
      ...popupStyle,
      ...customPopupStyle
    },
    displayValues,
    onDisplayValuesChange,
    mode: multiple ? "multiple" : void 0,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    showSearch: mergedShowSearch,
    OptionList: OptionList_default,
    emptyOptions,
    open: open3,
    popupClassName,
    placement,
    onPopupVisibleChange: onInternalPopupVisibleChange,
    getRawInputElement: () => children
  })));
});
if (true) {
  Cascader.displayName = "Cascader";
}
Cascader.SHOW_PARENT = SHOW_PARENT;
Cascader.SHOW_CHILD = SHOW_CHILD;
Cascader.Panel = Panel2;
var Cascader_default = Cascader;

// node_modules/@rc-component/cascader/es/index.js
var es_default15 = Cascader_default;

// node_modules/antd/es/cascader/hooks/useBase.js
var React199 = __toESM(require_react());
function useBase(customizePrefixCls, direction) {
  const {
    getPrefixCls,
    direction: rootDirection,
    renderEmpty
  } = React199.useContext(ConfigContext);
  const mergedDirection = direction || rootDirection;
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const cascaderPrefixCls = getPrefixCls("cascader", customizePrefixCls);
  return [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty];
}
var useBase_default = useBase;

// node_modules/antd/es/cascader/hooks/useCheckable.js
var React200 = __toESM(require_react());
function useCheckable(cascaderPrefixCls, multiple) {
  return React200.useMemo(() => multiple ? React200.createElement("span", {
    className: `${cascaderPrefixCls}-checkbox-inner`
  }) : false, [cascaderPrefixCls, multiple]);
}

// node_modules/antd/es/cascader/hooks/useColumnIcons.js
var React201 = __toESM(require_react());
var useColumnIcons = (prefixCls, rtl, expandIcon) => {
  let mergedExpandIcon = expandIcon;
  if (!expandIcon) {
    mergedExpandIcon = rtl ? React201.createElement(LeftOutlined_default, null) : React201.createElement(RightOutlined_default, null);
  }
  const loadingIcon = React201.useMemo(() => React201.createElement("span", {
    className: `${prefixCls}-menu-item-loading-icon`
  }, React201.createElement(LoadingOutlined_default, {
    spin: true
  })), [prefixCls]);
  return React201.useMemo(() => [mergedExpandIcon, loadingIcon], [mergedExpandIcon, loadingIcon]);
};
var useColumnIcons_default = useColumnIcons;

// node_modules/antd/es/cascader/Panel.js
var React202 = __toESM(require_react());

// node_modules/antd/es/checkbox/style/index.js
var genCheckboxStyle = (token) => {
  const {
    checkboxCls
  } = token;
  const wrapperCls = `${checkboxCls}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${checkboxCls}-group`]: {
        ...resetComponent(token),
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: token.marginXS,
        // Group > Grid
        [`> ${token.antCls}-row`]: {
          flex: 1
        }
      },
      // Wrapper
      [wrapperCls]: {
        ...resetComponent(token),
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${wrapperCls}`]: {
          marginInlineStart: 0
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            // FIXME: magic
            height: 14
            // FIXME: magic
          }
        }
      },
      // Wrapper > Checkbox
      [checkboxCls]: {
        ...resetComponent(token),
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        borderRadius: token.borderRadiusSM,
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${checkboxCls}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: genFocusOutline(token)
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          display: "block",
          width: token.checkboxSize,
          height: token.checkboxSize,
          direction: "ltr",
          backgroundColor: token.colorBgContainer,
          border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderRadius: token.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "25%",
            display: "table",
            width: token.calc(token.checkboxSize).div(14).mul(5).equal(),
            height: token.calc(token.checkboxSize).div(14).mul(8).equal(),
            border: `${unit(token.lineWidthBold)} solid ${token.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token.motionDurationFast} ${token.motionEaseInBack}, opacity ${token.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: token.paddingXS,
          paddingInlineEnd: token.paddingXS
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper & Wrapper > Checkbox
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token.colorPrimary,
          borderColor: token.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token.motionDurationMid} ${token.motionEaseOutBack} ${token.motionDurationFast}`
          }
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token.colorPrimaryHover,
          borderColor: "transparent"
        }
      }
    },
    // ================= Indeterminate =================
    {
      [checkboxCls]: {
        "&-indeterminate": {
          "&": {
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              backgroundColor: `${token.colorBgContainer}`,
              borderColor: `${token.colorBorder}`,
              "&:after": {
                top: "50%",
                insetInlineStart: "50%",
                width: token.calc(token.fontSizeLG).div(2).equal(),
                height: token.calc(token.fontSizeLG).div(2).equal(),
                backgroundColor: token.colorPrimary,
                border: 0,
                transform: "translate(-50%, -50%) scale(1)",
                opacity: 1,
                content: '""'
              }
            },
            // https://github.com/ant-design/ant-design/issues/50074
            [`&:hover ${checkboxCls}-inner`]: {
              backgroundColor: `${token.colorBgContainer}`,
              borderColor: `${token.colorPrimary}`
            }
          }
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${checkboxCls}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          background: token.colorBgContainerDisabled,
          borderColor: token.colorBorder,
          "&:after": {
            borderColor: token.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token.colorTextDisabled
        }
      }
    }
  ];
};
function getStyle(prefixCls, token) {
  const checkboxToken = merge(token, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token.controlInteractiveSize
  });
  return genCheckboxStyle(checkboxToken);
}
var style_default26 = genStyleHooks("Checkbox", (token, {
  prefixCls
}) => [getStyle(prefixCls, token)]);

// node_modules/antd/es/cascader/style/columns.js
var getColumnsStyle = (token) => {
  const {
    prefixCls,
    componentCls
  } = token;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
  &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
  ${cascaderMenuItemCls}-loading-icon
`;
  return [
    // ==================== Checkbox ====================
    getStyle(`${prefixCls}-checkbox`, token),
    {
      [componentCls]: {
        // ================== Checkbox ==================
        "&-checkbox": {
          top: 0,
          marginInlineEnd: token.paddingXS,
          pointerEvents: "unset"
        },
        // ==================== Menu ====================
        // >>> Menus
        "&-menus": {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          [`&${componentCls}-menu-empty`]: {
            [`${componentCls}-menu`]: {
              width: "100%",
              height: "auto",
              [cascaderMenuItemCls]: {
                color: token.colorTextDisabled
              }
            }
          }
        },
        // >>> Menu
        "&-menu": {
          flexGrow: 1,
          flexShrink: 0,
          minWidth: token.controlItemWidth,
          height: token.dropdownHeight,
          margin: 0,
          padding: token.menuPadding,
          overflow: "auto",
          verticalAlign: "top",
          listStyle: "none",
          "-ms-overflow-style": "-ms-autohiding-scrollbar",
          // https://github.com/ant-design/ant-design/issues/11857
          "&:not(:last-child)": {
            borderInlineEnd: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
          },
          "&-item": {
            ...textEllipsis,
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "center",
            padding: token.optionPadding,
            lineHeight: token.lineHeight,
            cursor: "pointer",
            transition: `all ${token.motionDurationMid}`,
            borderRadius: token.borderRadiusSM,
            "&:hover": {
              background: token.controlItemBgHover
            },
            "&-disabled": {
              color: token.colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                background: "transparent"
              },
              [iconCls]: {
                color: token.colorTextDisabled
              }
            },
            [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
              "&, &:hover": {
                color: token.optionSelectedColor,
                fontWeight: token.optionSelectedFontWeight,
                backgroundColor: token.optionSelectedBg
              }
            },
            "&-content": {
              flex: "auto"
            },
            [iconCls]: {
              marginInlineStart: token.paddingXXS,
              color: token.colorIcon,
              fontSize: token.fontSizeIcon
            },
            "&-keyword": {
              color: token.colorHighlight
            }
          }
        }
      }
    }
  ];
};
var columns_default = getColumnsStyle;

// node_modules/antd/es/cascader/style/index.js
var genBaseStyle6 = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [{
        [`&${antCls}-select-dropdown`]: {
          padding: 0
        }
      }, columns_default(token)]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token)
  ];
};
var prepareComponentToken23 = (token) => {
  const itemPaddingVertical = Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2);
  return {
    controlWidth: 184,
    controlItemWidth: 111,
    dropdownHeight: 180,
    optionSelectedBg: token.controlItemBgActive,
    optionSelectedFontWeight: token.fontWeightStrong,
    optionPadding: `${itemPaddingVertical}px ${token.paddingSM}px`,
    menuPadding: token.paddingXXS,
    optionSelectedColor: token.colorText
  };
};
var style_default27 = genStyleHooks("Cascader", genBaseStyle6, prepareComponentToken23, {
  resetFont: false,
  unitless: {
    optionSelectedFontWeight: true
  }
});

// node_modules/antd/es/cascader/style/panel.js
var genPanelStyle2 = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-panel`]: [columns_default(token), {
      display: "inline-flex",
      border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
      borderRadius: token.borderRadiusLG,
      overflowX: "auto",
      maxWidth: "100%",
      [`${componentCls}-menus`]: {
        alignItems: "stretch"
      },
      [`${componentCls}-menu`]: {
        height: "auto"
      },
      "&-empty": {
        padding: token.paddingXXS
      }
    }]
  };
};
var panel_default2 = genComponentStyleHook(["Cascader", "Panel"], genPanelStyle2, prepareComponentToken23, {
  resetFont: false
});

// node_modules/antd/es/cascader/Panel.js
function CascaderPanel(props) {
  const {
    prefixCls: customizePrefixCls,
    className,
    multiple,
    rootClassName,
    notFoundContent,
    direction,
    expandIcon,
    disabled: customDisabled
  } = props;
  const disabled = React202.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
  const rootCls = useCSSVarCls_default(cascaderPrefixCls);
  const [hashId, cssVarCls] = style_default27(cascaderPrefixCls, rootCls);
  panel_default2(cascaderPrefixCls);
  const isRtl = mergedDirection === "rtl";
  const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
  const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || React202.createElement(defaultRenderEmpty_default, {
    componentName: "Cascader"
  });
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  return React202.createElement(Panel2, {
    ...props,
    checkable,
    prefixCls: cascaderPrefixCls,
    className: clsx(className, hashId, rootClassName, cssVarCls, rootCls),
    notFoundContent: mergedNotFoundContent,
    direction: mergedDirection,
    expandIcon: mergedExpandIcon,
    loadingIcon,
    disabled: mergedDisabled
  });
}
var Panel_default2 = CascaderPanel;

// node_modules/antd/es/cascader/index.js
var {
  SHOW_CHILD: SHOW_CHILD2,
  SHOW_PARENT: SHOW_PARENT2
} = es_default15;
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index2) => index2 === 0 ? [cur] : [].concat(_toConsumableArray(list), [lowerKeyword, cur]), []);
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index2) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index2 % 2 === 1) {
      originWorld = // eslint-disable-next-line react/no-array-index-key
      React203.createElement("span", {
        className: `${prefixCls}-menu-item-keyword`,
        key: `separator-${index2}`
      }, originWorld);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
var defaultSearchRender = (inputValue, path2, prefixCls, fieldNames) => {
  const optionList = [];
  const lower2 = inputValue.toLowerCase();
  path2.forEach((node, index2) => {
    if (index2 !== 0) {
      optionList.push(" / ");
    }
    let label = node[fieldNames.label];
    const type = typeof label;
    if (type === "string" || type === "number") {
      label = highlightKeyword(String(label), lower2, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
var Cascader2 = React203.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    multiple,
    bordered = true,
    transitionName,
    choiceTransitionName = "",
    popupClassName,
    expandIcon,
    placement,
    showSearch,
    allowClear = true,
    notFoundContent,
    direction,
    getPopupContainer,
    status: customStatus,
    showArrow,
    builtinPlacements,
    style,
    variant: customVariant,
    dropdownClassName,
    dropdownRender,
    onDropdownVisibleChange,
    onPopupVisibleChange,
    dropdownMenuColumnStyle,
    popupRender,
    dropdownStyle,
    popupMenuColumnStyle,
    onOpenChange,
    styles,
    classNames,
    ...rest
  } = props;
  const restProps = omit(rest, ["suffixIcon"]);
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("cascader");
  const {
    popupOverflow
  } = React203.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React203.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  if (true) {
    const warning2 = devUseWarning("Cascader");
    const deprecatedProps = {
      dropdownClassName: "classNames.popup.root",
      dropdownStyle: "styles.popup.root",
      dropdownRender: "popupRender",
      dropdownMenuColumnStyle: "popupMenuColumnStyle",
      onDropdownVisibleChange: "onOpenChange",
      onPopupVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning2.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning2(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
  }
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
  const isRtl = mergedDirection === "rtl";
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default(prefixCls, rootCls);
  const cascaderRootCls = useCSSVarCls_default(cascaderPrefixCls);
  style_default27(cascaderPrefixCls, cascaderRootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default("cascader", customVariant, bordered);
  const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || React203.createElement(defaultRenderEmpty_default, {
    componentName: "Cascader"
  });
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedPopupMenuColumnStyle = popupMenuColumnStyle || dropdownMenuColumnStyle;
  const mergedOnOpenChange = onOpenChange || onPopupVisibleChange || onDropdownVisibleChange;
  const mergedShowSearch = React203.useMemo(() => {
    if (!showSearch) {
      return showSearch;
    }
    let searchConfig = {
      render: defaultSearchRender
    };
    if (typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    return searchConfig;
  }, [showSearch]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React203.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  const showSuffixIcon = useShowArrow(props.suffixIcon, showArrow);
  const {
    suffixIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...props,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    multiple,
    prefixCls,
    componentName: "Cascader"
  });
  const memoPlacement = React203.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return isRtl ? "bottomRight" : "bottomLeft";
  }, [placement, isRtl]);
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  const mergedProps = {
    ...props,
    variant,
    size: mergedSize,
    status: mergedStatus,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupStyle = {
    ...mergedStyles.popup?.root,
    ...dropdownStyle
  };
  const [zIndex] = useZIndex("SelectLike", mergedPopupStyle?.zIndex);
  const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${cascaderPrefixCls}-dropdown`, {
    [`${cascaderPrefixCls}-dropdown-rtl`]: mergedDirection === "rtl"
  }, rootClassName, rootCls, mergedClassNames.popup?.root, cascaderRootCls, hashId, cssVarCls);
  return React203.createElement(es_default15, {
    prefixCls,
    className: clsx(!customizePrefixCls && cascaderPrefixCls, {
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: isRtl,
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, rootClassName, mergedClassNames.root, rootCls, cascaderRootCls, hashId, cssVarCls),
    disabled: mergedDisabled,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    classNames: mergedClassNames,
    styles: mergedStyles,
    ...restProps,
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    direction: mergedDirection,
    placement: memoPlacement,
    notFoundContent: mergedNotFoundContent,
    allowClear: mergedAllowClear,
    showSearch: mergedShowSearch,
    expandIcon: mergedExpandIcon,
    suffixIcon,
    removeIcon,
    loadingIcon,
    checkable,
    popupClassName: mergedPopupClassName,
    popupPrefixCls: customizePrefixCls || cascaderPrefixCls,
    popupStyle: {
      ...mergedPopupStyle,
      zIndex
    },
    popupRender: mergedPopupRender,
    popupMenuColumnStyle: mergedPopupMenuColumnStyle,
    onPopupVisibleChange: mergedOnOpenChange,
    choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
    transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    ref
  });
});
if (true) {
  Cascader2.displayName = "Cascader";
}
var PurePanel5 = PurePanel_default(Cascader2, "popupAlign", (props) => omit(props, ["visible"]));
Cascader2.SHOW_PARENT = SHOW_PARENT2;
Cascader2.SHOW_CHILD = SHOW_CHILD2;
Cascader2.Panel = Panel_default2;
Cascader2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel5;
var cascader_default = Cascader2;

// node_modules/antd/es/checkbox/Checkbox.js
var React205 = __toESM(require_react());

// node_modules/antd/es/checkbox/GroupContext.js
var import_react60 = __toESM(require_react());
var GroupContext = import_react60.default.createContext(null);
var GroupContext_default = GroupContext;

// node_modules/antd/es/checkbox/Checkbox.js
var InternalCheckbox = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    indeterminate = false,
    style,
    onMouseEnter,
    onMouseLeave,
    skipGroup = false,
    disabled,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("checkbox");
  const checkboxGroup = React205.useContext(GroupContext_default);
  const {
    isFormItemInput
  } = React205.useContext(FormItemInputContext);
  const contextDisabled = React205.useContext(DisabledContext_default);
  const mergedDisabled = (checkboxGroup?.disabled || disabled) ?? contextDisabled;
  const mergedProps = {
    ...props,
    indeterminate,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prevValue = React205.useRef(restProps.value);
  const checkboxRef = React205.useRef(null);
  const mergedRef = composeRef(ref, checkboxRef);
  if (true) {
    const warning2 = devUseWarning("Checkbox");
    true ? warning2("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?") : void 0;
  }
  React205.useEffect(() => {
    checkboxGroup?.registerValue(restProps.value);
  }, []);
  React205.useEffect(() => {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup?.cancelValue(prevValue.current);
      checkboxGroup?.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return () => checkboxGroup?.cancelValue(restProps.value);
  }, [restProps.value]);
  React205.useEffect(() => {
    if (checkboxRef.current?.input) {
      checkboxRef.current.input.indeterminate = indeterminate;
    }
  }, [indeterminate]);
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default26(prefixCls, rootCls);
  const checkboxProps = {
    ...restProps
  };
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = (...args) => {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, args);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
  }
  const classString = clsx(`${prefixCls}-wrapper`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
    [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
  }, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
  const checkboxClass = clsx(mergedClassNames.icon, {
    [`${prefixCls}-indeterminate`]: indeterminate
  }, TARGET_CLS, hashId);
  const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
  return React205.createElement(wave_default, {
    component: "Checkbox",
    disabled: mergedDisabled
  }, React205.createElement("label", {
    className: classString,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    onMouseEnter,
    onMouseLeave,
    onClick: onLabelClick
  }, React205.createElement(es_default12, {
    ...checkboxProps,
    onClick: onInputClick,
    prefixCls,
    className: checkboxClass,
    style: mergedStyles.icon,
    disabled: mergedDisabled,
    ref: mergedRef
  }), isNonNullable_default(children) && React205.createElement("span", {
    className: clsx(`${prefixCls}-label`, mergedClassNames.label),
    style: mergedStyles.label
  }, children)));
};
var Checkbox3 = React205.forwardRef(InternalCheckbox);
if (true) {
  Checkbox3.displayName = "Checkbox";
}
var Checkbox_default = Checkbox3;

// node_modules/antd/es/checkbox/Group.js
var React206 = __toESM(require_react());
var CheckboxGroup = React206.forwardRef((props, ref) => {
  const {
    defaultValue,
    children,
    options = [],
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    onChange,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = React206.useContext(ConfigContext);
  const [value, setValue] = React206.useState(restProps.value || defaultValue || []);
  const [registeredValues, setRegisteredValues] = React206.useState([]);
  React206.useEffect(() => {
    if ("value" in restProps) {
      setValue(restProps.value || []);
    }
  }, [restProps.value]);
  const memoizedOptions = React206.useMemo(() => options.map((option) => {
    if (typeof option === "string" || typeof option === "number") {
      return {
        label: option,
        value: option
      };
    }
    return option;
  }), [options]);
  const cancelValue = (val) => {
    setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
  };
  const registerValue = (val) => {
    setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
  };
  const toggleOption = (option) => {
    const optionIndex = value.indexOf(option.value);
    const newValue = _toConsumableArray(value);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue(newValue);
    }
    onChange?.(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
      const indexA = memoizedOptions.findIndex((opt) => opt.value === a);
      const indexB = memoizedOptions.findIndex((opt) => opt.value === b);
      return indexA - indexB;
    }));
  };
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default26(prefixCls, rootCls);
  const domProps = omit(restProps, ["value", "disabled"]);
  const childrenNode = options.length ? memoizedOptions.map((option) => React206.createElement(Checkbox_default, {
    prefixCls,
    key: option.value.toString(),
    disabled: "disabled" in option ? option.disabled : restProps.disabled,
    value: option.value,
    checked: value.includes(option.value),
    onChange: option.onChange,
    className: clsx(`${groupPrefixCls}-item`, option.className),
    style: option.style,
    title: option.title,
    id: option.id,
    required: option.required
  }, option.label)) : children;
  const memoizedContext = React206.useMemo(() => ({
    toggleOption,
    value,
    disabled: restProps.disabled,
    name: restProps.name,
    // https://github.com/ant-design/ant-design/issues/16376
    registerValue,
    cancelValue
  }), [toggleOption, value, restProps.disabled, restProps.name, registerValue, cancelValue]);
  const classString = clsx(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, cssVarCls, rootCls, hashId);
  return React206.createElement("div", {
    className: classString,
    style,
    ...domProps,
    ref
  }, React206.createElement(GroupContext_default.Provider, {
    value: memoizedContext
  }, childrenNode));
});
var Group_default = CheckboxGroup;

// node_modules/antd/es/checkbox/index.js
var Checkbox4 = Checkbox_default;
Checkbox4.Group = Group_default;
Checkbox4.__ANT_CHECKBOX = true;
if (true) {
  Checkbox4.displayName = "Checkbox";
}
var checkbox_default = Checkbox4;

// node_modules/antd/es/grid/col.js
var React207 = __toESM(require_react());

// node_modules/antd/es/grid/RowContext.js
var import_react61 = __toESM(require_react());
var RowContext = (0, import_react61.createContext)({});
var RowContext_default = RowContext;

// node_modules/antd/es/grid/col.js
function parseFlex(flex) {
  if (flex === "auto") {
    return "1 1 auto";
  }
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Col = React207.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React207.useContext(ConfigContext);
  const {
    gutter,
    wrap
  } = React207.useContext(RowContext_default);
  const {
    prefixCls: customizePrefixCls,
    span,
    order,
    offset: offset3,
    push,
    pull,
    className,
    children,
    flex,
    style,
    ...others
  } = props;
  const prefixCls = getPrefixCls("col", customizePrefixCls);
  const [hashId, cssVarCls] = useColStyle(prefixCls);
  const sizeStyle = {};
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (typeof propSize === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = {
      ...sizeClassObj,
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    };
    if (sizeProps.flex) {
      sizeClassObj[`${prefixCls}-${size}-flex`] = true;
      sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
    }
  });
  const classes = clsx(prefixCls, {
    [`${prefixCls}-${span}`]: span !== void 0,
    [`${prefixCls}-order-${order}`]: order,
    [`${prefixCls}-offset-${offset3}`]: offset3,
    [`${prefixCls}-push-${push}`]: push,
    [`${prefixCls}-pull-${pull}`]: pull
  }, className, sizeClassObj, hashId, cssVarCls);
  const mergedStyle = {};
  if (gutter?.[0]) {
    const horizontalGutter = typeof gutter[0] === "number" ? `${gutter[0] / 2}px` : `calc(${gutter[0]} / 2)`;
    mergedStyle.paddingInline = horizontalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return React207.createElement("div", {
    ...others,
    style: {
      ...mergedStyle,
      ...style,
      ...sizeStyle
    },
    className: classes,
    ref
  }, children);
});
if (true) {
  Col.displayName = "Col";
}
var col_default = Col;

// node_modules/antd/es/grid/row.js
var React208 = __toESM(require_react());

// node_modules/antd/es/grid/hooks/useGutter.js
function useGutter(gutter, screens) {
  const results = [void 0, void 0];
  const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
  const mergedScreens = screens || {
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  };
  normalizedGutter.forEach((g, index2) => {
    if (typeof g === "object" && g !== null) {
      for (let i = 0; i < responsiveArray.length; i++) {
        const breakpoint = responsiveArray[i];
        if (mergedScreens[breakpoint] && g[breakpoint] !== void 0) {
          results[index2] = g[breakpoint];
          break;
        }
      }
    } else {
      results[index2] = g;
    }
  });
  return results;
}

// node_modules/antd/es/grid/row.js
function useMergedPropByScreen(oriProp, screen) {
  const [prop, setProp] = React208.useState(typeof oriProp === "string" ? oriProp : "");
  const calcMergedAlignOrJustify = () => {
    if (typeof oriProp === "string") {
      setProp(oriProp);
    }
    if (typeof oriProp !== "object") {
      return;
    }
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (!screen || !screen[breakpoint]) {
        continue;
      }
      const curVal = oriProp[breakpoint];
      if (curVal !== void 0) {
        setProp(curVal);
        return;
      }
    }
  };
  React208.useEffect(() => {
    calcMergedAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
var Row = React208.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style,
    children,
    gutter = 0,
    wrap,
    ...others
  } = props;
  const {
    getPrefixCls,
    direction
  } = React208.useContext(ConfigContext);
  const screens = useBreakpoint_default(true, null);
  const mergedAlign = useMergedPropByScreen(align, screens);
  const mergedJustify = useMergedPropByScreen(justify, screens);
  const prefixCls = getPrefixCls("row", customizePrefixCls);
  const [hashId, cssVarCls] = useRowStyle(prefixCls);
  const gutters = useGutter(gutter, screens);
  const classes = clsx(prefixCls, {
    [`${prefixCls}-no-wrap`]: wrap === false,
    [`${prefixCls}-${mergedJustify}`]: mergedJustify,
    [`${prefixCls}-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId, cssVarCls);
  const rowStyle = {};
  if (gutters?.[0]) {
    const horizontalGutter = typeof gutters[0] === "number" ? `${gutters[0] / -2}px` : `calc(${gutters[0]} / -2)`;
    rowStyle.marginInline = horizontalGutter;
  }
  const [gutterH, gutterV] = gutters;
  rowStyle.rowGap = gutterV;
  const rowContext = React208.useMemo(() => ({
    gutter: [gutterH, gutterV],
    wrap
  }), [gutterH, gutterV, wrap]);
  return React208.createElement(RowContext_default.Provider, {
    value: rowContext
  }, React208.createElement("div", {
    ...others,
    className: classes,
    style: {
      ...rowStyle,
      ...style
    },
    ref
  }, children));
});
if (true) {
  Row.displayName = "Row";
}
var row_default = Row;

// node_modules/antd/es/grid/index.js
function useBreakpoint2() {
  return useBreakpoint_default();
}
var grid_default = {
  useBreakpoint: useBreakpoint2
};

// node_modules/antd/es/col/index.js
var col_default2 = col_default;

// node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var React213 = __toESM(require_react());
var import_react64 = __toESM(require_react());

// node_modules/antd/es/date-picker/hooks/useMergedPickerSemantic.js
var React209 = __toESM(require_react());
var useMergedPickerSemantic = (pickerType, classNames, styles, popupClassName, popupStyle, mergedProps) => {
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig(pickerType);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React209.useMemo(() => {
    const filledClassNames = {
      ...mergedClassNames,
      popup: {
        ...mergedClassNames.popup,
        root: clsx(mergedClassNames.popup?.root, popupClassName)
      }
    };
    const filledStyles = {
      ...mergedStyles,
      popup: {
        ...mergedStyles.popup,
        root: {
          ...mergedStyles.popup?.root,
          ...popupStyle
        }
      }
    };
    return [filledClassNames, filledStyles];
  }, [mergedClassNames, mergedStyles, popupClassName, popupStyle]);
};
var useMergedPickerSemantic_default = useMergedPickerSemantic;

// node_modules/antd/es/date-picker/util.js
var React210 = __toESM(require_react());
function getPlaceholder(locale2, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
    return locale2.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.monthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.weekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.placeholder;
  }
  return locale2.lang.placeholder;
}
function getRangePlaceholder(locale2, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.rangeYearPlaceholder;
  }
  if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
    return locale2.lang.rangeQuarterPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.rangePlaceholder;
  }
  return locale2.lang.rangePlaceholder;
}
function useIcons2(props, prefixCls) {
  const {
    allowClear = true
  } = props;
  const {
    clearIcon,
    removeIcon
  } = useIcons({
    ...props,
    prefixCls,
    componentName: "DatePicker"
  });
  const mergedAllowClear = React210.useMemo(() => {
    if (allowClear === false) {
      return false;
    }
    const allowClearConfig = allowClear === true ? {} : allowClear;
    return {
      clearIcon,
      ...allowClearConfig
    };
  }, [allowClear, clearIcon]);
  return [mergedAllowClear, removeIcon];
}

// node_modules/antd/es/date-picker/generatePicker/constant.js
var [WEEK, WEEKPICKER] = ["week", "WeekPicker"];
var [MONTH, MONTHPICKER] = ["month", "MonthPicker"];
var [YEAR, YEARPICKER] = ["year", "YearPicker"];
var [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"];
var [TIME, TIMEPICKER] = ["time", "TimePicker"];

// node_modules/antd/es/date-picker/generatePicker/SuffixIcon.js
var import_react62 = __toESM(require_react());
var SuffixIcon = ({
  picker,
  hasFeedback,
  feedbackIcon,
  suffixIcon
}) => {
  if (suffixIcon === null || suffixIcon === false) {
    return null;
  }
  if (suffixIcon === true || suffixIcon === void 0) {
    return import_react62.default.createElement(import_react62.default.Fragment, null, picker === TIME ? import_react62.default.createElement(ClockCircleOutlined_default, null) : import_react62.default.createElement(CalendarOutlined_default, null), hasFeedback && feedbackIcon);
  }
  return suffixIcon;
};
var SuffixIcon_default = SuffixIcon;

// node_modules/antd/es/date-picker/generatePicker/useComponents.js
var import_react63 = __toESM(require_react());

// node_modules/antd/es/date-picker/PickerButton.js
var React212 = __toESM(require_react());
var PickerButton = (props) => React212.createElement(Button_default, {
  size: "small",
  type: "primary",
  ...props
});
var PickerButton_default = PickerButton;

// node_modules/antd/es/date-picker/generatePicker/useComponents.js
function useComponents(components) {
  return (0, import_react63.useMemo)(() => ({
    button: PickerButton_default,
    ...components
  }), [components]);
}

// node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var generateRangePicker = (generateConfig2) => {
  const RangePicker3 = (0, import_react64.forwardRef)((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      getPopupContainer: customGetPopupContainer,
      components,
      className,
      style,
      classNames,
      styles,
      placement,
      size: customizeSize,
      disabled: customDisabled,
      bordered = true,
      placeholder,
      status: customStatus,
      variant: customVariant,
      picker,
      dropdownClassName,
      popupClassName,
      popupStyle,
      rootClassName,
      suffixIcon,
      ...restProps
    } = props;
    const pickerType = picker === TIME ? "timePicker" : "datePicker";
    if (true) {
      const warning2 = devUseWarning("DatePicker.RangePicker");
      const deprecatedProps = {
        dropdownClassName: "classNames.popup.root",
        popupClassName: "classNames.popup.root",
        popupStyle: "styles.popup.root",
        bordered: "variant",
        onSelect: "onCalendarChange"
      };
      Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
        warning2.deprecated(!(oldProp in props), oldProp, newProp);
      });
    }
    const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle);
    const innerRef = React213.useRef(null);
    const {
      getPrefixCls,
      direction,
      getPopupContainer,
      rangePicker
    } = (0, import_react64.useContext)(ConfigContext);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const rootPrefixCls = getPrefixCls();
    const [variant, enableVariantCls] = useVariants_default("rangePicker", customVariant, bordered);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [hashId, cssVarCls] = style_default21(prefixCls, rootCls);
    const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
    const [mergedAllowClear] = useIcons2(props, prefixCls);
    const mergedComponents = useComponents(components);
    const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
    const disabled = React213.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled ?? disabled;
    const formItemContext = (0, import_react64.useContext)(FormItemInputContext);
    const {
      hasFeedback,
      status: contextStatus,
      feedbackIcon
    } = formItemContext;
    const mergedSuffixIcon = React213.createElement(SuffixIcon_default, {
      picker,
      hasFeedback,
      feedbackIcon,
      suffixIcon
    });
    (0, import_react64.useImperativeHandle)(ref, () => innerRef.current);
    const [contextLocale] = useLocale_default("Calendar", en_US_default2);
    const locale2 = {
      ...contextLocale,
      ...props.locale
    };
    const [zIndex] = useZIndex("DatePicker", mergedStyles?.popup?.root?.zIndex);
    return React213.createElement(ContextIsolator_default, {
      space: true
    }, React213.createElement(RangePicker_default, {
      separator: React213.createElement("span", {
        "aria-label": "to",
        className: `${prefixCls}-separator`
      }, React213.createElement(SwapRightOutlined_default, null)),
      disabled: mergedDisabled,
      ref: innerRef,
      placement,
      placeholder: getRangePlaceholder(locale2, picker, placeholder),
      suffixIcon: mergedSuffixIcon,
      prevIcon: React213.createElement("span", {
        className: `${prefixCls}-prev-icon`
      }),
      nextIcon: React213.createElement("span", {
        className: `${prefixCls}-next-icon`
      }),
      superPrevIcon: React213.createElement("span", {
        className: `${prefixCls}-super-prev-icon`
      }),
      superNextIcon: React213.createElement("span", {
        className: `${prefixCls}-super-next-icon`
      }),
      transitionName: `${rootPrefixCls}-slide-up`,
      picker,
      ...restProps,
      locale: locale2.lang,
      getPopupContainer: customGetPopupContainer || getPopupContainer,
      generateConfig: generateConfig2,
      components: mergedComponents,
      direction,
      // Style
      prefixCls,
      rootClassName: mergedRootClassName,
      className: clsx({
        [`${prefixCls}-${mergedSize}`]: mergedSize,
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, className, rangePicker?.className),
      style: {
        ...rangePicker?.style,
        ...style
      },
      // Semantic Style
      classNames: mergedClassNames,
      styles: {
        ...mergedStyles,
        popup: {
          ...mergedStyles.popup,
          root: {
            ...mergedStyles.popup.root,
            zIndex
          }
        }
      },
      allowClear: mergedAllowClear
    }));
  });
  if (true) {
    RangePicker3.displayName = "RangePicker";
  }
  return RangePicker3;
};
var generateRangePicker_default = generateRangePicker;

// node_modules/antd/es/date-picker/generatePicker/generateSinglePicker.js
var React214 = __toESM(require_react());
var import_react65 = __toESM(require_react());
var generatePicker = (generateConfig2) => {
  const getPicker = (picker, displayName) => {
    const pickerType = displayName === TIMEPICKER ? "timePicker" : "datePicker";
    const Picker2 = (0, import_react65.forwardRef)((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        getPopupContainer: customizeGetPopupContainer,
        components,
        style,
        className,
        size: customizeSize,
        bordered,
        placement,
        placeholder,
        disabled: customDisabled,
        status: customStatus,
        variant: customVariant,
        onCalendarChange,
        classNames,
        styles,
        dropdownClassName,
        popupClassName,
        popupStyle,
        rootClassName,
        suffixIcon,
        ...restProps
      } = props;
      if (true) {
        const warning2 = devUseWarning(displayName || "DatePicker");
        true ? warning2(picker !== "quarter", "deprecated", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`) : void 0;
        const deprecatedProps = {
          dropdownClassName: "classNames.popup.root",
          popupClassName: "classNames.popup.root",
          popupStyle: "styles.popup.root",
          bordered: "variant",
          onSelect: "onCalendarChange"
        };
        Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
          warning2.deprecated(!(oldProp in props), oldProp, newProp);
        });
      }
      const {
        getPrefixCls,
        direction,
        getPopupContainer,
        // Consume different styles according to different names
        [pickerType]: contextPickerConfig
      } = (0, import_react65.useContext)(ConfigContext);
      const prefixCls = getPrefixCls("picker", customizePrefixCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
      const disabled = React214.useContext(DisabledContext_default);
      const mergedDisabled = customDisabled ?? disabled;
      const mergedProps = {
        ...props,
        size: mergedSize,
        disabled: mergedDisabled,
        status: customStatus,
        variant: customVariant
      };
      const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle, mergedProps);
      const innerRef = React214.useRef(null);
      const [variant, enableVariantCls] = useVariants_default("datePicker", customVariant, bordered);
      const rootCls = useCSSVarCls_default(prefixCls);
      const [hashId, cssVarCls] = style_default21(prefixCls, rootCls);
      const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
      (0, import_react65.useImperativeHandle)(ref, () => innerRef.current);
      const additionalProps = {
        showToday: true
      };
      const mergedPicker = picker || props.picker;
      const rootPrefixCls = getPrefixCls();
      const {
        onSelect,
        multiple
      } = restProps;
      const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
      const onInternalCalendarChange = (date, dateStr, info) => {
        onCalendarChange?.(date, dateStr, info);
        if (hasLegacyOnSelect) {
          onSelect(date);
        }
      };
      const [mergedAllowClear, removeIcon] = useIcons2(props, prefixCls);
      const mergedComponents = useComponents(components);
      const formItemContext = (0, import_react65.useContext)(FormItemInputContext);
      const {
        hasFeedback,
        status: contextStatus,
        feedbackIcon
      } = formItemContext;
      const mergedSuffixIcon = React214.createElement(SuffixIcon_default, {
        picker: mergedPicker,
        hasFeedback,
        feedbackIcon,
        suffixIcon
      });
      const [contextLocale] = useLocale_default("DatePicker", en_US_default2);
      const locale2 = {
        ...contextLocale,
        ...props.locale
      };
      const [zIndex] = useZIndex("DatePicker", mergedStyles?.popup?.root?.zIndex);
      return React214.createElement(ContextIsolator_default, {
        space: true
      }, React214.createElement(es_default11, {
        ref: innerRef,
        placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
        suffixIcon: mergedSuffixIcon,
        placement,
        prevIcon: React214.createElement("span", {
          className: `${prefixCls}-prev-icon`
        }),
        nextIcon: React214.createElement("span", {
          className: `${prefixCls}-next-icon`
        }),
        superPrevIcon: React214.createElement("span", {
          className: `${prefixCls}-super-prev-icon`
        }),
        superNextIcon: React214.createElement("span", {
          className: `${prefixCls}-super-next-icon`
        }),
        transitionName: `${rootPrefixCls}-slide-up`,
        picker,
        onCalendarChange: onInternalCalendarChange,
        ...additionalProps,
        ...restProps,
        locale: locale2.lang,
        getPopupContainer: customizeGetPopupContainer || getPopupContainer,
        generateConfig: generateConfig2,
        components: mergedComponents,
        direction,
        disabled: mergedDisabled,
        // Style
        prefixCls,
        rootClassName: mergedRootClassName,
        className: clsx({
          [`${prefixCls}-${mergedSize}`]: mergedSize,
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, contextPickerConfig?.className, className),
        style: {
          ...contextPickerConfig?.style,
          ...style
        },
        // Semantic Style
        classNames: mergedClassNames,
        styles: {
          ...mergedStyles,
          popup: {
            ...mergedStyles.popup,
            root: {
              ...mergedStyles.popup.root,
              zIndex
            }
          }
        },
        allowClear: mergedAllowClear,
        removeIcon
      }));
    });
    if (displayName) {
      Picker2.displayName = displayName;
    }
    return Picker2;
  };
  const DatePicker2 = getPicker();
  const WeekPicker = getPicker(WEEK, WEEKPICKER);
  const MonthPicker = getPicker(MONTH, MONTHPICKER);
  const YearPicker = getPicker(YEAR, YEARPICKER);
  const QuarterPicker = getPicker(QUARTER, QUARTERPICKER);
  const TimePicker2 = getPicker(TIME, TIMEPICKER);
  return {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  };
};
var generateSinglePicker_default = generatePicker;

// node_modules/antd/es/date-picker/generatePicker/index.js
var generatePicker2 = (generateConfig2) => {
  const {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  } = generateSinglePicker_default(generateConfig2);
  const RangePicker3 = generateRangePicker_default(generateConfig2);
  const MergedDatePicker = DatePicker2;
  MergedDatePicker.WeekPicker = WeekPicker;
  MergedDatePicker.MonthPicker = MonthPicker;
  MergedDatePicker.YearPicker = YearPicker;
  MergedDatePicker.RangePicker = RangePicker3;
  MergedDatePicker.TimePicker = TimePicker2;
  MergedDatePicker.QuarterPicker = QuarterPicker;
  if (true) {
    MergedDatePicker.displayName = "DatePicker";
  }
  return MergedDatePicker;
};
var generatePicker_default = generatePicker2;

// node_modules/antd/es/date-picker/index.js
var DatePicker = generatePicker_default(dayjs_default);
var PurePanel6 = PurePanel_default(DatePicker, "popupAlign", void 0, "picker");
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel6;
var PureRangePanel = PurePanel_default(DatePicker.RangePicker, "popupAlign", void 0, "picker");
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
DatePicker.generatePicker = generatePicker_default;
var date_picker_default = DatePicker;

// node_modules/antd/es/descriptions/index.js
var React219 = __toESM(require_react());

// node_modules/antd/es/descriptions/constant.js
var DEFAULT_COLUMN_MAP = {
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
var constant_default = DEFAULT_COLUMN_MAP;

// node_modules/antd/es/descriptions/DescriptionsContext.js
var import_react66 = __toESM(require_react());
var DescriptionsContext = import_react66.default.createContext(null);
var DescriptionsContext_default = DescriptionsContext;

// node_modules/antd/es/descriptions/hooks/useItems.js
var React216 = __toESM(require_react());
var transChildren2Items = (childNodes) => toArray(childNodes).map((node) => ({
  ...node?.props,
  key: node.key
}));
function useItems2(screens, items, children) {
  const mergedItems = React216.useMemo(() => (
    // Take `items` first or convert `children` into items
    items || transChildren2Items(children)
  ), [items, children]);
  const responsiveItems = React216.useMemo(() => mergedItems.map(({
    span,
    ...restItem
  }) => {
    if (span === "filled") {
      return {
        ...restItem,
        filled: true
      };
    }
    return {
      ...restItem,
      span: typeof span === "number" ? span : matchScreen(screens, span)
    };
  }), [mergedItems, screens]);
  return responsiveItems;
}

// node_modules/antd/es/descriptions/hooks/useRow.js
var import_react67 = __toESM(require_react());
function getCalcRows(rowItems, mergedColumn) {
  let rows = [];
  let tmpRow = [];
  let exceed = false;
  let count = 0;
  rowItems.filter((n2) => n2).forEach((rowItem) => {
    const {
      filled,
      ...restItem
    } = rowItem;
    if (filled) {
      tmpRow.push(restItem);
      rows.push(tmpRow);
      tmpRow = [];
      count = 0;
      return;
    }
    const restSpan = mergedColumn - count;
    count += rowItem.span || 1;
    if (count >= mergedColumn) {
      if (count > mergedColumn) {
        exceed = true;
        tmpRow.push({
          ...restItem,
          span: restSpan
        });
      } else {
        tmpRow.push(restItem);
      }
      rows.push(tmpRow);
      tmpRow = [];
      count = 0;
    } else {
      tmpRow.push(restItem);
    }
  });
  if (tmpRow.length > 0) {
    rows.push(tmpRow);
  }
  rows = rows.map((rows2) => {
    const count2 = rows2.reduce((acc, item) => acc + (item.span || 1), 0);
    if (count2 < mergedColumn) {
      const last = rows2[rows2.length - 1];
      last.span = mergedColumn - (count2 - (last.span || 1));
      return rows2;
    }
    return rows2;
  });
  return [rows, exceed];
}
var useRow = (mergedColumn, items) => {
  const [rows, exceed] = (0, import_react67.useMemo)(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);
  if (true) {
    const warning2 = devUseWarning("Descriptions");
    true ? warning2(!exceed, "usage", "Sum of column `span` in a line not match `column` of Descriptions.") : void 0;
  }
  return rows;
};
var useRow_default = useRow;

// node_modules/antd/es/descriptions/Item.js
var DescriptionsItem = (props) => {
  return props.children;
};
var Item_default = DescriptionsItem;

// node_modules/antd/es/descriptions/Row.js
var React218 = __toESM(require_react());

// node_modules/antd/es/descriptions/Cell.js
var React217 = __toESM(require_react());
var Cell = (props) => {
  const {
    itemPrefixCls,
    component,
    span,
    className,
    style,
    labelStyle,
    contentStyle,
    bordered,
    label,
    content,
    colon,
    type,
    styles,
    classNames
  } = props;
  const Component6 = component;
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = React217.useContext(DescriptionsContext_default);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const mergedLabelStyle = {
    ...labelStyle,
    ...mergedStyles.label
  };
  const mergedContentStyle = {
    ...contentStyle,
    ...mergedStyles.content
  };
  if (bordered) {
    return React217.createElement(Component6, {
      colSpan: span,
      style,
      className: clsx(className, {
        [`${itemPrefixCls}-item-${type}`]: type === "label" || type === "content",
        [mergedClassNames.label]: mergedClassNames.label && type === "label",
        [mergedClassNames.content]: mergedClassNames.content && type === "content"
      })
    }, isNonNullable_default(label) && React217.createElement("span", {
      style: mergedLabelStyle
    }, label), isNonNullable_default(content) && React217.createElement("span", {
      style: mergedContentStyle
    }, content));
  }
  return React217.createElement(Component6, {
    className: clsx(`${itemPrefixCls}-item`, className),
    style,
    colSpan: span
  }, React217.createElement("div", {
    className: `${itemPrefixCls}-item-container`
  }, isNonNullable_default(label) && React217.createElement("span", {
    style: mergedLabelStyle,
    className: clsx(`${itemPrefixCls}-item-label`, mergedClassNames.label, {
      [`${itemPrefixCls}-item-no-colon`]: !colon
    })
  }, label), isNonNullable_default(content) && React217.createElement("span", {
    style: mergedContentStyle,
    className: clsx(`${itemPrefixCls}-item-content`, mergedClassNames.content)
  }, content)));
};
var Cell_default = Cell;

// node_modules/antd/es/descriptions/Row.js
function renderCells(items, {
  colon,
  prefixCls,
  bordered
}, {
  component,
  type,
  showLabel,
  showContent,
  labelStyle: rootLabelStyle,
  contentStyle: rootContentStyle,
  styles: rootStyles
}) {
  return items.map(({
    label,
    children,
    prefixCls: itemPrefixCls = prefixCls,
    className,
    style,
    labelStyle,
    contentStyle,
    span = 1,
    key,
    styles,
    classNames
  }, index2) => {
    if (typeof component === "string") {
      return React218.createElement(Cell_default, {
        key: `${type}-${key || index2}`,
        className,
        style,
        classNames,
        styles: {
          label: {
            ...rootLabelStyle,
            ...rootStyles?.label,
            ...labelStyle,
            ...styles?.label
          },
          content: {
            ...rootContentStyle,
            ...rootStyles?.content,
            ...contentStyle,
            ...styles?.content
          }
        },
        span,
        colon,
        component,
        itemPrefixCls,
        bordered,
        label: showLabel ? label : null,
        content: showContent ? children : null,
        type
      });
    }
    return [React218.createElement(Cell_default, {
      key: `label-${key || index2}`,
      className,
      style: {
        ...rootLabelStyle,
        ...rootStyles?.label,
        ...style,
        ...labelStyle,
        ...styles?.label
      },
      span: 1,
      colon,
      component: component[0],
      itemPrefixCls,
      bordered,
      label,
      type: "label"
    }), React218.createElement(Cell_default, {
      key: `content-${key || index2}`,
      className,
      style: {
        ...rootContentStyle,
        ...rootStyles?.content,
        ...style,
        ...contentStyle,
        ...styles?.content
      },
      span: span * 2 - 1,
      component: component[1],
      itemPrefixCls,
      bordered,
      content: children,
      type: "content"
    })];
  });
}
var Row2 = (props) => {
  const descContext = React218.useContext(DescriptionsContext_default);
  const {
    prefixCls,
    vertical,
    row,
    index: index2,
    bordered
  } = props;
  if (vertical) {
    return React218.createElement(React218.Fragment, null, React218.createElement("tr", {
      key: `label-${index2}`,
      className: `${prefixCls}-row`
    }, renderCells(row, props, {
      component: "th",
      type: "label",
      showLabel: true,
      ...descContext
    })), React218.createElement("tr", {
      key: `content-${index2}`,
      className: `${prefixCls}-row`
    }, renderCells(row, props, {
      component: "td",
      type: "content",
      showContent: true,
      ...descContext
    })));
  }
  return React218.createElement("tr", {
    key: index2,
    className: `${prefixCls}-row`
  }, renderCells(row, props, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    ...descContext
  }));
};
var Row_default = Row2;

// node_modules/antd/es/descriptions/style/index.js
var genBorderedStyle = (token) => {
  const {
    componentCls,
    labelBg
  } = token;
  return {
    [`&${componentCls}-bordered`]: {
      [`> ${componentCls}-view`]: {
        border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
        "> table": {
          tableLayout: "auto"
        },
        [`${componentCls}-row`]: {
          borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
          "&:first-child": {
            "> th:first-child, > td:first-child": {
              borderStartStartRadius: token.borderRadiusLG
            }
          },
          "&:last-child": {
            borderBottom: "none",
            "> th:first-child, > td:first-child": {
              borderEndStartRadius: token.borderRadiusLG
            }
          },
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token.padding)} ${unit(token.paddingLG)}`,
            borderInlineEnd: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
            "&:last-child": {
              borderInlineEnd: "none"
            }
          },
          [`> ${componentCls}-item-label`]: {
            color: token.colorTextSecondary,
            backgroundColor: labelBg,
            "&::after": {
              display: "none"
            }
          }
        }
      },
      [`&${componentCls}-middle`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token.paddingSM)} ${unit(token.paddingLG)}`
          }
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token.paddingXS)} ${unit(token.padding)}`
          }
        }
      }
    }
  };
};
var genDescriptionStyles = (token) => {
  const {
    componentCls,
    extraColor,
    itemPaddingBottom,
    itemPaddingEnd,
    colonMarginRight,
    colonMarginLeft,
    titleMarginBottom
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      ...genBorderedStyle(token),
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: titleMarginBottom
      },
      [`${componentCls}-title`]: {
        ...textEllipsis,
        flex: "auto",
        color: token.titleColor,
        fontWeight: token.fontWeightStrong,
        fontSize: token.fontSizeLG,
        lineHeight: token.lineHeightLG
      },
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: extraColor,
        fontSize: token.fontSize
      },
      [`${componentCls}-view`]: {
        width: "100%",
        borderRadius: token.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed",
          borderCollapse: "collapse"
        }
      },
      [`${componentCls}-row`]: {
        "> th, > td": {
          paddingBottom: itemPaddingBottom,
          paddingInlineEnd: itemPaddingEnd
        },
        "> th:last-child, > td:last-child": {
          paddingInlineEnd: 0
        },
        "&:last-child": {
          borderBottom: "none",
          "> th, > td": {
            paddingBottom: 0
          }
        }
      },
      [`${componentCls}-item-label`]: {
        color: token.labelColor,
        fontWeight: "normal",
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          // magic for position
          marginInline: `${unit(colonMarginLeft)} ${unit(colonMarginRight)}`
        },
        [`&${componentCls}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${componentCls}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${componentCls}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: token.contentColor,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${componentCls}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${componentCls}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${componentCls}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline",
            minWidth: "1em"
          }
        }
      },
      "&-middle": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token.paddingSM
          }
        }
      },
      "&-small": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token.paddingXS
          }
        }
      }
    }
  };
};
var prepareComponentToken24 = (token) => ({
  labelBg: token.colorFillAlter,
  labelColor: token.colorTextTertiary,
  titleColor: token.colorText,
  titleMarginBottom: token.fontSizeSM * token.lineHeightSM,
  itemPaddingBottom: token.padding,
  itemPaddingEnd: token.padding,
  colonMarginRight: token.marginXS,
  colonMarginLeft: token.marginXXS / 2,
  contentColor: token.colorText,
  extraColor: token.colorText
});
var style_default28 = genStyleHooks("Descriptions", (token) => {
  const descriptionToken = merge(token, {});
  return genDescriptionStyles(descriptionToken);
}, prepareComponentToken24);

// node_modules/antd/es/descriptions/index.js
var Descriptions = (props) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    extra,
    column,
    colon = true,
    bordered,
    layout,
    children,
    className,
    rootClassName,
    style,
    size: customizeSize,
    labelStyle,
    contentStyle,
    styles,
    items,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("descriptions");
  const prefixCls = getPrefixCls("descriptions", customizePrefixCls);
  const screens = useBreakpoint_default();
  if (true) {
    const warning2 = devUseWarning("Descriptions");
    [["labelStyle", "styles.label"], ["contentStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const mergedColumn = React219.useMemo(() => {
    if (typeof column === "number") {
      return column;
    }
    return matchScreen(screens, {
      ...constant_default,
      ...column
    }) ?? 3;
  }, [screens, column]);
  const mergedItems = useItems2(screens, items, children);
  const mergedSize = useSize_default(customizeSize);
  const rows = useRow_default(mergedColumn, mergedItems);
  const [hashId, cssVarCls] = style_default28(prefixCls);
  const mergedProps = {
    ...props,
    column: mergedColumn,
    items: mergedItems,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const memoizedValue = React219.useMemo(() => ({
    labelStyle,
    contentStyle,
    styles: {
      label: mergedStyles.label,
      content: mergedStyles.content
    },
    classNames: {
      label: clsx(mergedClassNames.label),
      content: clsx(mergedClassNames.content)
    }
  }), [labelStyle, contentStyle, mergedStyles.label, mergedStyles.content, mergedClassNames.label, mergedClassNames.content]);
  return React219.createElement(DescriptionsContext_default.Provider, {
    value: memoizedValue
  }, React219.createElement("div", {
    className: clsx(prefixCls, contextClassName, mergedClassNames.root, {
      [`${prefixCls}-${mergedSize}`]: mergedSize && mergedSize !== "default",
      [`${prefixCls}-bordered`]: !!bordered,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId, cssVarCls),
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style
    },
    ...restProps
  }, (title || extra) && React219.createElement("div", {
    className: clsx(`${prefixCls}-header`, mergedClassNames.header),
    style: mergedStyles.header
  }, title && React219.createElement("div", {
    className: clsx(`${prefixCls}-title`, mergedClassNames.title),
    style: mergedStyles.title
  }, title), extra && React219.createElement("div", {
    className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
    style: mergedStyles.extra
  }, extra)), React219.createElement("div", {
    className: `${prefixCls}-view`
  }, React219.createElement("table", null, React219.createElement("tbody", null, rows.map((row, index2) => React219.createElement(Row_default, {
    key: index2,
    index: index2,
    colon,
    prefixCls,
    vertical: layout === "vertical",
    bordered,
    row
  })))))));
};
if (true) {
  Descriptions.displayName = "Descriptions";
}
Descriptions.Item = Item_default;
var descriptions_default = Descriptions;

// node_modules/antd/es/drawer/index.js
var React226 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/Drawer.js
var React224 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/context.js
var React220 = __toESM(require_react());
var DrawerContext = React220.createContext(null);
var RefContext2 = React220.createContext({});
var context_default7 = DrawerContext;

// node_modules/@rc-component/drawer/es/DrawerPopup.js
var React223 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/DrawerPanel.js
var React221 = __toESM(require_react());
function _extends43() {
  _extends43 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends43.apply(this, arguments);
}
var DrawerPanel = (props) => {
  const {
    prefixCls,
    className,
    containerRef,
    ...restProps
  } = props;
  const {
    panel: panelRef
  } = React221.useContext(RefContext2);
  const mergedRef = useComposeRef(panelRef, containerRef);
  return React221.createElement("div", _extends43({
    className: clsx(`${prefixCls}-section`, className),
    role: "dialog",
    ref: mergedRef
  }, pickAttrs(props, {
    aria: true
  }), {
    "aria-modal": "true"
  }, restProps));
};
if (true) {
  DrawerPanel.displayName = "DrawerPanel";
}
var DrawerPanel_default = DrawerPanel;

// node_modules/@rc-component/drawer/es/hooks/useDrag.js
var React222 = __toESM(require_react());
function useDrag(options) {
  const {
    prefixCls,
    direction,
    className,
    style,
    maxSize,
    containerRef,
    currentSize,
    onResize,
    onResizeEnd,
    onResizeStart
  } = options;
  const [isDragging, setIsDragging] = React222.useState(false);
  const [startPos, setStartPos] = React222.useState(0);
  const [startSize, setStartSize] = React222.useState(0);
  const isHorizontal = direction === "left" || direction === "right";
  const handleMouseDown = useEvent_default((e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    setIsDragging(true);
    if (isHorizontal) {
      setStartPos(e3.clientX);
    } else {
      setStartPos(e3.clientY);
    }
    let startSize2;
    if (typeof currentSize === "number") {
      startSize2 = currentSize;
    } else if (containerRef?.current) {
      const rect = containerRef.current.getBoundingClientRect();
      startSize2 = isHorizontal ? rect.width : rect.height;
    }
    setStartSize(startSize2);
    onResizeStart?.(startSize2);
  });
  const handleMouseMove = useEvent_default((e3) => {
    if (!isDragging) return;
    const currentPos = isHorizontal ? e3.clientX : e3.clientY;
    let delta = currentPos - startPos;
    if (direction === "right" || direction === "bottom") {
      delta = -delta;
    }
    let newSize = startSize + delta;
    if (newSize < 0) {
      newSize = 0;
    }
    if (maxSize && newSize > maxSize) {
      newSize = maxSize;
    }
    onResize?.(newSize);
  });
  const handleMouseUp = React222.useCallback(() => {
    if (isDragging) {
      setIsDragging(false);
      if (containerRef?.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const finalSize = isHorizontal ? rect.width : rect.height;
        onResizeEnd?.(finalSize);
      }
    }
  }, [isDragging, containerRef, onResizeEnd, isHorizontal]);
  React222.useEffect(() => {
    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);
  const dragElementClassName = clsx(`${prefixCls}-dragger`, `${prefixCls}-dragger-${direction}`, {
    [`${prefixCls}-dragger-dragging`]: isDragging,
    [`${prefixCls}-dragger-horizontal`]: isHorizontal,
    [`${prefixCls}-dragger-vertical`]: !isHorizontal
  }, className);
  return {
    dragElementProps: {
      className: dragElementClassName,
      style,
      onMouseDown: handleMouseDown
    },
    isDragging
  };
}

// node_modules/@rc-component/drawer/es/util.js
function parseWidthHeight(value) {
  if (typeof value === "string") {
    const num = Number(value.replace(/px$/i, ""));
    const floatNum = parseFloat(value);
    if (floatNum === num) {
      warning_default(false, "Invalid value type of `width` or `height` which should be number type instead.");
    }
    if (!Number.isNaN(num)) {
      return num;
    }
  }
  return value;
}
function warnCheck(props) {
  warning_default(!("wrapperClassName" in props), `'wrapperClassName' is removed. Please use 'rootClassName' instead.`);
  warning_default(canUseDom() || !props.open, `Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.`);
}

// node_modules/@rc-component/drawer/es/DrawerPopup.js
function _extends44() {
  _extends44 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends44.apply(this, arguments);
}
var sentinelStyle2 = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none",
  position: "absolute"
};
var DrawerPopup = (props, ref) => {
  const {
    prefixCls,
    open: open3,
    placement,
    inline,
    push,
    forceRender,
    autoFocus,
    keyboard,
    // classNames
    classNames: drawerClassNames,
    // Root
    rootClassName,
    rootStyle,
    zIndex,
    // Drawer
    className,
    id,
    style,
    motion: motion2,
    width,
    height,
    size,
    maxSize,
    children,
    // Mask
    mask,
    maskClosable,
    maskMotion,
    maskClassName,
    maskStyle,
    // Events
    afterOpenChange,
    onClose,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    styles,
    drawerRender,
    resizable,
    defaultSize
  } = props;
  const panelRef = React223.useRef(null);
  const sentinelStartRef = React223.useRef(null);
  const sentinelEndRef = React223.useRef(null);
  React223.useImperativeHandle(ref, () => panelRef.current);
  const onPanelKeyDown = (event) => {
    const {
      keyCode,
      shiftKey
    } = event;
    switch (keyCode) {
      // Tab active
      case KeyCode_default.TAB: {
        if (keyCode === KeyCode_default.TAB) {
          if (!shiftKey && document.activeElement === sentinelEndRef.current) {
            sentinelStartRef.current?.focus({
              preventScroll: true
            });
          } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
            sentinelEndRef.current?.focus({
              preventScroll: true
            });
          }
        }
        break;
      }
      // Close
      case KeyCode_default.ESC: {
        if (onClose && keyboard) {
          event.stopPropagation();
          onClose(event);
        }
        break;
      }
    }
  };
  React223.useEffect(() => {
    if (open3 && autoFocus) {
      panelRef.current?.focus({
        preventScroll: true
      });
    }
  }, [open3]);
  const [pushed, setPushed] = React223.useState(false);
  const parentContext = React223.useContext(context_default7);
  let pushConfig;
  if (typeof push === "boolean") {
    pushConfig = push ? {} : {
      distance: 0
    };
  } else {
    pushConfig = push || {};
  }
  const pushDistance = pushConfig?.distance ?? parentContext?.pushDistance ?? 180;
  const mergedContext = React223.useMemo(() => ({
    pushDistance,
    push: () => {
      setPushed(true);
    },
    pull: () => {
      setPushed(false);
    }
  }), [pushDistance]);
  React223.useEffect(() => {
    if (open3) {
      parentContext?.push?.();
    } else {
      parentContext?.pull?.();
    }
  }, [open3]);
  React223.useEffect(() => () => {
    parentContext?.pull?.();
  }, []);
  const maskNode = React223.createElement(es_default4, _extends44({
    key: "mask"
  }, maskMotion, {
    visible: mask && open3
  }), ({
    className: motionMaskClassName,
    style: motionMaskStyle
  }, maskRef) => React223.createElement("div", {
    className: clsx(`${prefixCls}-mask`, motionMaskClassName, drawerClassNames?.mask, maskClassName),
    style: {
      ...motionMaskStyle,
      ...maskStyle,
      ...styles?.mask
    },
    onClick: maskClosable && open3 ? onClose : void 0,
    ref: maskRef
  }));
  const motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
  const [currentSize, setCurrentSize] = React223.useState();
  const isHorizontal = placement === "left" || placement === "right";
  const mergedSize = React223.useMemo(() => {
    const legacySize = isHorizontal ? width : height;
    const nextMergedSize = size ?? legacySize ?? currentSize ?? defaultSize ?? (isHorizontal ? 378 : void 0);
    return parseWidthHeight(nextMergedSize);
  }, [size, width, height, defaultSize, isHorizontal, currentSize]);
  const wrapperStyle = React223.useMemo(() => {
    const nextWrapperStyle = {};
    if (pushed && pushDistance) {
      switch (placement) {
        case "top":
          nextWrapperStyle.transform = `translateY(${pushDistance}px)`;
          break;
        case "bottom":
          nextWrapperStyle.transform = `translateY(${-pushDistance}px)`;
          break;
        case "left":
          nextWrapperStyle.transform = `translateX(${pushDistance}px)`;
          break;
        default:
          nextWrapperStyle.transform = `translateX(${-pushDistance}px)`;
          break;
      }
    }
    if (isHorizontal) {
      nextWrapperStyle.width = parseWidthHeight(mergedSize);
    } else {
      nextWrapperStyle.height = parseWidthHeight(mergedSize);
    }
    return nextWrapperStyle;
  }, [pushed, pushDistance, placement, isHorizontal, mergedSize]);
  const wrapperRef = React223.useRef(null);
  const isResizable = !!resizable;
  const resizeConfig = typeof resizable === "object" && resizable || {};
  const onInternalResize = useEvent_default((size2) => {
    setCurrentSize(size2);
    resizeConfig.onResize?.(size2);
  });
  const {
    dragElementProps,
    isDragging
  } = useDrag({
    prefixCls: `${prefixCls}-resizable`,
    direction: placement,
    className: drawerClassNames?.dragger,
    style: styles?.dragger,
    maxSize,
    containerRef: wrapperRef,
    currentSize: mergedSize,
    onResize: onInternalResize,
    onResizeStart: resizeConfig.onResizeStart,
    onResizeEnd: resizeConfig.onResizeEnd
  });
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const panelNode = React223.createElement(es_default4, _extends44({
    key: "panel"
  }, motionProps, {
    visible: open3,
    forceRender,
    onVisibleChanged: (nextVisible) => {
      afterOpenChange?.(nextVisible);
    },
    removeOnLeave: false,
    leavedClassName: `${prefixCls}-content-wrapper-hidden`
  }), ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => {
    const content = React223.createElement(DrawerPanel_default, _extends44({
      id,
      containerRef: motionRef,
      prefixCls,
      className: clsx(className, drawerClassNames?.section),
      style: {
        ...style,
        ...styles?.section
      }
    }, pickAttrs(props, {
      aria: true
    }), eventHandlers), children);
    return React223.createElement("div", _extends44({
      ref: wrapperRef,
      className: clsx(`${prefixCls}-content-wrapper`, isDragging && `${prefixCls}-content-wrapper-dragging`, drawerClassNames?.wrapper, !isDragging && motionClassName),
      style: {
        ...motionStyle,
        ...wrapperStyle,
        ...styles?.wrapper
      }
    }, pickAttrs(props, {
      data: true
    })), isResizable && React223.createElement("div", dragElementProps), drawerRender ? drawerRender(content) : content);
  });
  const containerStyle = {
    ...rootStyle
  };
  if (zIndex) {
    containerStyle.zIndex = zIndex;
  }
  return React223.createElement(context_default7.Provider, {
    value: mergedContext
  }, React223.createElement("div", {
    className: clsx(prefixCls, `${prefixCls}-${placement}`, rootClassName, {
      [`${prefixCls}-open`]: open3,
      [`${prefixCls}-inline`]: inline
    }),
    style: containerStyle,
    tabIndex: -1,
    ref: panelRef,
    onKeyDown: onPanelKeyDown
  }, maskNode, React223.createElement("div", {
    tabIndex: 0,
    ref: sentinelStartRef,
    style: sentinelStyle2,
    "aria-hidden": "true",
    "data-sentinel": "start"
  }), panelNode, React223.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle2,
    "aria-hidden": "true",
    "data-sentinel": "end"
  })));
};
var RefDrawerPopup = React223.forwardRef(DrawerPopup);
if (true) {
  RefDrawerPopup.displayName = "DrawerPopup";
}
var DrawerPopup_default = RefDrawerPopup;

// node_modules/@rc-component/drawer/es/Drawer.js
var Drawer = (props) => {
  const {
    open: open3 = false,
    prefixCls = "rc-drawer",
    placement = "right",
    autoFocus = true,
    keyboard = true,
    width,
    height,
    size,
    maxSize,
    mask = true,
    maskClosable = true,
    getContainer,
    forceRender,
    afterOpenChange,
    destroyOnHidden,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    resizable,
    defaultSize,
    // Refs
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React224.useState(false);
  if (true) {
    warnCheck(props);
  }
  const [mounted, setMounted] = React224.useState(false);
  useLayoutEffect_default(() => {
    setMounted(true);
  }, []);
  const mergedOpen = mounted ? open3 : false;
  const popupRef = React224.useRef(null);
  const lastActiveRef = React224.useRef(null);
  useLayoutEffect_default(() => {
    if (mergedOpen) {
      lastActiveRef.current = document.activeElement;
    }
  }, [mergedOpen]);
  const internalAfterOpenChange = (nextVisible) => {
    setAnimatedVisible(nextVisible);
    afterOpenChange?.(nextVisible);
    if (!nextVisible && lastActiveRef.current && !popupRef.current?.contains(lastActiveRef.current)) {
      lastActiveRef.current?.focus({
        preventScroll: true
      });
    }
  };
  const refContext = React224.useMemo(() => ({
    panel: panelRef
  }), [panelRef]);
  if (!forceRender && !animatedVisible && !mergedOpen && destroyOnHidden) {
    return null;
  }
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const drawerPopupProps = {
    ...props,
    open: mergedOpen,
    prefixCls,
    placement,
    autoFocus,
    keyboard,
    width,
    height,
    size,
    maxSize,
    defaultSize,
    mask,
    maskClosable,
    inline: getContainer === false,
    afterOpenChange: internalAfterOpenChange,
    ref: popupRef,
    resizable,
    ...eventHandlers
  };
  return React224.createElement(RefContext2.Provider, {
    value: refContext
  }, React224.createElement(es_default2, {
    open: mergedOpen || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer,
    autoLock: mask && (mergedOpen || animatedVisible)
  }, React224.createElement(DrawerPopup_default, drawerPopupProps)));
};
if (true) {
  Drawer.displayName = "Drawer";
}
var Drawer_default = Drawer;

// node_modules/@rc-component/drawer/es/index.js
var es_default16 = Drawer_default;

// node_modules/antd/es/drawer/DrawerPanel.js
var React225 = __toESM(require_react());
var DrawerPanel2 = (props) => {
  const {
    prefixCls,
    ariaId,
    title,
    footer,
    extra,
    closable,
    loading,
    onClose,
    headerStyle,
    bodyStyle,
    footerStyle,
    children,
    classNames: drawerClassNames,
    styles: drawerStyles
  } = props;
  const drawerContext = useComponentConfig("drawer");
  const {
    classNames: contextClassNames,
    styles: contextStyles,
    closable: contextClosable
  } = drawerContext;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, drawerClassNames], [contextStyles, drawerStyles], {
    props: {
      ...props,
      closable: closable ?? contextClosable
    }
  });
  const closablePlacement = React225.useMemo(() => {
    const mergedClosableVal = closable ?? contextClosable;
    if (mergedClosableVal === false) {
      return void 0;
    }
    if (typeof mergedClosableVal === "object" && mergedClosableVal && mergedClosableVal.placement === "end") {
      return "end";
    }
    return "start";
  }, [closable, contextClosable]);
  const customCloseIconRender = React225.useCallback((icon) => React225.createElement("button", {
    type: "button",
    onClick: onClose,
    className: clsx(`${prefixCls}-close`, {
      [`${prefixCls}-close-${closablePlacement}`]: closablePlacement === "end"
    }, mergedClassNames.close),
    style: mergedStyles.close
  }, icon), [onClose, prefixCls, closablePlacement, mergedClassNames.close, mergedStyles.close]);
  const [mergedClosable, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(drawerContext), {
    closable: true,
    closeIconRender: customCloseIconRender
  });
  const renderHeader = () => {
    if (!title && !mergedClosable) {
      return null;
    }
    return React225.createElement("div", {
      style: {
        ...mergedStyles.header,
        ...headerStyle
      },
      className: clsx(`${prefixCls}-header`, mergedClassNames.header, {
        [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra
      })
    }, React225.createElement("div", {
      className: `${prefixCls}-header-title`
    }, closablePlacement === "start" && mergedCloseIcon, title && React225.createElement("div", {
      className: clsx(`${prefixCls}-title`, mergedClassNames.title),
      style: mergedStyles.title,
      id: ariaId
    }, title)), extra && React225.createElement("div", {
      className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
      style: mergedStyles.extra
    }, extra), closablePlacement === "end" && mergedCloseIcon);
  };
  const renderFooter = () => {
    if (!footer) {
      return null;
    }
    return React225.createElement("div", {
      className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
      style: {
        ...mergedStyles.footer,
        ...footerStyle
      }
    }, footer);
  };
  return React225.createElement(React225.Fragment, null, renderHeader(), React225.createElement("div", {
    className: clsx(`${prefixCls}-body`, mergedClassNames.body),
    style: {
      ...mergedStyles.body,
      ...bodyStyle
    }
  }, loading ? React225.createElement(skeleton_default, {
    active: true,
    title: false,
    paragraph: {
      rows: 5
    },
    className: `${prefixCls}-body-skeleton`
  }) : children), renderFooter());
};
var DrawerPanel_default2 = DrawerPanel2;

// node_modules/antd/es/drawer/style/motion.js
var getMoveTranslate = (direction) => {
  const value = "100%";
  return {
    left: `translateX(-${value})`,
    right: `translateX(${value})`,
    top: `translateY(-${value})`,
    bottom: `translateY(${value})`
  }[direction];
};
var getEnterLeaveStyle = (startStyle, endStyle) => ({
  "&-enter, &-appear": {
    ...startStyle,
    "&-active": endStyle
  },
  "&-leave": {
    ...endStyle,
    "&-active": startStyle
  }
});
var getFadeStyle = (from, duration) => ({
  "&-enter, &-appear, &-leave": {
    "&-start": {
      transition: "none"
    },
    "&-active": {
      transition: `all ${duration}`
    }
  },
  ...getEnterLeaveStyle({
    opacity: from
  }, {
    opacity: 1
  })
});
var getPanelMotionStyles = (direction, duration) => [getFadeStyle(0.7, duration), getEnterLeaveStyle({
  transform: getMoveTranslate(direction)
}, {
  transform: "none"
})];
var genMotionStyle2 = (token) => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  return {
    [componentCls]: {
      // ======================== Mask ========================
      [`${componentCls}-mask-motion`]: getFadeStyle(0, motionDurationSlow),
      // ======================= Panel ========================
      [`${componentCls}-panel-motion`]: ["left", "right", "top", "bottom"].reduce((obj, direction) => ({
        ...obj,
        [`&-${direction}`]: getPanelMotionStyles(direction, motionDurationSlow)
      }), {})
    }
  };
};
var motion_default3 = genMotionStyle2;

// node_modules/antd/es/drawer/style/index.js
var genDrawerStyle = (token) => {
  const {
    borderRadiusSM,
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    paddingXS,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginXS,
    colorIcon,
    colorIconHover,
    colorBgTextHover,
    colorBgTextActive,
    colorText,
    fontWeightStrong,
    footerPaddingBlock,
    footerPaddingInline,
    draggerSize,
    calc
  } = token;
  const wrapperCls = `${componentCls}-content-wrapper`;
  const draggerCls = `${componentCls}-resizable-dragger`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      color: colorText,
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        display: "flex",
        flexDirection: "column",
        [`&${componentCls}-left`]: {
          boxShadow: token.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto",
        [`&${componentCls}-mask-blur`]: {
          backdropFilter: "blur(4px)"
        }
      },
      // ==================== Content =====================
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        maxWidth: "100vw",
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token.boxShadowDrawerDown
      },
      [`${componentCls}-section`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      // Header
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${unit(padding)} ${unit(paddingLG)}`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-flex",
        width: calc(fontSizeLG).add(paddingXS).equal(),
        height: calc(fontSizeLG).add(paddingXS).equal(),
        borderRadius: borderRadiusSM,
        justifyContent: "center",
        alignItems: "center",
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`,
        textRendering: "auto",
        [`&${componentCls}-close-end`]: {
          marginInlineStart: marginXS
        },
        [`&:not(${componentCls}-close-end)`]: {
          marginInlineEnd: marginXS
        },
        "&:hover": {
          color: colorIconHover,
          backgroundColor: colorBgTextHover,
          textDecoration: "none"
        },
        "&:active": {
          backgroundColor: colorBgTextActive
        },
        ...genFocusStyle(token)
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        fontWeight: token.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      // Body
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto",
        [`${componentCls}-body-skeleton`]: {
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center"
        }
      },
      // Footer
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${unit(footerPaddingBlock)} ${unit(footerPaddingInline)}`,
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
      },
      // ==================== Resizable ===================
      [draggerCls]: {
        position: "absolute",
        zIndex: 1,
        backgroundColor: "transparent",
        userSelect: "none",
        pointerEvents: "auto",
        "&:hover": {
          backgroundColor: token.colorPrimary,
          opacity: 0.2
        },
        "&-dragging": {
          backgroundColor: token.colorPrimary,
          opacity: 0.3
        }
      },
      [`${draggerCls}-left`]: {
        top: 0,
        bottom: 0,
        insetInlineEnd: 0,
        width: draggerSize,
        cursor: "col-resize"
      },
      [`${draggerCls}-right`]: {
        top: 0,
        bottom: 0,
        insetInlineStart: 0,
        width: draggerSize,
        cursor: "col-resize"
      },
      [`${draggerCls}-top`]: {
        insetInline: 0,
        bottom: 0,
        height: draggerSize,
        cursor: "row-resize"
      },
      [`${draggerCls}-bottom`]: {
        insetInline: 0,
        top: 0,
        height: draggerSize,
        cursor: "row-resize"
      },
      // Wrapper dragging state - disable transitions for smooth dragging
      [`${wrapperCls}-dragging`]: {
        userSelect: "none",
        transition: "none",
        willChange: "width, height",
        [`${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-section`]: {
          pointerEvents: "none"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken25 = (token) => ({
  zIndexPopup: token.zIndexPopupBase,
  footerPaddingBlock: token.paddingXS,
  footerPaddingInline: token.padding,
  draggerSize: 4
});
var style_default29 = genStyleHooks("Drawer", (token) => {
  const drawerToken = merge(token, {});
  return [genDrawerStyle(drawerToken), motion_default3(drawerToken)];
}, prepareComponentToken25);

// node_modules/antd/es/drawer/index.js
var defaultPushState = {
  distance: 180
};
var DEFAULT_SIZE3 = 378;
var Drawer2 = (props) => {
  const {
    rootClassName,
    size,
    defaultSize = DEFAULT_SIZE3,
    height,
    width,
    mask: drawerMask,
    push = defaultPushState,
    open: open3,
    afterOpenChange,
    onClose,
    prefixCls: customizePrefixCls,
    getContainer: customizeGetContainer,
    panelRef = null,
    style,
    className,
    resizable,
    "aria-labelledby": ariaLabelledby,
    // Deprecated
    maskStyle,
    drawerStyle,
    contentWrapperStyle,
    destroyOnClose,
    destroyOnHidden,
    ...rest
  } = props;
  const {
    placement
  } = rest;
  const id = useId_default();
  const ariaId = rest.title ? id : void 0;
  const {
    getPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    mask: contextMask
  } = useComponentConfig("drawer");
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default29(prefixCls);
  const getContainer = (
    //  false
    customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer
  );
  if (true) {
    const warning2 = devUseWarning("Drawer");
    [["headerStyle", "styles.header"], ["bodyStyle", "styles.body"], ["footerStyle", "styles.footer"], ["contentWrapperStyle", "styles.wrapper"], ["maskStyle", "styles.mask"], ["drawerStyle", "styles.section"], ["destroyInactivePanel", "destroyOnHidden"], ["width", "size"], ["height", "size"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (getContainer !== void 0 && props.style?.position === "absolute") {
      true ? warning2(false, "breaking", "`style` is replaced by `rootStyle` in v5. Please check that `position: absolute` is necessary.") : void 0;
    }
  }
  const drawerSize = React226.useMemo(() => {
    if (typeof size === "number") {
      return size;
    }
    if (size === "large") {
      return 736;
    }
    if (size === "default") {
      return DEFAULT_SIZE3;
    }
    if (!placement || placement === "left" || placement === "right") {
      return width;
    }
    return height;
  }, [size, placement, width, height]);
  const maskMotion = {
    motionName: getTransitionName(prefixCls, "mask-motion"),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  };
  const panelMotion = (motionPlacement) => ({
    motionName: getTransitionName(prefixCls, `panel-motion-${motionPlacement}`),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  });
  const innerPanelRef = usePanelRef();
  const mergedPanelRef = composeRef(panelRef, innerPanelRef);
  const [zIndex, contextZIndex] = useZIndex("Drawer", rest.zIndex);
  const {
    classNames,
    styles,
    rootStyle
  } = rest;
  const [mergedMask, maskBlurClassName] = useMergedMask(drawerMask, contextMask, prefixCls);
  const mergedProps = {
    ...props,
    zIndex,
    panelRef,
    mask: mergedMask,
    defaultSize,
    push
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const drawerClassName = clsx({
    "no-mask": !mergedMask,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  return React226.createElement(ContextIsolator_default, {
    form: true,
    space: true
  }, React226.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, React226.createElement(es_default16, {
    prefixCls,
    onClose,
    maskMotion,
    motion: panelMotion,
    ...rest,
    classNames: {
      mask: clsx(mergedClassNames.mask, maskBlurClassName.mask),
      section: mergedClassNames.section,
      wrapper: mergedClassNames.wrapper,
      dragger: mergedClassNames.dragger
    },
    styles: {
      mask: {
        ...mergedStyles.mask,
        ...maskStyle
      },
      section: {
        ...mergedStyles.section,
        ...drawerStyle
      },
      wrapper: {
        ...mergedStyles.wrapper,
        ...contentWrapperStyle
      },
      dragger: mergedStyles.dragger
    },
    open: open3,
    mask: mergedMask,
    push,
    size: drawerSize,
    defaultSize,
    style: {
      ...contextStyle,
      ...style
    },
    rootStyle: {
      ...rootStyle,
      ...mergedStyles.root
    },
    className: clsx(contextClassName, className),
    rootClassName: drawerClassName,
    getContainer,
    afterOpenChange,
    panelRef: mergedPanelRef,
    zIndex,
    ...resizable ? {
      resizable
    } : {},
    "aria-labelledby": ariaLabelledby ?? ariaId,
    destroyOnHidden: destroyOnHidden ?? destroyOnClose
  }, React226.createElement(DrawerPanel_default2, {
    prefixCls,
    size,
    ...rest,
    ariaId,
    onClose
  }))));
};
var PurePanel7 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    style,
    className,
    placement = "right",
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React226.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default29(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, cssVarCls, className);
  return React226.createElement("div", {
    className: cls,
    style
  }, React226.createElement(DrawerPanel_default2, {
    prefixCls,
    ...restProps
  }));
};
Drawer2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel7;
if (true) {
  Drawer2.displayName = "Drawer";
}
var drawer_default = Drawer2;

// node_modules/antd/es/dropdown/dropdown-button.js
var React230 = __toESM(require_react());

// node_modules/antd/es/space/index.js
var React229 = __toESM(require_react());

// node_modules/antd/es/_util/gapSize.js
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}
function isValidGapNumber(size) {
  if (!size) {
    return false;
  }
  return typeof size === "number" && !Number.isNaN(size);
}

// node_modules/antd/es/space/context.js
var import_react68 = __toESM(require_react());
var SpaceContext = import_react68.default.createContext({
  latestIndex: 0
});
var SpaceContextProvider = SpaceContext.Provider;

// node_modules/antd/es/space/Item.js
var React228 = __toESM(require_react());
var Item = (props) => {
  const {
    className,
    prefix,
    index: index2,
    children,
    separator,
    style,
    classNames,
    styles
  } = props;
  const {
    latestIndex
  } = React228.useContext(SpaceContext);
  if (!isNonNullable_default(children)) {
    return null;
  }
  return React228.createElement(React228.Fragment, null, React228.createElement("div", {
    className,
    style
  }, children), index2 < latestIndex && separator && React228.createElement("span", {
    className: clsx(`${prefix}-item-separator`, classNames.separator),
    style: styles.separator
  }, separator));
};
var Item_default2 = Item;

// node_modules/antd/es/space/style/index.js
var genSpaceStyle = (token) => {
  const {
    componentCls,
    antCls
  } = token;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item:empty`]: {
        display: "none"
      },
      // https://github.com/ant-design/ant-design/issues/47875
      [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
        display: "block"
      }
    }
  };
};
var genSpaceGapStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      "&-gap-row-small": {
        rowGap: token.spaceGapSmallSize
      },
      "&-gap-row-middle": {
        rowGap: token.spaceGapMiddleSize
      },
      "&-gap-row-large": {
        rowGap: token.spaceGapLargeSize
      },
      "&-gap-col-small": {
        columnGap: token.spaceGapSmallSize
      },
      "&-gap-col-middle": {
        columnGap: token.spaceGapMiddleSize
      },
      "&-gap-col-large": {
        columnGap: token.spaceGapLargeSize
      }
    }
  };
};
var style_default30 = genStyleHooks("Space", (token) => {
  const spaceToken = merge(token, {
    spaceGapSmallSize: token.paddingXS,
    spaceGapMiddleSize: token.padding,
    spaceGapLargeSize: token.paddingLG
  });
  return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken)];
}, () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: false
});

// node_modules/antd/es/space/index.js
var InternalSpace = React229.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction: directionConfig,
    size: contextSize,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("space");
  const {
    size = contextSize ?? "small",
    align,
    className,
    rootClassName,
    children,
    direction,
    orientation,
    prefixCls: customizePrefixCls,
    split,
    separator,
    style,
    vertical,
    wrap = false,
    classNames,
    styles,
    ...restProps
  } = props;
  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
  const isPresetVerticalSize = isPresetSize(verticalSize);
  const isPresetHorizontalSize = isPresetSize(horizontalSize);
  const isValidVerticalSize = isValidGapNumber(verticalSize);
  const isValidHorizontalSize = isValidGapNumber(horizontalSize);
  const childNodes = toArray(children, {
    keepEmpty: true
  });
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
  const mergedAlign = align === void 0 && !mergedVertical ? "center" : align;
  const mergedSeparator = separator ?? split;
  const prefixCls = getPrefixCls("space", customizePrefixCls);
  const [hashId, cssVarCls] = style_default30(prefixCls);
  const mergedProps = {
    ...props,
    size,
    orientation: mergedOrientation,
    align: mergedAlign
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(prefixCls, contextClassName, hashId, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
    [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
  }, className, rootClassName, cssVarCls, mergedClassNames.root);
  const itemClassName = clsx(`${prefixCls}-item`, mergedClassNames.item);
  const renderedItems = childNodes.map((child, i) => {
    const key = child?.key || `${itemClassName}-${i}`;
    return React229.createElement(Item_default2, {
      prefix: prefixCls,
      classNames: mergedClassNames,
      styles: mergedStyles,
      className: itemClassName,
      key,
      index: i,
      separator: mergedSeparator,
      style: mergedStyles.item
    }, child);
  });
  if (true) {
    const warning2 = devUseWarning("Space");
    [["direction", "orientation"], ["split", "separator"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const memoizedSpaceContext = React229.useMemo(() => {
    const calcLatestIndex = childNodes.reduce((latest, child, i) => isNonNullable_default(child) ? i : latest, 0);
    return {
      latestIndex: calcLatestIndex
    };
  }, [childNodes]);
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = "wrap";
  }
  if (!isPresetHorizontalSize && isValidHorizontalSize) {
    gapStyle.columnGap = horizontalSize;
  }
  if (!isPresetVerticalSize && isValidVerticalSize) {
    gapStyle.rowGap = verticalSize;
  }
  return React229.createElement("div", {
    ref,
    className: rootClassNames,
    style: {
      ...gapStyle,
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    ...restProps
  }, React229.createElement(SpaceContextProvider, {
    value: memoizedSpaceContext
  }, renderedItems));
});
var Space = InternalSpace;
Space.Compact = Compact_default;
Space.Addon = Addon_default;
if (true) {
  Space.displayName = "Space";
}
var space_default = Space;

// node_modules/antd/es/dropdown/dropdown-button.js
var DropdownButton = (props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React230.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    trigger,
    align,
    open: open3,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = React230.createElement(EllipsisOutlined_default, null),
    title,
    buttonsRender = (buttons) => buttons,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyOnHidden,
    destroyPopupOnHide,
    dropdownRender,
    popupRender,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const buttonPrefixCls = `${prefixCls}-button`;
  const mergedPopupRender = popupRender || dropdownRender;
  const dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    classNames: {
      root: overlayClassName
    },
    styles: {
      root: overlayStyle
    },
    destroyOnHidden,
    popupRender: mergedPopupRender
  };
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const classes = clsx(buttonPrefixCls, compactItemClassnames, className);
  if ("destroyPopupOnHide" in props) {
    dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
  }
  if ("open" in props) {
    dropdownProps.open = open3;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  if (true) {
    const warning2 = devUseWarning("Dropdown.Button");
    warning2.deprecated(false, "Dropdown.Button", "Space.Compact + Dropdown + Button");
  }
  const leftButton = React230.createElement(button_default, {
    type,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title
  }, children);
  const rightButton = React230.createElement(button_default, {
    type,
    danger,
    icon
  });
  const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return React230.createElement(space_default.Compact, {
    className: classes,
    size: compactSize,
    block: true,
    ...restProps
  }, leftButtonToRender, React230.createElement(dropdown_default, {
    ...dropdownProps
  }, rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
var dropdown_button_default = DropdownButton;

// node_modules/antd/es/dropdown/index.js
var Dropdown3 = dropdown_default;
Dropdown3.Button = dropdown_button_default;
var dropdown_default2 = Dropdown3;

// node_modules/antd/es/flex/index.js
var import_react69 = __toESM(require_react());

// node_modules/antd/es/flex/utils.js
var flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
var justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
var alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
var genClsWrap = (prefixCls, props) => {
  const wrap = props.wrap === true ? "wrap" : props.wrap;
  return {
    [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap)
  };
};
var genClsAlign = (prefixCls, props) => {
  const alignCls = {};
  alignItemsValues.forEach((cssKey) => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
  return alignCls;
};
var genClsJustify = (prefixCls, props) => {
  const justifyCls = {};
  justifyContentValues.forEach((cssKey) => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
  });
  return justifyCls;
};
var createFlexClassNames = (prefixCls, props) => {
  return clsx({
    ...genClsWrap(prefixCls, props),
    ...genClsAlign(prefixCls, props),
    ...genClsJustify(prefixCls, props)
  });
};
var utils_default = createFlexClassNames;

// node_modules/antd/es/flex/style/index.js
var genFlexStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      display: "flex",
      margin: 0,
      padding: 0,
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
};
var genFlexGapStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      "&-gap-small": {
        gap: token.flexGapSM
      },
      "&-gap-middle": {
        gap: token.flexGap
      },
      "&-gap-large": {
        gap: token.flexGapLG
      }
    }
  };
};
var genFlexWrapStyle = (token) => {
  const {
    componentCls
  } = token;
  const wrapStyle = {};
  flexWrapValues.forEach((value) => {
    wrapStyle[`${componentCls}-wrap-${value}`] = {
      flexWrap: value
    };
  });
  return wrapStyle;
};
var genAlignItemsStyle = (token) => {
  const {
    componentCls
  } = token;
  const alignStyle = {};
  alignItemsValues.forEach((value) => {
    alignStyle[`${componentCls}-align-${value}`] = {
      alignItems: value
    };
  });
  return alignStyle;
};
var genJustifyContentStyle = (token) => {
  const {
    componentCls
  } = token;
  const justifyStyle = {};
  justifyContentValues.forEach((value) => {
    justifyStyle[`${componentCls}-justify-${value}`] = {
      justifyContent: value
    };
  });
  return justifyStyle;
};
var prepareComponentToken26 = () => ({});
var style_default31 = genStyleHooks("Flex", (token) => {
  const {
    paddingXS,
    padding,
    paddingLG
  } = token;
  const flexToken = merge(token, {
    flexGapSM: paddingXS,
    flexGap: padding,
    flexGapLG: paddingLG
  });
  return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
}, prepareComponentToken26, {
  // Flex component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/46403
  resetStyle: false
});

// node_modules/antd/es/flex/index.js
var Flex = import_react69.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    rootClassName,
    className,
    style,
    flex,
    gap,
    vertical,
    orientation,
    component: Component6 = "div",
    children,
    ...othersProps
  } = props;
  const {
    flex: ctxFlex,
    direction: ctxDirection,
    getPrefixCls
  } = import_react69.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("flex", customizePrefixCls);
  const [hashId, cssVarCls] = style_default31(prefixCls);
  const [, mergedVertical] = useOrientation(orientation, vertical ?? ctxFlex?.vertical);
  const mergedCls = clsx(className, rootClassName, ctxFlex?.className, prefixCls, hashId, cssVarCls, utils_default(prefixCls, props), {
    [`${prefixCls}-rtl`]: ctxDirection === "rtl",
    [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
    [`${prefixCls}-vertical`]: mergedVertical
  });
  const mergedStyle = {
    ...ctxFlex?.style,
    ...style
  };
  if (isNonNullable_default(flex)) {
    mergedStyle.flex = flex;
  }
  if (isNonNullable_default(gap) && !isPresetSize(gap)) {
    mergedStyle.gap = gap;
  }
  return import_react69.default.createElement(Component6, {
    ref,
    className: mergedCls,
    style: mergedStyle,
    ...omit(othersProps, ["justify", "wrap", "align"])
  }, children);
});
if (true) {
  Flex.displayName = "Flex";
}
var flex_default = Flex;

// node_modules/antd/es/float-button/BackTop.js
var import_react73 = __toESM(require_react());

// node_modules/antd/es/float-button/context.js
var import_react70 = __toESM(require_react());
var GroupContext2 = import_react70.default.createContext(null);

// node_modules/antd/es/float-button/FloatButton.js
var import_react72 = __toESM(require_react());

// node_modules/antd/es/_util/convertToTooltipProps.js
var import_react71 = __toESM(require_react());
var convertToTooltipProps = (tooltip) => {
  if (!isNonNullable_default(tooltip)) {
    return null;
  }
  if (typeof tooltip === "object" && !(0, import_react71.isValidElement)(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
};
var convertToTooltipProps_default = convertToTooltipProps;

// node_modules/antd/es/float-button/style/button.js
var genFloatButtonStyle = (token) => {
  const {
    componentCls,
    floatButtonSize,
    iconCls,
    antCls,
    floatButtonIconSize
  } = token;
  const getCssVar = genCssVar(antCls, "float-btn");
  const badgeCls = `${componentCls}-badge`;
  const R = Math.SQRT2;
  const offsetR = (R - 1) / R;
  const offsetSquare = token.calc(token.borderRadius).mul(offsetR).equal();
  const offsetCircle = token.calc(token.controlHeight).div(2).mul(offsetR).equal();
  return {
    [componentCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        [getCssVar("size")]: unit(floatButtonSize)
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        flexDirection: "column",
        margin: 0,
        padding: `${unit(token.paddingXXS)} 0`,
        width: `var(${getCssVar("size")})`,
        minHeight: `var(${getCssVar("size")})`,
        height: "auto",
        wordBreak: "break-word",
        whiteSpace: "normal",
        gap: token.calc(token.paddingXXS).div(2).equal(),
        "&-rtl": {
          direction: "rtl"
        },
        // ======================== Individual ========================
        // Not in group
        [`&${componentCls}-individual`]: {
          position: "fixed",
          zIndex: token.zIndexPopupBase,
          insetInlineEnd: token.floatButtonInsetInlineEnd,
          bottom: token.floatButtonInsetBlockEnd,
          boxShadow: token.boxShadowSecondary
        },
        // =========================== Pure ===========================
        [`&${componentCls}-pure`]: {
          position: "relative",
          inset: "auto"
        },
        // ========================== Empty ===========================
        "&:empty": {
          display: "none"
        },
        // =========================== Icon ===========================
        [`${componentCls}-icon`]: {
          lineHeight: 1
        },
        // Icon Only will has large icon Size
        [`&${componentCls}-icon-only`]: {
          [iconCls]: {
            fontSize: floatButtonIconSize
          }
        },
        // =========================== Desc ===========================
        [`${componentCls}-content`]: {
          fontSize: token.fontSizeSM
        },
        // ========================== Badge ===========================
        [badgeCls]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          [`&:not(${badgeCls}-dot)`]: {
            transform: "translate(50%, -50%)"
          }
        },
        // RTL
        [`&-rtl ${badgeCls}:not(${badgeCls}-dot)`]: {
          transform: "translate(-50%, -50%)"
        },
        // Shape: square
        "&-square": {
          [`${badgeCls}-dot`]: {
            marginTop: offsetSquare,
            marginInlineEnd: offsetSquare
          }
        },
        // Shape: circle
        "&-circle": {
          [badgeCls]: {
            marginTop: offsetCircle,
            marginInlineEnd: offsetCircle
          }
        }
      }
    ]
  };
};
var button_default2 = genFloatButtonStyle;

// node_modules/antd/es/float-button/style/group.js
var genGroupStyle3 = (token) => {
  const {
    componentCls,
    antCls,
    floatButtonSize,
    padding
  } = token;
  const groupCls = `${componentCls}-group`;
  const listCls = `${groupCls}-list`;
  const getCssVar = genCssVar(antCls, "float-btn");
  return {
    [groupCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        [getCssVar("list-transform-start")]: `translate(0,${unit(floatButtonSize)})`,
        [getCssVar("list-trigger-offset")]: `calc(${unit(floatButtonSize)} + ${unit(padding)})`
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        ...resetComponent(token),
        position: "fixed",
        zIndex: token.zIndexPopupBase,
        insetInlineEnd: token.floatButtonInsetInlineEnd,
        bottom: token.floatButtonInsetBlockEnd,
        gap: padding,
        "&-rtl": {
          direction: "rtl"
        },
        // =========================== Pure ===========================
        [`&${componentCls}-pure`]: {
          position: "relative",
          inset: "auto"
        },
        // ========================== Button ==========================
        [componentCls]: {
          position: "relative",
          inset: "auto"
        }
      },
      // ==============================================================
      // ==                           List                           ==
      // ==============================================================
      {
        // ======================== Individual ========================
        // Not in group
        [`&:not(${groupCls}-individual) ${listCls}`]: {
          boxShadow: token.boxShadowSecondary
        },
        [`&${groupCls}-individual ${listCls}`]: {
          gap: padding
        },
        // =========================== Menu ===========================
        [`&-menu-mode ${listCls}`]: {
          position: "absolute"
        },
        // ========================== Motion ==========================
        [listCls]: {
          borderRadius: token.borderRadiusLG,
          "&-motion": {
            transition: `all ${token.motionDurationSlow}`,
            "&-enter, &-appear": {
              opacity: 0,
              transform: getCssVar("list-transform-start", true),
              "&-active": {
                opacity: 1,
                transform: `translate(0, 0)`
              }
            },
            "&-leave": {
              "&-active": {
                opacity: 0,
                transform: getCssVar("list-transform-start", true)
              }
            }
          }
        },
        // ======================== Placements ========================
        "&-top": {
          [listCls]: {
            bottom: getCssVar("list-trigger-offset", true)
          }
        },
        "&-bottom": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(0, calc(${unit(floatButtonSize)} * -1))`,
            top: getCssVar("list-trigger-offset", true)
          }
        },
        "&-left": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(${unit(floatButtonSize)}, 0)`,
            right: getCssVar("list-trigger-offset", true)
          }
        },
        "&-right": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(calc(${unit(floatButtonSize)} * -1), 0)`,
            left: getCssVar("list-trigger-offset", true)
          }
        }
      }
    ]
  };
};
var group_default3 = genGroupStyle3;

// node_modules/antd/es/float-button/style/index.js
var prepareComponentToken27 = () => ({});
var style_default32 = genStyleHooks("FloatButton", (token) => {
  const {
    controlHeightLG,
    marginXXL,
    marginLG,
    fontSizeIcon,
    calc
  } = token;
  const floatButtonToken = merge(token, {
    floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
    floatButtonSize: controlHeightLG,
    floatButtonInsetBlockEnd: marginXXL,
    floatButtonInsetInlineEnd: marginLG
  });
  return [button_default2(floatButtonToken), group_default3(floatButtonToken), initFadeMotion(token)];
}, prepareComponentToken27, {
  // Should be higher than Button (-999)
  order: -998
});

// node_modules/antd/es/float-button/FloatButton.js
var floatButtonPrefixCls = "float-btn";
var InternalFloatButton = import_react72.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    type = "default",
    shape = "circle",
    icon,
    description,
    content,
    tooltip,
    badge = {},
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = import_react72.default.useContext(ConfigContext);
  const groupContext = import_react72.default.useContext(GroupContext2);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const {
    shape: contextShape,
    individual: contextIndividual,
    classNames: contextClassNames,
    styles: contextStyles
  } = groupContext || {};
  const mergedShape = contextShape || shape;
  const mergedIndividual = contextIndividual ?? true;
  const mergedContent = content ?? description;
  const mergedProps = {
    ...props,
    type,
    shape: mergedShape
  };
  const [hashId, cssVarCls] = style_default32(prefixCls, rootCls);
  const floatButtonClassNames = import_react72.default.useMemo(() => ({
    icon: `${prefixCls}-icon`,
    content: `${prefixCls}-content`
  }), [prefixCls]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([floatButtonClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedIcon = !mergedContent && !icon ? import_react72.default.createElement(FileTextOutlined_default, null) : icon;
  const [zIndex] = useZIndex("FloatButton", style?.zIndex);
  const mergedStyle = {
    ...style,
    zIndex
  };
  const badgeProps = omit(badge, ["title", "children", "status", "text"]);
  const badgeNode = "badge" in props && import_react72.default.createElement(badge_default, {
    ...badgeProps,
    className: clsx(badgeProps.className, `${prefixCls}-badge`, {
      [`${prefixCls}-badge-dot`]: badgeProps.dot
    })
  });
  const tooltipProps = convertToTooltipProps_default(tooltip);
  if (true) {
    const warning2 = devUseWarning("FloatButton");
    true ? warning2(!(mergedShape === "circle" && mergedContent), "usage", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended.") : void 0;
    warning2.deprecated(!description, "description", "content");
  }
  let node = import_react72.default.createElement(Button_default, {
    ...restProps,
    ref,
    // Styles
    className: clsx(hashId, cssVarCls, rootCls, prefixCls, className, rootClassName, `${prefixCls}-${type}`, `${prefixCls}-${mergedShape}`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-individual`]: mergedIndividual,
      [`${prefixCls}-icon-only`]: !mergedContent
    }),
    classNames: mergedClassNames,
    styles: mergedStyles,
    style: mergedStyle,
    shape: mergedShape,
    // Others
    type,
    size: "large",
    icon: mergedIcon,
    _skipSemantic: true
  }, mergedContent, badgeNode);
  if (tooltipProps) {
    node = import_react72.default.createElement(tooltip_default, {
      ...tooltipProps
    }, node);
  }
  return node;
});
var FloatButton = InternalFloatButton;
if (true) {
  FloatButton.displayName = "FloatButton";
}
var FloatButton_default = FloatButton;

// node_modules/antd/es/float-button/BackTop.js
var defaultIcon = import_react73.default.createElement(VerticalAlignTopOutlined_default, null);
var BackTop2 = import_react73.default.forwardRef((props, ref) => {
  const {
    backTopIcon: contextIcon
  } = useComponentConfig("floatButton");
  const {
    prefixCls: customizePrefixCls,
    className,
    type = "default",
    shape = "circle",
    visibilityHeight = 400,
    icon,
    target,
    onClick,
    duration = 450,
    ...restProps
  } = props;
  const mergedIcon = icon ?? contextIcon ?? defaultIcon;
  const [visible, setVisible] = (0, import_react73.useState)(visibilityHeight === 0);
  const internalRef = import_react73.default.useRef(null);
  import_react73.default.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const getDefaultTarget2 = () => internalRef.current?.ownerDocument || window;
  const handleScroll = throttleByAnimationFrame_default((e3) => {
    const scrollTop = getScroll_default(e3.target);
    setVisible(scrollTop >= visibilityHeight);
  });
  (0, import_react73.useEffect)(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({
      target: container
    });
    container?.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container?.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = (e3) => {
    scrollTo(0, {
      getContainer: target || getDefaultTarget2,
      duration
    });
    onClick?.(e3);
  };
  const {
    getPrefixCls
  } = (0, import_react73.useContext)(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const groupShape = (0, import_react73.useContext)(GroupContext2)?.shape;
  const mergedShape = groupShape || shape;
  const contentProps = {
    prefixCls,
    icon: mergedIcon,
    type,
    shape: mergedShape,
    ...restProps
  };
  return import_react73.default.createElement(es_default4, {
    visible,
    motionName: `${rootPrefixCls}-fade`
  }, ({
    className: motionClassName
  }, setRef) => import_react73.default.createElement(FloatButton_default, {
    ref: composeRef(internalRef, setRef),
    ...contentProps,
    onClick: scrollToTop,
    className: clsx(className, motionClassName)
  }));
});
if (true) {
  BackTop2.displayName = "FloatButton.BackTop";
}
var BackTop_default = BackTop2;

// node_modules/antd/es/float-button/FloatButtonGroup.js
var import_react74 = __toESM(require_react());
var FloatButtonGroup = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style,
    classNames,
    styles,
    rootClassName,
    shape = "circle",
    type = "default",
    placement,
    icon = import_react74.default.createElement(FileTextOutlined_default, null),
    closeIcon,
    trigger,
    children,
    onOpenChange,
    open: customOpen,
    onClick: onTriggerButtonClick,
    ...floatButtonProps
  } = props;
  const {
    direction,
    getPrefixCls,
    closeIcon: contextCloseIcon,
    classNames: contextClassNames,
    styles: contextStyles,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("floatButtonGroup");
  const mergedCloseIcon = closeIcon ?? contextCloseIcon ?? import_react74.default.createElement(CloseOutlined_default, null);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default32(prefixCls, rootCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const isMenuMode = trigger && ["click", "hover"].includes(trigger);
  const [zIndex] = useZIndex("FloatButton", style?.zIndex);
  const floatButtonGroupRef = import_react74.default.useRef(null);
  const mergedPlacement = ["top", "left", "right", "bottom"].includes(placement) ? placement : "top";
  const [open3, setOpen] = useControlledState(false, customOpen);
  const hoverTrigger = trigger === "hover";
  const clickTrigger = trigger === "click";
  const triggerOpen = useEvent_default((nextOpen) => {
    if (open3 !== nextOpen) {
      setOpen(nextOpen);
      onOpenChange?.(nextOpen);
    }
  });
  const onMouseEnter = () => {
    if (hoverTrigger) {
      triggerOpen(true);
    }
  };
  const onMouseLeave = () => {
    if (hoverTrigger) {
      triggerOpen(false);
    }
  };
  const onInternalTriggerButtonClick = (e3) => {
    if (clickTrigger) {
      triggerOpen(!open3);
    }
    onTriggerButtonClick?.(e3);
  };
  import_react74.default.useEffect(() => {
    if (clickTrigger) {
      const onDocClick = (e3) => {
        if (floatButtonGroupRef.current?.contains(e3.target)) {
          return;
        }
        triggerOpen(false);
      };
      document.addEventListener("click", onDocClick, {
        capture: true
      });
      return () => document.removeEventListener("click", onDocClick, {
        capture: true
      });
    }
  }, [clickTrigger]);
  if (true) {
    const warning2 = devUseWarning("FloatButton.Group");
    true ? warning2(!("open" in props) || !!trigger, "usage", "`open` need to be used together with `trigger`") : void 0;
  }
  const individual = shape === "circle";
  const mergedProps = {
    ...props,
    shape,
    type,
    placement: mergedPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const listContext = import_react74.default.useMemo(() => ({
    shape,
    individual,
    classNames: {
      root: mergedClassNames.item,
      icon: mergedClassNames.itemIcon,
      content: mergedClassNames.itemContent
    },
    styles: {
      root: mergedStyles.item,
      icon: mergedStyles.itemIcon,
      content: mergedStyles.itemContent
    }
  }), [shape, individual, mergedClassNames, mergedStyles]);
  const triggerContext = import_react74.default.useMemo(() => ({
    ...listContext,
    individual: true,
    classNames: {
      root: mergedClassNames.trigger,
      icon: mergedClassNames.triggerIcon,
      content: mergedClassNames.triggerContent
    },
    styles: {
      root: mergedStyles.trigger,
      icon: mergedStyles.triggerIcon,
      content: mergedStyles.triggerContent
    }
  }), [listContext, mergedClassNames, mergedStyles]);
  let listNode;
  const listCls = `${groupPrefixCls}-list`;
  const renderList = (motionClassName) => {
    const vertical = mergedPlacement === "top" || mergedPlacement === "bottom";
    const sharedProps = {
      className: clsx(listCls, mergedClassNames.list, motionClassName),
      style: mergedStyles.list
    };
    if (individual) {
      listNode = import_react74.default.createElement(flex_default, {
        vertical,
        ...sharedProps
      }, children);
    } else {
      listNode = import_react74.default.createElement(space_default.Compact, {
        vertical,
        ...sharedProps
      }, children);
    }
    return listNode;
  };
  return import_react74.default.createElement(GroupContext2.Provider, {
    value: listContext
  }, import_react74.default.createElement("div", {
    className: clsx(groupPrefixCls, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, className, rootClassName, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-individual`]: individual,
      [`${groupPrefixCls}-${mergedPlacement}`]: isMenuMode,
      [`${groupPrefixCls}-menu-mode`]: isMenuMode
    }),
    style: {
      ...contextStyle,
      zIndex,
      ...mergedStyles.root,
      ...style
    },
    // ref
    ref: floatButtonGroupRef,
    // Hover trigger
    onMouseEnter,
    onMouseLeave
  }, isMenuMode ? import_react74.default.createElement(es_default4, {
    visible: open3,
    motionName: `${listCls}-motion`
  }, ({
    className: motionClassName
  }) => renderList(motionClassName)) : renderList(), isMenuMode && import_react74.default.createElement(GroupContext2.Provider, {
    value: triggerContext
  }, import_react74.default.createElement(FloatButton_default, {
    type,
    icon: open3 ? mergedCloseIcon : icon,
    "aria-label": props["aria-label"],
    className: `${groupPrefixCls}-trigger`,
    onClick: onInternalTriggerButtonClick,
    ...floatButtonProps
  }))));
};
var FloatButtonGroup_default = FloatButtonGroup;

// node_modules/antd/es/float-button/PurePanel.js
var React236 = __toESM(require_react());
var PureFloatButton = ({
  backTop,
  ...props
}) => backTop ? React236.createElement(BackTop_default, {
  ...props,
  visibilityHeight: 0
}) : React236.createElement(FloatButton_default, {
  ...props
});
var PurePanel8 = ({
  className,
  items,
  classNames: cls,
  styles,
  prefixCls: customizePrefixCls,
  ...restProps
}) => {
  const {
    getPrefixCls
  } = React236.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const pureCls = `${prefixCls}-pure`;
  if (items) {
    return React236.createElement(FloatButtonGroup_default, {
      className: clsx(className, pureCls),
      classNames: cls,
      styles,
      ...restProps
    }, items.map((item, index2) => React236.createElement(PureFloatButton, {
      key: index2,
      ...item
    })));
  }
  return React236.createElement(PureFloatButton, {
    className: clsx(className, pureCls),
    classNames: cls,
    styles,
    ...restProps
  });
};
var PurePanel_default5 = PurePanel8;

// node_modules/antd/es/float-button/index.js
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default5;
var float_button_default = FloatButton_default;

// node_modules/antd/es/form/ErrorList.js
var React238 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useDebounce.js
var React237 = __toESM(require_react());
function useDebounce(value) {
  const [cacheValue, setCacheValue] = React237.useState(value);
  React237.useEffect(() => {
    const timeout = setTimeout(() => {
      setCacheValue(value);
    }, value.length ? 0 : 10);
    return () => {
      clearTimeout(timeout);
    };
  }, [value]);
  return cacheValue;
}

// node_modules/antd/es/form/style/explain.js
var genFormValidateMotionStyle = (token) => {
  const {
    componentCls
  } = token;
  const helpCls = `${componentCls}-show-help`;
  const helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      // Explain holder
      transition: `opacity ${token.motionDurationFast} ${token.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token.motionDurationFast} ${token.motionEaseInOut},
                     opacity ${token.motionDurationFast} ${token.motionEaseInOut},
                     transform ${token.motionDurationFast} ${token.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: `translateY(-5px)`,
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: `translateY(-5px)`
        }
      }
    }
  };
};
var explain_default = genFormValidateMotionStyle;

// node_modules/antd/es/form/style/index.js
var resetForm = (token) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token.marginLG,
    padding: 0,
    color: token.colorTextDescription,
    fontSize: token.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
    outline: 0,
    boxShadow: `0 0 0 ${unit(token.controlOutlineWidth)} ${token.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: token.colorText,
    fontSize: token.fontSize,
    lineHeight: token.lineHeight
  }
});
var genFormSize = (token, height) => {
  const {
    formItemCls
  } = token;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
};
var genFormStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [token.componentCls]: {
      ...resetComponent(token),
      ...resetForm(token),
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": {
        ...genFormSize(token, token.controlHeightSM)
      },
      "&-large": {
        ...genFormSize(token, token.controlHeightLG)
      }
    }
  };
};
var genFormItemStyle = (token) => {
  const {
    formItemCls,
    iconCls,
    rootPrefixCls,
    antCls,
    labelRequiredMarkColor,
    labelColor,
    labelFontSize,
    labelHeight,
    labelColonMarginInlineStart,
    labelColonMarginInlineEnd,
    itemMarginBottom
  } = token;
  return {
    [formItemCls]: {
      ...resetComponent(token),
      marginBottom: itemMarginBottom,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden${antCls}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${formItemCls}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: token.lineHeight,
          whiteSpace: "unset",
          "> label": {
            verticalAlign: "middle",
            textWrap: "balance"
          }
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: labelHeight,
          color: labelColor,
          fontSize: labelFontSize,
          [`> ${iconCls}`]: {
            fontSize: token.fontSize,
            verticalAlign: "top"
          },
          [`&${formItemCls}-required`]: {
            "&::before": {
              display: "inline-block",
              marginInlineEnd: token.marginXXS,
              color: labelRequiredMarkColor,
              fontSize: token.fontSize,
              fontFamily: "SimSun, sans-serif",
              lineHeight: 1,
              content: '"*"'
            },
            [`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: {
              "&::before": {
                display: "none"
              }
            }
          },
          // Optional mark
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token.marginXXS,
            color: token.colorTextDescription,
            [`&${formItemCls}-required-mark-hidden`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-tooltip`]: {
            color: token.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: labelColonMarginInlineStart,
            marginInlineEnd: labelColonMarginInlineEnd
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${formItemCls}-control`]: {
        ["--ant-display"]: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%",
            // Fix https://github.com/ant-design/ant-design/issues/54042
            // Remove impact of whitespaces
            [`&:has(> ${antCls}-switch:only-child, > ${antCls}-rate:only-child)`]: {
              display: "flex",
              alignItems: "center"
            }
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [formItemCls]: {
        "&-additional": {
          display: "flex",
          flexDirection: "column"
        },
        "&-explain, &-extra": {
          clear: "both",
          color: token.colorTextDescription,
          fontSize: token.fontSize,
          lineHeight: token.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token.controlHeightSM,
          transition: `color ${token.motionDurationMid} ${token.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: token.colorError
          },
          "&-warning": {
            color: token.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token.motionDurationMid,
        animationTimingFunction: token.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token.colorSuccess
        },
        "&-error": {
          color: token.colorError
        },
        "&-warning": {
          color: token.colorWarning
        },
        "&-validating": {
          color: token.colorPrimary
        }
      }
    }
  };
};
var makeVerticalLayoutLabel = (token) => ({
  padding: token.verticalLabelPadding,
  margin: token.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
});
var genHorizontalStyle = (token) => {
  const {
    antCls,
    formItemCls
  } = token;
  return {
    [`${formItemCls}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
        [`& + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      },
      [`${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
    }
  };
};
var genInlineStyle = (token) => {
  const {
    componentCls,
    formItemCls,
    inlineItemMarginBottom
  } = token;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [`${formItemCls}-inline`]: {
        flex: "none",
        marginInlineEnd: token.margin,
        marginBottom: inlineItemMarginBottom,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
};
var makeVerticalLayout = (token) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${componentCls}:not(${componentCls}-inline)`]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label, ${formItemCls}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
};
var genVerticalStyle = (token) => {
  const {
    componentCls,
    formItemCls,
    antCls
  } = token;
  return {
    [`${formItemCls}-vertical`]: {
      [`${formItemCls}-row`]: {
        flexDirection: "column"
      },
      [`${formItemCls}-label > label`]: {
        height: "auto"
      },
      [`${formItemCls}-control`]: {
        width: "100%"
      },
      [`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
    },
    [`@media (max-width: ${unit(token.screenXSMax)})`]: [makeVerticalLayout(token), {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
        }
      }
    }],
    [`@media (max-width: ${unit(token.screenSMMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
        }
      }
    },
    [`@media (max-width: ${unit(token.screenMDMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
        }
      }
    },
    [`@media (max-width: ${unit(token.screenLGMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token)
        }
      }
    }
  };
};
var prepareComponentToken28 = (token) => ({
  labelRequiredMarkColor: token.colorError,
  labelColor: token.colorTextHeading,
  labelFontSize: token.fontSize,
  labelHeight: token.controlHeight,
  labelColonMarginInlineStart: token.marginXXS / 2,
  labelColonMarginInlineEnd: token.marginXS,
  itemMarginBottom: token.marginLG,
  verticalLabelPadding: `0 0 ${token.paddingXS}px`,
  verticalLabelMargin: 0,
  inlineItemMarginBottom: 0
});
var prepareToken4 = (token, rootPrefixCls) => {
  const formToken = merge(token, {
    formItemCls: `${token.componentCls}-item`,
    rootPrefixCls
  });
  return formToken;
};
var style_default33 = genStyleHooks("Form", (token, {
  rootPrefixCls
}) => {
  const formToken = prepareToken4(token, rootPrefixCls);
  return [genFormStyle(formToken), genFormItemStyle(formToken), explain_default(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), collapse_default(formToken), zoomIn];
}, prepareComponentToken28, {
  // Let From style before the Grid
  // ref https://github.com/ant-design/ant-design/issues/44386
  order: -1e3
});

// node_modules/antd/es/form/ErrorList.js
var EMPTY_LIST3 = [];
function toErrorEntity(error, prefix, errorStatus, index2 = 0) {
  return {
    key: typeof error === "string" ? error : `${prefix}-${index2}`,
    error,
    errorStatus
  };
}
var ErrorList = ({
  help,
  helpStatus,
  errors = EMPTY_LIST3,
  warnings = EMPTY_LIST3,
  className: rootClassName,
  fieldId,
  onVisibleChanged
}) => {
  const {
    prefixCls
  } = React238.useContext(FormItemPrefixContext);
  const baseClassName = `${prefixCls}-item-explain`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default33(prefixCls, rootCls);
  const collapseMotion = React238.useMemo(() => motion_default(prefixCls), [prefixCls]);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const fullKeyList = React238.useMemo(() => {
    if (isNonNullable_default(help)) {
      return [toErrorEntity(help, "help", helpStatus)];
    }
    return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning2, index2) => toErrorEntity(warning2, "warning", "warning", index2))));
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  const filledKeyFullKeyList = React238.useMemo(() => {
    const keysCount = {};
    fullKeyList.forEach(({
      key
    }) => {
      keysCount[key] = (keysCount[key] || 0) + 1;
    });
    return fullKeyList.map((entity, index2) => ({
      ...entity,
      key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index2}` : entity.key
    }));
  }, [fullKeyList]);
  const helpProps = {};
  if (fieldId) {
    helpProps.id = `${fieldId}_help`;
  }
  return React238.createElement(es_default4, {
    motionDeadline: collapseMotion.motionDeadline,
    motionName: `${prefixCls}-show-help`,
    visible: !!filledKeyFullKeyList.length,
    onVisibleChanged
  }, (holderProps) => {
    const {
      className: holderClassName,
      style: holderStyle
    } = holderProps;
    return React238.createElement("div", {
      ...helpProps,
      className: clsx(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
      style: holderStyle
    }, React238.createElement(CSSMotionList_default, {
      keys: filledKeyFullKeyList,
      ...motion_default(prefixCls),
      motionName: `${prefixCls}-show-help-item`,
      component: false
    }, (itemProps) => {
      const {
        key,
        error,
        errorStatus,
        className: itemClassName,
        style: itemStyle
      } = itemProps;
      return React238.createElement("div", {
        key,
        className: clsx(itemClassName, {
          [`${baseClassName}-${errorStatus}`]: errorStatus
        }),
        style: itemStyle
      }, error);
    }));
  });
};
var ErrorList_default = ErrorList;

// node_modules/antd/es/form/Form.js
var React240 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useFormWarning.js
var React239 = __toESM(require_react());
var names = {};
function useFormWarning({
  name
}) {
  const warning2 = devUseWarning("Form");
  React239.useEffect(() => {
    if (name) {
      names[name] = (names[name] || 0) + 1;
      true ? warning2(names[name] <= 1, "usage", "There exist multiple Form with same `name`.") : void 0;
      return () => {
        names[name] -= 1;
      };
    }
  }, [name]);
}

// node_modules/antd/es/form/Form.js
var InternalForm = (props, ref) => {
  const contextDisabled = React240.useContext(DisabledContext_default);
  const {
    getPrefixCls,
    direction,
    requiredMark: contextRequiredMark,
    colon: contextColon,
    scrollToFirstError: contextScrollToFirstError,
    className: contextClassName,
    style: contextStyle,
    styles: contextStyles,
    classNames: contextClassNames
  } = useComponentConfig("form");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    size,
    disabled = contextDisabled,
    form,
    colon,
    labelAlign,
    labelWrap,
    labelCol,
    wrapperCol,
    layout = "horizontal",
    scrollToFirstError,
    requiredMark,
    onFinishFailed,
    name,
    style,
    feedbackIcons,
    variant,
    classNames,
    styles,
    ...restFormProps
  } = props;
  const mergedSize = useSize_default(size);
  const contextValidateMessages = React240.useContext(validateMessagesContext_default);
  if (true) {
    useFormWarning(props);
  }
  const mergedRequiredMark = React240.useMemo(() => {
    if (requiredMark !== void 0) {
      return requiredMark;
    }
    if (contextRequiredMark !== void 0) {
      return contextRequiredMark;
    }
    return true;
  }, [requiredMark, contextRequiredMark]);
  const mergedColon = colon ?? contextColon;
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default33(prefixCls, rootCls);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled,
    layout,
    colon: mergedColon,
    requiredMark: mergedRequiredMark
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const formClassName = clsx(prefixCls, `${prefixCls}-${layout}`, {
    [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
    // todo: remove in next major version
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${mergedSize}`]: mergedSize
  }, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName, mergedClassNames.root);
  const [wrapForm] = useForm(form);
  const {
    __INTERNAL__
  } = wrapForm;
  __INTERNAL__.name = name;
  const formContextValue = React240.useMemo(() => ({
    name,
    labelAlign,
    labelCol,
    labelWrap,
    wrapperCol,
    layout,
    colon: mergedColon,
    requiredMark: mergedRequiredMark,
    itemRef: __INTERNAL__.itemRef,
    form: wrapForm,
    feedbackIcons,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons, mergedClassNames, mergedStyles]);
  const nativeElementRef = React240.useRef(null);
  React240.useImperativeHandle(ref, () => ({
    ...wrapForm,
    nativeElement: nativeElementRef.current?.nativeElement
  }));
  const scrollToField = (options, fieldName) => {
    if (options) {
      let defaultScrollToFirstError = {
        block: "nearest"
      };
      if (typeof options === "object") {
        defaultScrollToFirstError = {
          ...defaultScrollToFirstError,
          ...options
        };
      }
      wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
    }
  };
  const onInternalFinishFailed = (errorInfo) => {
    onFinishFailed?.(errorInfo);
    if (errorInfo.errorFields.length) {
      const fieldName = errorInfo.errorFields[0].name;
      if (scrollToFirstError !== void 0) {
        scrollToField(scrollToFirstError, fieldName);
        return;
      }
      if (contextScrollToFirstError !== void 0) {
        scrollToField(contextScrollToFirstError, fieldName);
      }
    }
  };
  return React240.createElement(VariantContext.Provider, {
    value: variant
  }, React240.createElement(DisabledContextProvider, {
    disabled
  }, React240.createElement(SizeContext_default.Provider, {
    value: mergedSize
  }, React240.createElement(FormProvider, {
    // This is not list in API, we pass with spread
    validateMessages: contextValidateMessages
  }, React240.createElement(FormContext.Provider, {
    value: formContextValue
  }, React240.createElement(NoFormStyle, {
    status: true
  }, React240.createElement(es_default, {
    id: name,
    ...restFormProps,
    name,
    onFinishFailed: onInternalFinishFailed,
    form: wrapForm,
    ref: nativeElementRef,
    style: {
      ...mergedStyles?.root,
      ...contextStyle,
      ...style
    },
    className: formClassName
  })))))));
};
var Form = React240.forwardRef(InternalForm);
if (true) {
  Form.displayName = "Form";
}
var Form_default = Form;

// node_modules/antd/es/form/FormItem/index.js
var React248 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useChildren.js
function useChildren(children) {
  if (typeof children === "function") {
    return children;
  }
  const childList = toArray(children);
  return childList.length <= 1 ? childList[0] : childList;
}

// node_modules/antd/es/form/hooks/useFormItemStatus.js
var React241 = __toESM(require_react());
var useFormItemStatus = () => {
  const {
    status,
    errors = [],
    warnings = []
  } = React241.useContext(FormItemInputContext);
  if (true) {
    const warning2 = devUseWarning("Form.Item");
    true ? warning2(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus") : void 0;
  }
  return {
    status,
    errors,
    warnings
  };
};
useFormItemStatus.Context = FormItemInputContext;
var useFormItemStatus_default = useFormItemStatus;

// node_modules/antd/es/form/hooks/useFrameState.js
var React242 = __toESM(require_react());
function useFrameState(defaultValue) {
  const [value, setValue] = React242.useState(defaultValue);
  const frameRef = React242.useRef(null);
  const batchRef = React242.useRef([]);
  const destroyRef = React242.useRef(false);
  React242.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
      raf_default.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = raf_default(() => {
        frameRef.current = null;
        setValue((prevValue) => {
          let current = prevValue;
          batchRef.current.forEach((func) => {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  return [value, setFrameValue];
}

// node_modules/antd/es/form/hooks/useItemRef.js
var React243 = __toESM(require_react());
function useItemRef() {
  const {
    itemRef
  } = React243.useContext(FormContext);
  const cacheRef = React243.useRef({});
  function getRef(name, children) {
    const childrenRef = children && typeof children === "object" && getNodeRef(children);
    const nameStr = name.join("_");
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
    }
    return cacheRef.current.ref;
  }
  return getRef;
}

// node_modules/antd/es/form/FormItem/ItemHolder.js
var React247 = __toESM(require_react());

// node_modules/antd/es/form/FormItemInput.js
var React244 = __toESM(require_react());

// node_modules/antd/es/form/style/fallbackCmp.js
var genFallbackStyle = (token) => {
  const {
    formItemCls
  } = token;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${formItemCls}-control`]: {
        display: "flex"
      }
    }
  };
};
var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token, {
  rootPrefixCls
}) => {
  const formToken = prepareToken4(token, rootPrefixCls);
  return genFallbackStyle(formToken);
});

// node_modules/antd/es/form/FormItemInput.js
var GRID_MAX = 24;
var FormItemInput = (props) => {
  const {
    prefixCls,
    status,
    labelCol,
    wrapperCol,
    children,
    errors,
    warnings,
    _internalItemRender: formItemRender,
    extra,
    help,
    fieldId,
    marginBottom,
    onErrorVisibleChanged,
    label
  } = props;
  const baseClassName = `${prefixCls}-item`;
  const formContext = React244.useContext(FormContext);
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = formContext;
  const mergedWrapperCol = React244.useMemo(() => {
    let mergedWrapper = {
      ...wrapperCol || formContext.wrapperCol || {}
    };
    if (label === null && !labelCol && !wrapperCol && formContext.labelCol) {
      const list = [void 0, "xs", "sm", "md", "lg", "xl", "xxl"];
      list.forEach((size) => {
        const _size = size ? [size] : [];
        const formLabel = get(formContext.labelCol, _size);
        const formLabelObj = typeof formLabel === "object" ? formLabel : {};
        const wrapper = get(mergedWrapper, _size);
        const wrapperObj = typeof wrapper === "object" ? wrapper : {};
        if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) {
          mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
        }
      });
    }
    return mergedWrapper;
  }, [wrapperCol, formContext.wrapperCol, formContext.labelCol, label, labelCol]);
  const className = clsx(`${baseClassName}-control`, mergedWrapperCol.className);
  const subFormContext = React244.useMemo(() => {
    const {
      labelCol: _labelCol,
      wrapperCol: _wrapperCol,
      ...rest
    } = formContext;
    return rest;
  }, [formContext]);
  const extraRef = React244.useRef(null);
  const [extraHeight, setExtraHeight] = React244.useState(0);
  useLayoutEffect_default(() => {
    if (extra && extraRef.current) {
      setExtraHeight(extraRef.current.clientHeight);
    } else {
      setExtraHeight(0);
    }
  }, [extra]);
  const inputDom = React244.createElement("div", {
    className: `${baseClassName}-control-input`
  }, React244.createElement("div", {
    className: clsx(`${baseClassName}-control-input-content`, contextClassNames?.content),
    style: contextStyles?.content
  }, children));
  const formItemContext = React244.useMemo(() => ({
    prefixCls,
    status
  }), [prefixCls, status]);
  const errorListDom = marginBottom !== null || errors.length || warnings.length ? React244.createElement(FormItemPrefixContext.Provider, {
    value: formItemContext
  }, React244.createElement(ErrorList_default, {
    fieldId,
    errors,
    warnings,
    help,
    helpStatus: status,
    className: `${baseClassName}-explain-connected`,
    onVisibleChanged: onErrorVisibleChanged
  })) : null;
  const extraProps = {};
  if (fieldId) {
    extraProps.id = `${fieldId}_extra`;
  }
  const extraDom = extra ? React244.createElement("div", {
    ...extraProps,
    className: `${baseClassName}-extra`,
    ref: extraRef
  }, extra) : null;
  const additionalDom = errorListDom || extraDom ? React244.createElement("div", {
    className: `${baseClassName}-additional`,
    style: marginBottom ? {
      minHeight: marginBottom + extraHeight
    } : {}
  }, errorListDom, extraDom) : null;
  const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) : React244.createElement(React244.Fragment, null, inputDom, additionalDom);
  return React244.createElement(FormContext.Provider, {
    value: subFormContext
  }, React244.createElement(col_default, {
    ...mergedWrapperCol,
    className
  }, dom), React244.createElement(fallbackCmp_default, {
    prefixCls
  }));
};
var FormItemInput_default = FormItemInput;

// node_modules/antd/es/form/FormItemLabel.js
var React245 = __toESM(require_react());
var FormItemLabel = ({
  prefixCls,
  label,
  htmlFor,
  labelCol,
  labelAlign,
  colon,
  required,
  requiredMark,
  tooltip,
  vertical
}) => {
  const [formLocale] = useLocale_default("Form");
  const {
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon,
    classNames: contextClassNames,
    styles: contextStyles
  } = React245.useContext(FormContext);
  if (!label) {
    return null;
  }
  const mergedLabelCol = labelCol || contextLabelCol || {};
  const mergedLabelAlign = labelAlign || contextLabelAlign;
  const labelClsBasic = `${prefixCls}-item-label`;
  const labelColClassName = clsx(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
    [`${labelClsBasic}-wrap`]: !!labelWrap
  });
  let labelChildren = label;
  const computedColon = colon === true || contextColon !== false && colon !== false;
  const haveColon = computedColon && !vertical;
  if (haveColon && typeof label === "string" && label.trim()) {
    labelChildren = label.replace(/[:|]\s*$/, "");
  }
  const tooltipProps = convertToTooltipProps_default(tooltip);
  if (tooltipProps) {
    const {
      icon = React245.createElement(QuestionCircleOutlined_default, null),
      ...restTooltipProps
    } = tooltipProps;
    const tooltipNode = React245.createElement(tooltip_default, {
      ...restTooltipProps
    }, React245.cloneElement(icon, {
      className: `${prefixCls}-item-tooltip`,
      title: "",
      onClick: (e3) => {
        e3.preventDefault();
      },
      tabIndex: null
    }));
    labelChildren = React245.createElement(React245.Fragment, null, labelChildren, tooltipNode);
  }
  const isOptionalMark = requiredMark === "optional";
  const isRenderMark = typeof requiredMark === "function";
  const hideRequiredMark = requiredMark === false;
  if (isRenderMark) {
    labelChildren = requiredMark(labelChildren, {
      required: !!required
    });
  } else if (isOptionalMark && !required) {
    labelChildren = React245.createElement(React245.Fragment, null, labelChildren, React245.createElement("span", {
      className: `${prefixCls}-item-optional`,
      title: ""
    }, formLocale?.optional || en_US_default4.Form?.optional));
  }
  let markType;
  if (hideRequiredMark) {
    markType = "hidden";
  } else if (isOptionalMark || isRenderMark) {
    markType = "optional";
  }
  const labelClassName = clsx(contextClassNames?.label, {
    [`${prefixCls}-item-required`]: required,
    [`${prefixCls}-item-required-mark-${markType}`]: markType,
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return React245.createElement(col_default, {
    ...mergedLabelCol,
    className: labelColClassName
  }, React245.createElement("label", {
    htmlFor,
    className: labelClassName,
    style: contextStyles?.label,
    title: typeof label === "string" ? label : ""
  }, labelChildren));
};
var FormItemLabel_default = FormItemLabel;

// node_modules/antd/es/form/FormItem/StatusProvider.js
var React246 = __toESM(require_react());
var iconMap = {
  success: CheckCircleFilled_default,
  warning: ExclamationCircleFilled_default,
  error: CloseCircleFilled_default,
  validating: LoadingOutlined_default
};
function StatusProvider({
  children,
  errors,
  warnings,
  hasFeedback,
  validateStatus,
  prefixCls,
  meta,
  noStyle,
  name
}) {
  const itemPrefixCls = `${prefixCls}-item`;
  const {
    feedbackIcons
  } = React246.useContext(FormContext);
  const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
  const {
    isFormItemInput: parentIsFormItemInput,
    status: parentStatus,
    hasFeedback: parentHasFeedback,
    feedbackIcon: parentFeedbackIcon,
    name: parentName
  } = React246.useContext(FormItemInputContext);
  const formItemStatusContext = React246.useMemo(() => {
    let feedbackIcon;
    if (hasFeedback) {
      const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
      const customIconNode = mergedValidateStatus && customIcons?.({
        status: mergedValidateStatus,
        errors,
        warnings
      })?.[mergedValidateStatus];
      const IconNode2 = mergedValidateStatus ? iconMap[mergedValidateStatus] : null;
      feedbackIcon = customIconNode !== false && IconNode2 ? React246.createElement("span", {
        className: clsx(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
      }, customIconNode || React246.createElement(IconNode2, null)) : null;
    }
    const context = {
      status: mergedValidateStatus || "",
      errors,
      warnings,
      hasFeedback: !!hasFeedback,
      feedbackIcon,
      isFormItemInput: true,
      name
    };
    if (noStyle) {
      context.status = (mergedValidateStatus ?? parentStatus) || "";
      context.isFormItemInput = parentIsFormItemInput;
      context.hasFeedback = !!(hasFeedback ?? parentHasFeedback);
      context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
      context.name = name ?? parentName;
    }
    return context;
  }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
  return React246.createElement(FormItemInputContext.Provider, {
    value: formItemStatusContext
  }, children);
}
var StatusProvider_default = StatusProvider;

// node_modules/antd/es/form/FormItem/ItemHolder.js
function ItemHolder(props) {
  const {
    prefixCls,
    className,
    rootClassName,
    style,
    help,
    errors,
    warnings,
    validateStatus,
    meta,
    hasFeedback,
    hidden,
    children,
    fieldId,
    required,
    isRequired,
    onSubItemMetaChange,
    layout: propsLayout,
    name,
    ...restProps
  } = props;
  const itemPrefixCls = `${prefixCls}-item`;
  const {
    requiredMark,
    layout: formLayout
  } = React247.useContext(FormContext);
  const layout = propsLayout || formLayout;
  const vertical = layout === "vertical";
  const itemRef = React247.useRef(null);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const hasHelp = isNonNullable_default(help);
  const hasError = !!(hasHelp || errors.length || warnings.length);
  const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
  const [marginBottom, setMarginBottom] = React247.useState(null);
  useLayoutEffect_default(() => {
    if (hasError && itemRef.current) {
      const itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(Number.parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError, isOnScreen]);
  const onErrorVisibleChanged = (nextVisible) => {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  };
  const getValidateState = (isDebounce = false) => {
    const _errors = isDebounce ? debounceErrors : meta.errors;
    const _warnings = isDebounce ? debounceWarnings : meta.warnings;
    return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
  };
  const mergedValidateStatus = getValidateState();
  const itemClassName = clsx(itemPrefixCls, className, rootClassName, {
    [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
    // Status
    [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
    [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
    [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
    [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
    [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
    [`${itemPrefixCls}-hidden`]: hidden,
    // Layout
    [`${itemPrefixCls}-${layout}`]: layout
  });
  return React247.createElement("div", {
    className: itemClassName,
    style,
    ref: itemRef
  }, React247.createElement(row_default, {
    className: `${itemPrefixCls}-row`,
    ...omit(restProps, [
      "_internalItemRender",
      "colon",
      "dependencies",
      "extra",
      "fieldKey",
      "getValueFromEvent",
      "getValueProps",
      "htmlFor",
      "id",
      // It is deprecated because `htmlFor` is its replacement.
      "initialValue",
      "isListField",
      "label",
      "labelAlign",
      "labelCol",
      "labelWrap",
      "messageVariables",
      "name",
      "normalize",
      "noStyle",
      "preserve",
      "requiredMark",
      "rules",
      "shouldUpdate",
      "trigger",
      "tooltip",
      "validateFirst",
      "validateTrigger",
      "valuePropName",
      "wrapperCol",
      "validateDebounce"
    ])
  }, React247.createElement(FormItemLabel_default, {
    htmlFor: fieldId,
    ...props,
    requiredMark,
    required: required ?? isRequired,
    prefixCls,
    vertical
  }), React247.createElement(FormItemInput_default, {
    ...props,
    ...meta,
    errors: debounceErrors,
    warnings: debounceWarnings,
    prefixCls,
    status: mergedValidateStatus,
    help,
    marginBottom,
    onErrorVisibleChanged
  }, React247.createElement(NoStyleItemContext.Provider, {
    value: onSubItemMetaChange
  }, React247.createElement(StatusProvider_default, {
    prefixCls,
    meta,
    errors: meta.errors,
    warnings: meta.warnings,
    hasFeedback,
    // Already calculated
    validateStatus: mergedValidateStatus,
    name
  }, children)))), !!marginBottom && React247.createElement("div", {
    className: `${itemPrefixCls}-margin-offset`,
    style: {
      marginBottom: -marginBottom
    }
  }));
}

// node_modules/antd/es/form/FormItem/index.js
var NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  return keysA.length === keysB.length && keysA.every((key) => {
    const propValueA = a[key];
    const propValueB = b[key];
    return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
  });
}
var MemoInput = React248.memo((props) => props.children, (prev, next) => isSimilarControl(prev.control, next.control) && prev.update === next.update && prev.childProps.length === next.childProps.length && prev.childProps.every((value, index2) => value === next.childProps[index2]));
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: [],
    validated: false
  };
}
function InternalFormItem(props) {
  const {
    name,
    noStyle,
    className,
    dependencies,
    prefixCls: customizePrefixCls,
    shouldUpdate,
    rules,
    children,
    required,
    label,
    messageVariables,
    trigger = "onChange",
    validateTrigger,
    hidden,
    help,
    layout
  } = props;
  const {
    getPrefixCls
  } = React248.useContext(ConfigContext);
  const {
    name: formName
  } = React248.useContext(FormContext);
  const mergedChildren = useChildren(children);
  const isRenderProps = typeof mergedChildren === "function";
  const notifyParentMetaChange = React248.useContext(NoStyleItemContext);
  const {
    validateTrigger: contextValidateTrigger
  } = React248.useContext(FieldContext_default);
  const mergedValidateTrigger = isNonNullable_default(validateTrigger) ? validateTrigger : contextValidateTrigger;
  const hasName = isNonNullable_default(name);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default33(prefixCls, rootCls);
  const warning2 = devUseWarning("Form.Item");
  if (true) {
    true ? warning2(name !== null, "usage", "`null` is passed as `name` property") : void 0;
  }
  const listContext = React248.useContext(ListContext_default);
  const fieldKeyPathRef = React248.useRef(null);
  const [subFieldErrors, setSubFieldErrors] = useFrameState({});
  const [meta, setMeta] = useSafeState(() => genEmptyMeta());
  const onMetaChange = (nextMeta) => {
    const keyInfo = listContext?.getKey(nextMeta.name);
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    if (noStyle && help !== false && notifyParentMetaChange) {
      let namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== void 0) {
          const [fieldKey, restPath] = keyInfo;
          namePath = [fieldKey].concat(_toConsumableArray(restPath));
          fieldKeyPathRef.current = namePath;
        }
      } else {
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  };
  const onSubItemMetaChange = (subMeta, uniqueKeys) => {
    setSubFieldErrors((prevSubFieldErrors) => {
      const clone = {
        ...prevSubFieldErrors
      };
      const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
      const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        delete clone[mergedNameKey];
      } else {
        clone[mergedNameKey] = subMeta;
      }
      return clone;
    });
  };
  const [mergedErrors, mergedWarnings] = React248.useMemo(() => {
    const errorList = _toConsumableArray(meta.errors);
    const warningList = _toConsumableArray(meta.warnings);
    Object.values(subFieldErrors).forEach((subFieldError) => {
      errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
      warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
    });
    return [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]);
  const getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return React248.createElement(StatusProvider_default, {
        prefixCls,
        hasFeedback: props.hasFeedback,
        validateStatus: props.validateStatus,
        meta,
        errors: mergedErrors,
        warnings: mergedWarnings,
        noStyle: true,
        name
      }, baseChildren);
    }
    return React248.createElement(ItemHolder, {
      key: "row",
      ...props,
      className: clsx(className, cssVarCls, rootCls, hashId),
      prefixCls,
      fieldId,
      isRequired,
      errors: mergedErrors,
      warnings: mergedWarnings,
      meta,
      onSubItemMetaChange,
      layout,
      name
    }, baseChildren);
  }
  if (!hasName && !isRenderProps && !dependencies) {
    return renderLayout(mergedChildren);
  }
  let variables = {};
  if (typeof label === "string") {
    variables.label = label;
  } else if (name) {
    variables.label = String(name);
  }
  if (messageVariables) {
    variables = {
      ...variables,
      ...messageVariables
    };
  }
  return React248.createElement(Field_default, {
    ...props,
    messageVariables: variables,
    trigger,
    validateTrigger: mergedValidateTrigger,
    onMetaChange
  }, (control, renderMeta, context) => {
    const mergedName = toArray3(name).length && renderMeta ? renderMeta.name : [];
    const fieldId = getFieldId(mergedName, formName);
    const isRequired = required !== void 0 ? required : !!rules?.some((rule) => {
      if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
        return true;
      }
      if (typeof rule === "function") {
        const ruleEntity = rule(context);
        return ruleEntity?.required && !ruleEntity?.warningOnly;
      }
      return false;
    });
    const mergedControl = {
      ...control
    };
    let childNode = null;
    true ? warning2(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps.") : void 0;
    if (Array.isArray(mergedChildren) && hasName) {
      true ? warning2(false, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item.") : void 0;
      childNode = mergedChildren;
    } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
      true ? warning2(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`.") : void 0;
      true ? warning2(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.") : void 0;
    } else if (dependencies && !isRenderProps && !hasName) {
      true ? warning2(false, "usage", "Must set `name` or use a render function when `dependencies` is set.") : void 0;
    } else if (React248.isValidElement(mergedChildren)) {
      true ? warning2(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.") : void 0;
      const childProps = {
        ...mergedChildren.props,
        ...mergedControl
      };
      if (!childProps.id) {
        childProps.id = fieldId;
      }
      if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
        const describedbyArr = [];
        if (help || mergedErrors.length > 0) {
          describedbyArr.push(`${fieldId}_help`);
        }
        if (props.extra) {
          describedbyArr.push(`${fieldId}_extra`);
        }
        childProps["aria-describedby"] = describedbyArr.join(" ");
      }
      if (mergedErrors.length > 0) {
        childProps["aria-invalid"] = "true";
      }
      if (isRequired) {
        childProps["aria-required"] = "true";
      }
      if (supportRef(mergedChildren)) {
        childProps.ref = getItemRef(mergedName, mergedChildren);
      }
      const triggers = new Set([].concat(_toConsumableArray(toArray3(trigger)), _toConsumableArray(toArray3(mergedValidateTrigger))));
      triggers.forEach((eventName) => {
        childProps[eventName] = (...args) => {
          mergedControl[eventName]?.(...args);
          mergedChildren.props[eventName]?.(...args);
        };
      });
      const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
      childNode = React248.createElement(MemoInput, {
        control: mergedControl,
        update: mergedChildren,
        childProps: watchingChildProps
      }, cloneElement(mergedChildren, childProps));
    } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
      childNode = mergedChildren(context);
    } else {
      true ? warning2(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead.") : void 0;
      childNode = mergedChildren;
    }
    return renderLayout(childNode, fieldId, isRequired);
  });
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus_default;
var FormItem_default = FormItem;

// node_modules/antd/es/form/FormList.js
var React249 = __toESM(require_react());
var FormList = ({
  prefixCls: customizePrefixCls,
  children,
  ...props
}) => {
  if (true) {
    const warning2 = devUseWarning("Form.List");
    true ? warning2(typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.") : void 0;
  }
  const {
    getPrefixCls
  } = React249.useContext(ConfigContext);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const contextValue = React249.useMemo(() => ({
    prefixCls,
    status: "error"
  }), [prefixCls]);
  return React249.createElement(List_default, {
    ...props
  }, (fields, operation, meta) => React249.createElement(FormItemPrefixContext.Provider, {
    value: contextValue
  }, children(fields.map((field) => ({
    ...field,
    fieldKey: field.key
  })), operation, {
    errors: meta.errors,
    warnings: meta.warnings
  })));
};
var FormList_default = FormList;

// node_modules/antd/es/form/hooks/useFormInstance.js
var React250 = __toESM(require_react());
function useFormInstance() {
  const {
    form
  } = React250.useContext(FormContext);
  return form;
}

// node_modules/antd/es/form/index.js
var Form2 = Form_default;
Form2.Item = FormItem_default;
Form2.List = FormList_default;
Form2.ErrorList = ErrorList_default;
Form2.useForm = useForm;
Form2.useFormInstance = useFormInstance;
Form2.useWatch = useWatch_default;
Form2.Provider = FormProvider;
var form_default = Form2;

// node_modules/antd/es/image/index.js
var React262 = __toESM(require_react());

// node_modules/@rc-component/image/es/Image.js
var React259 = __toESM(require_react());
var import_react81 = __toESM(require_react());

// node_modules/@rc-component/image/es/Preview/index.js
var import_react79 = __toESM(require_react());

// node_modules/@rc-component/image/es/context.js
var React251 = __toESM(require_react());
var PreviewGroupContext = React251.createContext(null);

// node_modules/@rc-component/image/es/util.js
function isImageValid(src) {
  return new Promise((resolve) => {
    if (!src) {
      resolve(false);
      return;
    }
    const img = document.createElement("img");
    img.onerror = () => resolve(false);
    img.onload = () => resolve(true);
    img.src = src;
  });
}
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}

// node_modules/@rc-component/image/es/hooks/useImageTransform.js
var import_react75 = __toESM(require_react());
var initialTransform = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: false,
  flipY: false
};
function useImageTransform(imgRef, minScale, maxScale, onTransform) {
  const frame = (0, import_react75.useRef)(null);
  const queue = (0, import_react75.useRef)([]);
  const [transform, setTransform] = (0, import_react75.useState)(initialTransform);
  const resetTransform = (action) => {
    setTransform(initialTransform);
    if (!isEqual_default(initialTransform, transform)) {
      onTransform?.({
        transform: initialTransform,
        action
      });
    }
  };
  const updateTransform = (newTransform, action) => {
    if (frame.current === null) {
      queue.current = [];
      frame.current = raf_default(() => {
        setTransform((preState) => {
          let memoState = preState;
          queue.current.forEach((queueState) => {
            memoState = {
              ...memoState,
              ...queueState
            };
          });
          frame.current = null;
          onTransform?.({
            transform: memoState,
            action
          });
          return memoState;
        });
      });
    }
    queue.current.push({
      ...transform,
      ...newTransform
    });
  };
  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {
    const {
      width,
      height,
      offsetWidth,
      offsetHeight,
      offsetLeft,
      offsetTop
    } = imgRef.current;
    let newRatio = ratio;
    let newScale = transform.scale * ratio;
    if (newScale > maxScale) {
      newScale = maxScale;
      newRatio = maxScale / transform.scale;
    } else if (newScale < minScale) {
      newScale = isTouch ? newScale : minScale;
      newRatio = newScale / transform.scale;
    }
    const mergedCenterX = centerX ?? innerWidth / 2;
    const mergedCenterY = centerY ?? innerHeight / 2;
    const diffRatio = newRatio - 1;
    const diffImgX = diffRatio * width * 0.5;
    const diffImgY = diffRatio * height * 0.5;
    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);
    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);
    let newX = transform.x - (diffOffsetLeft - diffImgX);
    let newY = transform.y - (diffOffsetTop - diffImgY);
    if (ratio < 1 && newScale === 1) {
      const mergedWidth = offsetWidth * newScale;
      const mergedHeight = offsetHeight * newScale;
      const {
        width: clientWidth,
        height: clientHeight
      } = getClientSize();
      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
        newX = 0;
        newY = 0;
      }
    }
    updateTransform({
      x: newX,
      y: newY,
      scale: newScale
    }, action);
  };
  return {
    transform,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  };
}

// node_modules/@rc-component/image/es/hooks/useMouseEvent.js
var import_react76 = __toESM(require_react());

// node_modules/@rc-component/image/es/getFixScaleEleTransPosition.js
function fixPoint(key, start, width, clientWidth) {
  const startAddWidth = start + width;
  const offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return {
        [key]: offsetStart
      };
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return {
        [key]: -offsetStart
      };
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return {
      [key]: start < 0 ? offsetStart : -offsetStart
    };
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  const {
    width: clientWidth,
    height: clientHeight
  } = getClientSize();
  let fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = {
      ...fixPoint("x", left, width, clientWidth),
      ...fixPoint("y", top, height, clientHeight)
    };
  }
  return fixPos;
}

// node_modules/@rc-component/image/es/previewConfig.js
var BASE_SCALE_RATIO = 1;
var WHEEL_MAX_SCALE_RATIO = 1;

// node_modules/@rc-component/image/es/hooks/useMouseEvent.js
function useMouseEvent(imgRef, movable, open3, scaleStep, transform, updateTransform, dispatchZoomChange) {
  const {
    rotate,
    scale,
    x,
    y
  } = transform;
  const [isMoving, setMoving] = (0, import_react76.useState)(false);
  const startPositionInfo = (0, import_react76.useRef)({
    diffX: 0,
    diffY: 0,
    transformX: 0,
    transformY: 0
  });
  const onMouseDown = (event) => {
    if (!movable || event.button !== 0) return;
    event.preventDefault();
    event.stopPropagation();
    startPositionInfo.current = {
      diffX: event.pageX - x,
      diffY: event.pageY - y,
      transformX: x,
      transformY: y
    };
    setMoving(true);
  };
  const onMouseMove = (event) => {
    if (open3 && isMoving) {
      updateTransform({
        x: event.pageX - startPositionInfo.current.diffX,
        y: event.pageY - startPositionInfo.current.diffY
      }, "move");
    }
  };
  const onMouseUp = () => {
    if (open3 && isMoving) {
      setMoving(false);
      const {
        transformX,
        transformY
      } = startPositionInfo.current;
      const hasChangedPosition = x !== transformX && y !== transformY;
      if (!hasChangedPosition) return;
      const width = imgRef.current.offsetWidth * scale;
      const height = imgRef.current.offsetHeight * scale;
      const {
        left,
        top
      } = imgRef.current.getBoundingClientRect();
      const isRotate = rotate % 180 !== 0;
      const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
      if (fixState) {
        updateTransform({
          ...fixState
        }, "dragRebound");
      }
    }
  };
  const onWheel = (event) => {
    if (!open3 || event.deltaY == 0) return;
    const scaleRatio = Math.abs(event.deltaY / 100);
    const mergedScaleRatio = Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO);
    let ratio = BASE_SCALE_RATIO + mergedScaleRatio * scaleStep;
    if (event.deltaY > 0) {
      ratio = BASE_SCALE_RATIO / ratio;
    }
    dispatchZoomChange(ratio, "wheel", event.clientX, event.clientY);
  };
  (0, import_react76.useEffect)(() => {
    if (movable) {
      window.addEventListener("mouseup", onMouseUp, false);
      window.addEventListener("mousemove", onMouseMove, false);
      try {
        if (window.top !== window.self) {
          window.top.addEventListener("mouseup", onMouseUp, false);
          window.top.addEventListener("mousemove", onMouseMove, false);
        }
      } catch (error) {
        warning(false, `[rc-image] ${error}`);
      }
    }
    return () => {
      window.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("mousemove", onMouseMove);
      try {
        window.top?.removeEventListener("mouseup", onMouseUp);
        window.top?.removeEventListener("mousemove", onMouseMove);
      } catch (error) {
      }
    };
  }, [open3, isMoving, x, y, rotate, movable]);
  return {
    isMoving,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onWheel
  };
}

// node_modules/@rc-component/image/es/hooks/useStatus.js
var import_react77 = __toESM(require_react());
function useStatus({
  src,
  isCustomPlaceholder,
  fallback
}) {
  const [status, setStatus] = (0, import_react77.useState)(isCustomPlaceholder ? "loading" : "normal");
  const isLoaded = (0, import_react77.useRef)(false);
  const isError = status === "error";
  (0, import_react77.useEffect)(() => {
    let isCurrentSrc = true;
    isImageValid(src).then((isValid) => {
      if (!isValid && isCurrentSrc) {
        setStatus("error");
      }
    });
    return () => {
      isCurrentSrc = false;
    };
  }, [src]);
  (0, import_react77.useEffect)(() => {
    if (isCustomPlaceholder && !isLoaded.current) {
      setStatus("loading");
    } else if (isError) {
      setStatus("normal");
    }
  }, [src]);
  const onLoad = () => {
    setStatus("normal");
  };
  const getImgRef = (img) => {
    isLoaded.current = false;
    if (status === "loading" && img?.complete && (img.naturalWidth || img.naturalHeight)) {
      isLoaded.current = true;
      onLoad();
    }
  };
  const srcAndOnload = isError && fallback ? {
    src: fallback
  } : {
    onLoad,
    src
  };
  return [getImgRef, srcAndOnload, status];
}

// node_modules/@rc-component/image/es/hooks/useTouchEvent.js
var import_react78 = __toESM(require_react());
function getDistance(a, b) {
  const x = a.x - b.x;
  const y = a.y - b.y;
  return Math.hypot(x, y);
}
function getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {
  const distance1 = getDistance(oldPoint1, newPoint1);
  const distance2 = getDistance(oldPoint2, newPoint2);
  if (distance1 === 0 && distance2 === 0) {
    return [oldPoint1.x, oldPoint1.y];
  }
  const ratio = distance1 / (distance1 + distance2);
  const x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);
  const y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);
  return [x, y];
}
function useTouchEvent(imgRef, movable, open3, minScale, transform, updateTransform, dispatchZoomChange) {
  const {
    rotate,
    scale,
    x,
    y
  } = transform;
  const [isTouching, setIsTouching] = (0, import_react78.useState)(false);
  const touchPointInfo = (0, import_react78.useRef)({
    point1: {
      x: 0,
      y: 0
    },
    point2: {
      x: 0,
      y: 0
    },
    eventType: "none"
  });
  const updateTouchPointInfo = (values) => {
    touchPointInfo.current = {
      ...touchPointInfo.current,
      ...values
    };
  };
  const onTouchStart = (event) => {
    if (!movable) return;
    event.stopPropagation();
    setIsTouching(true);
    const {
      touches = []
    } = event;
    if (touches.length > 1) {
      updateTouchPointInfo({
        point1: {
          x: touches[0].clientX,
          y: touches[0].clientY
        },
        point2: {
          x: touches[1].clientX,
          y: touches[1].clientY
        },
        eventType: "touchZoom"
      });
    } else {
      updateTouchPointInfo({
        point1: {
          x: touches[0].clientX - x,
          y: touches[0].clientY - y
        },
        eventType: "move"
      });
    }
  };
  const onTouchMove = (event) => {
    const {
      touches = []
    } = event;
    const {
      point1,
      point2,
      eventType
    } = touchPointInfo.current;
    if (touches.length > 1 && eventType === "touchZoom") {
      const newPoint1 = {
        x: touches[0].clientX,
        y: touches[0].clientY
      };
      const newPoint2 = {
        x: touches[1].clientX,
        y: touches[1].clientY
      };
      const [centerX, centerY] = getCenter(point1, point2, newPoint1, newPoint2);
      const ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);
      dispatchZoomChange(ratio, "touchZoom", centerX, centerY, true);
      updateTouchPointInfo({
        point1: newPoint1,
        point2: newPoint2,
        eventType: "touchZoom"
      });
    } else if (eventType === "move") {
      updateTransform({
        x: touches[0].clientX - point1.x,
        y: touches[0].clientY - point1.y
      }, "move");
      updateTouchPointInfo({
        eventType: "move"
      });
    }
  };
  const onTouchEnd = () => {
    if (!open3) return;
    if (isTouching) {
      setIsTouching(false);
    }
    updateTouchPointInfo({
      eventType: "none"
    });
    if (minScale > scale) {
      return updateTransform({
        x: 0,
        y: 0,
        scale: minScale
      }, "touchZoom");
    }
    const width = imgRef.current.offsetWidth * scale;
    const height = imgRef.current.offsetHeight * scale;
    const {
      left,
      top
    } = imgRef.current.getBoundingClientRect();
    const isRotate = rotate % 180 !== 0;
    const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
    if (fixState) {
      updateTransform({
        ...fixState
      }, "dragRebound");
    }
  };
  (0, import_react78.useEffect)(() => {
    const preventDefault = (e3) => {
      e3.preventDefault();
    };
    if (open3 && movable) {
      window.addEventListener("touchmove", preventDefault, {
        passive: false
      });
    }
    return () => {
      window.removeEventListener("touchmove", preventDefault);
    };
  }, [open3, movable]);
  return {
    isTouching,
    onTouchStart,
    onTouchMove,
    onTouchEnd
  };
}

// node_modules/@rc-component/image/es/Preview/CloseBtn.js
var React252 = __toESM(require_react());
function CloseBtn(props) {
  const {
    prefixCls,
    icon,
    onClick
  } = props;
  return React252.createElement("button", {
    className: `${prefixCls}-close`,
    onClick
  }, icon);
}

// node_modules/@rc-component/image/es/Preview/Footer.js
var React253 = __toESM(require_react());
function Footer3(props) {
  const {
    prefixCls,
    showProgress,
    current,
    count,
    showSwitch,
    // Style
    classNames,
    styles,
    // render
    icons: icons2,
    image,
    transform,
    countRender,
    actionsRender,
    // Scale
    scale,
    minScale,
    maxScale,
    // Actions
    onActive,
    onFlipY,
    onFlipX,
    onRotateLeft,
    onRotateRight,
    onZoomOut,
    onZoomIn,
    onClose,
    onReset
  } = props;
  const {
    left,
    right,
    prev,
    next,
    flipY,
    flipX,
    rotateLeft,
    rotateRight,
    zoomOut,
    zoomIn: zoomIn2
  } = icons2;
  const progressNode = showProgress && React253.createElement("div", {
    className: `${prefixCls}-progress`
  }, countRender ? countRender(current + 1, count) : React253.createElement("bdi", null, `${current + 1} / ${count}`));
  const actionCls = `${prefixCls}-actions-action`;
  const renderOperation = ({
    type,
    disabled,
    onClick,
    icon
  }) => {
    return React253.createElement("div", {
      key: type,
      className: clsx(actionCls, `${actionCls}-${type}`, {
        [`${actionCls}-disabled`]: !!disabled
      }),
      onClick
    }, icon);
  };
  const switchPrevNode = showSwitch ? renderOperation({
    icon: prev ?? left,
    onClick: () => onActive(-1),
    type: "prev",
    disabled: current === 0
  }) : void 0;
  const switchNextNode = showSwitch ? renderOperation({
    icon: next ?? right,
    onClick: () => onActive(1),
    type: "next",
    disabled: current === count - 1
  }) : void 0;
  const flipYNode = renderOperation({
    icon: flipY,
    onClick: onFlipY,
    type: "flipY"
  });
  const flipXNode = renderOperation({
    icon: flipX,
    onClick: onFlipX,
    type: "flipX"
  });
  const rotateLeftNode = renderOperation({
    icon: rotateLeft,
    onClick: onRotateLeft,
    type: "rotateLeft"
  });
  const rotateRightNode = renderOperation({
    icon: rotateRight,
    onClick: onRotateRight,
    type: "rotateRight"
  });
  const zoomOutNode = renderOperation({
    icon: zoomOut,
    onClick: onZoomOut,
    type: "zoomOut",
    disabled: scale <= minScale
  });
  const zoomInNode = renderOperation({
    icon: zoomIn2,
    onClick: onZoomIn,
    type: "zoomIn",
    disabled: scale === maxScale
  });
  const actionsNode = React253.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames.actions),
    style: styles.actions
  }, flipYNode, flipXNode, rotateLeftNode, rotateRightNode, zoomOutNode, zoomInNode);
  return React253.createElement("div", {
    className: clsx(`${prefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, progressNode, actionsRender ? actionsRender(actionsNode, {
    icons: {
      prevIcon: switchPrevNode,
      nextIcon: switchNextNode,
      flipYIcon: flipYNode,
      flipXIcon: flipXNode,
      rotateLeftIcon: rotateLeftNode,
      rotateRightIcon: rotateRightNode,
      zoomOutIcon: zoomOutNode,
      zoomInIcon: zoomInNode
    },
    actions: {
      onActive,
      onFlipY,
      onFlipX,
      onRotateLeft,
      onRotateRight,
      onZoomOut,
      onZoomIn,
      onReset,
      onClose
    },
    transform,
    current,
    total: count,
    image
  }) : actionsNode);
}

// node_modules/@rc-component/image/es/Preview/PrevNext.js
var React254 = __toESM(require_react());
function PrevNext(props) {
  const {
    prefixCls,
    onActive,
    current,
    count,
    icons: {
      left,
      right,
      prev,
      next
    }
  } = props;
  const switchCls = `${prefixCls}-switch`;
  return React254.createElement(React254.Fragment, null, React254.createElement("div", {
    className: clsx(switchCls, `${switchCls}-prev`, {
      [`${switchCls}-disabled`]: current === 0
    }),
    onClick: () => onActive(-1)
  }, prev ?? left), React254.createElement("div", {
    className: clsx(switchCls, `${switchCls}-next`, {
      [`${switchCls}-disabled`]: current === count - 1
    }),
    onClick: () => onActive(1)
  }, next ?? right));
}

// node_modules/@rc-component/image/es/Preview/index.js
function _extends45() {
  _extends45 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends45.apply(this, arguments);
}
var PreviewImage = ({
  fallback,
  src,
  imgRef,
  ...props
}) => {
  const [getImgRef, srcAndOnload] = useStatus({
    src,
    fallback
  });
  return import_react79.default.createElement("img", _extends45({
    ref: (ref) => {
      imgRef.current = ref;
      getImgRef(ref);
    }
  }, props, srcAndOnload));
};
var Preview = (props) => {
  const {
    prefixCls,
    rootClassName,
    src,
    alt,
    imageInfo,
    fallback,
    movable = true,
    onClose,
    open: open3,
    afterOpenChange,
    icons: icons2 = {},
    closeIcon,
    getContainer,
    current = 0,
    count = 1,
    countRender,
    scaleStep = 0.5,
    minScale = 1,
    maxScale = 50,
    motionName = "fade",
    imageRender,
    imgCommonProps,
    actionsRender,
    onTransform,
    onChange,
    classNames = {},
    styles = {},
    mousePosition: mousePosition2,
    zIndex
  } = props;
  const imgRef = (0, import_react79.useRef)();
  const groupContext = (0, import_react79.useContext)(PreviewGroupContext);
  const showLeftOrRightSwitches = groupContext && count > 1;
  const showOperationsProgress = groupContext && count >= 1;
  const [enableTransition, setEnableTransition] = (0, import_react79.useState)(true);
  const {
    transform,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  } = useImageTransform(imgRef, minScale, maxScale, onTransform);
  const {
    isMoving,
    onMouseDown,
    onWheel
  } = useMouseEvent(imgRef, movable, open3, scaleStep, transform, updateTransform, dispatchZoomChange);
  const {
    isTouching,
    onTouchStart,
    onTouchMove,
    onTouchEnd
  } = useTouchEvent(imgRef, movable, open3, minScale, transform, updateTransform, dispatchZoomChange);
  const {
    rotate,
    scale
  } = transform;
  (0, import_react79.useEffect)(() => {
    if (!enableTransition) {
      setEnableTransition(true);
    }
  }, [enableTransition]);
  (0, import_react79.useEffect)(() => {
    if (!open3) {
      resetTransform("close");
    }
  }, [open3]);
  const onDoubleClick = (event) => {
    if (open3) {
      if (scale !== 1) {
        updateTransform({
          x: 0,
          y: 0,
          scale: 1
        }, "doubleClick");
      } else {
        dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "doubleClick", event.clientX, event.clientY);
      }
    }
  };
  const imgNode = import_react79.default.createElement(PreviewImage, _extends45({}, imgCommonProps, {
    width: props.width,
    height: props.height,
    imgRef,
    className: `${prefixCls}-img`,
    alt,
    style: {
      transform: `translate3d(${transform.x}px, ${transform.y}px, 0) scale3d(${transform.flipX ? "-" : ""}${scale}, ${transform.flipY ? "-" : ""}${scale}, 1) rotate(${rotate}deg)`,
      transitionDuration: (!enableTransition || isTouching) && "0s"
    },
    fallback,
    src,
    onWheel,
    onMouseDown,
    onDoubleClick,
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onTouchCancel: onTouchEnd
  }));
  const image = {
    url: src,
    alt,
    ...imageInfo
  };
  const onZoomIn = () => {
    dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "zoomIn");
  };
  const onZoomOut = () => {
    dispatchZoomChange(BASE_SCALE_RATIO / (BASE_SCALE_RATIO + scaleStep), "zoomOut");
  };
  const onRotateRight = () => {
    updateTransform({
      rotate: rotate + 90
    }, "rotateRight");
  };
  const onRotateLeft = () => {
    updateTransform({
      rotate: rotate - 90
    }, "rotateLeft");
  };
  const onFlipX = () => {
    updateTransform({
      flipX: !transform.flipX
    }, "flipX");
  };
  const onFlipY = () => {
    updateTransform({
      flipY: !transform.flipY
    }, "flipY");
  };
  const onReset = () => {
    resetTransform("reset");
  };
  const onActive = (offset3) => {
    const nextCurrent = current + offset3;
    if (nextCurrent >= 0 && nextCurrent <= count - 1) {
      setEnableTransition(false);
      resetTransform(offset3 < 0 ? "prev" : "next");
      onChange?.(nextCurrent, current);
    }
  };
  const onKeyDown2 = useEvent_default((event) => {
    if (open3) {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode_default.ESC) {
        onClose?.();
      }
      if (showLeftOrRightSwitches) {
        if (keyCode === KeyCode_default.LEFT) {
          onActive(-1);
        } else if (keyCode === KeyCode_default.RIGHT) {
          onActive(1);
        }
      }
    }
  });
  (0, import_react79.useEffect)(() => {
    if (open3) {
      window.addEventListener("keydown", onKeyDown2);
      return () => {
        window.removeEventListener("keydown", onKeyDown2);
      };
    }
  }, [open3]);
  const [lockScroll, setLockScroll] = (0, import_react79.useState)(false);
  import_react79.default.useEffect(() => {
    if (open3) {
      setLockScroll(true);
    }
  }, [open3]);
  const onVisibleChanged = (nextVisible) => {
    if (!nextVisible) {
      setLockScroll(false);
    }
    afterOpenChange?.(nextVisible);
  };
  const [portalRender, setPortalRender] = (0, import_react79.useState)(false);
  useLayoutEffect_default(() => {
    if (open3) {
      setPortalRender(true);
    }
  }, [open3]);
  const bodyStyle = {
    ...styles.body
  };
  if (mousePosition2) {
    bodyStyle.transformOrigin = `${mousePosition2.x}px ${mousePosition2.y}px`;
  }
  return import_react79.default.createElement(es_default2, {
    open: portalRender,
    getContainer,
    autoLock: lockScroll
  }, import_react79.default.createElement(es_default4, {
    motionName,
    visible: portalRender && open3,
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    onVisibleChanged
  }, ({
    className: motionClassName,
    style: motionStyle
  }) => {
    const mergedStyle = {
      ...styles.root,
      ...motionStyle
    };
    if (zIndex) {
      mergedStyle.zIndex = zIndex;
    }
    return import_react79.default.createElement("div", {
      className: clsx(prefixCls, rootClassName, classNames.root, motionClassName, {
        [`${prefixCls}-moving`]: isMoving
      }),
      style: mergedStyle
    }, import_react79.default.createElement("div", {
      className: clsx(`${prefixCls}-mask`, classNames.mask),
      style: styles.mask,
      onClick: onClose
    }), import_react79.default.createElement("div", {
      className: clsx(`${prefixCls}-body`, classNames.body),
      style: bodyStyle
    }, imageRender ? imageRender(imgNode, {
      transform,
      image,
      ...groupContext ? {
        current
      } : {}
    }) : imgNode), closeIcon !== false && closeIcon !== null && import_react79.default.createElement(CloseBtn, {
      prefixCls,
      icon: closeIcon === true ? icons2.close : closeIcon || icons2.close,
      onClick: onClose
    }), showLeftOrRightSwitches && import_react79.default.createElement(PrevNext, {
      prefixCls,
      current,
      count,
      icons: icons2,
      onActive
    }), import_react79.default.createElement(Footer3, {
      prefixCls,
      showProgress: showOperationsProgress,
      current,
      count,
      showSwitch: showLeftOrRightSwitches,
      classNames,
      styles,
      image,
      transform,
      icons: icons2,
      countRender,
      actionsRender,
      scale,
      minScale,
      maxScale,
      onActive,
      onFlipY,
      onFlipX,
      onRotateLeft,
      onRotateRight,
      onZoomOut,
      onZoomIn,
      onClose,
      onReset
    }));
  }));
};
var Preview_default = Preview;

// node_modules/@rc-component/image/es/PreviewGroup.js
var React257 = __toESM(require_react());
var import_react80 = __toESM(require_react());

// node_modules/@rc-component/image/es/hooks/usePreviewItems.js
var React256 = __toESM(require_react());

// node_modules/@rc-component/image/es/common.js
var COMMON_PROPS = ["crossOrigin", "decoding", "draggable", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "alt"];

// node_modules/@rc-component/image/es/hooks/usePreviewItems.js
function usePreviewItems(items) {
  const [images, setImages] = React256.useState({});
  const registerImage = React256.useCallback((id, data) => {
    setImages((imgs) => ({
      ...imgs,
      [id]: data
    }));
    return () => {
      setImages((imgs) => {
        const cloneImgs = {
          ...imgs
        };
        delete cloneImgs[id];
        return cloneImgs;
      });
    };
  }, []);
  const mergedItems = React256.useMemo(() => {
    if (items) {
      return items.map((item) => {
        if (typeof item === "string") {
          return {
            data: {
              src: item
            }
          };
        }
        const data = {};
        Object.keys(item).forEach((key) => {
          if (["src", ...COMMON_PROPS].includes(key)) {
            data[key] = item[key];
          }
        });
        return {
          data
        };
      });
    }
    return Object.keys(images).reduce((total, id) => {
      const {
        canPreview,
        data
      } = images[id];
      if (canPreview) {
        total.push({
          data,
          id
        });
      }
      return total;
    }, []);
  }, [items, images]);
  return [mergedItems, registerImage, !!items];
}

// node_modules/@rc-component/image/es/PreviewGroup.js
function _extends46() {
  _extends46 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends46.apply(this, arguments);
}
var Group = ({
  previewPrefixCls = "rc-image-preview",
  classNames,
  styles,
  children,
  icons: icons2 = {},
  items,
  preview,
  fallback
}) => {
  const {
    open: previewOpen,
    onOpenChange,
    current: currentIndex,
    onChange,
    ...restProps
  } = preview && typeof preview === "object" ? preview : {};
  const [mergedItems, register, fromItems] = usePreviewItems(items);
  const [current, setCurrent] = useControlledState(0, currentIndex);
  const [keepOpenIndex, setKeepOpenIndex] = (0, import_react80.useState)(false);
  const {
    src,
    ...imgCommonProps
  } = mergedItems[current]?.data || {};
  const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
  const triggerShowPreview = useEvent_default((next) => {
    setShowPreview(next);
    if (next !== isShowPreview) {
      onOpenChange?.(next, {
        current
      });
    }
  });
  const [mousePosition2, setMousePosition] = (0, import_react80.useState)(null);
  const onPreviewFromImage = React257.useCallback((id, imageSrc, mouseX, mouseY) => {
    const index2 = fromItems ? mergedItems.findIndex((item) => item.data.src === imageSrc) : mergedItems.findIndex((item) => item.id === id);
    setCurrent(index2 < 0 ? 0 : index2);
    triggerShowPreview(true);
    setMousePosition({
      x: mouseX,
      y: mouseY
    });
    setKeepOpenIndex(true);
  }, [mergedItems, fromItems]);
  React257.useEffect(() => {
    if (isShowPreview) {
      if (!keepOpenIndex) {
        setCurrent(0);
      }
    } else {
      setKeepOpenIndex(false);
    }
  }, [isShowPreview]);
  const onInternalChange = (next, prev) => {
    setCurrent(next);
    onChange?.(next, prev);
  };
  const onPreviewClose = () => {
    triggerShowPreview(false);
    setMousePosition(null);
  };
  const previewGroupContext = React257.useMemo(() => ({
    register,
    onPreview: onPreviewFromImage
  }), [register, onPreviewFromImage]);
  return React257.createElement(PreviewGroupContext.Provider, {
    value: previewGroupContext
  }, children, React257.createElement(Preview_default, _extends46({
    "aria-hidden": !isShowPreview,
    open: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    imgCommonProps,
    src,
    fallback,
    icons: icons2,
    current,
    count: mergedItems.length,
    onChange: onInternalChange
  }, restProps, {
    classNames: classNames?.popup,
    styles: styles?.popup
  })));
};
var PreviewGroup_default = Group;

// node_modules/@rc-component/image/es/hooks/useRegisterImage.js
var React258 = __toESM(require_react());
var uid = 0;
function useRegisterImage(canPreview, data) {
  const [id] = React258.useState(() => {
    uid += 1;
    return String(uid);
  });
  const groupContext = React258.useContext(PreviewGroupContext);
  const registerData = {
    data,
    canPreview
  };
  React258.useEffect(() => {
    if (groupContext) {
      return groupContext.register(id, registerData);
    }
  }, []);
  React258.useEffect(() => {
    if (groupContext) {
      groupContext.register(id, registerData);
    }
  }, [canPreview, data]);
  return id;
}

// node_modules/@rc-component/image/es/Image.js
function _extends47() {
  _extends47 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends47.apply(this, arguments);
}
var ImageInternal = (props) => {
  const {
    // Misc
    prefixCls = "rc-image",
    previewPrefixCls = `${prefixCls}-preview`,
    // Style
    rootClassName,
    className,
    style,
    classNames = {},
    styles = {},
    width,
    height,
    // Image
    src: imgSrc,
    alt,
    placeholder,
    fallback,
    // Preview
    preview = true,
    // Events
    onClick,
    onError,
    ...otherProps
  } = props;
  const groupContext = (0, import_react81.useContext)(PreviewGroupContext);
  const canPreview = !!preview;
  const {
    src: previewSrc,
    open: previewOpen,
    onOpenChange: onPreviewOpenChange,
    cover,
    rootClassName: previewRootClassName,
    ...restProps
  } = preview && typeof preview === "object" ? preview : {};
  const coverPlacement = typeof cover === "object" && cover.placement ? cover.placement || "center" : "center";
  const coverNode = typeof cover === "object" && cover.coverNode ? cover.coverNode : cover;
  const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
  const [mousePosition2, setMousePosition] = (0, import_react81.useState)(null);
  const triggerPreviewOpen = (nextOpen) => {
    setShowPreview(nextOpen);
    onPreviewOpenChange?.(nextOpen);
  };
  const onPreviewClose = () => {
    triggerPreviewOpen(false);
  };
  const isCustomPlaceholder = placeholder && placeholder !== true;
  const src = previewSrc ?? imgSrc;
  const [getImgRef, srcAndOnload, status] = useStatus({
    src: imgSrc,
    isCustomPlaceholder,
    fallback
  });
  const imgCommonProps = (0, import_react81.useMemo)(() => {
    const obj = {};
    COMMON_PROPS.forEach((prop) => {
      if (props[prop] !== void 0) {
        obj[prop] = props[prop];
      }
    });
    return obj;
  }, COMMON_PROPS.map((prop) => props[prop]));
  const registerData = (0, import_react81.useMemo)(() => ({
    ...imgCommonProps,
    src
  }), [src, imgCommonProps]);
  const imageId = useRegisterImage(canPreview, registerData);
  const onPreview = (e3) => {
    const rect = e3.target.getBoundingClientRect();
    const left = rect.x + rect.width / 2;
    const top = rect.y + rect.height / 2;
    if (groupContext) {
      groupContext.onPreview(imageId, src, left, top);
    } else {
      setMousePosition({
        x: left,
        y: top
      });
      triggerPreviewOpen(true);
    }
    onClick?.(e3);
  };
  return React259.createElement(React259.Fragment, null, React259.createElement("div", _extends47({}, otherProps, {
    className: clsx(prefixCls, rootClassName, classNames.root, {
      [`${prefixCls}-error`]: status === "error"
    }),
    onClick: canPreview ? onPreview : onClick,
    style: {
      width,
      height,
      ...styles.root
    }
  }), React259.createElement("img", _extends47({}, imgCommonProps, {
    className: clsx(`${prefixCls}-img`, {
      [`${prefixCls}-img-placeholder`]: placeholder === true
    }, classNames.image, className),
    style: {
      height,
      ...styles.image,
      ...style
    },
    ref: getImgRef
  }, srcAndOnload, {
    width,
    height,
    onError
  })), status === "loading" && React259.createElement("div", {
    "aria-hidden": "true",
    className: `${prefixCls}-placeholder`
  }, placeholder), cover !== false && canPreview && React259.createElement("div", {
    className: clsx(`${prefixCls}-cover`, classNames.cover, `${prefixCls}-cover-${coverPlacement}`),
    style: {
      display: style?.display === "none" ? "none" : void 0,
      ...styles.cover
    }
  }, coverNode)), !groupContext && canPreview && React259.createElement(Preview_default, _extends47({
    "aria-hidden": !isShowPreview,
    open: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    src,
    alt,
    imageInfo: {
      width,
      height
    },
    fallback,
    imgCommonProps
  }, restProps, {
    classNames: classNames?.popup,
    styles: styles?.popup,
    rootClassName: clsx(previewRootClassName, rootClassName)
  })));
};
ImageInternal.PreviewGroup = PreviewGroup_default;
if (true) {
  ImageInternal.displayName = "Image";
}
var Image_default2 = ImageInternal;

// node_modules/@rc-component/image/es/index.js
var es_default17 = Image_default2;

// node_modules/antd/es/image/hooks/useMergedPreviewConfig.js
var import_react82 = __toESM(require_react());
var useMergedPreviewConfig = (previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, icons2, defaultCover) => {
  const [zIndex] = useZIndex("ImagePreview", previewConfig?.zIndex);
  const [mergedPreviewMask, blurClassName] = useMergedMask(previewConfig?.mask, contextPreviewConfig?.mask, `${prefixCls}-preview`);
  return import_react82.default.useMemo(() => {
    if (!previewConfig) {
      return previewConfig;
    }
    const {
      cover,
      getContainer,
      closeIcon,
      rootClassName: previewRootClassName
    } = previewConfig;
    const {
      closeIcon: contextCloseIcon
    } = contextPreviewConfig ?? {};
    return {
      motionName: getTransitionName(`${prefixCls}-preview`, "fade"),
      ...previewConfig,
      ...defaultCover ? {
        cover: cover ?? defaultCover
      } : {},
      icons: icons2,
      getContainer: getContainer ?? getContextPopupContainer,
      zIndex,
      closeIcon: closeIcon ?? contextCloseIcon,
      rootClassName: clsx(mergedRootClassName, previewRootClassName),
      mask: mergedPreviewMask,
      blurClassName: blurClassName.mask
    };
  }, [previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, defaultCover, icons2, zIndex, mergedPreviewMask, blurClassName]);
};
var useMergedPreviewConfig_default = useMergedPreviewConfig;

// node_modules/antd/es/image/hooks/usePreviewConfig.js
var import_react83 = __toESM(require_react());
function normalizeMask(mask) {
  if ((0, import_react83.isValidElement)(mask)) {
    return [mask, void 0];
  }
  if (typeof mask === "boolean" || mask && typeof mask === "object") {
    return [void 0, mask];
  }
  return [void 0, void 0];
}
function usePreviewConfig(preview) {
  const rawPreviewConfig = (0, import_react83.useMemo)(() => {
    if (typeof preview === "boolean") {
      return preview ? {} : null;
    }
    return preview && typeof preview === "object" ? preview : {};
  }, [preview]);
  const splittedPreviewConfig = (0, import_react83.useMemo)(() => {
    if (!rawPreviewConfig) {
      return [rawPreviewConfig, "", ""];
    }
    const {
      open: open3,
      onOpenChange,
      cover,
      actionsRender,
      visible,
      onVisibleChange,
      rootClassName,
      maskClassName,
      mask,
      forceRender: _forceRender,
      destroyOnClose: _destroyOnClose,
      toolbarRender,
      ...restPreviewConfig
    } = rawPreviewConfig;
    let onInternalOpenChange;
    if (onOpenChange) {
      onInternalOpenChange = onOpenChange;
    } else if (onVisibleChange) {
      onInternalOpenChange = (nextOpen, info) => {
        const {
          current
        } = info || {};
        if (current !== void 0) {
          onVisibleChange(nextOpen, !nextOpen, current);
        } else {
          onVisibleChange(nextOpen, !nextOpen);
        }
      };
    }
    const [coverElement, maskConfig] = normalizeMask(mask);
    return [{
      ...restPreviewConfig,
      open: open3 ?? visible,
      onOpenChange: onInternalOpenChange,
      cover: cover ?? coverElement,
      mask: maskConfig,
      actionsRender: actionsRender ?? toolbarRender
    }, rootClassName, maskClassName];
  }, [rawPreviewConfig]);
  if (true) {
    const warning2 = devUseWarning("Image");
    if (rawPreviewConfig) {
      [["visible", "open"], ["onVisibleChange", "onOpenChange"], ["maskClassName", "classNames.cover"], ["rootClassName", "classNames.root"], ["toolbarRender", "actionsRender"]].forEach(([deprecatedName, newName]) => {
        warning2.deprecated(!(deprecatedName in rawPreviewConfig), deprecatedName, newName);
      });
      true ? warning2(!(0, import_react83.isValidElement)(rawPreviewConfig.mask), "deprecated", "`mask` used as ReactNode is deprecated. Please use `cover` instead.") : void 0;
      true ? warning2(!("forceRender" in rawPreviewConfig), "breaking", "`forceRender` is no longer supported.") : void 0;
      true ? warning2(!("destroyOnClose" in rawPreviewConfig), "breaking", "`destroyOnClose` is no longer supported.") : void 0;
    }
  }
  return splittedPreviewConfig;
}

// node_modules/antd/es/image/PreviewGroup.js
var React261 = __toESM(require_react());

// node_modules/antd/es/image/style/index.js
var genBoxStyle = (position2) => ({
  position: position2 || "absolute",
  inset: 0
});
var genImageCoverStyle = (token) => {
  const {
    componentCls,
    motionDurationSlow,
    colorTextLightSolid
  } = token;
  return {
    [componentCls]: {
      [`${componentCls}-cover`]: {
        position: "absolute",
        inset: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: colorTextLightSolid,
        background: new FastColor("#000").setA(0.3).toRgbString(),
        cursor: "pointer",
        opacity: 0,
        transition: `opacity ${motionDurationSlow}`
      },
      "&:hover": {
        [`${componentCls}-cover`]: {
          opacity: 1
        }
      },
      [`${componentCls}-cover-top`]: {
        inset: "0 0 auto 0",
        justifyContent: "center"
      },
      [`${componentCls}-cover-bottom`]: {
        inset: "auto 0 0 0",
        justifyContent: "center"
      }
    }
  };
};
var genImagePreviewStyle = (token) => {
  const {
    motionEaseOut,
    previewCls,
    motionDurationSlow,
    componentCls,
    colorBgMask,
    marginXL,
    marginSM,
    margin,
    colorTextLightSolid,
    paddingSM,
    paddingLG,
    previewOperationHoverColor,
    previewOperationColorDisabled,
    previewOperationSize,
    zIndexPopup
  } = token;
  const operationBg = new FastColor(colorBgMask).setA(0.1);
  const operationBgHover = operationBg.clone().setA(0.2);
  const singleBtn = {
    position: "absolute",
    color: colorTextLightSolid,
    backgroundColor: operationBg.toRgbString(),
    borderRadius: "50%",
    padding: paddingSM,
    outline: 0,
    border: 0,
    cursor: "pointer",
    transition: `all ${motionDurationSlow}`,
    display: "flex",
    fontSize: previewOperationSize,
    "&:hover": {
      backgroundColor: operationBgHover.toRgbString()
    },
    "&:active": {
      backgroundColor: operationBg.toRgbString()
    }
  };
  return {
    [`${componentCls}-preview`]: {
      textAlign: "center",
      inset: 0,
      position: "fixed",
      userSelect: "none",
      zIndex: zIndexPopup,
      // ================= Mask =================
      [`${previewCls}-mask`]: {
        inset: 0,
        position: "absolute",
        background: colorBgMask,
        [`&${componentCls}-preview-mask-blur`]: {
          backdropFilter: "blur(4px)"
        },
        [`&${componentCls}-preview-mask-hidden`]: {
          display: "none"
        }
      },
      // ================= Body =================
      [`${previewCls}-body`]: {
        ...genBoxStyle(),
        "pointer-events": "none",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "> *": {
          pointerEvents: "auto"
        }
      },
      // Body > Image
      [`${previewCls}-img`]: {
        maxWidth: "100%",
        maxHeight: "70%",
        verticalAlign: "middle",
        transform: "scale3d(1, 1, 1)",
        cursor: "grab",
        transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`
      },
      [`&-moving ${previewCls}-img`]: {
        cursor: "grabbing"
      },
      // =============== CloseBtn ===============
      [`${previewCls}-close`]: {
        // Shared style
        ...singleBtn,
        top: marginSM,
        insetInlineEnd: marginSM
      },
      // ================ Switch ================
      [`${previewCls}-switch`]: {
        ...singleBtn,
        top: "50%",
        transform: `translateY(-50%)`,
        "&-disabled": {
          "&, &:hover, &:active": {
            color: previewOperationColorDisabled,
            background: "transparent",
            cursor: "not-allowed"
          }
        },
        "&-prev": {
          insetInlineStart: marginSM
        },
        "&-next": {
          insetInlineEnd: marginSM
        }
      },
      // ================ Footer ================
      [`${previewCls}-footer`]: {
        position: "absolute",
        bottom: marginXL,
        left: {
          _skip_check_: true,
          value: "50%"
        },
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        color: token.previewOperationColor,
        transform: "translateX(-50%)",
        gap: margin
      },
      // =============== Actions ================
      [`${previewCls}-actions`]: {
        display: "flex",
        gap: paddingSM,
        padding: `0 ${unit(paddingLG)}`,
        backgroundColor: operationBg.toRgbString(),
        borderRadius: 100,
        fontSize: previewOperationSize,
        "&-action": {
          padding: paddingSM,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          display: "flex",
          [`&:not(${previewCls}-actions-action-disabled):hover`]: {
            color: previewOperationHoverColor
          },
          "&-disabled": {
            color: previewOperationColorDisabled,
            cursor: "not-allowed"
          }
        }
      }
    }
  };
};
var genImageStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    // ============================== image ==============================
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-placeholder`]: {
        ...genBoxStyle()
      }
    }
  };
};
var genPreviewMotion = (token) => {
  const {
    previewCls,
    motionDurationSlow
  } = token;
  return {
    [previewCls]: {
      "&-fade": {
        transition: `opacity ${motionDurationSlow}`,
        "&-enter, &-appear": {
          opacity: 0,
          [`${previewCls}-body`]: {
            transform: "scale(0)"
          },
          "&-active": {
            opacity: 1,
            [`${previewCls}-body`]: {
              transform: "scale(1)",
              transition: `transform ${motionDurationSlow}`
            }
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0,
            [`${previewCls}-body`]: {
              transform: "scale(0)",
              transition: `transform ${motionDurationSlow}`
            }
          }
        }
      }
    }
  };
};
var prepareComponentToken29 = (token) => ({
  zIndexPopup: token.zIndexPopupBase + 80,
  previewOperationColor: new FastColor(token.colorTextLightSolid).setA(0.65).toRgbString(),
  previewOperationHoverColor: new FastColor(token.colorTextLightSolid).setA(0.85).toRgbString(),
  previewOperationColorDisabled: new FastColor(token.colorTextLightSolid).setA(0.25).toRgbString(),
  previewOperationSize: token.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
});
var style_default34 = genStyleHooks("Image", (token) => {
  const previewCls = `${token.componentCls}-preview`;
  const imageToken = merge(token, {
    previewCls,
    imagePreviewSwitchSize: token.controlHeightLG
  });
  return [genImageStyle(imageToken), genImageCoverStyle(imageToken), genImagePreviewStyle(imageToken), genPreviewMotion(imageToken)];
}, prepareComponentToken29);

// node_modules/antd/es/image/PreviewGroup.js
var icons = {
  rotateLeft: React261.createElement(RotateLeftOutlined_default, null),
  rotateRight: React261.createElement(RotateRightOutlined_default, null),
  zoomIn: React261.createElement(ZoomInOutlined_default, null),
  zoomOut: React261.createElement(ZoomOutOutlined_default, null),
  close: React261.createElement(CloseOutlined_default, null),
  left: React261.createElement(LeftOutlined_default, null),
  right: React261.createElement(RightOutlined_default, null),
  flipX: React261.createElement(SwapOutlined_default, null),
  flipY: React261.createElement(SwapOutlined_default, {
    rotate: 90
  })
};
var InternalPreviewGroup = ({
  previewPrefixCls: customizePrefixCls,
  preview,
  classNames,
  styles,
  ...otherProps
}) => {
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    direction,
    preview: contextPreview,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("image");
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const previewPrefixCls = `${prefixCls}-preview`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default34(prefixCls, rootCls);
  const mergedRootClassName = clsx(hashId, cssVarCls, rootCls);
  const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
  const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
  const memoizedIcons = React261.useMemo(() => ({
    ...icons,
    left: direction === "rtl" ? React261.createElement(RightOutlined_default, null) : React261.createElement(LeftOutlined_default, null),
    right: direction === "rtl" ? React261.createElement(LeftOutlined_default, null) : React261.createElement(RightOutlined_default, null)
  }), [direction]);
  const mergedPreview = useMergedPreviewConfig_default(
    // Preview config
    previewConfig,
    contextPreviewConfig,
    // MISC
    prefixCls,
    mergedRootClassName,
    getContextPopupContainer,
    icons
  );
  const {
    mask: mergedMask,
    blurClassName
  } = mergedPreview ?? {};
  const mergedProps = {
    ...otherProps,
    classNames,
    styles
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames, {
    cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
    popup: {
      root: clsx(contextPreviewRootClassName, previewRootClassName),
      mask: clsx({
        [`${prefixCls}-preview-mask-hidden`]: !mergedMask
      }, blurClassName)
    }
  }], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React261.createElement(es_default17.PreviewGroup, {
    preview: mergedPreview,
    previewPrefixCls,
    icons: memoizedIcons,
    ...otherProps,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
};
var PreviewGroup_default2 = InternalPreviewGroup;

// node_modules/antd/es/image/index.js
var Image2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    preview,
    className,
    rootClassName,
    style,
    styles,
    classNames,
    wrapperStyle,
    fallback,
    ...otherProps
  } = props;
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    preview: contextPreview,
    styles: contextStyles,
    classNames: contextClassNames,
    fallback: contextFallback
  } = useComponentConfig("image");
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  if (true) {
    const warning2 = devUseWarning("Image");
    warning2.deprecated(!wrapperStyle, "wrapperStyle", "styles.root");
  }
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default34(prefixCls, rootCls);
  const mergedRootClassName = clsx(rootClassName, hashId, cssVarCls, rootCls);
  const mergedClassName = clsx(className, hashId, contextClassName);
  const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
  const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
  const mergedPreviewConfig = useMergedPreviewConfig_default(
    // Preview config
    previewConfig,
    contextPreviewConfig,
    // MISC
    prefixCls,
    mergedRootClassName,
    getContextPopupContainer,
    icons,
    true
  );
  const mergedProps = {
    ...props,
    preview: mergedPreviewConfig
  };
  const mergedLegacyClassNames = React262.useMemo(() => ({
    cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
    popup: {
      root: clsx(contextPreviewRootClassName, previewRootClassName)
    }
  }), [previewRootClassName, previewMaskClassName, contextPreviewRootClassName, contextPreviewMaskClassName]);
  const {
    mask: mergedMask,
    blurClassName
  } = mergedPreviewConfig ?? {};
  const mergedPopupClassNames = React262.useMemo(() => ({
    mask: clsx({
      [`${prefixCls}-preview-mask-hidden`]: !mergedMask
    }, blurClassName)
  }), [mergedMask, prefixCls, blurClassName]);
  const internalClassNames = React262.useMemo(() => [contextClassNames, classNames, mergedLegacyClassNames, {
    popup: mergedPopupClassNames
  }], [contextClassNames, classNames, mergedLegacyClassNames, mergedPopupClassNames]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic(internalClassNames, [contextStyles, {
    root: wrapperStyle
  }, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedStyle = {
    ...contextStyle,
    ...style
  };
  const mergedFallback = fallback ?? contextFallback;
  return React262.createElement(es_default17, {
    prefixCls,
    preview: mergedPreviewConfig || false,
    rootClassName: mergedRootClassName,
    className: mergedClassName,
    style: mergedStyle,
    fallback: mergedFallback,
    ...otherProps,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
};
Image2.PreviewGroup = PreviewGroup_default2;
if (true) {
  Image2.displayName = "Image";
}
var image_default = Image2;

// node_modules/antd/es/input/Group.js
var React263 = __toESM(require_react());
var import_react84 = __toESM(require_react());
var Group2 = (props) => {
  const {
    getPrefixCls,
    direction
  } = (0, import_react84.useContext)(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className
  } = props;
  const prefixCls = getPrefixCls("input-group", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input");
  const [hashId, cssVarCls] = style_default2(inputPrefixCls);
  const cls = clsx(prefixCls, cssVarCls, {
    [`${prefixCls}-lg`]: props.size === "large",
    [`${prefixCls}-sm`]: props.size === "small",
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, className);
  const formItemContext = (0, import_react84.useContext)(FormItemInputContext);
  const groupFormItemContext = (0, import_react84.useMemo)(() => ({
    ...formItemContext,
    isFormItemInput: false
  }), [formItemContext]);
  if (true) {
    const warning2 = devUseWarning("Input.Group");
    warning2.deprecated(false, "Input.Group", "Space.Compact");
  }
  return React263.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, React263.createElement(space_default.Compact, {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, props.children));
};
var Group_default2 = Group2;

// node_modules/antd/es/input/OTP/index.js
var React265 = __toESM(require_react());

// node_modules/antd/es/input/style/otp.js
var genOTPStyle = (token) => {
  const {
    componentCls,
    paddingXS
  } = token;
  return {
    [componentCls]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: paddingXS,
      [`${componentCls}-input-wrapper`]: {
        position: "relative",
        [`${componentCls}-mask-icon`]: {
          position: "absolute",
          zIndex: "1",
          top: "50%",
          right: "50%",
          transform: "translate(50%, -50%)",
          pointerEvents: "none"
        },
        [`${componentCls}-mask-input`]: {
          color: "transparent",
          caretColor: token.colorText
        },
        [`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
          "-webkit-appearance": "none",
          margin: 0
        },
        [`${componentCls}-mask-input[type=number]`]: {
          "-moz-appearance": "textfield"
        }
      },
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-input`]: {
        textAlign: "center",
        paddingInline: token.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token.calc(token.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token.paddingXS
      }
    }
  };
};
var otp_default = genStyleHooks(["Input", "OTP"], (token) => {
  const inputToken = merge(token, initInputToken(token));
  return genOTPStyle(inputToken);
}, initComponentToken);

// node_modules/antd/es/input/OTP/OTPInput.js
var React264 = __toESM(require_react());
var OTPInput = React264.forwardRef((props, ref) => {
  const {
    className,
    value,
    onChange,
    onActiveChange,
    index: index2,
    mask,
    onFocus,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React264.useContext(ConfigContext);
  const prefixCls = getPrefixCls("otp");
  const maskValue = typeof mask === "string" ? mask : value;
  const inputRef = React264.useRef(null);
  React264.useImperativeHandle(ref, () => inputRef.current);
  const onInternalChange = (e3) => {
    onChange(index2, e3.target.value);
  };
  const syncSelection = () => {
    raf_default(() => {
      const inputEle = inputRef.current?.input;
      if (document.activeElement === inputEle && inputEle) {
        inputEle.select();
      }
    });
  };
  const onInternalFocus = (e3) => {
    onFocus?.(e3);
    syncSelection();
  };
  const onInternalKeyDown = (event) => {
    const {
      key,
      ctrlKey,
      metaKey
    } = event;
    if (key === "ArrowLeft") {
      onActiveChange(index2 - 1);
    } else if (key === "ArrowRight") {
      onActiveChange(index2 + 1);
    } else if (key === "z" && (ctrlKey || metaKey)) {
      event.preventDefault();
    } else if (key === "Backspace" && !value) {
      onActiveChange(index2 - 1);
    }
    syncSelection();
  };
  return React264.createElement("span", {
    className: `${prefixCls}-input-wrapper`,
    role: "presentation"
  }, mask && value !== "" && value !== void 0 && React264.createElement("span", {
    className: `${prefixCls}-mask-icon`,
    "aria-hidden": "true"
  }, maskValue), React264.createElement(Input_default, {
    "aria-label": `OTP Input ${index2 + 1}`,
    type: mask === true ? "password" : "text",
    ...restProps,
    ref: inputRef,
    value,
    onInput: onInternalChange,
    onFocus: onInternalFocus,
    onKeyDown: onInternalKeyDown,
    onMouseDown: syncSelection,
    onMouseUp: syncSelection,
    className: clsx(className, {
      [`${prefixCls}-mask-input`]: mask
    })
  }));
});
var OTPInput_default = OTPInput;

// node_modules/antd/es/input/OTP/index.js
function strToArr(str) {
  return (str || "").split("");
}
var Separator = (props) => {
  const {
    index: index2,
    prefixCls,
    separator,
    className: semanticClassName,
    style: semanticStyle
  } = props;
  const separatorNode = typeof separator === "function" ? separator(index2) : separator;
  if (!separatorNode) {
    return null;
  }
  return React265.createElement("span", {
    className: clsx(`${prefixCls}-separator`, semanticClassName),
    style: semanticStyle
  }, separatorNode);
};
var OTP = React265.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    length = 6,
    size: customSize,
    defaultValue,
    value,
    onChange,
    formatter,
    separator,
    variant,
    disabled,
    status: customStatus,
    autoFocus,
    mask,
    type,
    onInput,
    onFocus,
    inputMode,
    classNames,
    styles,
    className,
    style,
    ...restProps
  } = props;
  if (true) {
    const warning2 = devUseWarning("Input.OTP");
    true ? warning2(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.") : void 0;
  }
  const {
    classNames: contextClassNames,
    styles: contextStyles,
    getPrefixCls,
    direction,
    style: contextStyle,
    className: contextClassName
  } = useComponentConfig("otp");
  const prefixCls = getPrefixCls("otp", customizePrefixCls);
  const mergedProps = {
    ...props,
    length
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const domAttrs = pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  });
  const [hashId, cssVarCls] = otp_default(prefixCls);
  const mergedSize = useSize_default((ctx) => customSize ?? ctx);
  const formContext = React265.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(formContext.status, customStatus);
  const proxyFormContext = React265.useMemo(() => ({
    ...formContext,
    status: mergedStatus,
    hasFeedback: false,
    feedbackIcon: null
  }), [formContext, mergedStatus]);
  const containerRef = React265.useRef(null);
  const refs = React265.useRef({});
  React265.useImperativeHandle(ref, () => ({
    focus: () => {
      refs.current[0]?.focus();
    },
    blur: () => {
      for (let i = 0; i < length; i += 1) {
        refs.current[i]?.blur();
      }
    },
    nativeElement: containerRef.current
  }));
  const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
  const [valueCells, setValueCells] = React265.useState(() => strToArr(internalFormatter(defaultValue || "")));
  React265.useEffect(() => {
    if (value !== void 0) {
      setValueCells(strToArr(value));
    }
  }, [value]);
  const triggerValueCellsChange = useEvent_default((nextValueCells) => {
    setValueCells(nextValueCells);
    if (onInput) {
      onInput(nextValueCells);
    }
    if (onChange && nextValueCells.length === length && nextValueCells.every((c) => c) && nextValueCells.some((c, index2) => valueCells[index2] !== c)) {
      onChange(nextValueCells.join(""));
    }
  });
  const patchValue = useEvent_default((index2, txt) => {
    let nextCells = _toConsumableArray(valueCells);
    for (let i = 0; i < index2; i += 1) {
      if (!nextCells[i]) {
        nextCells[i] = "";
      }
    }
    if (txt.length <= 1) {
      nextCells[index2] = txt;
    } else {
      nextCells = nextCells.slice(0, index2).concat(strToArr(txt));
    }
    nextCells = nextCells.slice(0, length);
    for (let i = nextCells.length - 1; i >= 0; i -= 1) {
      if (nextCells[i]) {
        break;
      }
      nextCells.pop();
    }
    const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
    nextCells = strToArr(formattedValue).map((c, i) => {
      if (c === " " && !nextCells[i]) {
        return nextCells[i];
      }
      return c;
    });
    return nextCells;
  });
  const onInputChange = (index2, txt) => {
    const nextCells = patchValue(index2, txt);
    const nextIndex = Math.min(index2 + txt.length, length - 1);
    if (nextIndex !== index2 && nextCells[index2] !== void 0) {
      refs.current[nextIndex]?.focus();
    }
    triggerValueCellsChange(nextCells);
  };
  const onInputActiveChange = (nextIndex) => {
    refs.current[nextIndex]?.focus();
  };
  const onInputFocus = (event, index2) => {
    for (let i = 0; i < index2; i += 1) {
      if (!refs.current[i]?.input?.value) {
        refs.current[i]?.focus();
        break;
      }
    }
    onFocus?.(event);
  };
  const inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus,
    mask,
    type,
    inputMode
  };
  return React265.createElement("div", {
    ...domAttrs,
    ref: containerRef,
    className: clsx(className, prefixCls, {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, cssVarCls, hashId, contextClassName, mergedClassNames.root),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    role: "group"
  }, React265.createElement(FormItemInputContext.Provider, {
    value: proxyFormContext
  }, Array.from({
    length
  }).map((_, index2) => {
    const key = `otp-${index2}`;
    const singleValue = valueCells[index2] || "";
    return React265.createElement(React265.Fragment, {
      key
    }, React265.createElement(OTPInput_default, {
      ref: (inputEle) => {
        refs.current[index2] = inputEle;
      },
      index: index2,
      size: mergedSize,
      htmlSize: 1,
      className: clsx(mergedClassNames.input, `${prefixCls}-input`),
      style: mergedStyles.input,
      onChange: onInputChange,
      value: singleValue,
      onActiveChange: onInputActiveChange,
      autoFocus: index2 === 0 && autoFocus,
      onFocus: (event) => onInputFocus(event, index2),
      ...inputSharedProps
    }), index2 < length - 1 && React265.createElement(Separator, {
      separator,
      index: index2,
      prefixCls,
      className: clsx(mergedClassNames.separator),
      style: mergedStyles.separator
    }));
  })));
});
var OTP_default = OTP;

// node_modules/antd/es/input/Password.js
var React266 = __toESM(require_react());
var import_react85 = __toESM(require_react());
var defaultIconRender = (visible) => visible ? React266.createElement(EyeOutlined_default, null) : React266.createElement(EyeInvisibleOutlined_default, null);
var actionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = React266.forwardRef((props, ref) => {
  const {
    disabled: customDisabled,
    action = "click",
    visibilityToggle = true,
    iconRender = defaultIconRender,
    suffix
  } = props;
  const disabled = React266.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
  const [visible, setVisible] = (0, import_react85.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
  const inputRef = (0, import_react85.useRef)(null);
  React266.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = () => {
    if (mergedDisabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    const nextVisible = !visible;
    setVisible(nextVisible);
    if (typeof visibilityToggle === "object") {
      visibilityToggle.onVisibleChange?.(nextVisible);
    }
  };
  const getIcon2 = (prefixCls2) => {
    const iconTrigger = actionMap[action] || "";
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: (e3) => {
        e3.preventDefault();
      },
      onMouseUp: (e3) => {
        e3.preventDefault();
      }
    };
    return React266.cloneElement(React266.isValidElement(icon) ? icon : React266.createElement("span", null, icon), iconProps);
  };
  const {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React266.useContext(ConfigContext);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const prefixCls = getPrefixCls("input-password", customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon2(prefixCls);
  const inputClassName = clsx(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = {
    ...omit(restProps, ["suffix", "iconRender", "visibilityToggle"]),
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: React266.createElement(React266.Fragment, null, suffixIcon, suffix)
  };
  if (size) {
    omittedProps.size = size;
  }
  return React266.createElement(Input_default, {
    ref: composeRef(ref, inputRef),
    ...omittedProps
  });
});
if (true) {
  Password.displayName = "Input.Password";
}
var Password_default = Password;

// node_modules/antd/es/input/Search.js
var React267 = __toESM(require_react());

// node_modules/antd/es/input/style/search.js
var genSearchStyle = (token) => {
  const {
    componentCls
  } = token;
  const btnCls = `${componentCls}-btn`;
  return {
    [componentCls]: {
      width: "100%",
      // =========================== Button ===========================
      [btnCls]: {
        "&-filled": {
          background: token.colorFillTertiary,
          "&:not(:disabled)": {
            "&:hover": {
              background: token.colorFillSecondary
            },
            "&:active": {
              background: token.colorFill
            }
          }
        }
      }
    }
  };
};
var search_default = genStyleHooks(["Input", "Search"], (token) => {
  return [genSearchStyle(token)];
});

// node_modules/antd/es/input/Search.js
var Search = React267.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    style,
    enterButton = false,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd,
    variant,
    onPressEnter: customOnPressEnter,
    classNames,
    styles,
    hidden,
    ...restProps
  } = props;
  const {
    direction,
    getPrefixCls,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("inputSearch");
  const mergedProps = {
    ...props,
    enterButton
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    button: {
      _default: "root"
    }
  });
  const composedRef = React267.useRef(false);
  const prefixCls = getPrefixCls("input-search", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const [hashId, cssVarCls] = search_default(prefixCls);
  const {
    compactSize
  } = useCompactItemContext(prefixCls, direction);
  const size = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const inputRef = React267.useRef(null);
  const onChange = (e3) => {
    if (e3?.target && e3.type === "click" && customOnSearch) {
      customOnSearch(e3.target.value, e3, {
        source: "clear"
      });
    }
    customOnChange?.(e3);
  };
  const onMouseDown = (e3) => {
    if (document.activeElement === inputRef.current?.input) {
      e3.preventDefault();
    }
  };
  const onSearch = (e3) => {
    if (customOnSearch) {
      customOnSearch(inputRef.current?.input?.value, e3, {
        source: "input"
      });
    }
  };
  const onPressEnter = (e3) => {
    if (composedRef.current || loading) {
      return;
    }
    customOnPressEnter?.(e3);
    onSearch(e3);
  };
  const searchIcon = typeof enterButton === "boolean" ? React267.createElement(SearchOutlined_default, null) : null;
  const btnPrefixCls = `${prefixCls}-btn`;
  const btnClassName = clsx(btnPrefixCls, {
    [`${btnPrefixCls}-${variant}`]: variant
  });
  let button;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement(enterButtonAsElement, {
      onMouseDown,
      onClick: (e3) => {
        enterButtonAsElement?.props?.onClick?.(e3);
        onSearch(e3);
      },
      key: "enterButton",
      ...isAntdButton ? {
        className: btnClassName,
        size
      } : {}
    });
  } else {
    button = React267.createElement(Button_default, {
      classNames: mergedClassNames.button,
      styles: mergedStyles.button,
      className: btnClassName,
      color: enterButton ? "primary" : "default",
      size,
      disabled,
      key: "enterButton",
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon,
      variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
    }, enterButton);
  }
  if (addonAfter) {
    button = [button, cloneElement(addonAfter, {
      key: "addonAfter"
    })];
  }
  const mergedClassName = clsx(prefixCls, cssVarCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className, hashId, mergedClassNames.root);
  const handleOnCompositionStart = (e3) => {
    composedRef.current = true;
    onCompositionStart?.(e3);
  };
  const handleOnCompositionEnd = (e3) => {
    composedRef.current = false;
    onCompositionEnd?.(e3);
  };
  const rootProps = pickAttrs(restProps, {
    data: true
  });
  const inputProps = omit({
    ...restProps,
    classNames: omit(mergedClassNames, ["button", "root"]),
    styles: omit(mergedStyles, ["button", "root"]),
    prefixCls: inputPrefixCls,
    type: "search",
    size,
    variant,
    onPressEnter,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    onChange,
    disabled
  }, Object.keys(rootProps));
  return React267.createElement(Compact_default, {
    className: mergedClassName,
    style: {
      ...style,
      ...mergedStyles.root
    },
    ...rootProps,
    hidden
  }, React267.createElement(Input_default, {
    ref: composeRef(inputRef, ref),
    ...inputProps
  }), button);
});
if (true) {
  Search.displayName = "Search";
}
var Search_default = Search;

// node_modules/antd/es/input/TextArea.js
var React270 = __toESM(require_react());
var import_react87 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/TextArea.js
var import_react86 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/ResizableTextArea.js
var React268 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/calculateNodeHeight.js
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node, useCache = false) {
  const nodeRef = node.getAttribute("id") || node.getAttribute("data-reactid") || node.getAttribute("name");
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  const style = window.getComputedStyle(node);
  const boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
  const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  const sizingStyle = SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  const nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode, useCache = false, minRows = null, maxRows = null) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    hiddenTextarea.setAttribute("name", "hiddenTextarea");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  const {
    paddingSize,
    borderSize,
    boxSizing,
    sizingStyle
  } = calculateNodeStyling(uiTextNode, useCache);
  hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  let minHeight = void 0;
  let maxHeight = void 0;
  let overflowY;
  let height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  const style = {
    height,
    overflowY,
    resize: "none"
  };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  if (maxHeight) {
    style.maxHeight = maxHeight;
  }
  return style;
}

// node_modules/@rc-component/textarea/es/ResizableTextArea.js
function _extends48() {
  _extends48 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends48.apply(this, arguments);
}
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = React268.forwardRef((props, ref) => {
  const {
    prefixCls,
    defaultValue,
    value,
    autoSize,
    onResize,
    className,
    style,
    disabled,
    onChange,
    // Test only
    onInternalAutoSize,
    ...restProps
  } = props;
  const [internalValue, setMergedValue] = useControlledState(defaultValue, value);
  const mergedValue = internalValue ?? "";
  const onInternalChange = (event) => {
    setMergedValue(event.target.value);
    onChange?.(event);
  };
  const textareaRef = React268.useRef();
  React268.useImperativeHandle(ref, () => ({
    textArea: textareaRef.current
  }));
  const [minRows, maxRows] = React268.useMemo(() => {
    if (autoSize && typeof autoSize === "object") {
      return [autoSize.minRows, autoSize.maxRows];
    }
    return [];
  }, [autoSize]);
  const needAutoSize = !!autoSize;
  const [resizeState, setResizeState] = React268.useState(RESIZE_STABLE);
  const [autoSizeStyle, setAutoSizeStyle] = React268.useState();
  const startResize = () => {
    setResizeState(RESIZE_START);
    if (false) {
      onInternalAutoSize?.();
    }
  };
  useLayoutEffect_default(() => {
    if (needAutoSize) {
      startResize();
    }
  }, [value, minRows, maxRows, needAutoSize]);
  useLayoutEffect_default(() => {
    if (resizeState === RESIZE_START) {
      setResizeState(RESIZE_MEASURING);
    } else if (resizeState === RESIZE_MEASURING) {
      const textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
      setResizeState(RESIZE_STABLE);
      setAutoSizeStyle(textareaStyles);
    } else {
    }
  }, [resizeState]);
  const resizeRafRef = React268.useRef();
  const cleanRaf = () => {
    raf_default.cancel(resizeRafRef.current);
  };
  const onInternalResize = (size) => {
    if (resizeState === RESIZE_STABLE) {
      onResize?.(size);
      if (autoSize) {
        cleanRaf();
        resizeRafRef.current = raf_default(() => {
          startResize();
        });
      }
    }
  };
  React268.useEffect(() => cleanRaf, []);
  const mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
  const mergedStyle = {
    ...style,
    ...mergedAutoSizeStyle
  };
  if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
    mergedStyle.overflowY = "hidden";
    mergedStyle.overflowX = "hidden";
  }
  return React268.createElement(es_default3, {
    onResize: onInternalResize,
    disabled: !(autoSize || onResize)
  }, React268.createElement("textarea", _extends48({}, restProps, {
    ref: textareaRef,
    style: mergedStyle,
    className: clsx(prefixCls, className, {
      [`${prefixCls}-disabled`]: disabled
    }),
    disabled,
    value: mergedValue,
    onChange: onInternalChange
  })));
});
var ResizableTextArea_default = ResizableTextArea;

// node_modules/@rc-component/textarea/es/TextArea.js
function _extends49() {
  _extends49 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends49.apply(this, arguments);
}
var TextArea = import_react86.default.forwardRef(({
  defaultValue,
  value: customValue,
  onFocus,
  onBlur,
  onChange,
  allowClear,
  maxLength,
  onCompositionStart,
  onCompositionEnd,
  suffix,
  prefixCls = "rc-textarea",
  showCount,
  count,
  className,
  style,
  disabled,
  hidden,
  classNames,
  styles,
  onResize,
  onClear,
  onPressEnter,
  readOnly,
  autoSize,
  onKeyDown: onKeyDown2,
  ...rest
}, ref) => {
  const [value, setValue] = useControlledState(defaultValue, customValue);
  const formatValue2 = value === void 0 || value === null ? "" : String(value);
  const [focused, setFocused] = import_react86.default.useState(false);
  const compositionRef = import_react86.default.useRef(false);
  const [textareaResized, setTextareaResized] = import_react86.default.useState(null);
  const holderRef = (0, import_react86.useRef)(null);
  const resizableTextAreaRef = (0, import_react86.useRef)(null);
  const getTextArea = () => resizableTextAreaRef.current?.textArea;
  const focus = () => {
    getTextArea().focus();
  };
  (0, import_react86.useImperativeHandle)(ref, () => ({
    resizableTextArea: resizableTextAreaRef.current,
    focus,
    blur: () => {
      getTextArea().blur();
    },
    nativeElement: holderRef.current?.nativeElement || getTextArea()
  }));
  (0, import_react86.useEffect)(() => {
    setFocused((prev) => !disabled && prev);
  }, [disabled]);
  const [selection, setSelection] = import_react86.default.useState(null);
  import_react86.default.useEffect(() => {
    if (selection) {
      getTextArea().setSelectionRange(...selection);
    }
  }, [selection]);
  const countConfig = useCount(count, showCount);
  const mergedMax = countConfig.max ?? maxLength;
  const hasMaxLength = Number(mergedMax) > 0;
  const valueLength = countConfig.strategy(formatValue2);
  const isOutOfRange = !!mergedMax && valueLength > mergedMax;
  const triggerChange = (e3, currentValue) => {
    let cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
      }
    }
    setValue(cutValue);
    resolveOnChange(e3.currentTarget, e3, onChange, cutValue);
  };
  const onInternalCompositionStart = (e3) => {
    compositionRef.current = true;
    onCompositionStart?.(e3);
  };
  const onInternalCompositionEnd = (e3) => {
    compositionRef.current = false;
    triggerChange(e3, e3.currentTarget.value);
    onCompositionEnd?.(e3);
  };
  const onInternalChange = (e3) => {
    triggerChange(e3, e3.target.value);
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter" && onPressEnter && !e3.nativeEvent.isComposing) {
      onPressEnter(e3);
    }
    onKeyDown2?.(e3);
  };
  const handleFocus = (e3) => {
    setFocused(true);
    onFocus?.(e3);
  };
  const handleBlur = (e3) => {
    setFocused(false);
    onBlur?.(e3);
  };
  const handleReset = (e3) => {
    setValue("");
    focus();
    resolveOnChange(getTextArea(), e3, onChange);
  };
  let suffixNode = suffix;
  let dataCount;
  if (countConfig.show) {
    if (countConfig.showFormatter) {
      dataCount = countConfig.showFormatter({
        value: formatValue2,
        count: valueLength,
        maxLength: mergedMax
      });
    } else {
      dataCount = `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
    }
    suffixNode = import_react86.default.createElement(import_react86.default.Fragment, null, suffixNode, import_react86.default.createElement("span", {
      className: clsx(`${prefixCls}-data-count`, classNames?.count),
      style: styles?.count
    }, dataCount));
  }
  const handleResize = (size) => {
    onResize?.(size);
    if (getTextArea()?.style.height) {
      setTextareaResized(true);
    }
  };
  const isPureTextArea = !autoSize && !showCount && !allowClear;
  return import_react86.default.createElement(BaseInput_default, {
    ref: holderRef,
    value: formatValue2,
    allowClear,
    handleReset,
    suffix: suffixNode,
    prefixCls,
    classNames: {
      ...classNames,
      affixWrapper: clsx(classNames?.affixWrapper, {
        [`${prefixCls}-show-count`]: showCount,
        [`${prefixCls}-textarea-allow-clear`]: allowClear
      })
    },
    disabled,
    focused,
    className: clsx(className, isOutOfRange && `${prefixCls}-out-of-range`),
    style: {
      ...style,
      ...textareaResized && !isPureTextArea ? {
        height: "auto"
      } : {}
    },
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof dataCount === "string" ? dataCount : void 0
      }
    },
    hidden,
    readOnly,
    onClear
  }, import_react86.default.createElement(ResizableTextArea_default, _extends49({}, rest, {
    autoSize,
    maxLength,
    onKeyDown: handleKeyDown,
    onChange: onInternalChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onCompositionStart: onInternalCompositionStart,
    onCompositionEnd: onInternalCompositionEnd,
    className: clsx(classNames?.textarea),
    style: {
      resize: style?.resize,
      ...styles?.textarea
    },
    disabled,
    prefixCls,
    onResize: handleResize,
    ref: resizableTextAreaRef,
    readOnly
  })));
});
var TextArea_default = TextArea;

// node_modules/@rc-component/textarea/es/index.js
var es_default18 = TextArea_default;

// node_modules/antd/es/input/style/textarea.js
var genTextAreaStyle = (token) => {
  const {
    componentCls,
    paddingLG
  } = token;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    // Raw Textarea
    [`textarea${componentCls}`]: {
      maxWidth: "100%",
      // prevent textarea resize from coming out of its container
      height: "auto",
      minHeight: token.controlHeight,
      lineHeight: token.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${token.motionDurationSlow}`,
      resize: "vertical",
      [`&${componentCls}-mouse-active`]: {
        transition: `all ${token.motionDurationSlow}, height 0s, width 0s`
      }
    },
    // Wrapper for resize
    [`${componentCls}-textarea-affix-wrapper-resize-dirty`]: {
      width: "auto"
    },
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        [`${componentCls}-data-count`]: {
          position: "absolute",
          bottom: token.calc(token.fontSize).mul(token.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: token.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
        paddingInlineEnd: paddingLG
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          minHeight: token.calc(token.controlHeight).sub(token.calc(token.lineWidth).mul(2)).equal(),
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token.paddingInline,
            insetBlockStart: token.paddingXS
          },
          // Feedback Icon
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: {
        [`${componentCls}-suffix`]: {
          [`${componentCls}-data-count`]: {
            direction: "ltr",
            insetInlineStart: 0
          }
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
        [`${componentCls}-suffix`]: {
          [`${componentCls}-clear-icon`]: {
            insetInlineEnd: token.paddingInlineSM
          }
        }
      }
    }
  };
};
var textarea_default = genStyleHooks(["Input", "TextArea"], (token) => {
  const inputToken = merge(token, initInputToken(token));
  return genTextAreaStyle(inputToken);
}, initComponentToken, {
  resetFont: false
});

// node_modules/antd/es/input/TextArea.js
var TextArea2 = (0, import_react87.forwardRef)((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear,
    classNames,
    rootClassName,
    className,
    style,
    styles,
    variant: customVariant,
    showCount,
    onMouseDown,
    onResize,
    ...rest
  } = props;
  if (true) {
    const {
      deprecated
    } = devUseWarning("TextArea");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const {
    getPrefixCls,
    direction,
    allowClear: contextAllowClear,
    autoComplete: contextAutoComplete,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("textArea");
  const disabled = React270.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React270.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const innerRef = React270.useRef(null);
  React270.useImperativeHandle(ref, () => ({
    resizableTextArea: innerRef.current?.resizableTextArea,
    focus: (option) => {
      triggerFocus(innerRef.current?.resizableTextArea?.textArea, option);
    },
    blur: () => innerRef.current?.blur()
  }));
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
  textarea_default(prefixCls, rootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
  const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
  const [isMouseDown, setIsMouseDown] = React270.useState(false);
  const [resizeDirty, setResizeDirty] = React270.useState(false);
  const onInternalMouseDown = (e3) => {
    setIsMouseDown(true);
    onMouseDown?.(e3);
    const onMouseUp = () => {
      setIsMouseDown(false);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mouseup", onMouseUp);
  };
  const onInternalResize = (size) => {
    onResize?.(size);
    if (isMouseDown && typeof getComputedStyle === "function") {
      const ele = innerRef.current?.nativeElement?.querySelector("textarea");
      if (ele && getComputedStyle(ele).resize === "both") {
        setResizeDirty(true);
      }
    }
  };
  return React270.createElement(es_default18, {
    autoComplete: contextAutoComplete,
    ...rest,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    styles: mergedStyles,
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    className: clsx(
      cssVarCls,
      rootCls,
      className,
      rootClassName,
      compactItemClassnames,
      contextClassName,
      mergedClassNames.root,
      // Only for wrapper
      {
        [`${prefixCls}-textarea-affix-wrapper-resize-dirty`]: resizeDirty
      }
    ),
    classNames: {
      ...mergedClassNames,
      textarea: clsx({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large"
      }, hashId, mergedClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: clsx(`${prefixCls}-textarea-affix-wrapper`, {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-textarea-show-count`]: showCount || props.count?.show
      }, hashId)
    },
    prefixCls,
    suffix: hasFeedback && React270.createElement("span", {
      className: `${prefixCls}-textarea-suffix`
    }, feedbackIcon),
    showCount,
    ref: innerRef,
    onResize: onInternalResize,
    onMouseDown: onInternalMouseDown
  });
});
var TextArea_default2 = TextArea2;

// node_modules/antd/es/input/index.js
var Input2 = Input_default;
Input2.Group = Group_default2;
Input2.Search = Search_default;
Input2.TextArea = TextArea_default2;
Input2.Password = Password_default;
Input2.OTP = OTP_default;
var input_default = Input2;

// node_modules/antd/es/layout/layout.js
var React271 = __toESM(require_react());

// node_modules/antd/es/layout/hooks/useHasSider.js
function useHasSider(siders, children, hasSider) {
  if (typeof hasSider === "boolean") {
    return hasSider;
  }
  if (siders.length) {
    return true;
  }
  const childNodes = toArray(children);
  return childNodes.some((node) => node.type === Sider_default);
}

// node_modules/antd/es/layout/layout.js
function generator({
  suffixCls,
  tagName,
  displayName
}) {
  return (BasicComponent) => {
    const Adapter = React271.forwardRef((props, ref) => React271.createElement(BasicComponent, {
      ref,
      suffixCls,
      tagName,
      ...props
    }));
    if (true) {
      Adapter.displayName = displayName;
    }
    return Adapter;
  };
}
var Basic = React271.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    suffixCls,
    className,
    tagName: TagName,
    ...others
  } = props;
  const {
    getPrefixCls
  } = React271.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const [hashId] = style_default16(prefixCls);
  const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
  return React271.createElement(TagName, {
    className: clsx(customizePrefixCls || prefixWithSuffixCls, className, hashId),
    ref,
    ...others
  });
});
var BasicLayout = React271.forwardRef((props, ref) => {
  const {
    direction
  } = React271.useContext(ConfigContext);
  const [siders, setSiders] = React271.useState([]);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    hasSider,
    tagName: Tag2,
    style,
    ...others
  } = props;
  const passedProps = omit(others, ["suffixCls"]);
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("layout");
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const mergedHasSider = useHasSider(siders, children, hasSider);
  const [hashId, cssVarCls] = style_default16(prefixCls);
  const classString = clsx(prefixCls, {
    [`${prefixCls}-has-sider`]: mergedHasSider,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, hashId, cssVarCls);
  const contextValue = React271.useMemo(() => ({
    siderHook: {
      addSider: (id) => {
        setSiders((prev) => [].concat(_toConsumableArray(prev), [id]));
      },
      removeSider: (id) => {
        setSiders((prev) => prev.filter((currentId) => currentId !== id));
      }
    }
  }), []);
  return React271.createElement(LayoutContext.Provider, {
    value: contextValue
  }, React271.createElement(Tag2, {
    ref,
    className: classString,
    style: {
      ...contextStyle,
      ...style
    },
    ...passedProps
  }, children));
});
var Layout = generator({
  tagName: "div",
  displayName: "Layout"
})(BasicLayout);
var Header = generator({
  suffixCls: "header",
  tagName: "header",
  displayName: "Header"
})(Basic);
var Footer4 = generator({
  suffixCls: "footer",
  tagName: "footer",
  displayName: "Footer"
})(Basic);
var Content2 = generator({
  suffixCls: "content",
  tagName: "main",
  displayName: "Content"
})(Basic);
var layout_default = Layout;

// node_modules/antd/es/layout/index.js
var Layout2 = layout_default;
Layout2.Header = Header;
Layout2.Footer = Footer4;
Layout2.Content = Content2;
Layout2.Sider = Sider_default;
Layout2._InternalSiderContext = SiderContext;
var layout_default2 = Layout2;

// node_modules/antd/es/list/index.js
var React283 = __toESM(require_react());

// node_modules/antd/es/pagination/Pagination.js
var React275 = __toESM(require_react());

// node_modules/@rc-component/pagination/es/Pagination.js
var import_react90 = __toESM(require_react());

// node_modules/@rc-component/pagination/es/locale/zh_CN.js
var locale = {
  // Options
  items_per_page: "/",
  jump_to: "",
  jump_to_confirm: "",
  page: "",
  // Pagination
  prev_page: "",
  next_page: "",
  prev_5: " 5 ",
  next_5: " 5 ",
  prev_3: " 3 ",
  next_3: " 3 ",
  page_size: ""
};
var zh_CN_default = locale;

// node_modules/@rc-component/pagination/es/Options.js
var import_react88 = __toESM(require_react());
var defaultPageSizeOptions = [10, 20, 50, 100];
var Options = (props) => {
  const {
    pageSizeOptions = defaultPageSizeOptions,
    locale: locale2,
    changeSize,
    pageSize,
    goButton,
    quickGo,
    rootPrefixCls,
    disabled,
    buildOptionText,
    showSizeChanger,
    sizeChangerRender
  } = props;
  const [goInputText, setGoInputText] = import_react88.default.useState("");
  const getValidValue = import_react88.default.useMemo(() => {
    return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
  }, [goInputText]);
  const mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : (value) => `${value} ${locale2.items_per_page}`;
  const handleChange = (e3) => {
    const value = e3.target.value;
    if (/^\d*$/.test(value)) {
      setGoInputText(value);
    }
  };
  const handleBlur = (e3) => {
    if (goButton || goInputText === "") {
      return;
    }
    setGoInputText("");
    if (e3.relatedTarget && (e3.relatedTarget.className.includes(`${rootPrefixCls}-item-link`) || e3.relatedTarget.className.includes(`${rootPrefixCls}-item`))) {
      return;
    }
    quickGo?.(getValidValue);
  };
  const go = (e3) => {
    if (goInputText === "") {
      return;
    }
    if (e3.keyCode === KeyCode_default.ENTER || e3.type === "click") {
      setGoInputText("");
      quickGo?.(getValidValue);
    }
  };
  const getPageSizeOptions = () => {
    if (pageSizeOptions.some((option) => option.toString() === pageSize.toString())) {
      return pageSizeOptions;
    }
    return pageSizeOptions.concat([pageSize]).sort((a, b) => {
      const numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
      const numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
      return numberA - numberB;
    });
  };
  const prefixCls = `${rootPrefixCls}-options`;
  if (!showSizeChanger && !quickGo) {
    return null;
  }
  let changeSelect = null;
  let goInput = null;
  let gotoButton = null;
  if (showSizeChanger && sizeChangerRender) {
    changeSelect = sizeChangerRender({
      disabled,
      size: pageSize,
      onSizeChange: (nextValue) => {
        changeSize?.(Number(nextValue));
      },
      "aria-label": locale2.page_size,
      className: `${prefixCls}-size-changer`,
      options: getPageSizeOptions().map((opt) => ({
        label: mergeBuildOptionText(opt),
        value: opt
      }))
    });
  }
  if (quickGo) {
    if (goButton) {
      gotoButton = typeof goButton === "boolean" ? import_react88.default.createElement("button", {
        type: "button",
        onClick: go,
        onKeyUp: go,
        disabled,
        className: `${prefixCls}-quick-jumper-button`
      }, locale2.jump_to_confirm) : import_react88.default.createElement("span", {
        onClick: go,
        onKeyUp: go
      }, goButton);
    }
    goInput = import_react88.default.createElement("div", {
      className: `${prefixCls}-quick-jumper`
    }, locale2.jump_to, import_react88.default.createElement("input", {
      disabled,
      type: "text",
      value: goInputText,
      onChange: handleChange,
      onKeyUp: go,
      onBlur: handleBlur,
      "aria-label": locale2.page
    }), locale2.page, gotoButton);
  }
  return import_react88.default.createElement("li", {
    className: prefixCls
  }, changeSelect, goInput);
};
if (true) {
  Options.displayName = "Options";
}
var Options_default = Options;

// node_modules/@rc-component/pagination/es/Pager.js
var import_react89 = __toESM(require_react());
var Pager = (props) => {
  const {
    rootPrefixCls,
    page,
    active,
    className,
    style,
    showTitle,
    onClick,
    onKeyPress,
    itemRender
  } = props;
  const prefixCls = `${rootPrefixCls}-item`;
  const cls = clsx(prefixCls, `${prefixCls}-${page}`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-disabled`]: !page
  }, className);
  const handleClick = () => {
    onClick(page);
  };
  const handleKeyPress = (e3) => {
    onKeyPress(e3, onClick, page);
  };
  const pager = itemRender(page, "page", import_react89.default.createElement("a", {
    rel: "nofollow"
  }, page));
  return pager ? import_react89.default.createElement("li", {
    title: showTitle ? String(page) : null,
    className: cls,
    style,
    onClick: handleClick,
    onKeyDown: handleKeyPress,
    tabIndex: 0
  }, pager) : null;
};
if (true) {
  Pager.displayName = "Pager";
}
var Pager_default = Pager;

// node_modules/@rc-component/pagination/es/Pagination.js
function _extends50() {
  _extends50 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends50.apply(this, arguments);
}
var defaultItemRender = (_, __, element) => element;
function noop2() {
}
function isInteger(v) {
  const value = Number(v);
  return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
function calculatePage(p, pageSize, total) {
  const _pageSize = typeof p === "undefined" ? pageSize : p;
  return Math.floor((total - 1) / _pageSize) + 1;
}
var Pagination = (props) => {
  const {
    // cls
    prefixCls = "rc-pagination",
    selectPrefixCls = "rc-select",
    className,
    classNames: paginationClassNames,
    styles,
    // control
    current: currentProp,
    defaultCurrent = 1,
    total = 0,
    pageSize: pageSizeProp,
    defaultPageSize = 10,
    onChange = noop2,
    // config
    hideOnSinglePage,
    align,
    showPrevNextJumpers = true,
    showQuickJumper,
    showLessItems,
    showTitle = true,
    onShowSizeChange = noop2,
    locale: locale2 = zh_CN_default,
    style,
    totalBoundaryShowSizeChanger = 50,
    disabled,
    simple,
    showTotal,
    showSizeChanger = total > totalBoundaryShowSizeChanger,
    sizeChangerRender,
    pageSizeOptions,
    // render
    itemRender = defaultItemRender,
    jumpPrevIcon,
    jumpNextIcon,
    prevIcon,
    nextIcon
  } = props;
  const paginationRef = import_react90.default.useRef(null);
  const [pageSize, setPageSize] = useControlledState(defaultPageSize, pageSizeProp);
  const [internalCurrent, setCurrent] = useControlledState(defaultCurrent, currentProp);
  const current = Math.max(1, Math.min(internalCurrent, calculatePage(void 0, pageSize, total)));
  const [internalInputVal, setInternalInputVal] = import_react90.default.useState(current);
  (0, import_react90.useEffect)(() => {
    setInternalInputVal(current);
  }, [current]);
  const hasOnChange = onChange !== noop2;
  const hasCurrent = "current" in props;
  if (true) {
    warning_default(hasCurrent ? hasOnChange : true, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
  }
  const jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
  const jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
  function getItemIcon(icon, label) {
    let iconNode = icon || import_react90.default.createElement("button", {
      type: "button",
      "aria-label": label,
      className: `${prefixCls}-item-link`
    });
    if (typeof icon === "function") {
      iconNode = import_react90.default.createElement(icon, props);
    }
    return iconNode;
  }
  function getValidValue(e3) {
    const inputValue = e3.target.value;
    const allPages2 = calculatePage(void 0, pageSize, total);
    let value;
    if (inputValue === "") {
      value = inputValue;
    } else if (Number.isNaN(Number(inputValue))) {
      value = internalInputVal;
    } else if (inputValue >= allPages2) {
      value = allPages2;
    } else {
      value = Number(inputValue);
    }
    return value;
  }
  function isValid(page) {
    return isInteger(page) && page !== current && isInteger(total) && total > 0;
  }
  const shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
  function handleKeyDown(event) {
    if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) {
      event.preventDefault();
    }
  }
  function handleKeyUp(event) {
    const value = getValidValue(event);
    if (value !== internalInputVal) {
      setInternalInputVal(value);
    }
    switch (event.keyCode) {
      case KeyCode_default.ENTER:
        handleChange(value);
        break;
      case KeyCode_default.UP:
        handleChange(value - 1);
        break;
      case KeyCode_default.DOWN:
        handleChange(value + 1);
        break;
      default:
        break;
    }
  }
  function handleBlur(event) {
    handleChange(getValidValue(event));
  }
  function changePageSize(size) {
    const newCurrent = calculatePage(size, pageSize, total);
    const nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
    setPageSize(size);
    setInternalInputVal(nextCurrent);
    onShowSizeChange?.(current, size);
    setCurrent(nextCurrent);
    onChange?.(nextCurrent, size);
  }
  function handleChange(page) {
    if (isValid(page) && !disabled) {
      const currentPage = calculatePage(void 0, pageSize, total);
      let newPage = page;
      if (page > currentPage) {
        newPage = currentPage;
      } else if (page < 1) {
        newPage = 1;
      }
      if (newPage !== internalInputVal) {
        setInternalInputVal(newPage);
      }
      setCurrent(newPage);
      onChange?.(newPage, pageSize);
      return newPage;
    }
    return current;
  }
  const hasPrev = current > 1;
  const hasNext = current < calculatePage(void 0, pageSize, total);
  function prevHandle() {
    if (hasPrev) handleChange(current - 1);
  }
  function nextHandle() {
    if (hasNext) handleChange(current + 1);
  }
  function jumpPrevHandle() {
    handleChange(jumpPrevPage);
  }
  function jumpNextHandle() {
    handleChange(jumpNextPage);
  }
  function runIfEnter(event, callback, ...restParams) {
    if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) {
      callback(...restParams);
    }
  }
  function runIfEnterPrev(event) {
    runIfEnter(event, prevHandle);
  }
  function runIfEnterNext(event) {
    runIfEnter(event, nextHandle);
  }
  function runIfEnterJumpPrev(event) {
    runIfEnter(event, jumpPrevHandle);
  }
  function runIfEnterJumpNext(event) {
    runIfEnter(event, jumpNextHandle);
  }
  function renderPrev(prevPage2) {
    const prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
    return import_react90.default.isValidElement(prevButton) ? import_react90.default.cloneElement(prevButton, {
      disabled: !hasPrev
    }) : prevButton;
  }
  function renderNext(nextPage2) {
    const nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
    return import_react90.default.isValidElement(nextButton) ? import_react90.default.cloneElement(nextButton, {
      disabled: !hasNext
    }) : nextButton;
  }
  function handleGoTO(event) {
    if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) {
      handleChange(internalInputVal);
    }
  }
  let jumpPrev = null;
  const dataOrAriaAttributeProps = pickAttrs(props, {
    aria: true,
    data: true
  });
  const totalText = showTotal && import_react90.default.createElement("li", {
    className: `${prefixCls}-total-text`
  }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
  let jumpNext = null;
  const allPages = calculatePage(void 0, pageSize, total);
  if (hideOnSinglePage && total <= pageSize) {
    return null;
  }
  const pagerList = [];
  const pagerProps = {
    rootPrefixCls: prefixCls,
    onClick: handleChange,
    onKeyPress: runIfEnter,
    showTitle,
    itemRender,
    page: -1,
    className: paginationClassNames?.item,
    style: styles?.item
  };
  const prevPage = current - 1 > 0 ? current - 1 : 0;
  const nextPage = current + 1 < allPages ? current + 1 : allPages;
  const goButton = showQuickJumper && showQuickJumper.goButton;
  const isReadOnly = typeof simple === "object" ? simple.readOnly : !simple;
  let gotoButton = goButton;
  let simplePager = null;
  if (simple) {
    if (goButton) {
      if (typeof goButton === "boolean") {
        gotoButton = import_react90.default.createElement("button", {
          type: "button",
          onClick: handleGoTO,
          onKeyUp: handleGoTO
        }, locale2.jump_to_confirm);
      } else {
        gotoButton = import_react90.default.createElement("span", {
          onClick: handleGoTO,
          onKeyUp: handleGoTO
        }, goButton);
      }
      gotoButton = import_react90.default.createElement("li", {
        title: showTitle ? `${locale2.jump_to}${current}/${allPages}` : null,
        className: `${prefixCls}-simple-pager`
      }, gotoButton);
    }
    simplePager = import_react90.default.createElement("li", {
      title: showTitle ? `${current}/${allPages}` : null,
      className: clsx(`${prefixCls}-simple-pager`, paginationClassNames?.item),
      style: styles?.item
    }, isReadOnly ? internalInputVal : import_react90.default.createElement("input", {
      type: "text",
      "aria-label": locale2.jump_to,
      value: internalInputVal,
      disabled,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onChange: handleKeyUp,
      onBlur: handleBlur,
      size: 3
    }), import_react90.default.createElement("span", {
      className: `${prefixCls}-slash`
    }, "/"), allPages);
  }
  const pageBufferSize = showLessItems ? 1 : 2;
  if (allPages <= 3 + pageBufferSize * 2) {
    if (!allPages) {
      pagerList.push(import_react90.default.createElement(Pager_default, _extends50({}, pagerProps, {
        key: "noPager",
        page: 1,
        className: `${prefixCls}-item-disabled`
      })));
    }
    for (let i = 1; i <= allPages; i += 1) {
      pagerList.push(import_react90.default.createElement(Pager_default, _extends50({}, pagerProps, {
        key: i,
        page: i,
        active: current === i
      })));
    }
  } else {
    const prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
    const nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
    const jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
    const jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
    if (showPrevNextJumpers) {
      jumpPrev = jumpPrevContent ? import_react90.default.createElement("li", {
        title: showTitle ? prevItemTitle : null,
        key: "prev",
        onClick: jumpPrevHandle,
        tabIndex: 0,
        onKeyDown: runIfEnterJumpPrev,
        className: clsx(`${prefixCls}-jump-prev`, {
          [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
        })
      }, jumpPrevContent) : null;
      jumpNext = jumpNextContent ? import_react90.default.createElement("li", {
        title: showTitle ? nextItemTitle : null,
        key: "next",
        onClick: jumpNextHandle,
        tabIndex: 0,
        onKeyDown: runIfEnterJumpNext,
        className: clsx(`${prefixCls}-jump-next`, {
          [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
        })
      }, jumpNextContent) : null;
    }
    let left = Math.max(1, current - pageBufferSize);
    let right = Math.min(current + pageBufferSize, allPages);
    if (current - 1 <= pageBufferSize) {
      right = 1 + pageBufferSize * 2;
    }
    if (allPages - current <= pageBufferSize) {
      left = allPages - pageBufferSize * 2;
    }
    for (let i = left; i <= right; i += 1) {
      pagerList.push(import_react90.default.createElement(Pager_default, _extends50({}, pagerProps, {
        key: i,
        page: i,
        active: current === i
      })));
    }
    if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
      pagerList[0] = import_react90.default.cloneElement(pagerList[0], {
        className: clsx(`${prefixCls}-item-after-jump-prev`, pagerList[0].props.className)
      });
      pagerList.unshift(jumpPrev);
    }
    if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
      const lastOne = pagerList[pagerList.length - 1];
      pagerList[pagerList.length - 1] = import_react90.default.cloneElement(lastOne, {
        className: clsx(`${prefixCls}-item-before-jump-next`, lastOne.props.className)
      });
      pagerList.push(jumpNext);
    }
    if (left !== 1) {
      pagerList.unshift(import_react90.default.createElement(Pager_default, _extends50({}, pagerProps, {
        key: 1,
        page: 1
      })));
    }
    if (right !== allPages) {
      pagerList.push(import_react90.default.createElement(Pager_default, _extends50({}, pagerProps, {
        key: allPages,
        page: allPages
      })));
    }
  }
  let prev = renderPrev(prevPage);
  if (prev) {
    const prevDisabled = !hasPrev || !allPages;
    prev = import_react90.default.createElement("li", {
      title: showTitle ? locale2.prev_page : null,
      onClick: prevHandle,
      tabIndex: prevDisabled ? null : 0,
      onKeyDown: runIfEnterPrev,
      className: clsx(`${prefixCls}-prev`, paginationClassNames?.item, {
        [`${prefixCls}-disabled`]: prevDisabled
      }),
      style: styles?.item,
      "aria-disabled": prevDisabled
    }, prev);
  }
  let next = renderNext(nextPage);
  if (next) {
    let nextDisabled, nextTabIndex;
    if (simple) {
      nextDisabled = !hasNext;
      nextTabIndex = hasPrev ? 0 : null;
    } else {
      nextDisabled = !hasNext || !allPages;
      nextTabIndex = nextDisabled ? null : 0;
    }
    next = import_react90.default.createElement("li", {
      title: showTitle ? locale2.next_page : null,
      onClick: nextHandle,
      tabIndex: nextTabIndex,
      onKeyDown: runIfEnterNext,
      className: clsx(`${prefixCls}-next`, paginationClassNames?.item, {
        [`${prefixCls}-disabled`]: nextDisabled
      }),
      style: styles?.item,
      "aria-disabled": nextDisabled
    }, next);
  }
  const cls = clsx(prefixCls, className, {
    [`${prefixCls}-start`]: align === "start",
    [`${prefixCls}-center`]: align === "center",
    [`${prefixCls}-end`]: align === "end",
    [`${prefixCls}-simple`]: simple,
    [`${prefixCls}-disabled`]: disabled
  });
  return import_react90.default.createElement("ul", _extends50({
    className: cls,
    style,
    ref: paginationRef
  }, dataOrAriaAttributeProps), totalText, prev, simple ? simplePager : pagerList, next, import_react90.default.createElement(Options_default, {
    locale: locale2,
    rootPrefixCls: prefixCls,
    disabled,
    selectPrefixCls,
    changeSize: changePageSize,
    pageSize,
    pageSizeOptions,
    quickGo: shouldDisplayQuickJumper ? handleChange : null,
    goButton: gotoButton,
    showSizeChanger,
    sizeChangerRender
  }));
};
if (true) {
  Pagination.displayName = "Pagination";
}
var Pagination_default = Pagination;

// node_modules/antd/es/pagination/style/index.js
var genPaginationDisabledStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        backgroundColor: "transparent",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token.colorBorder,
          backgroundColor: token.itemActiveBgDisabled,
          "&:hover, &:active": {
            backgroundColor: token.itemActiveBgDisabled
          },
          a: {
            color: token.itemActiveColorDisabled
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        color: token.colorTextDisabled
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        [`${componentCls}-item-link-icon`]: {
          opacity: 0
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 1
        }
      }
    }
  };
};
var genPaginationMiniStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token.itemSizeSM,
      lineHeight: unit(token.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token.itemSizeSM,
      height: token.itemSizeSM,
      margin: 0,
      lineHeight: unit(token.calc(token.itemSizeSM).sub(2).equal())
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token.itemSizeSM,
      height: token.itemSizeSM,
      margin: 0,
      lineHeight: unit(token.itemSizeSM)
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token.itemSizeSM,
        lineHeight: unit(token.itemSizeSM)
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token.itemSizeSM,
      marginInlineEnd: 0,
      lineHeight: unit(token.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: token.miniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: token.itemSizeSM,
        lineHeight: unit(token.itemSizeSM),
        input: {
          ...genInputSmallStyle(token),
          width: token.paginationMiniQuickJumperInputWidth,
          height: token.controlHeightSM
        }
      }
    }
  };
};
var genPaginationSimpleStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`&${componentCls}-simple`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        height: token.itemSize,
        lineHeight: unit(token.itemSize),
        verticalAlign: "top",
        [`${componentCls}-item-link`]: {
          height: token.itemSize,
          backgroundColor: "transparent",
          border: 0,
          "&:hover": {
            backgroundColor: token.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token.colorBgTextActive
          },
          "&::after": {
            height: token.itemSize,
            lineHeight: unit(token.itemSize)
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        display: "inline-flex",
        alignItems: "center",
        height: token.itemSize,
        marginInlineEnd: token.marginXS,
        input: {
          boxSizing: "border-box",
          height: "100%",
          width: token.quickJumperInputWidth,
          padding: `0 ${unit(token.paginationItemPaddingInline)}`,
          textAlign: "center",
          backgroundColor: token.itemInputBg,
          border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderRadius: token.borderRadius,
          outline: "none",
          transition: `border-color ${token.motionDurationMid}`,
          color: "inherit",
          "&:hover": {
            borderColor: token.colorPrimary
          },
          "&:focus": {
            borderColor: token.colorPrimaryHover,
            boxShadow: `${unit(token.inputOutlineOffset)} 0 ${unit(token.controlOutlineWidth)} ${token.controlOutline}`
          },
          "&[disabled]": {
            color: token.colorTextDisabled,
            backgroundColor: token.colorBgContainerDisabled,
            borderColor: token.colorBorder,
            cursor: "not-allowed"
          }
        }
      },
      [`&${componentCls}-disabled`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`${componentCls}-item-link`]: {
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        }
      },
      [`&${componentCls}-mini`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          height: token.itemSizeSM,
          lineHeight: unit(token.itemSizeSM),
          [`${componentCls}-item-link`]: {
            height: token.itemSizeSM,
            "&::after": {
              height: token.itemSizeSM,
              lineHeight: unit(token.itemSizeSM)
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          height: token.itemSizeSM,
          input: {
            width: token.paginationMiniQuickJumperInputWidth
          }
        }
      }
    }
  };
};
var genPaginationJumpStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token.colorPrimary,
          fontSize: token.fontSizeSM,
          opacity: 0,
          transition: `all ${token.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token.colorTextDisabled,
          letterSpacing: token.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token.itemSize,
      height: token.itemSize,
      color: token.colorText,
      fontFamily: token.fontFamily,
      lineHeight: unit(token.itemSize),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token.borderRadius,
      cursor: "pointer",
      transition: `all ${token.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      outline: 0,
      button: {
        color: token.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${unit(token.lineWidth)} ${token.lineType} transparent`,
        borderRadius: token.borderRadius,
        outline: "none",
        transition: `all ${token.motionDurationMid}`
      },
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token.paginationSlashMarginInlineEnd,
      marginInlineStart: token.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token.margin,
      verticalAlign: "middle",
      "&-size-changer": {
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token.controlHeight,
        marginInlineStart: token.marginXS,
        lineHeight: unit(token.controlHeight),
        verticalAlign: "top",
        input: {
          ...genBasicInputStyle(token),
          ...genBaseOutlinedStyle(token, {
            borderColor: token.colorBorder,
            hoverBorderColor: token.colorPrimaryHover,
            activeBorderColor: token.colorPrimary,
            activeShadow: token.activeShadow
          }),
          "&[disabled]": {
            ...genDisabledStyle(token)
          },
          width: token.quickJumperInputWidth,
          height: token.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token.marginXS,
          marginInlineEnd: token.marginXS
        }
      }
    }
  };
};
var genPaginationItemStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-item`]: {
      display: "inline-block",
      minWidth: token.itemSize,
      height: token.itemSize,
      marginInlineEnd: token.marginXS,
      fontFamily: token.fontFamily,
      lineHeight: unit(token.calc(token.itemSize).sub(2).equal()),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: token.itemBg,
      border: `${unit(token.lineWidth)} ${token.lineType} transparent`,
      borderRadius: token.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${unit(token.paginationItemPaddingInline)}`,
        color: token.colorText,
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token.motionDurationMid}`,
          backgroundColor: token.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token.colorBgTextActive
        }
      },
      "&-active": {
        fontWeight: token.fontWeightStrong,
        backgroundColor: token.itemActiveBg,
        borderColor: token.colorPrimary,
        a: {
          color: token.itemActiveColor
        },
        "&:hover": {
          borderColor: token.colorPrimaryHover
        },
        "&:hover a": {
          color: token.itemActiveColorHover
        }
      }
    }
  };
};
var genPaginationStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      display: "flex",
      "&-start": {
        justifyContent: "start"
      },
      "&-center": {
        justifyContent: "center"
      },
      "&-end": {
        justifyContent: "end"
      },
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token.itemSize,
        marginInlineEnd: token.marginXS,
        lineHeight: unit(token.calc(token.itemSize).sub(2).equal()),
        verticalAlign: "middle"
      },
      // item style
      ...genPaginationItemStyle(token),
      // jump btn style
      ...genPaginationJumpStyle(token),
      // simple style
      ...genPaginationSimpleStyle(token),
      // mini style
      ...genPaginationMiniStyle(token),
      // disabled style
      ...genPaginationDisabledStyle(token),
      // media query style
      [`@media only screen and (max-width: ${token.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    },
    // rtl style
    [`&${token.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var genPaginationFocusStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}:not(${componentCls}-disabled)`]: {
      [`${componentCls}-item`]: {
        ...genFocusStyle(token)
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        "&:focus-visible": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          },
          ...genFocusOutline(token)
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:focus-visible ${componentCls}-item-link`]: genFocusOutline(token)
      }
    }
  };
};
var prepareComponentToken30 = (token) => ({
  itemBg: token.colorBgContainer,
  itemSize: token.controlHeight,
  itemSizeSM: token.controlHeightSM,
  itemActiveBg: token.colorBgContainer,
  itemActiveColor: token.colorPrimary,
  itemActiveColorHover: token.colorPrimaryHover,
  itemLinkBg: token.colorBgContainer,
  itemActiveColorDisabled: token.colorTextDisabled,
  itemActiveBgDisabled: token.controlItemBgActiveDisabled,
  itemInputBg: token.colorBgContainer,
  miniOptionsSizeChangerTop: 0,
  ...initComponentToken(token)
});
var prepareToken5 = (token) => merge(token, {
  inputOutlineOffset: 0,
  quickJumperInputWidth: token.calc(token.controlHeightLG).mul(1.25).equal(),
  paginationMiniOptionsMarginInlineStart: token.calc(token.marginXXS).div(2).equal(),
  paginationMiniQuickJumperInputWidth: token.calc(token.controlHeightLG).mul(1.1).equal(),
  paginationItemPaddingInline: token.calc(token.marginXXS).mul(1.5).equal(),
  paginationEllipsisLetterSpacing: token.calc(token.marginXXS).div(2).equal(),
  paginationSlashMarginInlineStart: token.marginSM,
  paginationSlashMarginInlineEnd: token.marginSM,
  paginationEllipsisTextIndent: "0.13em"
  // magic for ui experience
}, initInputToken(token));
var style_default35 = genStyleHooks("Pagination", (token) => {
  const paginationToken = prepareToken5(token);
  return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
}, prepareComponentToken30);

// node_modules/antd/es/pagination/style/bordered.js
var genBorderedStyle2 = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token.colorBgContainerDisabled,
        borderColor: token.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token.colorBgContainerDisabled,
          borderColor: token.colorBorder,
          a: {
            color: token.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token.itemActiveBgDisabled
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token.colorBgContainerDisabled,
          borderColor: token.colorBorder,
          color: token.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token.colorBgContainerDisabled,
          borderColor: token.colorBorder
        }
      }
    },
    [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token.colorPrimaryHover,
          backgroundColor: token.itemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token.itemLinkBg,
          borderColor: token.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token.colorPrimary,
          backgroundColor: token.itemBg,
          color: token.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token.colorBorder,
            color: token.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token.itemBg,
        border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token.colorPrimary,
          backgroundColor: token.itemBg,
          a: {
            color: token.colorPrimary
          }
        },
        "&-active": {
          borderColor: token.colorPrimary
        }
      }
    }
  };
};
var bordered_default = genSubStyleComponent(["Pagination", "bordered"], (token) => {
  const paginationToken = prepareToken5(token);
  return genBorderedStyle2(paginationToken);
}, prepareComponentToken30);

// node_modules/antd/es/pagination/useShowSizeChanger.js
var import_react91 = __toESM(require_react());
function useShowSizeChanger(showSizeChanger) {
  return (0, import_react91.useMemo)(() => {
    if (typeof showSizeChanger === "boolean") {
      return [showSizeChanger, {}];
    }
    if (showSizeChanger && typeof showSizeChanger === "object") {
      return [true, showSizeChanger];
    }
    return [void 0, void 0];
  }, [showSizeChanger]);
}

// node_modules/antd/es/pagination/Pagination.js
var Pagination2 = (props) => {
  const {
    align,
    prefixCls: customizePrefixCls,
    selectPrefixCls: customizeSelectPrefixCls,
    className,
    rootClassName,
    style,
    size: customizeSize,
    locale: customLocale,
    responsive,
    showSizeChanger,
    selectComponentClass,
    pageSizeOptions,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    xs
  } = useBreakpoint_default(responsive);
  const [, token] = useToken();
  const {
    getPrefixCls,
    direction,
    showSizeChanger: contextShowSizeChangerConfig,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("pagination");
  const prefixCls = getPrefixCls("pagination", customizePrefixCls);
  const [hashId, cssVarCls] = style_default35(prefixCls);
  const mergedSize = useSize_default(customizeSize);
  const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
  const mergedProps = {
    ...props,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const [contextLocale] = useLocale_default("Pagination", en_US_default);
  const locale2 = {
    ...contextLocale,
    ...customLocale
  };
  const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
  const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
  const mergedShowSizeChanger = propShowSizeChanger ?? contextShowSizeChanger;
  const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps ?? contextSizeChangerSelectProps;
  const SizeChanger = selectComponentClass || select_default;
  const mergedPageSizeOptions = React275.useMemo(() => {
    return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
  }, [pageSizeOptions]);
  const sizeChangerRender = (info) => {
    const {
      disabled,
      size: pageSize,
      onSizeChange,
      "aria-label": ariaLabel,
      className: sizeChangerClassName,
      options
    } = info;
    const {
      className: propSizeChangerClassName,
      onChange: propSizeChangerOnChange
    } = mergedShowSizeChangerSelectProps || {};
    const selectedValue = options.find((option) => String(option.value) === String(pageSize))?.value;
    return React275.createElement(SizeChanger, {
      disabled,
      showSearch: true,
      popupMatchSelectWidth: false,
      getPopupContainer: (triggerNode) => triggerNode.parentNode,
      "aria-label": ariaLabel,
      options,
      ...mergedShowSizeChangerSelectProps,
      value: selectedValue,
      onChange: (nextSize, option) => {
        onSizeChange?.(nextSize);
        propSizeChangerOnChange?.(nextSize, option);
      },
      size: isSmall ? "small" : "middle",
      className: clsx(sizeChangerClassName, propSizeChangerClassName)
    });
  };
  if (true) {
    const warning2 = devUseWarning("Pagination");
    true ? warning2(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.") : void 0;
  }
  const iconsProps = React275.useMemo(() => {
    const ellipsis = React275.createElement("span", {
      className: `${prefixCls}-item-ellipsis`
    }, "");
    const prevIcon = React275.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? React275.createElement(RightOutlined_default, null) : React275.createElement(LeftOutlined_default, null));
    const nextIcon = React275.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? React275.createElement(LeftOutlined_default, null) : React275.createElement(RightOutlined_default, null));
    const jumpPrevIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      React275.createElement("a", {
        className: `${prefixCls}-item-link`
      }, React275.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? React275.createElement(DoubleRightOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }) : React275.createElement(DoubleLeftOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    );
    const jumpNextIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      React275.createElement("a", {
        className: `${prefixCls}-item-link`
      }, React275.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? React275.createElement(DoubleLeftOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }) : React275.createElement(DoubleRightOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    );
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  }, [direction, prefixCls]);
  const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
  const extendedClassName = clsx({
    [`${prefixCls}-${align}`]: !!align,
    [`${prefixCls}-mini`]: isSmall,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-bordered`]: token.wireframe
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  return React275.createElement(React275.Fragment, null, token.wireframe && React275.createElement(bordered_default, {
    prefixCls
  }), React275.createElement(Pagination_default, {
    ...iconsProps,
    ...restProps,
    styles: mergedStyles,
    classNames: mergedClassNames,
    style: mergedStyle,
    prefixCls,
    selectPrefixCls,
    className: extendedClassName,
    locale: locale2,
    pageSizeOptions: mergedPageSizeOptions,
    showSizeChanger: mergedShowSizeChanger,
    sizeChangerRender
  }));
};
if (true) {
  Pagination2.displayName = "Pagination";
}
var Pagination_default2 = Pagination2;

// node_modules/antd/es/pagination/index.js
var pagination_default = Pagination_default2;

// node_modules/antd/es/spin/index.js
var React280 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/index.js
var React278 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/Looper.js
var React277 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/Progress.js
var React276 = __toESM(require_react());
var viewSize = 100;
var borderWidth = viewSize / 5;
var radius = viewSize / 2 - borderWidth / 2;
var circumference = radius * 2 * Math.PI;
var position = 50;
var CustomCircle = (props) => {
  const {
    dotClassName,
    style,
    hasCircleCls
  } = props;
  return React276.createElement("circle", {
    className: clsx(`${dotClassName}-circle`, {
      [`${dotClassName}-circle-bg`]: hasCircleCls
    }),
    r: radius,
    cx: position,
    cy: position,
    strokeWidth: borderWidth,
    style
  });
};
var Progress = ({
  percent,
  prefixCls
}) => {
  const dotClassName = `${prefixCls}-dot`;
  const holderClassName = `${dotClassName}-holder`;
  const hideClassName = `${holderClassName}-hidden`;
  const [render2, setRender] = React276.useState(false);
  useLayoutEffect_default(() => {
    if (percent !== 0) {
      setRender(true);
    }
  }, [percent !== 0]);
  const safePtg = Math.max(Math.min(percent, 100), 0);
  if (!render2) {
    return null;
  }
  const circleStyle = {
    strokeDashoffset: `${circumference / 4}`,
    strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
  };
  return React276.createElement("span", {
    className: clsx(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
  }, React276.createElement("svg", {
    viewBox: `0 0 ${viewSize} ${viewSize}`,
    role: "progressbar",
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-valuenow": safePtg
  }, React276.createElement(CustomCircle, {
    dotClassName,
    hasCircleCls: true
  }), React276.createElement(CustomCircle, {
    dotClassName,
    style: circleStyle
  })));
};
var Progress_default = Progress;

// node_modules/antd/es/spin/Indicator/Looper.js
function Looper(props) {
  const {
    prefixCls,
    percent = 0,
    className,
    style
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  const holderClassName = `${dotClassName}-holder`;
  const hideClassName = `${holderClassName}-hidden`;
  return React277.createElement(React277.Fragment, null, React277.createElement("span", {
    className: clsx(holderClassName, className, percent > 0 && hideClassName),
    style
  }, React277.createElement("span", {
    className: clsx(dotClassName, `${prefixCls}-dot-spin`)
  }, [1, 2, 3, 4].map((i) => React277.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: i
  })))), React277.createElement(Progress_default, {
    prefixCls,
    percent
  }));
}

// node_modules/antd/es/spin/Indicator/index.js
function Indicator(props) {
  const {
    prefixCls,
    indicator,
    percent,
    className,
    style
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator && React278.isValidElement(indicator)) {
    return cloneElement(indicator, (currentProps) => ({
      className: clsx(currentProps.className, dotClassName, className),
      style: {
        ...currentProps.style,
        ...style
      },
      percent
    }));
  }
  return React278.createElement(Looper, {
    prefixCls,
    percent,
    className,
    style
  });
}

// node_modules/antd/es/spin/style/index.js
var antSpinMove = new Keyframes_default("antSpinMove", {
  to: {
    opacity: 1
  }
});
var antRotate = new Keyframes_default("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
var genSpinStyle = (token) => {
  const {
    componentCls,
    calc
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "absolute",
      display: "none",
      color: token.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "relative",
        display: "inline-block",
        opacity: 1
      },
      [`${componentCls}-text`]: {
        fontSize: token.fontSize,
        paddingTop: calc(calc(token.dotSize).sub(token.fontSize)).div(2).add(2).equal()
      },
      "&-fullscreen": {
        position: "fixed",
        width: "100vw",
        height: "100vh",
        backgroundColor: token.colorBgMask,
        zIndex: token.zIndexPopupBase,
        inset: 0,
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        opacity: 0,
        visibility: "hidden",
        transition: `all ${token.motionDurationMid}`,
        "&-show": {
          opacity: 1,
          visibility: "visible"
        },
        [componentCls]: {
          [`${componentCls}-dot-holder`]: {
            color: token.colorWhite
          },
          [`${componentCls}-text`]: {
            color: token.colorTextLightSolid
          }
        }
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token.contentHeight,
          [`${componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: calc(token.dotSize).mul(-1).div(2).equal()
          },
          [`${componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            textShadow: `0 1px 2px ${token.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${componentCls}-show-text ${componentCls}-dot`]: {
            marginTop: calc(token.dotSize).div(2).mul(-1).sub(10).equal()
          },
          "&-sm": {
            [`${componentCls}-dot`]: {
              margin: calc(token.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token.dotSizeSM).sub(token.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          "&-lg": {
            [`${componentCls}-dot`]: {
              margin: calc(token.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token.dotSizeLG).sub(token.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token.colorBgContainer,
            opacity: 0,
            transition: `all ${token.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          "&::after": {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      "&-tip": {
        color: token.spinDotDefault
      },
      // holder
      // ------------------------------
      [`${componentCls}-dot-holder`]: {
        width: "1em",
        height: "1em",
        fontSize: token.dotSize,
        display: "inline-block",
        transition: `transform ${token.motionDurationSlow} ease, opacity ${token.motionDurationSlow} ease`,
        transformOrigin: "50% 50%",
        lineHeight: 1,
        color: token.colorPrimary,
        "&-hidden": {
          transform: "scale(0.3)",
          opacity: 0
        }
      },
      // progress
      // ------------------------------
      [`${componentCls}-dot-progress`]: {
        position: "absolute",
        inset: 0
      },
      // dots
      // ------------------------------
      [`${componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: calc(token.dotSize).sub(calc(token.marginXXS).div(2)).div(2).equal(),
          height: calc(token.dotSize).sub(calc(token.marginXXS).div(2)).div(2).equal(),
          background: "currentColor",
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0,
            animationDelay: "0s"
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        },
        "&-circle": {
          strokeLinecap: "round",
          transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${token.motionDurationSlow} ease`).join(","),
          fillOpacity: 0,
          stroke: "currentcolor"
        },
        "&-circle-bg": {
          stroke: token.colorFillSecondary
        }
      },
      // small
      [`&-sm ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token.dotSizeSM
        }
      },
      [`&-sm ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token.dotSizeSM).sub(calc(token.marginXXS).div(2))).div(2).equal(),
          height: calc(calc(token.dotSizeSM).sub(calc(token.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token.dotSizeLG
        }
      },
      [`&-lg ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token.dotSizeLG).sub(token.marginXXS)).div(2).equal(),
          height: calc(calc(token.dotSizeLG).sub(token.marginXXS)).div(2).equal()
        }
      },
      [`&${componentCls}-show-text ${componentCls}-text`]: {
        display: "block"
      }
    }
  };
};
var prepareComponentToken31 = (token) => {
  const {
    controlHeightLG,
    controlHeight
  } = token;
  return {
    contentHeight: 400,
    dotSize: controlHeightLG / 2,
    dotSizeSM: controlHeightLG * 0.35,
    dotSizeLG: controlHeight
  };
};
var style_default36 = genStyleHooks("Spin", (token) => {
  const spinToken = merge(token, {
    spinDotDefault: token.colorTextDescription
  });
  return genSpinStyle(spinToken);
}, prepareComponentToken31);

// node_modules/antd/es/spin/usePercent.js
var React279 = __toESM(require_react());
var AUTO_INTERVAL = 200;
var STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
function usePercent(spinning, percent) {
  const [mockPercent, setMockPercent] = React279.useState(0);
  const mockIntervalRef = React279.useRef(null);
  const isAuto = percent === "auto";
  React279.useEffect(() => {
    if (isAuto && spinning) {
      setMockPercent(0);
      mockIntervalRef.current = setInterval(() => {
        setMockPercent((prev) => {
          const restPTG = 100 - prev;
          for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
            const [limit, stepPtg] = STEP_BUCKETS[i];
            if (prev <= limit) {
              return prev + restPTG * stepPtg;
            }
          }
          return prev;
        });
      }, AUTO_INTERVAL);
    }
    return () => {
      if (mockIntervalRef.current) {
        clearInterval(mockIntervalRef.current);
        mockIntervalRef.current = null;
      }
    };
  }, [isAuto, spinning]);
  return isAuto ? mockPercent : percent;
}

// node_modules/antd/es/spin/index.js
var defaultIndicator;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !Number.isNaN(Number(delay));
}
var Spin = (props) => {
  const {
    prefixCls: customizePrefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style,
    children,
    fullscreen = false,
    indicator,
    percent,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    indicator: contextIndicator,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("spin");
  const prefixCls = getPrefixCls("spin", customizePrefixCls);
  const [hashId, cssVarCls] = style_default36(prefixCls);
  const [spinning, setSpinning] = React280.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
  const mergedPercent = usePercent(spinning, percent);
  React280.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        showSpinning?.cancel?.();
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = React280.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
  const mergedProps = {
    ...props,
    size,
    spinning,
    tip,
    fullscreen,
    children,
    percent: mergedPercent
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning2 = devUseWarning("Spin");
    true ? warning2(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.") : void 0;
  }
  const spinClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, !fullscreen && rootClassName, !fullscreen && mergedClassNames.root, hashId, cssVarCls);
  const containerClassName = clsx(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const mergedIndicator = indicator ?? contextIndicator ?? defaultIndicator;
  const mergedStyle = {
    ...contextStyle,
    ...style
  };
  const spinElement = React280.createElement("div", {
    ...restProps,
    style: fullscreen ? mergedStyle : {
      ...mergedStyles.root,
      ...mergedStyle
    },
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }, React280.createElement(Indicator, {
    className: mergedClassNames.indicator,
    style: mergedStyles.indicator,
    prefixCls,
    indicator: mergedIndicator,
    percent: mergedPercent
  }), tip && (isNestedPattern || fullscreen) ? React280.createElement("div", {
    className: clsx(`${prefixCls}-text`, mergedClassNames.tip),
    style: mergedStyles.tip
  }, tip) : null);
  if (isNestedPattern) {
    return React280.createElement("div", {
      ...restProps,
      className: clsx(`${prefixCls}-nested-loading`, wrapperClassName, mergedClassNames.wrapper, hashId, cssVarCls),
      style: mergedStyles.wrapper
    }, spinning && React280.createElement("div", {
      key: "loading"
    }, spinElement), React280.createElement("div", {
      className: containerClassName,
      key: "container"
    }, children));
  }
  if (fullscreen) {
    return React280.createElement("div", {
      className: clsx(`${prefixCls}-fullscreen`, {
        [`${prefixCls}-fullscreen-show`]: spinning
      }, rootClassName, hashId, cssVarCls, mergedClassNames.mask),
      style: mergedStyles.mask
    }, spinElement);
  }
  return spinElement;
};
Spin.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
if (true) {
  Spin.displayName = "Spin";
}
var spin_default = Spin;

// node_modules/antd/es/list/context.js
var import_react92 = __toESM(require_react());
var ListContext = import_react92.default.createContext({});
var ListConsumer = ListContext.Consumer;

// node_modules/antd/es/list/Item.js
var import_react93 = __toESM(require_react());
var Meta = ({
  prefixCls: customizePrefixCls,
  className,
  avatar,
  title,
  description,
  ...others
}) => {
  const {
    getPrefixCls
  } = (0, import_react93.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const classString = clsx(`${prefixCls}-item-meta`, className);
  const content = import_react93.default.createElement("div", {
    className: `${prefixCls}-item-meta-content`
  }, title && import_react93.default.createElement("h4", {
    className: `${prefixCls}-item-meta-title`
  }, title), description && import_react93.default.createElement("div", {
    className: `${prefixCls}-item-meta-description`
  }, description));
  return import_react93.default.createElement("div", {
    ...others,
    className: classString
  }, avatar && import_react93.default.createElement("div", {
    className: `${prefixCls}-item-meta-avatar`
  }, avatar), (title || description) && content);
};
var InternalItem = import_react93.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    actions,
    extra,
    styles,
    className,
    classNames: customizeClassNames,
    colStyle,
    ...others
  } = props;
  const {
    grid,
    itemLayout
  } = (0, import_react93.useContext)(ListContext);
  const {
    getPrefixCls,
    list
  } = (0, import_react93.useContext)(ConfigContext);
  const moduleClass = (moduleName) => clsx(list?.item?.classNames?.[moduleName], customizeClassNames?.[moduleName]);
  const moduleStyle = (moduleName) => ({
    ...list?.item?.styles?.[moduleName],
    ...styles?.[moduleName]
  });
  const isItemContainsTextNodeAndNotSingular = () => {
    const childNodes = toArray(children);
    const hasTextNode = childNodes.some((node) => typeof node === "string");
    return hasTextNode && childNodes.length > 1;
  };
  const isFlexMode = () => {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  };
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const actionsContent = actions && actions.length > 0 && import_react93.default.createElement("ul", {
    className: clsx(`${prefixCls}-item-action`, moduleClass("actions")),
    key: "actions",
    style: moduleStyle("actions")
  }, actions.map((action, i) => (
    // eslint-disable-next-line react/no-array-index-key
    import_react93.default.createElement("li", {
      key: `${prefixCls}-item-action-${i}`
    }, action, i !== actions.length - 1 && import_react93.default.createElement("em", {
      className: `${prefixCls}-item-action-split`
    }))
  )));
  const Element3 = grid ? "div" : "li";
  const itemChildren = import_react93.default.createElement(Element3, {
    ...others,
    ...!grid ? {
      ref
    } : {},
    className: clsx(`${prefixCls}-item`, {
      [`${prefixCls}-item-no-flex`]: !isFlexMode()
    }, className)
  }, itemLayout === "vertical" && extra ? [import_react93.default.createElement("div", {
    className: `${prefixCls}-item-main`,
    key: "content"
  }, children, actionsContent), import_react93.default.createElement("div", {
    className: clsx(`${prefixCls}-item-extra`, moduleClass("extra")),
    key: "extra",
    style: moduleStyle("extra")
  }, extra)] : [children, actionsContent, cloneElement(extra, {
    key: "extra"
  })]);
  return grid ? import_react93.default.createElement(col_default, {
    ref,
    flex: 1,
    style: colStyle
  }, itemChildren) : itemChildren;
});
var Item2 = InternalItem;
Item2.Meta = Meta;
var Item_default3 = Item2;

// node_modules/antd/es/list/style/index.js
var genBorderedStyle3 = (token) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    itemPaddingSM,
    itemPaddingLG,
    marginLG,
    borderRadiusLG
  } = token;
  const innerCornerBorderRadius = unit(token.calc(borderRadiusLG).sub(token.lineWidth).equal());
  return {
    [listBorderedCls]: {
      border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header`]: {
        borderRadius: `${innerCornerBorderRadius} ${innerCornerBorderRadius} 0 0`
      },
      [`${componentCls}-footer`]: {
        borderRadius: `0 0 ${innerCornerBorderRadius} ${innerCornerBorderRadius}`
      },
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${unit(margin)} ${unit(marginLG)}`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingLG
      }
    }
  };
};
var genResponsiveStyle = (token) => {
  const {
    componentCls,
    screenSM,
    screenMD,
    marginLG,
    marginSM,
    margin
  } = token;
  return {
    [`@media screen and (max-width:${screenMD}px)`]: {
      [componentCls]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM}px)`]: {
      [componentCls]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${unit(margin)}`
          }
        }
      }
    }
  };
};
var genBaseStyle7 = (token) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    itemPadding,
    colorPrimary,
    itemPaddingSM,
    itemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth,
    headerBg,
    footerBg,
    emptyTextPadding,
    metaMarginBottom,
    avatarMarginRight,
    titleMarginBottom,
    descriptionFontSize
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      // fix https://github.com/ant-design/ant-design/issues/46177
      ["--rc-virtual-list-scrollbar-bg"]: token.colorSplit,
      "*": {
        outline: "none"
      },
      [`${componentCls}-header`]: {
        background: headerBg
      },
      [`${componentCls}-footer`]: {
        background: footerBg
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: {
        marginBlockStart: marginLG,
        // https://github.com/ant-design/ant-design/issues/20037
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: itemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: avatarMarginRight
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            margin: `0 0 ${unit(token.marginXXS)} 0`,
            color: colorText,
            fontSize: token.fontSize,
            lineHeight: token.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              "&:hover": {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: descriptionFontSize,
            lineHeight: token.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          "& > li": {
            position: "relative",
            display: "inline-block",
            padding: `0 ${unit(paddingXS)}`,
            color: colorTextDescription,
            fontSize: token.fontSize,
            lineHeight: token.lineHeight,
            textAlign: "center",
            "&:first-child": {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: token.calc(token.fontHeight).sub(token.calc(token.marginXXS).mul(2)).equal(),
            transform: "translateY(-50%)",
            backgroundColor: token.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${unit(padding)} 0`,
        color: colorTextDescription,
        fontSize: token.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding: emptyTextPadding,
        color: token.colorTextDisabled,
        fontSize: token.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    },
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: metaMarginBottom,
        [`${componentCls}-item-meta-title`]: {
          marginBlockStart: 0,
          marginBlockEnd: titleMarginBottom,
          color: colorText,
          fontSize: token.fontSizeLG,
          lineHeight: token.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${unit(padding)}`,
          "&:first-child": {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`,
      "&:last-child": {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${unit(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: itemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: itemPaddingSM
    },
    // Horizontal
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
};
var prepareComponentToken32 = (token) => ({
  contentWidth: 220,
  itemPadding: `${unit(token.paddingContentVertical)} 0`,
  itemPaddingSM: `${unit(token.paddingContentVerticalSM)} ${unit(token.paddingContentHorizontal)}`,
  itemPaddingLG: `${unit(token.paddingContentVerticalLG)} ${unit(token.paddingContentHorizontalLG)}`,
  headerBg: "transparent",
  footerBg: "transparent",
  emptyTextPadding: token.padding,
  metaMarginBottom: token.padding,
  avatarMarginRight: token.padding,
  titleMarginBottom: token.paddingSM,
  descriptionFontSize: token.fontSize
});
var style_default37 = genStyleHooks("List", (token) => {
  const listToken = merge(token, {
    listBorderedCls: `${token.componentCls}-bordered`,
    minHeight: token.controlHeightLG
  });
  return [genBaseStyle7(listToken), genBorderedStyle3(listToken), genResponsiveStyle(listToken)];
}, prepareComponentToken32);

// node_modules/antd/es/list/index.js
var InternalList = (props, ref) => {
  const {
    pagination = false,
    prefixCls: customizePrefixCls,
    bordered = false,
    split = true,
    className,
    rootClassName,
    style,
    children,
    itemLayout,
    loadMore,
    grid,
    dataSource = [],
    size: customizeSize,
    header,
    footer,
    loading = false,
    rowKey,
    renderItem: renderItem2,
    locale: locale2,
    ...rest
  } = props;
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  const [paginationCurrent, setPaginationCurrent] = React283.useState(paginationObj.defaultCurrent || 1);
  const [paginationSize, setPaginationSize] = React283.useState(paginationObj.defaultPageSize || 10);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("list");
  const {
    renderEmpty
  } = React283.useContext(ConfigContext);
  const defaultPaginationProps = {
    current: 1,
    total: 0,
    position: "bottom"
  };
  const triggerPaginationEvent = (eventName) => (page, pageSize) => {
    setPaginationCurrent(page);
    setPaginationSize(pageSize);
    if (pagination) {
      pagination?.[eventName]?.(page, pageSize);
    }
  };
  const onPaginationChange = triggerPaginationEvent("onChange");
  const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  const renderInternalItem = (item, index2) => {
    if (!renderItem2) {
      return null;
    }
    let key;
    if (typeof rowKey === "function") {
      key = rowKey(item);
    } else if (rowKey) {
      key = item[rowKey];
    } else {
      key = item.key;
    }
    if (!key) {
      key = `list-item-${index2}`;
    }
    return React283.createElement(React283.Fragment, {
      key
    }, renderItem2(item, index2));
  };
  const isSomethingAfterLastItem = !!(loadMore || pagination || footer);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const [hashId, cssVarCls] = style_default37(prefixCls);
  let loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  const isLoading = !!loadingProp?.spinning;
  const mergedSize = useSize_default(customizeSize);
  let sizeCls = "";
  switch (mergedSize) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
    default:
      break;
  }
  const classString = clsx(prefixCls, {
    [`${prefixCls}-vertical`]: itemLayout === "vertical",
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-split`]: split,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-loading`]: isLoading,
    [`${prefixCls}-grid`]: !!grid,
    [`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, hashId, cssVarCls);
  const paginationProps = extendsObject_default(defaultPaginationProps, {
    total: dataSource.length,
    current: paginationCurrent,
    pageSize: paginationSize
  }, pagination || {});
  const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  paginationProps.current = Math.min(paginationProps.current, largestPage);
  const paginationContent = pagination && React283.createElement("div", {
    className: clsx(`${prefixCls}-pagination`)
  }, React283.createElement(pagination_default, {
    align: "end",
    ...paginationProps,
    onChange: onPaginationChange,
    onShowSizeChange: onPaginationShowSizeChange
  }));
  let splitDataSource = _toConsumableArray(dataSource);
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
    }
  }
  const needResponsive = Object.keys(grid || {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint_default(needResponsive);
  const currentBreakpoint = React283.useMemo(() => {
    for (let i = 0; i < responsiveArray.length; i += 1) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens]);
  const colStyle = React283.useMemo(() => {
    if (!grid) {
      return void 0;
    }
    const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: `${100 / columnCount}%`,
        maxWidth: `${100 / columnCount}%`
      };
    }
  }, [JSON.stringify(grid), currentBreakpoint]);
  let childrenContent = isLoading && React283.createElement("div", {
    style: {
      minHeight: 53
    }
  });
  if (splitDataSource.length > 0) {
    const items = splitDataSource.map(renderInternalItem);
    childrenContent = grid ? React283.createElement(row_default, {
      gutter: grid.gutter
    }, React283.Children.map(items, (child) => React283.createElement("div", {
      key: child?.key,
      style: colStyle
    }, child))) : React283.createElement("ul", {
      className: `${prefixCls}-items`
    }, items);
  } else if (!children && !isLoading) {
    childrenContent = React283.createElement("div", {
      className: `${prefixCls}-empty-text`
    }, locale2?.emptyText || renderEmpty?.("List") || React283.createElement(defaultRenderEmpty_default, {
      componentName: "List"
    }));
  }
  const paginationPosition = paginationProps.position;
  const contextValue = React283.useMemo(() => ({
    grid,
    itemLayout
  }), [JSON.stringify(grid), itemLayout]);
  if (true) {
    const warning2 = devUseWarning("List");
    true ? warning2(false, "deprecated", "The `List` component is deprecated. And will be removed in next major version.") : void 0;
  }
  return React283.createElement(ListContext.Provider, {
    value: contextValue
  }, React283.createElement("div", {
    ref,
    style: {
      ...contextStyle,
      ...style
    },
    className: classString,
    ...rest
  }, (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && React283.createElement("div", {
    className: `${prefixCls}-header`
  }, header), React283.createElement(spin_default, {
    ...loadingProp
  }, childrenContent, children), footer && React283.createElement("div", {
    className: `${prefixCls}-footer`
  }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent));
};
var ListWithForwardRef = React283.forwardRef(InternalList);
if (true) {
  ListWithForwardRef.displayName = "Deprecated.List";
}
var List = ListWithForwardRef;
List.Item = Item_default3;
var list_default = List;

// node_modules/antd/es/masonry/Masonry.js
var React288 = __toESM(require_react());

// node_modules/antd/es/masonry/hooks/useDelay.js
var React284 = __toESM(require_react());
function useDelay(callback) {
  const idRef = React284.useRef(0);
  const clearRaf = () => {
    raf_default.cancel(idRef.current);
  };
  React284.useEffect(() => clearRaf, []);
  const triggerFn = useEvent_default(() => {
    clearRaf();
    idRef.current = raf_default(callback);
  });
  return triggerFn;
}

// node_modules/antd/es/masonry/hooks/usePositions.js
var React285 = __toESM(require_react());
function usePositions(itemHeights, columnCount, verticalGutter) {
  const [orderItemPositions, orderTotalHeight] = React285.useMemo(() => {
    const columnHeights = new Array(columnCount).fill(0);
    const itemPositions = /* @__PURE__ */ new Map();
    for (let i = 0; i < itemHeights.length; i += 1) {
      const [itemKey2, itemHeight, itemColumn] = itemHeights[i];
      let targetColumnIndex = itemColumn ?? columnHeights.indexOf(Math.min.apply(Math, _toConsumableArray(columnHeights)));
      targetColumnIndex = Math.min(targetColumnIndex, columnCount - 1);
      const top = columnHeights[targetColumnIndex];
      itemPositions.set(itemKey2, {
        column: targetColumnIndex,
        top
      });
      columnHeights[targetColumnIndex] += itemHeight + verticalGutter;
    }
    return [itemPositions, Math.max(0, Math.max.apply(Math, _toConsumableArray(columnHeights)) - verticalGutter)];
  }, [columnCount, itemHeights, verticalGutter]);
  return [orderItemPositions, orderTotalHeight];
}

// node_modules/antd/es/masonry/hooks/useRefs.js
var React286 = __toESM(require_react());
function useRefs() {
  const refs = React286.useRef(null);
  if (refs.current === null) {
    refs.current = /* @__PURE__ */ new Map();
  }
  const setRef = (key, element) => {
    refs.current.set(key, element);
  };
  const getRef = (key) => refs.current.get(key);
  return [setRef, getRef];
}

// node_modules/antd/es/masonry/MasonryItem.js
var import_react94 = __toESM(require_react());
var MasonryItem = import_react94.default.forwardRef((props, ref) => {
  const {
    item,
    style,
    prefixCls,
    itemRender,
    className,
    index: index2,
    column,
    onResize
  } = props;
  const itemPrefix = `${prefixCls}-item`;
  const renderNode = (0, import_react94.useMemo)(() => {
    return item.children ?? itemRender?.({
      ...item,
      index: index2,
      column
    });
  }, [item, itemRender, column, index2]);
  let returnNode = import_react94.default.createElement("div", {
    ref,
    style,
    className: clsx(itemPrefix, className)
  }, renderNode);
  if (onResize) {
    returnNode = import_react94.default.createElement(es_default3, {
      onResize
    }, returnNode);
  }
  return returnNode;
});
if (true) {
  MasonryItem.displayName = "MasonryItem";
}
var MasonryItem_default = MasonryItem;

// node_modules/antd/es/masonry/style/index.js
var genMasonryStyle = (token) => {
  const {
    componentCls
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      position: "relative",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      flexWrap: "wrap",
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${itemCls}`]: {
        boxSizing: "border-box",
        // Motion
        "&-fade": {
          "&-appear": {
            transition: `opacity ${token.motionDurationSlow} ${token.motionEaseOut}`,
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            transition: `opacity ${token.motionDurationFast} ${token.motionEaseOut}`,
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          }
        },
        [`&:not(${itemCls}-fade)`]: {
          transition: ["left", "right", "top"].map((prop) => `${prop} ${token.motionDurationSlow} ${token.motionEaseOut}`).join(",")
        }
      }
    }
  };
};
var style_default38 = genStyleHooks("Masonry", (token) => [genMasonryStyle(token)]);

// node_modules/antd/es/masonry/Masonry.js
var Masonry = React288.forwardRef((props, ref) => {
  const {
    rootClassName,
    className,
    style,
    classNames,
    styles,
    columns,
    prefixCls: customizePrefixCls,
    gutter = 0,
    items,
    itemRender,
    onLayoutChange,
    fresh
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("masonry");
  const prefixCls = getPrefixCls("masonry", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default38(prefixCls, rootCls);
  const containerRef = React288.useRef(null);
  React288.useImperativeHandle(ref, () => ({
    nativeElement: containerRef.current
  }));
  const [setItemRef, getItemRef] = useRefs();
  const [mergedItems, setMergedItems] = React288.useState([]);
  React288.useEffect(() => {
    setMergedItems(items || []);
  }, [items]);
  const screens = useBreakpoint_default();
  const gutters = useGutter(gutter, screens);
  const [horizontalGutter = 0, verticalGutter = horizontalGutter] = gutters;
  const columnCount = React288.useMemo(() => {
    if (!columns) {
      return 3;
    }
    if (typeof columns === "number") {
      return columns;
    }
    const matchingBreakpoint = responsiveArray.find((breakpoint) => screens[breakpoint] && columns[breakpoint] !== void 0);
    if (matchingBreakpoint) {
      return columns[matchingBreakpoint];
    }
    return columns.xs ?? 1;
  }, [columns, screens]);
  const mergedProps = {
    ...props,
    columns: columnCount
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const [itemHeights, setItemHeights] = React288.useState([]);
  const collectItemSize = useDelay(() => {
    const nextItemsHeight = mergedItems.map((item, index2) => {
      const itemKey2 = item.key ?? index2;
      const itemEle = getItemRef(itemKey2);
      const rect = itemEle?.getBoundingClientRect();
      return [itemKey2, rect ? rect.height : 0, item.column];
    });
    setItemHeights((prevItemsHeight) => isEqual_default(prevItemsHeight, nextItemsHeight) ? prevItemsHeight : nextItemsHeight);
  });
  const [itemPositions, totalHeight] = usePositions(itemHeights, columnCount, verticalGutter);
  const itemWithPositions = React288.useMemo(() => mergedItems.map((item, index2) => {
    const key = item.key ?? index2;
    return {
      item,
      itemIndex: index2,
      // CSSMotion will transform key to string.
      // Let's keep the original key here.
      itemKey: key,
      key,
      position: itemPositions.get(key)
    };
  }), [mergedItems, itemPositions]);
  React288.useEffect(() => {
    collectItemSize();
  }, [mergedItems, columnCount]);
  const [itemColumns, setItemColumns] = React288.useState([]);
  useLayoutEffect_default(() => {
    if (onLayoutChange && itemWithPositions.every(({
      position: position2
    }) => position2)) {
      setItemColumns((prevItemColumns) => {
        const nextItemColumns = itemWithPositions.map(({
          item,
          position: position2
        }) => [item, position2.column]);
        return isEqual_default(prevItemColumns, nextItemColumns) ? prevItemColumns : nextItemColumns;
      });
    }
  }, [itemWithPositions]);
  useLayoutEffect_default(() => {
    if (onLayoutChange && items && items.length === itemColumns.length) {
      onLayoutChange(itemColumns.map(([item, column]) => ({
        ...item,
        column
      })));
    }
  }, [itemColumns]);
  return React288.createElement(es_default3, {
    onResize: collectItemSize
  }, React288.createElement("div", {
    ref: containerRef,
    className: clsx(prefixCls, contextClassName, mergedClassNames.root, rootClassName, className, hashId, cssVarCls, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }),
    style: {
      height: totalHeight,
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    // Listen for image events
    onLoad: collectItemSize,
    onError: collectItemSize
  }, React288.createElement(CSSMotionList_default, {
    keys: itemWithPositions,
    component: false,
    // Motion config
    motionAppear: true,
    motionLeave: true,
    motionName: `${prefixCls}-item-fade`
  }, (motionInfo, motionRef) => {
    const {
      item,
      itemKey: itemKey2,
      position: position2 = {},
      itemIndex,
      key,
      className: motionClassName,
      style: motionStyle
    } = motionInfo;
    const {
      column: columnIndex = 0
    } = position2;
    const itemStyle = {
      "--item-width": `calc((100% + ${horizontalGutter}px) / ${columnCount})`,
      insetInlineStart: `calc(var(--item-width) * ${columnIndex})`,
      width: `calc(var(--item-width) - ${horizontalGutter}px)`,
      top: position2.top,
      position: "absolute"
    };
    return React288.createElement(MasonryItem_default, {
      prefixCls,
      key,
      item,
      style: {
        ...motionStyle,
        ...mergedStyles.item,
        ...itemStyle
      },
      className: clsx(mergedClassNames.item, motionClassName),
      ref: composeRef(motionRef, (ele) => setItemRef(itemKey2, ele)),
      index: itemIndex,
      itemRender,
      column: columnIndex,
      onResize: fresh ? collectItemSize : null
    });
  })));
});
if (true) {
  Masonry.displayName = "Masonry";
}
var Masonry_default = Masonry;

// node_modules/antd/es/masonry/index.js
var masonry_default = Masonry_default;

// node_modules/antd/es/mentions/index.js
var React294 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/Mentions.js
var import_react98 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/hooks/useEffectState.js
var import_react95 = __toESM(require_react());
function useEffectState() {
  const [effectId, setEffectId] = (0, import_react95.useState)({
    id: 0,
    callback: null
  });
  const update = (0, import_react95.useCallback)((callback) => {
    setEffectId(({
      id
    }) => ({
      id: id + 1,
      callback
    }));
  }, []);
  (0, import_react95.useEffect)(() => {
    effectId.callback?.();
  }, [effectId]);
  return update;
}

// node_modules/@rc-component/mentions/es/KeywordTrigger.js
var React291 = __toESM(require_react());
var import_react97 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/DropdownMenu.js
var import_react96 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/MentionsContext.js
var React289 = __toESM(require_react());
var MentionsContext = React289.createContext(null);
var MentionsContext_default = MentionsContext;

// node_modules/@rc-component/mentions/es/DropdownMenu.js
function DropdownMenu(props) {
  const {
    notFoundContent,
    activeIndex,
    setActiveIndex,
    selectOption,
    onFocus,
    onBlur,
    onScroll
  } = import_react96.default.useContext(MentionsContext_default);
  const {
    prefixCls,
    options,
    opened
  } = props;
  const activeOption = options[activeIndex] || {};
  const menuRef = (0, import_react96.useRef)(null);
  (0, import_react96.useEffect)(() => {
    if (activeIndex === -1 || !menuRef.current || !opened) {
      return;
    }
    const activeItem = menuRef.current?.findItem?.({
      key: activeOption.key
    });
    if (activeItem) {
      activeItem.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }, [activeIndex, activeOption.key, opened]);
  return import_react96.default.createElement(es_default10, {
    ref: menuRef,
    prefixCls: `${prefixCls}-menu`,
    activeKey: activeOption.key,
    onSelect: ({
      key
    }) => {
      const option = options.find(({
        key: optionKey
      }) => optionKey === key);
      selectOption(option);
    },
    onFocus,
    onBlur,
    onScroll
  }, options.map((option, index2) => {
    const {
      key,
      disabled,
      className,
      style,
      label
    } = option;
    return import_react96.default.createElement(MenuItem_default, {
      key,
      disabled,
      className,
      style,
      onMouseEnter: () => {
        setActiveIndex(index2);
      }
    }, label);
  }), !options.length && import_react96.default.createElement(MenuItem_default, {
    disabled: true
  }, notFoundContent));
}
var DropdownMenu_default = DropdownMenu;

// node_modules/@rc-component/mentions/es/KeywordTrigger.js
var BUILT_IN_PLACEMENTS2 = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
var KeywordTrigger = (props) => {
  const {
    prefixCls,
    options,
    children,
    visible,
    transitionName,
    getPopupContainer,
    popupClassName,
    popupStyle,
    direction,
    placement
  } = props;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const [opened, setOpened] = React291.useState(false);
  const dropdownElement = React291.createElement(DropdownMenu_default, {
    prefixCls: dropdownPrefix,
    options,
    opened
  });
  const dropdownPlacement = (0, import_react97.useMemo)(() => {
    let popupPlacement;
    if (direction === "rtl") {
      popupPlacement = placement === "top" ? "topLeft" : "bottomLeft";
    } else {
      popupPlacement = placement === "top" ? "topRight" : "bottomRight";
    }
    return popupPlacement;
  }, [direction, placement]);
  return React291.createElement(es_default5, {
    prefixCls: dropdownPrefix,
    popupVisible: visible,
    popup: dropdownElement,
    popupPlacement: dropdownPlacement,
    popupMotion: {
      motionName: transitionName
    },
    builtinPlacements: BUILT_IN_PLACEMENTS2,
    getPopupContainer,
    popupClassName,
    popupStyle,
    afterOpenChange: setOpened
  }, children);
};
var KeywordTrigger_default = KeywordTrigger;

// node_modules/@rc-component/mentions/es/Option.js
var Option3 = () => null;
var Option_default = Option3;

// node_modules/@rc-component/mentions/es/util.js
function getBeforeSelectionText(input) {
  const {
    selectionStart
  } = input;
  return input.value.slice(0, selectionStart);
}
function getLastMeasureIndex(text, prefix) {
  return prefix.reduce((lastMatch, prefixStr) => {
    const lastIndex = text.lastIndexOf(prefixStr);
    if (lastIndex > lastMatch.location) {
      return {
        location: lastIndex,
        prefix: prefixStr
      };
    }
    return lastMatch;
  }, {
    location: -1,
    prefix: ""
  });
}
function lower(char) {
  return (char || "").toLowerCase();
}
function reduceText(text, targetText, split) {
  const firstChar = text[0];
  if (!firstChar || firstChar === split) {
    return text;
  }
  let restText = text;
  const targetTextLen = targetText.length;
  for (let i = 0; i < targetTextLen; i += 1) {
    if (lower(restText[i]) !== lower(targetText[i])) {
      restText = restText.slice(i);
      break;
    } else if (i === targetTextLen - 1) {
      restText = restText.slice(targetTextLen);
    }
  }
  return restText;
}
function replaceWithMeasure(text, measureConfig) {
  const {
    measureLocation,
    prefix,
    targetText,
    selectionStart,
    split
  } = measureConfig;
  let beforeMeasureText = text.slice(0, measureLocation);
  if (beforeMeasureText[beforeMeasureText.length - split.length] === split) {
    beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split.length);
  }
  if (beforeMeasureText) {
    beforeMeasureText = `${beforeMeasureText}${split}`;
  }
  let restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix.length), split);
  if (restText.slice(0, split.length) === split) {
    restText = restText.slice(split.length);
  }
  const connectedStartText = `${beforeMeasureText}${prefix}${targetText}${split}`;
  return {
    text: `${connectedStartText}${restText}`,
    selectionLocation: connectedStartText.length
  };
}
function setInputSelection(input, location) {
  input.setSelectionRange(location, location);
  input.blur();
  input.focus();
}
function validateSearch(text, split) {
  return !split || text.indexOf(split) === -1;
}
function filterOption(input, {
  value = ""
}) {
  const lowerCase = input.toLowerCase();
  return value.toLowerCase().indexOf(lowerCase) !== -1;
}

// node_modules/@rc-component/mentions/es/context.js
var React292 = __toESM(require_react());
var UnstableContext = React292.createContext({});

// node_modules/@rc-component/mentions/es/Mentions.js
function _extends51() {
  _extends51 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends51.apply(this, arguments);
}
var InternalMentions = (0, import_react98.forwardRef)((props, ref) => {
  const {
    // Style
    prefixCls,
    className,
    style,
    classNames: mentionClassNames,
    styles,
    // Misc
    prefix = "@",
    split = " ",
    notFoundContent = "Not Found",
    value,
    defaultValue,
    children,
    options,
    allowClear,
    hasWrapper,
    silent,
    // Events
    validateSearch: validateSearch2 = validateSearch,
    filterOption: filterOption2 = filterOption,
    onChange,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onPressEnter,
    onSearch,
    onSelect,
    onFocus,
    onBlur,
    // Dropdown
    transitionName,
    placement,
    direction,
    getPopupContainer,
    popupClassName,
    rows = 1,
    // Fix Warning: Received `false` for a non-boolean attribute `visible`.
    // https://github.com/ant-design/ant-design/blob/df933e94efc8f376003bbdc658d64b64a0e53495/components/mentions/demo/render-panel.tsx
    // @ts-expect-error
    visible,
    onPopupScroll,
    // Rest
    ...restProps
  } = props;
  const mergedPrefix = (0, import_react98.useMemo)(() => Array.isArray(prefix) ? prefix : [prefix], [prefix]);
  const containerRef = (0, import_react98.useRef)(null);
  const textareaRef = (0, import_react98.useRef)(null);
  const measureRef = (0, import_react98.useRef)(null);
  const getTextArea = () => textareaRef.current?.resizableTextArea?.textArea;
  import_react98.default.useImperativeHandle(ref, () => ({
    focus: () => textareaRef.current?.focus(),
    blur: () => textareaRef.current?.blur(),
    textarea: textareaRef.current?.resizableTextArea?.textArea,
    nativeElement: containerRef.current
  }));
  const [measuring, setMeasuring] = (0, import_react98.useState)(false);
  const [measureText, setMeasureText] = (0, import_react98.useState)("");
  const [measurePrefix, setMeasurePrefix] = (0, import_react98.useState)("");
  const [measureLocation, setMeasureLocation] = (0, import_react98.useState)(0);
  const [activeIndex, setActiveIndex] = (0, import_react98.useState)(0);
  const [isFocus, setIsFocus] = (0, import_react98.useState)(false);
  const uniqueKey2 = useId_default(props.id);
  const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", value);
  const {
    open: open3
  } = (0, import_react98.useContext)(UnstableContext);
  (0, import_react98.useEffect)(() => {
    if (measuring && measureRef.current) {
      measureRef.current.scrollTop = getTextArea().scrollTop;
    }
  }, [measuring]);
  const [mergedMeasuring, mergedMeasureText, mergedMeasurePrefix, mergedMeasureLocation] = import_react98.default.useMemo(() => {
    if (open3) {
      for (let i = 0; i < mergedPrefix.length; i += 1) {
        const curPrefix = mergedPrefix[i];
        const index2 = mergedValue.lastIndexOf(curPrefix);
        if (index2 >= 0) {
          return [true, "", curPrefix, index2];
        }
      }
    }
    return [measuring, measureText, measurePrefix, measureLocation];
  }, [open3, measuring, mergedPrefix, mergedValue, measureText, measurePrefix, measureLocation]);
  const getOptions = import_react98.default.useCallback((targetMeasureText) => {
    let list;
    if (options && options.length > 0) {
      list = options.map((item) => ({
        ...item,
        key: `${item?.key ?? item.value}-${uniqueKey2}`
      }));
    } else {
      list = toArray(children).map(({
        props: optionProps,
        key
      }) => ({
        ...optionProps,
        label: optionProps.children,
        key: `${key || optionProps.value}-${uniqueKey2}`
      }));
    }
    return list.filter((option) => {
      if (filterOption2 === false) {
        return true;
      }
      return filterOption2(targetMeasureText, option);
    });
  }, [options, uniqueKey2, children, filterOption2]);
  const mergedOptions = import_react98.default.useMemo(() => getOptions(mergedMeasureText), [getOptions, mergedMeasureText]);
  const onSelectionEffect = useEffectState();
  const startMeasure = (nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {
    setMeasuring(true);
    setMeasureText(nextMeasureText);
    setMeasurePrefix(nextMeasurePrefix);
    setMeasureLocation(nextMeasureLocation);
    setActiveIndex(0);
  };
  const stopMeasure = (callback) => {
    setMeasuring(false);
    setMeasureLocation(0);
    setMeasureText("");
    onSelectionEffect(callback);
  };
  const triggerChange = (nextValue) => {
    setMergedValue(nextValue);
    onChange?.(nextValue);
  };
  const onInternalChange = ({
    target: {
      value: nextValue
    }
  }) => {
    triggerChange(nextValue);
  };
  const selectOption = (option) => {
    const {
      value: mentionValue = ""
    } = option;
    const {
      text,
      selectionLocation
    } = replaceWithMeasure(mergedValue, {
      measureLocation: mergedMeasureLocation,
      targetText: mentionValue,
      prefix: mergedMeasurePrefix,
      selectionStart: getTextArea()?.selectionStart,
      split
    });
    triggerChange(text);
    stopMeasure(() => {
      setInputSelection(getTextArea(), selectionLocation);
    });
    onSelect?.(option, mergedMeasurePrefix);
  };
  const onInternalKeyDown = (event) => {
    const {
      which
    } = event;
    onKeyDown2?.(event);
    if (!mergedMeasuring) {
      return;
    }
    if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
      const optionLen = mergedOptions.length;
      const offset3 = which === KeyCode_default.UP ? -1 : 1;
      const newActiveIndex = (activeIndex + offset3 + optionLen) % optionLen;
      setActiveIndex(newActiveIndex);
      event.preventDefault();
    } else if (which === KeyCode_default.ESC) {
      stopMeasure();
    } else if (which === KeyCode_default.ENTER) {
      event.preventDefault();
      if (silent) {
        return;
      }
      if (!mergedOptions.length) {
        stopMeasure();
        return;
      }
      const option = mergedOptions[activeIndex];
      selectOption(option);
    }
  };
  const onInternalKeyUp = (event) => {
    const {
      key,
      which
    } = event;
    const target = event.target;
    const selectionStartText = getBeforeSelectionText(target);
    const {
      location: measureIndex,
      prefix: nextMeasurePrefix
    } = getLastMeasureIndex(selectionStartText, mergedPrefix);
    onKeyUp?.(event);
    if ([KeyCode_default.ESC, KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.ENTER].indexOf(which) !== -1) {
      return;
    }
    if (measureIndex !== -1) {
      const nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);
      const validateMeasure = validateSearch2(nextMeasureText, split);
      const matchOption = !!getOptions(nextMeasureText).length;
      if (validateMeasure) {
        if (key === nextMeasurePrefix || key === "Shift" || which === KeyCode_default.ALT || key === "AltGraph" || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) {
          startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);
        }
      } else if (mergedMeasuring) {
        stopMeasure();
      }
      if (onSearch && validateMeasure) {
        onSearch(nextMeasureText, nextMeasurePrefix);
      }
    } else if (mergedMeasuring) {
      stopMeasure();
    }
  };
  const onInternalPressEnter = (event) => {
    if (!mergedMeasuring && onPressEnter) {
      onPressEnter(event);
    }
  };
  const focusRef = (0, import_react98.useRef)();
  const onInternalFocus = (event) => {
    window.clearTimeout(focusRef.current);
    if (!isFocus && event && onFocus) {
      onFocus(event);
    }
    setIsFocus(true);
  };
  const onInternalBlur = (event) => {
    focusRef.current = window.setTimeout(() => {
      setIsFocus(false);
      stopMeasure();
      onBlur?.(event);
    }, 0);
  };
  const onDropdownFocus = () => {
    onInternalFocus();
  };
  const onDropdownBlur = () => {
    onInternalBlur();
  };
  const onInternalPopupScroll = (event) => {
    onPopupScroll?.(event);
  };
  const mergedStyles = import_react98.default.useMemo(() => {
    const resizeStyle = styles?.textarea?.resize ?? style?.resize;
    const mergedTextareaStyle = {
      ...styles?.textarea
    };
    if (resizeStyle !== void 0) {
      mergedTextareaStyle.resize = resizeStyle;
    }
    return {
      ...styles,
      textarea: mergedTextareaStyle
    };
  }, [style, styles]);
  const mentionNode = import_react98.default.createElement(import_react98.default.Fragment, null, import_react98.default.createElement(es_default18, _extends51({
    classNames: {
      textarea: mentionClassNames?.textarea
    },
    styles: mergedStyles,
    ref: textareaRef,
    value: mergedValue
  }, restProps, {
    rows,
    onChange: onInternalChange,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onPressEnter: onInternalPressEnter,
    onFocus: onInternalFocus,
    onBlur: onInternalBlur
  })), mergedMeasuring && import_react98.default.createElement("div", {
    ref: measureRef,
    className: `${prefixCls}-measure`
  }, mergedValue.slice(0, mergedMeasureLocation), import_react98.default.createElement(MentionsContext_default.Provider, {
    value: {
      notFoundContent,
      activeIndex,
      setActiveIndex,
      selectOption,
      onFocus: onDropdownFocus,
      onBlur: onDropdownBlur,
      onScroll: onInternalPopupScroll
    }
  }, import_react98.default.createElement(KeywordTrigger_default, {
    prefixCls,
    transitionName,
    placement,
    direction,
    options: mergedOptions,
    visible: true,
    getPopupContainer,
    popupClassName: clsx(popupClassName, mentionClassNames?.popup),
    popupStyle: styles?.popup
  }, import_react98.default.createElement("span", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));
  if (!hasWrapper) {
    return import_react98.default.createElement("div", {
      className: clsx(prefixCls, className),
      style,
      ref: containerRef
    }, mentionNode);
  }
  return mentionNode;
});
var Mentions = (0, import_react98.forwardRef)(({
  suffix,
  prefixCls = "rc-mentions",
  defaultValue,
  value: customValue,
  id,
  allowClear,
  onChange,
  classNames: mentionsClassNames,
  styles,
  className,
  disabled,
  onClear,
  ...rest
}, ref) => {
  const hasSuffix = !!(suffix || allowClear);
  const holderRef = (0, import_react98.useRef)(null);
  const mentionRef = (0, import_react98.useRef)(null);
  (0, import_react98.useImperativeHandle)(ref, () => ({
    ...mentionRef.current,
    nativeElement: holderRef.current?.nativeElement || mentionRef.current?.nativeElement
  }));
  const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", customValue);
  const triggerChange = (currentValue) => {
    setMergedValue(currentValue);
    onChange?.(currentValue);
  };
  const handleReset = () => {
    triggerChange("");
  };
  return import_react98.default.createElement(BaseInput_default, {
    suffix,
    prefixCls,
    value: mergedValue,
    allowClear,
    handleReset,
    className: clsx(prefixCls, className, {
      // hasSuffix
      [`${prefixCls}-has-suffix`]: hasSuffix
    }),
    classNames: mentionsClassNames,
    disabled,
    ref: holderRef,
    onClear
  }, import_react98.default.createElement(InternalMentions, _extends51({
    className: mentionsClassNames?.mentions,
    styles,
    classNames: mentionsClassNames,
    prefixCls,
    id,
    ref: mentionRef,
    onChange: triggerChange,
    disabled,
    hasWrapper: hasSuffix
  }, rest)));
});
Mentions.Option = Option_default;
var Mentions_default = Mentions;

// node_modules/@rc-component/mentions/es/index.js
var es_default19 = Mentions_default;

// node_modules/antd/es/_util/toList.js
var toList = (candidate, skipEmpty = false) => {
  if (skipEmpty && !isNonNullable_default(candidate)) {
    return [];
  }
  return Array.isArray(candidate) ? candidate : [candidate];
};
var toList_default = toList;

// node_modules/antd/es/mentions/style/index.js
var genDropdownStyle2 = (token) => {
  const {
    componentCls,
    fontSize,
    paddingXXS,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    itemPaddingVertical,
    controlPaddingHorizontal,
    colorText,
    borderRadius,
    lineHeight,
    colorTextDisabled,
    controlItemBgHover,
    motionDurationSlow
  } = token;
  return {
    [componentCls]: {
      // ================== Dropdown ==================
      "&-dropdown": {
        // Ref select dropdown style
        ...resetComponent(token),
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: token.zIndexPopup,
        boxSizing: "border-box",
        fontSize,
        fontVariant: "initial",
        padding: paddingXXS,
        backgroundColor: colorBgElevated,
        borderRadius: borderRadiusLG,
        outline: "none",
        boxShadow: boxShadowSecondary,
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token.dropdownHeight,
          margin: 0,
          paddingInlineStart: 0,
          // Override default ul/ol
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            minWidth: token.controlItemWidth,
            padding: `${unit(itemPaddingVertical)} ${unit(controlPaddingHorizontal)}`,
            color: colorText,
            borderRadius,
            fontWeight: "normal",
            lineHeight,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&:hover": {
              backgroundColor: controlItemBgHover
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: controlItemBgHover,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: colorText,
              fontWeight: token.fontWeightStrong,
              backgroundColor: controlItemBgHover
            },
            "&-active": {
              backgroundColor: controlItemBgHover
            }
          }
        }
      }
    }
  };
};
var genMentionsStyle = (token) => {
  const {
    componentCls,
    calc,
    colorText,
    antCls,
    colorTextDisabled
  } = token;
  return {
    [componentCls]: [
      // =========================== Common ===========================
      resetComponent(token),
      genBasicInputStyle(token, {
        largeStyle: {
          padding: void 0
        },
        smallStyle: {
          padding: void 0
        }
      }),
      // ========================== Variants ==========================
      genOutlinedStyle(token),
      genFilledStyle(token),
      genBorderlessStyle(token),
      genUnderlinedStyle(token),
      // ========================== Mentions ==========================
      {
        "--mentions-padding-inline": token.paddingInline,
        "--mentions-padding-block": token.paddingBlock,
        "--mentions-control-height": token.controlHeight,
        display: "flex",
        padding: 0,
        whiteSpace: "pre-wrap",
        // ========================= Textarea =========================
        "> textarea": [resetComponent(token), genPlaceholderStyle(token.colorTextPlaceholder), {
          background: "transparent",
          border: "none",
          borderRadius: "inherit",
          outline: "none",
          flex: "auto",
          minWidth: 0,
          resize: "none",
          "&:disabled": {
            color: colorTextDisabled
          }
        }],
        [`> textarea, ${componentCls}-measure`]: {
          color: colorText,
          boxSizing: "border-box",
          margin: 0,
          minHeight: calc("var(--mentions-control-height)").sub(calc(token.lineWidth).mul(2).equal()).equal(),
          paddingInline: "var(--mentions-padding-inline)",
          paddingBlock: "var(--mentions-padding-block)",
          overflow: "inherit",
          overflowX: "hidden",
          overflowY: "auto",
          fontWeight: "inherit",
          fontSize: "inherit",
          fontFamily: "inherit",
          fontStyle: "inherit",
          fontVariant: "inherit",
          fontSizeAdjust: "inherit",
          fontStretch: "inherit",
          lineHeight: "inherit",
          direction: "inherit",
          letterSpacing: "inherit",
          whiteSpace: "inherit",
          textAlign: "inherit",
          verticalAlign: "top",
          wordWrap: "break-word",
          wordBreak: "inherit",
          tabSize: "inherit"
        },
        // ========================= Measure ==========================
        [`${componentCls}-measure`]: {
          position: "absolute",
          inset: 0,
          zIndex: -1,
          color: "transparent",
          pointerEvents: "none",
          "> span": {
            display: "inline-block",
            minHeight: "1em"
          }
        },
        // ========================== Suffix ==========================
        [`${componentCls}-suffix`]: {
          display: "inline-flex",
          alignItems: "center",
          flex: "none",
          color: token.colorTextQuaternary,
          fontSize: token.fontSizeIcon,
          lineHeight: 1,
          position: "absolute",
          top: "50%",
          transform: "translateY(-50%)",
          insetInlineEnd: "var(--mentions-padding-inline)",
          columnGap: token.marginXS,
          [`${componentCls}-clear-icon`]: {
            // https://github.com/ant-design/ant-design/pull/18151
            // https://codesandbox.io/s/wizardly-sun-u10br
            cursor: "pointer",
            border: 0,
            background: "transparent",
            "&:hover": {
              color: token.colorIcon
            },
            "&:active": {
              color: token.colorText
            },
            "&-hidden": {
              visibility: "hidden"
            }
          },
          [`${antCls}-form-item-feedback-icon`]: {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      },
      // ========================= AllowClear =========================
      {
        "&-has-suffix": {
          "> textarea": {
            paddingInlineEnd: calc(token.paddingXXS).mul(1.5).add(token.fontSizeIcon).add("var(--mentions-padding-inline)").equal()
          }
        }
      },
      // ========================== Disabled ==========================
      {
        "&-disabled": {
          "> textarea": {
            ...genDisabledStyle(token)
          }
        }
      },
      // ============================ Size ============================
      {
        "&-lg": {
          "--mentions-padding-inline": token.paddingInlineLG,
          "--mentions-padding-block": token.paddingBlockLG,
          "--mentions-control-height": token.controlHeightLG
        },
        "&-sm": {
          "--mentions-padding-inline": token.paddingInlineSM,
          "--mentions-padding-block": token.paddingBlockSM,
          "--mentions-control-height": token.controlHeightSM
        }
      }
    ]
  };
};
var prepareComponentToken33 = (token) => ({
  ...initComponentToken(token),
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: token.zIndexPopupBase + 50,
  itemPaddingVertical: (token.controlHeight - token.fontHeight) / 2
});
var style_default39 = genStyleHooks("Mentions", (token) => {
  const mentionsToken = merge(token, initInputToken(token));
  return [genMentionsStyle(mentionsToken), genDropdownStyle2(mentionsToken)];
}, prepareComponentToken33);

// node_modules/antd/es/mentions/index.js
var {
  Option: Option4
} = es_default19;
function loadingFilterOption() {
  return true;
}
var InternalMentions2 = React294.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    disabled: customDisabled,
    loading,
    filterOption: filterOption2,
    children,
    notFoundContent,
    options,
    status: customStatus,
    allowClear = false,
    popupClassName,
    style,
    variant: customVariant,
    classNames,
    styles,
    size: customSize,
    ...restProps
  } = props;
  const [focused, setFocused] = React294.useState(false);
  const innerRef = React294.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  const mergedSize = useSize_default((ctx) => customSize ?? ctx);
  if (true) {
    const warning2 = devUseWarning("Mentions");
    warning2.deprecated(!children, "Mentions.Option", "options");
  }
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("mentions");
  const {
    renderEmpty
  } = React294.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React294.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const contextDisabled = React294.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? contextDisabled;
  const prefixCls = getPrefixCls("mentions", customizePrefixCls);
  const mergedProps = {
    ...props,
    disabled: mergedDisabled,
    status: mergedStatus,
    loading,
    options,
    variant: customVariant
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const onFocus = (...args) => {
    if (restProps.onFocus) {
      restProps.onFocus.apply(restProps, args);
    }
    setFocused(true);
  };
  const onBlur = (...args) => {
    if (restProps.onBlur) {
      restProps.onBlur.apply(restProps, args);
    }
    setFocused(false);
  };
  const notFoundContentEle = React294.useMemo(() => {
    if (notFoundContent !== void 0) {
      return notFoundContent;
    }
    return renderEmpty?.("Select") || React294.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }, [notFoundContent, renderEmpty]);
  const mentionOptions = React294.useMemo(() => {
    if (loading) {
      return React294.createElement(Option4, {
        value: "ANTD_SEARCHING",
        disabled: true
      }, React294.createElement(spin_default, {
        size: "small"
      }));
    }
    return children;
  }, [loading, children]);
  const mergedOptions = loading ? [{
    value: "ANTD_SEARCHING",
    disabled: true,
    label: React294.createElement(spin_default, {
      size: "small"
    })
  }] : options;
  const mentionsfilterOption = loading ? loadingFilterOption : filterOption2;
  const mergedAllowClear = getAllowClear_default(allowClear);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default39(prefixCls, rootCls);
  const [variant, enableVariantCls] = useVariants_default("mentions", customVariant);
  const suffixNode = hasFeedback && React294.createElement(React294.Fragment, null, feedbackIcon);
  const mergedClassName = clsx(contextClassName, className, rootClassName, cssVarCls, rootCls, mergedClassNames.root, {
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large"
  });
  return React294.createElement(es_default19, {
    silent: loading,
    prefixCls,
    notFoundContent: notFoundContentEle,
    className: mergedClassName,
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    direction,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    ...restProps,
    filterOption: mentionsfilterOption,
    onFocus,
    onBlur,
    ref: mergedRef,
    options: mergedOptions,
    suffix: suffixNode,
    styles: {
      textarea: mergedStyles.textarea,
      popup: mergedStyles.popup,
      suffix: mergedStyles.suffix
    },
    classNames: {
      textarea: clsx(mergedClassNames.textarea),
      popup: clsx(mergedClassNames.popup, popupClassName, rootClassName, hashId, cssVarCls, rootCls),
      suffix: mergedClassNames.suffix,
      mentions: clsx({
        [`${prefixCls}-disabled`]: mergedDisabled,
        [`${prefixCls}-focused`]: focused,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: hashId
    }
  }, mentionOptions);
});
var Mentions2 = InternalMentions2;
if (true) {
  Mentions2.displayName = "Mentions";
}
Mentions2.Option = Option4;
var PurePanel9 = PurePanel_default(Mentions2, void 0, void 0, "mentions");
Mentions2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel9;
Mentions2.getMentions = (value = "", config = {}) => {
  const {
    prefix = "@",
    split = " "
  } = config;
  const prefixList = toList_default(prefix);
  return value.split(split).map((str = "") => {
    let hitPrefix = null;
    prefixList.some((prefixStr) => {
      const startStr = str.slice(0, prefixStr.length);
      if (startStr === prefixStr) {
        hitPrefix = prefixStr;
        return true;
      }
      return false;
    });
    if (hitPrefix !== null) {
      return {
        prefix: hitPrefix,
        value: str.slice(hitPrefix.length)
      };
    }
    return null;
  }).filter((entity) => !!entity && !!entity.value);
};
var mentions_default = Mentions2;

// node_modules/antd/es/message/index.js
var import_react99 = __toESM(require_react());
var message = null;
var act = (callback) => callback();
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
  const {
    getContainer,
    duration,
    rtl,
    maxCount,
    top
  } = defaultGlobalConfig;
  const mergedContainer = getContainer?.() || document.body;
  return {
    getContainer: () => mergedContainer,
    duration,
    rtl,
    maxCount,
    top
  };
}
var GlobalHolder = import_react99.default.forwardRef((props, ref) => {
  const {
    messageConfig,
    sync
  } = props;
  const {
    getPrefixCls
  } = (0, import_react99.useContext)(ConfigContext);
  const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
  const appConfig = (0, import_react99.useContext)(AppConfigContext);
  const [api, holder] = useInternalMessage({
    ...messageConfig,
    prefixCls,
    ...appConfig.message
  });
  import_react99.default.useImperativeHandle(ref, () => {
    const instance = {
      ...api
    };
    Object.keys(instance).forEach((method) => {
      instance[method] = (...args) => {
        sync();
        return api[method].apply(api, args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper = import_react99.default.forwardRef((_, ref) => {
  const [messageConfig, setMessageConfig] = import_react99.default.useState(getGlobalContext);
  const sync = () => {
    setMessageConfig(getGlobalContext);
  };
  import_react99.default.useEffect(sync, []);
  const global = globalConfig();
  const rootPrefixCls = global.getRootPrefixCls();
  const rootIconPrefixCls = global.getIconPrefixCls();
  const theme = global.getTheme();
  const dom = import_react99.default.createElement(GlobalHolder, {
    ref,
    sync,
    messageConfig
  });
  return import_react99.default.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    theme
  }, global.holderRender ? global.holderRender(dom) : dom);
});
var flushMessageQueue = () => {
  if (!message) {
    const holderFragment = document.createDocumentFragment();
    const newMessage = {
      fragment: holderFragment
    };
    message = newMessage;
    act(() => {
      render(import_react99.default.createElement(GlobalHolderWrapper, {
        ref: (node) => {
          const {
            instance,
            sync
          } = node || {};
          Promise.resolve().then(() => {
            if (!newMessage.instance && instance) {
              newMessage.instance = instance;
              newMessage.sync = sync;
              flushMessageQueue();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  if (!message.instance) {
    return;
  }
  taskQueue.forEach((task) => {
    const {
      type,
      skipped
    } = task;
    if (!skipped) {
      switch (type) {
        case "open": {
          act(() => {
            const closeFn = message.instance.open({
              ...defaultGlobalConfig,
              ...task.config
            });
            closeFn?.then(task.resolve);
            task.setCloseFn(closeFn);
          });
          break;
        }
        case "destroy":
          act(() => {
            message?.instance.destroy(task.key);
          });
          break;
        // Other type open
        default: {
          act(() => {
            var _message$instance;
            const closeFn = (_message$instance = message.instance)[type].apply(_message$instance, _toConsumableArray(task.args));
            closeFn?.then(task.resolve);
            task.setCloseFn(closeFn);
          });
        }
      }
    }
  });
  taskQueue = [];
};
function setMessageGlobalConfig(config) {
  defaultGlobalConfig = {
    ...defaultGlobalConfig,
    ...config
  };
  act(() => {
    message?.sync?.();
  });
}
function open(config) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: "open",
      config,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
function typeOpen(type, args) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("message");
  }
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type,
      args,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
var destroy = (key) => {
  taskQueue.push({
    type: "destroy",
    key
  });
  flushMessageQueue();
};
var methods = ["success", "info", "warning", "error", "loading"];
var baseStaticMethods = {
  open,
  destroy,
  config: setMessageGlobalConfig,
  useMessage,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default3
};
var staticMethods = baseStaticMethods;
methods.forEach((type) => {
  staticMethods[type] = (...args) => typeOpen(type, args);
});
if (false) {
  _actWrapper = (wrapper) => {
    act = wrapper;
  };
}
if (false) {
  _actDestroy = () => {
    message = null;
  };
}
var message_default = staticMethods;

// node_modules/antd/es/modal/PurePanel.js
var React296 = __toESM(require_react());
var PurePanel10 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    closeIcon,
    closable,
    type,
    title,
    children,
    footer,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React296.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const prefixCls = customizePrefixCls || getPrefixCls("modal");
  const rootCls = useCSSVarCls_default(rootPrefixCls);
  const [hashId, cssVarCls] = style_default10(prefixCls, rootCls);
  const confirmPrefixCls = `${prefixCls}-confirm`;
  let additionalProps = {};
  if (type) {
    additionalProps = {
      closable: closable ?? false,
      title: "",
      footer: "",
      children: React296.createElement(ConfirmContent, {
        ...props,
        prefixCls,
        confirmPrefixCls,
        rootPrefixCls,
        content: children
      })
    };
  } else {
    additionalProps = {
      closable: closable ?? true,
      title,
      footer: footer !== null && React296.createElement(Footer, {
        ...props
      }),
      children
    };
  }
  return React296.createElement(Panel_default, {
    prefixCls,
    className: clsx(hashId, `${prefixCls}-pure-panel`, type && confirmPrefixCls, type && `${confirmPrefixCls}-${type}`, className, cssVarCls, rootCls),
    ...restProps,
    closeIcon: renderCloseIcon(prefixCls, closeIcon),
    closable,
    ...additionalProps
  });
};
var PurePanel_default6 = withPureRenderTheme(PurePanel10);

// node_modules/antd/es/modal/index.js
function modalWarn(props) {
  return confirm(withWarn(props));
}
var Modal2 = Modal_default;
Modal2.useModal = useModal_default;
Modal2.info = function infoFn(props) {
  return confirm(withInfo(props));
};
Modal2.success = function successFn(props) {
  return confirm(withSuccess(props));
};
Modal2.error = function errorFn(props) {
  return confirm(withError(props));
};
Modal2.warning = modalWarn;
Modal2.warn = modalWarn;
Modal2.confirm = function confirmFn(props) {
  return confirm(withConfirm(props));
};
Modal2.destroyAll = function destroyAllFn() {
  while (destroyFns_default.length) {
    const close = destroyFns_default.pop();
    if (close) {
      close();
    }
  }
};
Modal2.config = modalGlobalConfig;
Modal2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default6;
if (true) {
  Modal2.displayName = "Modal";
}
var modal_default = Modal2;

// node_modules/antd/es/notification/index.js
var import_react100 = __toESM(require_react());
var notification = null;
var act2 = (callback) => callback();
var taskQueue2 = [];
var defaultGlobalConfig2 = {};
function getGlobalContext2() {
  const {
    getContainer,
    rtl,
    maxCount,
    top,
    bottom,
    showProgress,
    pauseOnHover
  } = defaultGlobalConfig2;
  const mergedContainer = getContainer?.() || document.body;
  return {
    getContainer: () => mergedContainer,
    rtl,
    maxCount,
    top,
    bottom,
    showProgress,
    pauseOnHover
  };
}
var GlobalHolder2 = import_react100.default.forwardRef((props, ref) => {
  const {
    notificationConfig,
    sync
  } = props;
  const {
    getPrefixCls
  } = (0, import_react100.useContext)(ConfigContext);
  const prefixCls = defaultGlobalConfig2.prefixCls || getPrefixCls("notification");
  const appConfig = (0, import_react100.useContext)(AppConfigContext);
  const [api, holder] = useInternalNotification({
    ...notificationConfig,
    prefixCls,
    ...appConfig.notification
  });
  import_react100.default.useEffect(sync, []);
  import_react100.default.useImperativeHandle(ref, () => {
    const instance = {
      ...api
    };
    Object.keys(instance).forEach((method) => {
      instance[method] = (...args) => {
        sync();
        return api[method].apply(api, args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper2 = import_react100.default.forwardRef((_, ref) => {
  const [notificationConfig, setNotificationConfig] = import_react100.default.useState(getGlobalContext2);
  const sync = () => {
    setNotificationConfig(getGlobalContext2);
  };
  import_react100.default.useEffect(sync, []);
  const global = globalConfig();
  const rootPrefixCls = global.getRootPrefixCls();
  const rootIconPrefixCls = global.getIconPrefixCls();
  const theme = global.getTheme();
  const dom = import_react100.default.createElement(GlobalHolder2, {
    ref,
    sync,
    notificationConfig
  });
  return import_react100.default.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    theme
  }, global.holderRender ? global.holderRender(dom) : dom);
});
var flushNotificationQueue = () => {
  if (!notification) {
    const holderFragment = document.createDocumentFragment();
    const newNotification = {
      fragment: holderFragment
    };
    notification = newNotification;
    act2(() => {
      render(import_react100.default.createElement(GlobalHolderWrapper2, {
        ref: (node) => {
          const {
            instance,
            sync
          } = node || {};
          Promise.resolve().then(() => {
            if (!newNotification.instance && instance) {
              newNotification.instance = instance;
              newNotification.sync = sync;
              flushNotificationQueue();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  if (!notification.instance) {
    return;
  }
  taskQueue2.forEach((task) => {
    switch (task.type) {
      case "open": {
        act2(() => {
          notification.instance.open({
            ...defaultGlobalConfig2,
            ...task.config
          });
        });
        break;
      }
      case "destroy":
        act2(() => {
          notification?.instance?.destroy(task.key);
        });
        break;
    }
  });
  taskQueue2 = [];
};
function setNotificationGlobalConfig(config) {
  defaultGlobalConfig2 = {
    ...defaultGlobalConfig2,
    ...config
  };
  act2(() => {
    notification?.sync?.();
  });
}
function open2(config) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("notification");
  }
  taskQueue2.push({
    type: "open",
    config
  });
  flushNotificationQueue();
}
var destroy2 = (key) => {
  taskQueue2.push({
    type: "destroy",
    key
  });
  flushNotificationQueue();
};
var methods2 = ["success", "info", "warning", "error"];
var baseStaticMethods2 = {
  open: open2,
  destroy: destroy2,
  config: setNotificationGlobalConfig,
  useNotification: useNotification2,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default4
};
var staticMethods2 = baseStaticMethods2;
methods2.forEach((type) => {
  staticMethods2[type] = (config) => open2({
    ...config,
    type
  });
});
if (false) {
  _actWrapper = (wrapper) => {
    act2 = wrapper;
  };
}
if (false) {
  _actDestroy = () => {
    notification = null;
  };
}
var notification_default = staticMethods2;

// node_modules/antd/es/popconfirm/index.js
var React299 = __toESM(require_react());

// node_modules/antd/es/popconfirm/PurePanel.js
var React298 = __toESM(require_react());

// node_modules/antd/es/popconfirm/style/index.js
var genBaseStyle8 = (token) => {
  const {
    componentCls,
    iconCls,
    antCls,
    zIndexPopup,
    colorText,
    colorWarning,
    marginXXS,
    marginXS,
    fontSize,
    fontWeightStrong,
    colorTextHeading
  } = token;
  return {
    [componentCls]: {
      zIndex: zIndexPopup,
      [`&${antCls}-popover`]: {
        fontSize
      },
      [`${componentCls}-message`]: {
        marginBottom: marginXS,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${componentCls}-message-icon ${iconCls}`]: {
          color: colorWarning,
          fontSize,
          lineHeight: 1,
          marginInlineEnd: marginXS
        },
        [`${componentCls}-title`]: {
          fontWeight: fontWeightStrong,
          color: colorTextHeading,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${componentCls}-description`]: {
          marginTop: marginXXS,
          color: colorText
        }
      },
      [`${componentCls}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: marginXS
        }
      }
    }
  };
};
var prepareComponentToken34 = (token) => {
  const {
    zIndexPopupBase
  } = token;
  return {
    zIndexPopup: zIndexPopupBase + 60
  };
};
var style_default40 = genStyleHooks("Popconfirm", (token) => genBaseStyle8(token), prepareComponentToken34, {
  resetStyle: false
});

// node_modules/antd/es/popconfirm/PurePanel.js
var Overlay2 = (props) => {
  const {
    prefixCls,
    okButtonProps,
    cancelButtonProps,
    title,
    description,
    cancelText,
    okText,
    okType = "primary",
    icon = React298.createElement(ExclamationCircleFilled_default, null),
    showCancel = true,
    close,
    onConfirm,
    onCancel,
    onPopupClick,
    classNames,
    styles
  } = props;
  const {
    getPrefixCls
  } = React298.useContext(ConfigContext);
  const [contextLocale] = useLocale_default("Popconfirm", en_US_default4.Popconfirm);
  const titleNode = getRenderPropValue(title);
  const descriptionNode = getRenderPropValue(description);
  return React298.createElement("div", {
    className: `${prefixCls}-inner-content`,
    onClick: onPopupClick
  }, React298.createElement("div", {
    className: `${prefixCls}-message`
  }, icon && React298.createElement("span", {
    className: `${prefixCls}-message-icon`
  }, icon), React298.createElement("div", {
    className: `${prefixCls}-message-text`
  }, titleNode && React298.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames?.title),
    style: styles?.title
  }, titleNode), descriptionNode && React298.createElement("div", {
    className: clsx(`${prefixCls}-description`, classNames?.content),
    style: styles?.content
  }, descriptionNode))), React298.createElement("div", {
    className: `${prefixCls}-buttons`
  }, showCancel && React298.createElement(Button_default, {
    onClick: onCancel,
    size: "small",
    ...cancelButtonProps
  }, cancelText || contextLocale?.cancelText), React298.createElement(ActionButton_default, {
    buttonProps: {
      size: "small",
      ...convertLegacyProps(okType),
      ...okButtonProps
    },
    actionFn: onConfirm,
    close,
    prefixCls: getPrefixCls("btn"),
    quitOnNullishReturnValue: true,
    emitEvent: true
  }, okText || contextLocale?.okText)));
};
var PurePanel11 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    placement,
    className,
    style,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React298.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  style_default40(prefixCls);
  return React298.createElement(PurePanel_default2, {
    placement,
    className: clsx(prefixCls, className),
    style,
    content: React298.createElement(Overlay2, {
      prefixCls,
      ...restProps
    })
  });
};
var PurePanel_default7 = PurePanel11;

// node_modules/antd/es/popconfirm/index.js
var InternalPopconfirm = React299.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    placement = "top",
    trigger,
    okType = "primary",
    icon = React299.createElement(ExclamationCircleFilled_default, null),
    children,
    overlayClassName,
    onOpenChange,
    overlayStyle,
    styles,
    arrow: popconfirmArrow,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("popconfirm");
  const [open3, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const mergedArrow = useMergedArrow_default(popconfirmArrow, contextArrow);
  const mergedTrigger = trigger || contextTrigger || "click";
  const settingOpen = (value, e3) => {
    setOpen(value);
    onOpenChange?.(value, e3);
  };
  const close = (e3) => {
    settingOpen(false, e3);
  };
  const onConfirm = (e3) => props.onConfirm?.call(void 0, e3);
  const onCancel = (e3) => {
    settingOpen(false, e3);
    props.onCancel?.call(void 0, e3);
  };
  const onInternalOpenChange = (value, e3) => {
    const {
      disabled = false
    } = props;
    if (disabled) {
      return;
    }
    settingOpen(value, e3);
  };
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  const mergedProps = {
    ...props,
    placement,
    trigger: mergedTrigger,
    okType,
    overlayStyle,
    styles,
    classNames
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(prefixCls, contextClassName, overlayClassName, mergedClassNames.root);
  style_default40(prefixCls);
  return React299.createElement(popover_default, {
    arrow: mergedArrow,
    ...omit(restProps, ["title"]),
    trigger: mergedTrigger,
    placement,
    onOpenChange: onInternalOpenChange,
    open: open3,
    ref,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow
    },
    styles: {
      root: {
        ...contextStyle,
        ...mergedStyles.root,
        ...overlayStyle
      },
      container: mergedStyles.container,
      arrow: mergedStyles.arrow
    },
    content: React299.createElement(Overlay2, {
      okType,
      icon,
      ...props,
      prefixCls,
      close,
      onConfirm,
      onCancel,
      classNames: mergedClassNames,
      styles: mergedStyles
    }),
    "data-popover-inject": true
  }, children);
});
var Popconfirm = InternalPopconfirm;
Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default7;
if (true) {
  Popconfirm.displayName = "Popconfirm";
}
var popconfirm_default = Popconfirm;

// node_modules/antd/es/progress/progress.js
var React308 = __toESM(require_react());

// node_modules/antd/es/progress/Circle.js
var React305 = __toESM(require_react());

// node_modules/@rc-component/progress/es/Line.js
var React301 = __toESM(require_react());

// node_modules/@rc-component/progress/es/common.js
var import_react101 = __toESM(require_react());
var defaultProps2 = {
  percent: 0,
  prefixCls: "rc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  railColor: "#D9D9D9",
  railWidth: 1,
  gapPosition: "bottom",
  loading: false
};
var useTransitionDuration = () => {
  const pathsRef = (0, import_react101.useRef)([]);
  const prevTimeStamp = (0, import_react101.useRef)(null);
  (0, import_react101.useEffect)(() => {
    const now2 = Date.now();
    let updated = false;
    pathsRef.current.forEach((path2) => {
      if (!path2) {
        return;
      }
      updated = true;
      const pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated) {
      prevTimeStamp.current = Date.now();
    }
  });
  return pathsRef.current;
};

// node_modules/@rc-component/progress/es/utils/getIndeterminateLine.js
var import_react102 = __toESM(require_react());
var getIndeterminateLine_default = ((options) => {
  const {
    id,
    percent,
    strokeLinecap,
    strokeWidth,
    loading
  } = options;
  if (!loading) {
    return {
      indeterminateStyleProps: {},
      indeterminateStyleAnimation: null
    };
  }
  const animationName = `${id}-indeterminate-animate`;
  const strokeDashOffset = 100 - (percent + (strokeLinecap === "round" ? strokeWidth : 0));
  return {
    indeterminateStyleProps: {
      strokeDasharray: `${percent} 100`,
      animation: `${animationName} .6s linear alternate infinite`,
      strokeDashoffset: 0
    },
    indeterminateStyleAnimation: import_react102.default.createElement("style", null, `@keyframes ${animationName} {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -${strokeDashOffset};
          }`)
  };
});

// node_modules/@rc-component/progress/es/Line.js
function _extends52() {
  _extends52 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends52.apply(this, arguments);
}
var Line = (props) => {
  const {
    id,
    className,
    percent,
    prefixCls,
    strokeColor,
    strokeLinecap,
    strokeWidth,
    style,
    railColor,
    railWidth,
    transition,
    loading,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  const mergedId = useId_default(id);
  delete restProps.gapPosition;
  const percentList = Array.isArray(percent) ? percent : [percent];
  const strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
  const paths = useTransitionDuration();
  const center = strokeWidth / 2;
  const right = 100 - strokeWidth / 2;
  const pathString = `M ${strokeLinecap === "round" ? center : 0},${center}
         L ${strokeLinecap === "round" ? right : 100},${center}`;
  const viewBoxString = `0 0 100 ${strokeWidth}`;
  let stackPtg = 0;
  const {
    indeterminateStyleProps,
    indeterminateStyleAnimation
  } = getIndeterminateLine_default({
    id: mergedId,
    loading,
    percent: percentList[0],
    strokeLinecap,
    strokeWidth
  });
  return React301.createElement("svg", _extends52({
    className: clsx(`${prefixCls}-line`, className),
    viewBox: viewBoxString,
    preserveAspectRatio: "none",
    style
  }, restProps), React301.createElement("path", {
    className: `${prefixCls}-line-rail`,
    d: pathString,
    strokeLinecap,
    stroke: railColor,
    strokeWidth: railWidth || strokeWidth,
    fillOpacity: "0"
  }), percentList.map((ptg, index2) => {
    let dashPercent = 1;
    switch (strokeLinecap) {
      case "round":
        dashPercent = 1 - strokeWidth / 100;
        break;
      case "square":
        dashPercent = 1 - strokeWidth / 2 / 100;
        break;
      default:
        dashPercent = 1;
        break;
    }
    const pathStyle = {
      strokeDasharray: `${ptg * dashPercent}px, 100px`,
      strokeDashoffset: `-${stackPtg}px`,
      transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear",
      ...indeterminateStyleProps
    };
    const color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
    stackPtg += ptg;
    return React301.createElement("path", {
      key: index2,
      className: `${prefixCls}-line-path`,
      d: pathString,
      strokeLinecap,
      stroke: color,
      strokeWidth,
      fillOpacity: "0",
      ref: (elem) => {
        paths[index2] = elem;
      },
      style: pathStyle
    });
  }), indeterminateStyleAnimation);
};
if (true) {
  Line.displayName = "Line";
}

// node_modules/@rc-component/progress/es/Circle/index.js
var React304 = __toESM(require_react());

// node_modules/@rc-component/progress/es/Circle/PtgCircle.js
var React302 = __toESM(require_react());
var Block = ({
  bg,
  children
}) => React302.createElement("div", {
  style: {
    width: "100%",
    height: "100%",
    background: bg
  }
}, children);
function getPtgColors(color, scale) {
  return Object.keys(color).map((key) => {
    const parsedKey = parseFloat(key);
    const ptgKey = `${Math.floor(parsedKey * scale)}%`;
    return `${color[key]} ${ptgKey}`;
  });
}
var PtgCircle = React302.forwardRef((props, ref) => {
  const {
    prefixCls,
    color,
    gradientId,
    radius: radius2,
    className,
    style: circleStyleForStack,
    ptg,
    strokeLinecap,
    strokeWidth,
    size,
    gapDegree
  } = props;
  const isGradient = color && typeof color === "object";
  const stroke = isGradient ? `#FFF` : void 0;
  const halfSize = size / 2;
  const circleNode = React302.createElement("circle", {
    className: clsx(`${prefixCls}-circle-path`, className),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke,
    strokeLinecap,
    strokeWidth,
    opacity: ptg === 0 ? 0 : 1,
    style: circleStyleForStack,
    ref
  });
  if (!isGradient) {
    return circleNode;
  }
  const maskId = `${gradientId}-conic`;
  const fromDeg = gapDegree ? `${180 + gapDegree / 2}deg` : "0deg";
  const conicColors = getPtgColors(color, (360 - gapDegree) / 360);
  const linearColors = getPtgColors(color, 1);
  const conicColorBg = `conic-gradient(from ${fromDeg}, ${conicColors.join(", ")})`;
  const linearColorBg = `linear-gradient(to ${gapDegree ? "bottom" : "top"}, ${linearColors.join(", ")})`;
  return React302.createElement(React302.Fragment, null, React302.createElement("mask", {
    id: maskId
  }, circleNode), React302.createElement("foreignObject", {
    x: 0,
    y: 0,
    width: size,
    height: size,
    mask: `url(#${maskId})`
  }, React302.createElement(Block, {
    bg: linearColorBg
  }, React302.createElement(Block, {
    bg: conicColorBg
  }))));
});
if (true) {
  PtgCircle.displayName = "PtgCircle";
}
var PtgCircle_default = PtgCircle;

// node_modules/@rc-component/progress/es/Circle/util.js
var VIEW_BOX_SIZE = 100;
var getCircleStyle = (perimeter, perimeterWithoutGap, offset3, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth, stepSpace = 0) => {
  const offsetDeg = offset3 / 100 * 360 * ((360 - gapDegree) / 360);
  const positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition];
  let strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  if (strokeLinecap === "round" && percent !== 100) {
    strokeDashoffset += strokeWidth / 2;
    if (strokeDashoffset >= perimeterWithoutGap) {
      strokeDashoffset = perimeterWithoutGap - 0.01;
    }
  }
  const halfSize = VIEW_BOX_SIZE / 2;
  return {
    stroke: typeof strokeColor === "string" ? strokeColor : void 0,
    strokeDasharray: `${perimeterWithoutGap}px ${perimeter}`,
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: `rotate(${rotateDeg + offsetDeg + positionDeg}deg)`,
    transformOrigin: `${halfSize}px ${halfSize}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
    fillOpacity: 0
  };
};

// node_modules/@rc-component/progress/es/utils/getIndeterminateCircle.js
var import_react103 = __toESM(require_react());
var getIndeterminateCircle_default = (({
  id,
  loading
}) => {
  if (!loading) {
    return {
      indeterminateStyleProps: {},
      indeterminateStyleAnimation: null
    };
  }
  const animationName = `${id}-indeterminate-animate`;
  return {
    indeterminateStyleProps: {
      transform: "rotate(0deg)",
      animation: `${animationName} 1s linear infinite`
    },
    indeterminateStyleAnimation: import_react103.default.createElement("style", null, `@keyframes ${animationName} {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }`)
  };
});

// node_modules/@rc-component/progress/es/Circle/index.js
function _extends53() {
  _extends53 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends53.apply(this, arguments);
}
function toArray4(value) {
  const mergedValue = value ?? [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var Circle = (props) => {
  const {
    id,
    prefixCls,
    classNames = {},
    styles = {},
    steps,
    strokeWidth,
    railWidth,
    gapDegree = 0,
    gapPosition,
    railColor,
    strokeLinecap,
    style,
    className,
    strokeColor,
    percent,
    loading,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  const halfSize = VIEW_BOX_SIZE / 2;
  const mergedId = useId_default(id);
  const gradientId = `${mergedId}-gradient`;
  const radius2 = halfSize - strokeWidth / 2;
  const perimeter = Math.PI * 2 * radius2;
  const rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
  const perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
  const {
    count: stepCount,
    gap: stepGap
  } = typeof steps === "object" ? steps : {
    count: steps,
    gap: 2
  };
  const percentList = toArray4(percent);
  const strokeColorList = toArray4(strokeColor);
  const gradient = strokeColorList.find((color) => color && typeof color === "object");
  const isConicGradient = gradient && typeof gradient === "object";
  const mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap;
  const {
    indeterminateStyleProps,
    indeterminateStyleAnimation
  } = getIndeterminateCircle_default({
    id: mergedId,
    loading
  });
  const circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, railColor, mergedStrokeLinecap, strokeWidth);
  const paths = useTransitionDuration();
  const getStokeList = () => {
    let stackPtg = 0;
    return percentList.map((ptg, index2) => {
      const color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
      const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
      stackPtg += ptg;
      return React304.createElement(PtgCircle_default, {
        key: index2,
        color,
        ptg,
        radius: radius2,
        prefixCls,
        gradientId,
        className: classNames.track,
        style: {
          ...circleStyleForStack,
          ...indeterminateStyleProps,
          ...styles.track
        },
        strokeLinecap: mergedStrokeLinecap,
        strokeWidth,
        gapDegree,
        ref: (elem) => {
          paths[index2] = elem;
        },
        size: VIEW_BOX_SIZE
      });
    }).reverse();
  };
  const getStepStokeList = () => {
    const current = Math.round(stepCount * (percentList[0] / 100));
    const stepPtg = 100 / stepCount;
    let stackPtg = 0;
    return new Array(stepCount).fill(null).map((_, index2) => {
      const color = index2 <= current - 1 ? strokeColorList[0] : railColor;
      const stroke = color && typeof color === "object" ? `url(#${gradientId})` : void 0;
      const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
      stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
      return React304.createElement("circle", {
        key: index2,
        className: clsx(`${prefixCls}-circle-path`, classNames.track),
        r: radius2,
        cx: halfSize,
        cy: halfSize,
        stroke,
        strokeWidth,
        opacity: 1,
        style: {
          ...circleStyleForStack,
          ...styles.track
        },
        ref: (elem) => {
          paths[index2] = elem;
        }
      });
    });
  };
  return React304.createElement("svg", _extends53({
    className: clsx(`${prefixCls}-circle`, classNames.root, className),
    viewBox: `0 0 ${VIEW_BOX_SIZE} ${VIEW_BOX_SIZE}`,
    style: {
      ...styles.root,
      ...style
    },
    id,
    role: "presentation"
  }, restProps), !stepCount && React304.createElement("circle", {
    className: clsx(`${prefixCls}-circle-rail`, classNames.rail),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke: railColor,
    strokeLinecap: mergedStrokeLinecap,
    strokeWidth: railWidth || strokeWidth,
    style: {
      ...circleStyle,
      ...styles.rail
    }
  }), stepCount ? getStepStokeList() : getStokeList(), indeterminateStyleAnimation);
};
if (true) {
  Circle.displayName = "Circle";
}
var Circle_default = Circle;

// node_modules/antd/es/progress/utils.js
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent({
  success
}) {
  let percent;
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
var getPercentage = ({
  percent,
  success
}) => {
  const realSuccessPercent = validProgress(getSuccessPercent({
    success
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
};
var getStrokeColor = ({
  success = {},
  strokeColor
}) => {
  const {
    strokeColor: successColor
  } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
};
var getSize2 = (size, type, extra) => {
  let width = -1;
  let height = -1;
  if (type === "step") {
    const steps = extra.steps;
    const strokeWidth = extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      width = size === "small" ? 2 : 14;
      height = strokeWidth ?? 8;
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
    }
    width *= steps;
  } else if (type === "line") {
    const strokeWidth = extra?.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      height = strokeWidth || (size === "small" ? 6 : 8);
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
    }
  } else if (type === "circle" || type === "dashboard") {
    if (typeof size === "string" || typeof size === "undefined") {
      [width, height] = size === "small" ? [60, 60] : [120, 120];
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else if (Array.isArray(size)) {
      width = size[0] ?? size[1] ?? 120;
      height = size[0] ?? size[1] ?? 120;
    }
  }
  return [width, height];
};

// node_modules/antd/es/progress/Circle.js
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
var OMIT_SEMANTIC_NAMES = ["root", "body", "indicator"];
var Circle2 = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    railColor,
    trailColor,
    strokeLinecap = "round",
    gapPosition,
    gapPlacement,
    gapDegree,
    width: originWidth = 120,
    type,
    children,
    success,
    size = originWidth,
    steps
  } = props;
  const {
    direction
  } = useComponentConfig("progress");
  const mergedRailColor = railColor ?? trailColor;
  const [width, height] = getSize2(size, "circle");
  let {
    strokeWidth
  } = props;
  if (strokeWidth === void 0) {
    strokeWidth = Math.max(getMinPercent(width), 6);
  }
  const circleStyle = {
    width,
    height,
    fontSize: width * 0.15 + 6
  };
  const realGapDegree = React305.useMemo(() => {
    if (gapDegree || gapDegree === 0) {
      return gapDegree;
    }
    if (type === "dashboard") {
      return 75;
    }
    return void 0;
  }, [gapDegree, type]);
  const percentArray = getPercentage(props);
  const gapPos = React305.useMemo(() => {
    const mergedPlacement = (gapPlacement ?? gapPosition) || type === "dashboard" && "bottom" || void 0;
    const isRTL = direction === "rtl";
    switch (mergedPlacement) {
      case "start":
        return isRTL ? "right" : "left";
      case "end":
        return isRTL ? "left" : "right";
      default:
        return mergedPlacement;
    }
  }, [direction, gapPlacement, gapPosition, type]);
  const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
  const strokeColor = getStrokeColor({
    success,
    strokeColor: props.strokeColor
  });
  const wrapperClassName = clsx(`${prefixCls}-body`, {
    [`${prefixCls}-circle-gradient`]: isGradient
  }, classNames.body);
  const circleContent = React305.createElement(Circle_default, {
    steps,
    percent: steps ? percentArray[1] : percentArray,
    strokeWidth,
    railWidth: strokeWidth,
    strokeColor: steps ? strokeColor[1] : strokeColor,
    strokeLinecap,
    railColor: mergedRailColor,
    prefixCls,
    gapDegree: realGapDegree,
    gapPosition: gapPos,
    classNames: omit(classNames, OMIT_SEMANTIC_NAMES),
    styles: omit(styles, OMIT_SEMANTIC_NAMES)
  });
  const smallCircle = width <= 20;
  const node = React305.createElement("div", {
    className: wrapperClassName,
    style: {
      ...circleStyle,
      ...styles.body
    }
  }, circleContent, !smallCircle && children);
  if (smallCircle) {
    return React305.createElement(tooltip_default, {
      title: children
    }, node);
  }
  return node;
};
var Circle_default2 = Circle2;

// node_modules/antd/es/progress/Line.js
var React306 = __toESM(require_react());

// node_modules/antd/es/progress/style/index.js
var LineStrokeColorVar = "--progress-line-stroke-color";
var genAntProgressActive = (isRtl) => {
  const direction = isRtl ? "100%" : "-100%";
  return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
    "0%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.1
    },
    "20%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.5
    },
    to: {
      transform: "translateX(0) scaleX(1)",
      opacity: 0
    }
  });
};
var genBaseStyle9 = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [progressCls]: {
      ...resetComponent(token),
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      [`${progressCls}-indicator`]: {
        color: token.colorText,
        lineHeight: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token.fontSize
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-indicator`]: {
          color: token.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-indicator`]: {
          color: token.colorSuccess
        }
      }
    }
  };
};
var genLineStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-line`]: {
      position: "relative",
      width: "100%",
      fontSize: token.fontSize,
      [`${componentCls}-body`]: {
        display: "inline-flex",
        alignItems: "center",
        width: "100%",
        gap: token.marginXS
      },
      [`${componentCls}-rail`]: {
        flex: "auto",
        background: token.remainingColor,
        borderRadius: token.lineBorderRadius,
        position: "relative",
        width: "100%"
      },
      [`&${componentCls}-status-active`]: {
        [`${componentCls}-track:after`]: {
          content: '""',
          position: "absolute",
          inset: 0,
          backgroundColor: token.colorBgContainer,
          borderRadius: "inherit",
          opacity: 0,
          animationName: genAntProgressActive(),
          animationDuration: token.progressActiveMotionDuration,
          animationTimingFunction: token.motionEaseOutQuint,
          animationIterationCount: "infinite"
        }
      },
      [`${componentCls}-track`]: {
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: 0,
        borderRadius: "inherit",
        background: token.defaultColor,
        transition: `all ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`,
        minWidth: "max-content",
        display: "flex",
        alignItems: "center",
        "&-success": {
          background: token.colorSuccess
        }
      },
      [`&${componentCls}-status-exception`]: {
        [`${componentCls}-track`]: {
          background: token.colorError
        }
      },
      [`&${componentCls}-status-success`]: {
        [`${componentCls}-track`]: {
          background: token.colorSuccess
        }
      },
      // >>>>> indicator
      // >>> Outer
      [`${componentCls}-indicator-outer`]: {
        [`&${componentCls}-indicator-start`]: {
          order: -1
        }
      },
      [`${componentCls}-body-layout-bottom`]: {
        flexDirection: "column",
        alignItems: "center",
        gap: token.marginXXS
      },
      // >>> Inner
      [`${componentCls}-indicator${componentCls}-indicator-inner`]: {
        color: token.colorWhite,
        paddingInline: token.paddingXXS,
        width: "100%",
        display: "flex",
        justifyContent: "center",
        [`&${componentCls}-indicator-end`]: {
          justifyContent: "end"
        },
        [`&${componentCls}-indicator-start`]: {
          justifyContent: "start"
        },
        [`&${componentCls}-indicator-bright`]: {
          color: "rgba(0, 0, 0, 0.45)"
        }
      }
    }
  };
};
var genCircleStyle = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [`${progressCls}-circle`]: {
      [`${progressCls}-circle-rail`]: {
        stroke: token.remainingColor
      },
      [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token.defaultColor
        }
      },
      [`${progressCls}-body`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`${progressCls}-indicator`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token.circleTextColor,
        fontSize: token.circleTextFontSize,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: token.circleIconFontSize
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token.colorError
          }
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token.colorSuccess
          }
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
};
var genStepStyle = (token) => {
  const {
    componentCls: progressCls
  } = token;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-body": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          gap: token.progressStepMarginInlineEnd,
          [`${progressCls}-indicator`]: {
            marginInlineStart: token.marginXS
          }
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token.progressStepMinWidth,
          backgroundColor: token.remainingColor,
          transition: `all ${token.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token.defaultColor
          }
        }
      }
    }
  };
};
var genSmallLine = (token) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-indicator ${iconPrefixCls}`]: {
        fontSize: token.fontSizeSM
      }
    }
  };
};
var prepareComponentToken35 = (token) => ({
  circleTextColor: token.colorText,
  defaultColor: token.colorInfo,
  remainingColor: token.colorFillSecondary,
  lineBorderRadius: 100,
  // magic for capsule shape, should be a very large number
  circleTextFontSize: "1em",
  circleIconFontSize: `${token.fontSize / token.fontSizeSM}em`
});
var style_default41 = genStyleHooks("Progress", (token) => {
  const progressStepMarginInlineEnd = token.calc(token.marginXXS).div(2).equal();
  const progressToken = merge(token, {
    progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: "2.4s"
  });
  return [genBaseStyle9(progressToken), genLineStyle(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
}, prepareComponentToken35);

// node_modules/antd/es/progress/Line.js
var sortGradient = (gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const formattedKey = Number.parseFloat(key.replace(/%/g, ""));
    if (!Number.isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort((a, b) => a.key - b.key);
  return tempArr.map(({
    key,
    value
  }) => `${value} ${key}%`).join(", ");
};
var handleGradient = (strokeColor, directionConfig) => {
  const {
    from = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right",
    ...rest
  } = strokeColor;
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest);
    const background2 = `linear-gradient(${direction}, ${sortedGradients})`;
    return {
      background: background2,
      [LineStrokeColorVar]: background2
    };
  }
  const background = `linear-gradient(${direction}, ${from}, ${to})`;
  return {
    background,
    [LineStrokeColorVar]: background
  };
};
var Line2 = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    direction: directionConfig,
    percent,
    size,
    strokeWidth,
    strokeColor,
    strokeLinecap = "round",
    children,
    railColor,
    trailColor,
    percentPosition,
    success
  } = props;
  const {
    align: infoAlign,
    type: infoPosition
  } = percentPosition;
  const mergedRailColor = railColor ?? trailColor;
  const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
  if (true) {
    const warning2 = devUseWarning("Progress");
    warning2.deprecated(!("strokeWidth" in props), "strokeWidth", "size");
  }
  const mergedSize = size ?? [-1, strokeWidth || (size === "small" ? 6 : 8)];
  const [width, height] = getSize2(mergedSize, "line", {
    strokeWidth
  });
  const railStyle = {
    backgroundColor: mergedRailColor || void 0,
    borderRadius,
    height
  };
  const trackCls = `${prefixCls}-track`;
  const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
    [LineStrokeColorVar]: strokeColor,
    background: strokeColor
  };
  const percentTrackStyle = {
    width: `${validProgress(percent)}%`,
    height,
    borderRadius,
    ...backgroundProps
  };
  const successPercent = getSuccessPercent(props);
  const successTrackStyle = {
    width: `${validProgress(successPercent)}%`,
    height,
    borderRadius,
    backgroundColor: success?.strokeColor
  };
  return React306.createElement("div", {
    className: clsx(`${prefixCls}-body`, classNames.body, {
      [`${prefixCls}-body-layout-bottom`]: infoAlign === "center" && infoPosition === "outer"
    }),
    style: {
      width: width > 0 ? width : "100%",
      ...styles.body
    }
  }, React306.createElement("div", {
    className: clsx(`${prefixCls}-rail`, classNames.rail),
    style: {
      ...railStyle,
      ...styles.rail
    }
  }, React306.createElement("div", {
    className: clsx(trackCls, classNames.track),
    style: {
      ...percentTrackStyle,
      ...styles.track
    }
  }, infoPosition === "inner" && children), successPercent !== void 0 && React306.createElement("div", {
    className: clsx(trackCls, `${trackCls}-success`, classNames.track),
    style: {
      ...successTrackStyle,
      ...styles.track
    }
  })), infoPosition === "outer" && children);
};
var Line_default2 = Line2;

// node_modules/antd/es/progress/Steps.js
var React307 = __toESM(require_react());
var Steps = (props) => {
  const {
    classNames,
    styles,
    size,
    steps,
    rounding: customRounding = Math.round,
    percent = 0,
    strokeWidth = 8,
    strokeColor,
    railColor,
    trailColor,
    prefixCls,
    children
  } = props;
  const current = customRounding(steps * (percent / 100));
  const stepWidth = size === "small" ? 2 : 14;
  const mergedSize = size ?? [stepWidth, strokeWidth];
  const [width, height] = getSize2(mergedSize, "step", {
    steps,
    strokeWidth
  });
  const unitWidth = width / steps;
  const styledSteps = Array.from({
    length: steps
  });
  const mergedRailColor = railColor ?? trailColor;
  for (let i = 0; i < steps; i++) {
    const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] = React307.createElement("div", {
      key: i,
      className: clsx(`${prefixCls}-steps-item`, {
        [`${prefixCls}-steps-item-active`]: i <= current - 1
      }, classNames.track),
      style: {
        backgroundColor: i <= current - 1 ? color : mergedRailColor,
        width: unitWidth,
        height,
        ...styles.track
      }
    });
  }
  return React307.createElement("div", {
    className: clsx(`${prefixCls}-steps-body`, classNames.body),
    style: styles.body
  }, styledSteps, children);
};
var Steps_default = Steps;

// node_modules/antd/es/progress/progress.js
var ProgressStatuses = ["normal", "exception", "active", "success"];
var Progress2 = React308.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    styles,
    steps,
    strokeColor,
    percent = 0,
    size = "default",
    showInfo = true,
    type = "line",
    status,
    format: format2,
    style,
    percentPosition = {},
    ...restProps
  } = props;
  const {
    align: infoAlign = "end",
    type: infoPosition = "outer"
  } = percentPosition;
  const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
  const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
  const strokeColorIsBright = React308.useMemo(() => {
    if (strokeColorNotArray) {
      const color = typeof strokeColorNotArray === "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];
      return new FastColor(color).isLight();
    }
    return false;
  }, [strokeColor]);
  const percentNumber = React308.useMemo(() => {
    const successPercent = getSuccessPercent(props);
    return Number.parseInt(successPercent !== void 0 ? (successPercent ?? 0)?.toString() : (percent ?? 0)?.toString(), 10);
  }, [percent, props.success]);
  const progressStatus = React308.useMemo(() => {
    if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
      return "success";
    }
    return status || "normal";
  }, [status, percentNumber]);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("progress");
  const prefixCls = getPrefixCls("progress", customizePrefixCls);
  const [hashId, cssVarCls] = style_default41(prefixCls);
  const mergedProps = {
    ...props,
    percent,
    type,
    size,
    showInfo,
    percentPosition
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const isLineType = type === "line";
  const isPureLineType = isLineType && !steps;
  const progressInfo = React308.useMemo(() => {
    if (!showInfo) {
      return null;
    }
    const successPercent = getSuccessPercent(props);
    let text;
    const textFormatter = format2 || ((number) => `${number}%`);
    const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
    if (infoPosition === "inner" || format2 || progressStatus !== "exception" && progressStatus !== "success") {
      text = textFormatter(validProgress(percent), validProgress(successPercent));
    } else if (progressStatus === "exception") {
      text = isLineType ? React308.createElement(CloseCircleFilled_default, null) : React308.createElement(CloseOutlined_default, null);
    } else if (progressStatus === "success") {
      text = isLineType ? React308.createElement(CheckCircleFilled_default, null) : React308.createElement(CheckOutlined_default, null);
    }
    return React308.createElement("span", {
      className: clsx(`${prefixCls}-indicator`, {
        [`${prefixCls}-indicator-bright`]: isBrightInnerColor,
        [`${prefixCls}-indicator-${infoAlign}`]: isPureLineType,
        [`${prefixCls}-indicator-${infoPosition}`]: isPureLineType
      }, mergedClassNames.indicator),
      style: mergedStyles.indicator,
      title: typeof text === "string" ? text : void 0
    }, text);
  }, [showInfo, percent, percentNumber, progressStatus, type, prefixCls, format2, isLineType, strokeColorIsBright, infoPosition, infoAlign, isPureLineType, mergedClassNames.indicator, mergedStyles.indicator]);
  if (true) {
    const warning2 = devUseWarning("Progress");
    [["width", "size"], ["trailColor", "railColor"], ["gapPosition", "gapPlacement"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (type === "circle" || type === "dashboard") {
      if (Array.isArray(size)) {
        true ? warning2(false, "usage", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.') : void 0;
      } else if (typeof size === "object") {
        true ? warning2(false, "usage", 'Type "circle" and "dashboard" do not accept object as `size`, please use number or preset size instead.') : void 0;
      }
    }
  }
  const sharedProps = {
    ...props,
    classNames: mergedClassNames,
    styles: mergedStyles
  };
  let progress;
  if (type === "line") {
    progress = steps ? React308.createElement(Steps_default, {
      ...sharedProps,
      strokeColor: strokeColorNotGradient,
      prefixCls,
      steps: typeof steps === "object" ? steps.count : steps
    }, progressInfo) : React308.createElement(Line_default2, {
      ...sharedProps,
      strokeColor: strokeColorNotArray,
      prefixCls,
      direction,
      percentPosition: {
        align: infoAlign,
        type: infoPosition
      }
    }, progressInfo);
  } else if (type === "circle" || type === "dashboard") {
    progress = React308.createElement(Circle_default2, {
      ...sharedProps,
      strokeColor: strokeColorNotArray,
      prefixCls,
      progressStatus
    }, progressInfo);
  }
  const classString = clsx(prefixCls, `${prefixCls}-status-${progressStatus}`, {
    [`${prefixCls}-${type === "dashboard" && "circle" || type}`]: type !== "line",
    [`${prefixCls}-inline-circle`]: type === "circle" && getSize2(size, "circle")[0] <= 20,
    [`${prefixCls}-line`]: isPureLineType,
    [`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
    [`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
    [`${prefixCls}-steps`]: steps,
    [`${prefixCls}-show-info`]: showInfo,
    [`${prefixCls}-${size}`]: typeof size === "string",
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  return React308.createElement("div", {
    ref,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style
    },
    className: classString,
    role: "progressbar",
    "aria-valuenow": percentNumber,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    ...omit(restProps, ["railColor", "trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "gapPlacement", "strokeLinecap", "success"])
  }, progress);
});
if (true) {
  Progress2.displayName = "Progress";
}
var progress_default = Progress2;

// node_modules/antd/es/progress/index.js
var progress_default2 = progress_default;

// node_modules/antd/es/qr-code/index.js
var import_react108 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(r2, e3) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e3 && r2 && "number" == typeof r2.length) {
      t2 && (r2 = t2);
      var _n = 0, F = function F2() {
      };
      return {
        s: F,
        n: function n2() {
          return _n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[_n++]
          };
        },
        e: function e4(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o3, a = true, u = false;
  return {
    s: function s() {
      t2 = t2.call(r2);
    },
    n: function n2() {
      var r3 = t2.next();
      return a = r3.done, r3;
    },
    e: function e4(r3) {
      u = true, o3 = r3;
    },
    f: function f() {
      try {
        a || null == t2["return"] || t2["return"]();
      } finally {
        if (u) throw o3;
      }
    }
  };
}

// node_modules/@rc-component/qrcode/es/libs/qrcodegen.js
var _class;
var _class2;
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len != 0) {
    throw new RangeError("Value out of range");
  }
  for (var i = len - 1; i >= 0; i--) {
    bb.push(val >>> i & 1);
  }
}
function getBit(x, i) {
  return (x >>> i & 1) != 0;
}
function assert(cond) {
  if (!cond) {
    throw new Error("Assertion error");
  }
}
var Mode = (function() {
  function Mode2(modeBits, numBitsCharCount) {
    _classCallCheck(this, Mode2);
    _defineProperty(this, "modeBits", void 0);
    _defineProperty(this, "numBitsCharCount", void 0);
    this.modeBits = modeBits;
    this.numBitsCharCount = numBitsCharCount;
  }
  _createClass(Mode2, [{
    key: "numCharCountBits",
    value: function numCharCountBits(ver) {
      return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
    }
  }]);
  return Mode2;
})();
_class = Mode;
_defineProperty(Mode, "NUMERIC", new _class(1, [10, 12, 14]));
_defineProperty(Mode, "ALPHANUMERIC", new _class(2, [9, 11, 13]));
_defineProperty(Mode, "BYTE", new _class(4, [8, 16, 16]));
_defineProperty(Mode, "KANJI", new _class(8, [8, 10, 12]));
_defineProperty(Mode, "ECI", new _class(7, [0, 0, 0]));
var Ecc = _createClass(function Ecc2(ordinal, formatBits) {
  _classCallCheck(this, Ecc2);
  _defineProperty(this, "ordinal", void 0);
  _defineProperty(this, "formatBits", void 0);
  this.ordinal = ordinal;
  this.formatBits = formatBits;
});
_class2 = Ecc;
_defineProperty(Ecc, "LOW", new _class2(0, 1));
_defineProperty(Ecc, "MEDIUM", new _class2(1, 0));
_defineProperty(Ecc, "QUARTILE", new _class2(2, 3));
_defineProperty(Ecc, "HIGH", new _class2(3, 2));
var QrSegment = (function() {
  function QrSegment2(mode, numChars, bitData) {
    _classCallCheck(this, QrSegment2);
    _defineProperty(this, "mode", void 0);
    _defineProperty(this, "numChars", void 0);
    _defineProperty(this, "bitData", void 0);
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0) {
      throw new RangeError("Invalid argument");
    }
    this.bitData = bitData.slice();
  }
  _createClass(QrSegment2, [{
    key: "getData",
    value: function getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
  }], [{
    key: "makeBytes",
    value: (
      /*-- Static factory functions (mid level) --*/
      // Returns a segment representing the given binary data encoded in
      // byte mode. All input byte arrays are acceptable. Any text string
      // can be converted to UTF-8 bytes and encoded as a byte mode segment.
      function makeBytes(data) {
        var bb = [];
        var _iterator = _createForOfIteratorHelper(data), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var b = _step.value;
            appendBits(b, 8, bb);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return new QrSegment2(Mode.BYTE, data.length, bb);
      }
    )
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
  }, {
    key: "makeNumeric",
    value: function makeNumeric(digits) {
      if (!QrSegment2.isNumeric(digits)) {
        throw new RangeError("String contains non-numeric characters");
      }
      var bb = [];
      for (var i = 0; i < digits.length; ) {
        var n2 = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substring(i, i + n2), 10), n2 * 3 + 1, bb);
        i += n2;
      }
      return new QrSegment2(Mode.NUMERIC, digits.length, bb);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
  }, {
    key: "makeAlphanumeric",
    value: function makeAlphanumeric(text) {
      if (!QrSegment2.isAlphanumeric(text)) {
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      }
      var bb = [];
      var i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        var temp = QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length) {
        appendBits(QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      }
      return new QrSegment2(Mode.ALPHANUMERIC, text.length, bb);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
  }, {
    key: "makeSegments",
    value: function makeSegments(text) {
      if (text == "") {
        return [];
      } else if (QrSegment2.isNumeric(text)) {
        return [QrSegment2.makeNumeric(text)];
      } else if (QrSegment2.isAlphanumeric(text)) {
        return [QrSegment2.makeAlphanumeric(text)];
      } else {
        return [QrSegment2.makeBytes(QrSegment2.toUtf8ByteArray(text))];
      }
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
  }, {
    key: "makeEci",
    value: function makeEci(assignVal) {
      var bb = [];
      if (assignVal < 0) {
        throw new RangeError("ECI assignment value out of range");
      } else if (assignVal < 1 << 7) {
        appendBits(assignVal, 8, bb);
      } else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else {
        throw new RangeError("ECI assignment value out of range");
      }
      return new QrSegment2(Mode.ECI, 0, bb);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
  }, {
    key: "isNumeric",
    value: function isNumeric2(text) {
      return QrSegment2.NUMERIC_REGEX.test(text);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
  }, {
    key: "isAlphanumeric",
    value: function isAlphanumeric(text) {
      return QrSegment2.ALPHANUMERIC_REGEX.test(text);
    }
  }, {
    key: "getTotalBits",
    value: function getTotalBits(segs, version2) {
      var result = 0;
      var _iterator2 = _createForOfIteratorHelper(segs), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var seg = _step2.value;
          var ccbits = seg.mode.numCharCountBits(version2);
          if (seg.numChars >= 1 << ccbits) {
            return Infinity;
          }
          result += 4 + ccbits + seg.bitData.length;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
  }, {
    key: "toUtf8ByteArray",
    value: function toUtf8ByteArray(input) {
      var str = encodeURI(input);
      var result = [];
      for (var i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%") {
          result.push(str.charCodeAt(i));
        } else {
          result.push(parseInt(str.substring(i + 1, i + 3), 16));
          i += 2;
        }
      }
      return result;
    }
    /*-- Constants --*/
    // Describes precisely all strings that are encodable in numeric mode.
  }]);
  return QrSegment2;
})();
_defineProperty(QrSegment, "NUMERIC_REGEX", /^[0-9]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_REGEX", /^[A-Z0-9 $%*+.\/:-]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
var QrCode = (function() {
  function QrCode2(version2, errorCorrectionLevel, dataCodewords, oriMsk) {
    _classCallCheck(this, QrCode2);
    _defineProperty(this, "size", void 0);
    _defineProperty(this, "mask", void 0);
    _defineProperty(this, "modules", []);
    _defineProperty(this, "isFunction", []);
    _defineProperty(this, "version", void 0);
    _defineProperty(this, "errorCorrectionLevel", void 0);
    var msk = oriMsk;
    this.version = version2;
    this.errorCorrectionLevel = errorCorrectionLevel;
    if (version2 < QrCode2.MIN_VERSION || version2 > QrCode2.MAX_VERSION) {
      throw new RangeError("Version value out of range");
    }
    if (msk < -1 || msk > 7) {
      throw new RangeError("Mask value out of range");
    }
    this.size = version2 * 4 + 17;
    var row = [];
    for (var i = 0; i < this.size; i++) {
      row.push(false);
    }
    for (var _i = 0; _i < this.size; _i++) {
      this.modules.push(row.slice());
      this.isFunction.push(row.slice());
    }
    this.drawFunctionPatterns();
    var allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk == -1) {
      var minPenalty = 1e9;
      for (var _i2 = 0; _i2 < 8; _i2++) {
        this.applyMask(_i2);
        this.drawFormatBits(_i2);
        var penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = _i2;
          minPenalty = penalty;
        }
        this.applyMask(_i2);
      }
    }
    assert(0 <= msk && msk <= 7);
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
    this.isFunction = [];
  }
  _createClass(QrCode2, [{
    key: "getModule",
    value: function getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    // Modified to expose modules for easy access
  }, {
    key: "getModules",
    value: function getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
  }, {
    key: "drawFunctionPatterns",
    value: function drawFunctionPatterns() {
      for (var i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      var alignPatPos = this.getAlignmentPatternPositions();
      var numAlign = alignPatPos.length;
      for (var _i3 = 0; _i3 < numAlign; _i3++) {
        for (var j = 0; j < numAlign; j++) {
          if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) {
            this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);
          }
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
  }, {
    key: "drawFormatBits",
    value: function drawFormatBits(mask) {
      var data = this.errorCorrectionLevel.formatBits << 3 | mask;
      var rem = data;
      for (var i = 0; i < 10; i++) {
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      }
      var bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (var _i4 = 0; _i4 <= 5; _i4++) {
        this.setFunctionModule(8, _i4, getBit(bits, _i4));
      }
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (var _i5 = 9; _i5 < 15; _i5++) {
        this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));
      }
      for (var _i6 = 0; _i6 < 8; _i6++) {
        this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));
      }
      for (var _i7 = 8; _i7 < 15; _i7++) {
        this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));
      }
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
  }, {
    key: "drawVersion",
    value: function drawVersion() {
      if (this.version < 7) {
        return;
      }
      var rem = this.version;
      for (var i = 0; i < 12; i++) {
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      }
      var bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (var _i8 = 0; _i8 < 18; _i8++) {
        var color = getBit(bits, _i8);
        var a = this.size - 11 + _i8 % 3;
        var b = Math.floor(_i8 / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
  }, {
    key: "drawFinderPattern",
    value: function drawFinderPattern(x, y) {
      for (var dy = -4; dy <= 4; dy++) {
        for (var dx = -4; dx <= 4; dx++) {
          var dist = Math.max(Math.abs(dx), Math.abs(dy));
          var xx = x + dx;
          var yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) {
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
          }
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
  }, {
    key: "drawAlignmentPattern",
    value: function drawAlignmentPattern(x, y) {
      for (var dy = -2; dy <= 2; dy++) {
        for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
  }, {
    key: "setFunctionModule",
    value: function setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
  }, {
    key: "addEccAndInterleave",
    value: function addEccAndInterleave(data) {
      var ver = this.version;
      var ecl = this.errorCorrectionLevel;
      if (data.length != QrCode2.getNumDataCodewords(ver, ecl)) {
        throw new RangeError("Invalid argument");
      }
      var numBlocks = QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      var blockEccLen = QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      var rawCodewords = Math.floor(QrCode2.getNumRawDataModules(ver) / 8);
      var numShortBlocks = numBlocks - rawCodewords % numBlocks;
      var shortBlockLen = Math.floor(rawCodewords / numBlocks);
      var blocks = [];
      var rsDiv = QrCode2.reedSolomonComputeDivisor(blockEccLen);
      for (var i = 0, k = 0; i < numBlocks; i++) {
        var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        var ecc = QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks) {
          dat.push(0);
        }
        blocks.push(dat.concat(ecc));
      }
      var result = [];
      var _loop = function _loop2(_i92) {
        blocks.forEach(function(block, j) {
          if (_i92 != shortBlockLen - blockEccLen || j >= numShortBlocks) {
            result.push(block[_i92]);
          }
        });
      };
      for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {
        _loop(_i9);
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
  }, {
    key: "drawCodewords",
    value: function drawCodewords(data) {
      if (data.length != Math.floor(QrCode2.getNumRawDataModules(this.version) / 8)) {
        throw new RangeError("Invalid argument");
      }
      var i = 0;
      for (var right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6) {
          right = 5;
        }
        for (var vert = 0; vert < this.size; vert++) {
          for (var j = 0; j < 2; j++) {
            var x = right - j;
            var upward = (right + 1 & 2) == 0;
            var y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
  }, {
    key: "applyMask",
    value: function applyMask(mask) {
      if (mask < 0 || mask > 7) {
        throw new RangeError("Mask value out of range");
      }
      for (var y = 0; y < this.size; y++) {
        for (var x = 0; x < this.size; x++) {
          var invert = void 0;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert) {
            this.modules[y][x] = !this.modules[y][x];
          }
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  }, {
    key: "getPenaltyScore",
    value: function getPenaltyScore() {
      var result = 0;
      for (var y = 0; y < this.size; y++) {
        var runColor = false;
        var runX = 0;
        var runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (var x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5) {
              result += QrCode2.PENALTY_N1;
            } else if (runX > 5) {
              result++;
            }
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor) {
              result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
            }
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode2.PENALTY_N3;
      }
      for (var _x = 0; _x < this.size; _x++) {
        var _runColor = false;
        var runY = 0;
        var _runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (var _y = 0; _y < this.size; _y++) {
          if (this.modules[_y][_x] == _runColor) {
            runY++;
            if (runY == 5) {
              result += QrCode2.PENALTY_N1;
            } else if (runY > 5) {
              result++;
            }
          } else {
            this.finderPenaltyAddHistory(runY, _runHistory);
            if (!_runColor) {
              result += this.finderPenaltyCountPatterns(_runHistory) * QrCode2.PENALTY_N3;
            }
            _runColor = this.modules[_y][_x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode2.PENALTY_N3;
      }
      for (var _y2 = 0; _y2 < this.size - 1; _y2++) {
        for (var _x2 = 0; _x2 < this.size - 1; _x2++) {
          var color = this.modules[_y2][_x2];
          if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) {
            result += QrCode2.PENALTY_N2;
          }
        }
      }
      var dark = 0;
      var _iterator3 = _createForOfIteratorHelper(this.modules), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var row = _step3.value;
          dark = row.reduce(function(sum, color2) {
            return sum + (color2 ? 1 : 0);
          }, dark);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var total = this.size * this.size;
      var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * QrCode2.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of numberegers.
  }, {
    key: "getAlignmentPatternPositions",
    value: function getAlignmentPatternPositions() {
      if (this.version == 1) {
        return [];
      } else {
        var numAlign = Math.floor(this.version / 7) + 2;
        var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        var result = [6];
        for (var pos = this.size - 7; result.length < numAlign; pos -= step) {
          result.splice(1, 0, pos);
        }
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
  }, {
    key: "finderPenaltyCountPatterns",
    value: (
      // Can only be called immediately after a light run is added, and
      // returns either 0, 1, or 2. A helper function for getPenaltyScore().
      function finderPenaltyCountPatterns(runHistory) {
        var n2 = runHistory[1];
        assert(n2 <= this.size * 3);
        var core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
        return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
      }
    )
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  }, {
    key: "finderPenaltyTerminateAndCount",
    value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {
      var currentRunLength = oriCurrentRunLength;
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  }, {
    key: "finderPenaltyAddHistory",
    value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {
      var currentRunLength = oriCurrentRunLength;
      if (runHistory[0] == 0) {
        currentRunLength += this.size;
      }
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
    /*-- Constants and tables --*/
    // The minimum version number supported in the QR Code Model 2 standard.
  }], [{
    key: "encodeText",
    value: (
      /*-- Static factory functions (high level) --*/
      // Returns a QR Code representing the given Unicode text string at the given error correction level.
      // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
      // Unicode code ponumbers (not UTF-16 code units) if the low error correction level is used. The smallest possible
      // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
      // ecl argument if it can be done without increasing the version.
      function encodeText(text, ecl) {
        var segs = QrSegment.makeSegments(text);
        return QrCode2.encodeSegments(segs, ecl);
      }
    )
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
  }, {
    key: "encodeBinary",
    value: function encodeBinary(data, ecl) {
      var seg = QrSegment.makeBytes(data);
      return QrCode2.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
  }, {
    key: "encodeSegments",
    value: function encodeSegments(segs, oriEcl) {
      var minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
      var mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      var boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (!(QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode2.MAX_VERSION) || mask < -1 || mask > 7) {
        throw new RangeError("Invalid value");
      }
      var version2;
      var dataUsedBits;
      for (version2 = minVersion; ; version2++) {
        var _dataCapacityBits = QrCode2.getNumDataCodewords(version2, oriEcl) * 8;
        var usedBits = QrSegment.getTotalBits(segs, version2);
        if (usedBits <= _dataCapacityBits) {
          dataUsedBits = usedBits;
          break;
        }
        if (version2 >= maxVersion) {
          throw new RangeError("Data too long");
        }
      }
      var ecl = oriEcl;
      for (var _i10 = 0, _arr = [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]; _i10 < _arr.length; _i10++) {
        var newEcl = _arr[_i10];
        if (boostEcl && dataUsedBits <= QrCode2.getNumDataCodewords(version2, newEcl) * 8) {
          ecl = newEcl;
        }
      }
      var bb = [];
      var _iterator4 = _createForOfIteratorHelper(segs), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var seg = _step4.value;
          appendBits(seg.mode.modeBits, 4, bb);
          appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
          var _iterator5 = _createForOfIteratorHelper(seg.getData()), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var b = _step5.value;
              bb.push(b);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      assert(bb.length == dataUsedBits);
      var dataCapacityBits = QrCode2.getNumDataCodewords(version2, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {
        appendBits(padByte, 8, bb);
      }
      var dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length) {
        dataCodewords.push(0);
      }
      bb.forEach(function(b2, i) {
        dataCodewords[i >>> 3] |= b2 << 7 - (i & 7);
      });
      return new QrCode2(version2, ecl, dataCodewords, mask);
    }
  }, {
    key: "getNumRawDataModules",
    value: function getNumRawDataModules(ver) {
      if (ver < QrCode2.MIN_VERSION || ver > QrCode2.MAX_VERSION) {
        throw new RangeError("Version number out of range");
      }
      var result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        var numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7) {
          result -= 36;
        }
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
  }, {
    key: "getNumDataCodewords",
    value: function getNumDataCodewords(ver, ecl) {
      return Math.floor(QrCode2.getNumRawDataModules(ver) / 8) - QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
  }, {
    key: "reedSolomonComputeDivisor",
    value: function reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255) {
        throw new RangeError("Degree out of range");
      }
      var result = [];
      for (var i = 0; i < degree - 1; i++) {
        result.push(0);
      }
      result.push(1);
      var root = 1;
      for (var _i11 = 0; _i11 < degree; _i11++) {
        for (var j = 0; j < result.length; j++) {
          result[j] = QrCode2.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length) {
            result[j] ^= result[j + 1];
          }
        }
        root = QrCode2.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
  }, {
    key: "reedSolomonComputeRemainder",
    value: function reedSolomonComputeRemainder(data, divisor) {
      var result = divisor.map(function() {
        return 0;
      });
      var _iterator6 = _createForOfIteratorHelper(data), _step6;
      try {
        var _loop2 = function _loop22() {
          var b = _step6.value;
          var factor = b ^ result.shift();
          result.push(0);
          divisor.forEach(function(coef, i) {
            result[i] ^= QrCode2.reedSolomonMultiply(coef, factor);
          });
        };
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          _loop2();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit numberegers. This could be implemented as a lookup table of 256*256 entries of unumber8.
  }, {
    key: "reedSolomonMultiply",
    value: function reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0) {
        throw new RangeError("Byte out of range");
      }
      var z = 0;
      for (var i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
  }]);
  return QrCode2;
})();
_defineProperty(QrCode, "MIN_VERSION", 1);
_defineProperty(QrCode, "MAX_VERSION", 40);
_defineProperty(QrCode, "PENALTY_N1", 3);
_defineProperty(QrCode, "PENALTY_N2", 3);
_defineProperty(QrCode, "PENALTY_N3", 40);
_defineProperty(QrCode, "PENALTY_N4", 10);
_defineProperty(QrCode, "ECC_CODEWORDS_PER_BLOCK", [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
]);
_defineProperty(QrCode, "NUM_ERROR_CORRECTION_BLOCKS", [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
]);

// node_modules/@rc-component/qrcode/es/utils.js
var ERROR_LEVEL_MAP = {
  L: Ecc.LOW,
  M: Ecc.MEDIUM,
  Q: Ecc.QUARTILE,
  H: Ecc.HIGH
};
var DEFAULT_SIZE4 = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BACKGROUND_COLOR = "#FFFFFF";
var DEFAULT_FRONT_COLOR = "#000000";
var DEFAULT_NEED_MARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
var generatePath = function generatePath2(modules) {
  var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function(row, y) {
    var start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
};
var excavateModules = function excavateModules2(modules, excavation) {
  return modules.slice().map(function(row, y) {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map(function(cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
};
var getImageSettings = function getImageSettings2(cells, size, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w = (imageSettings.width || defaultSize) * scale;
  var h = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
  var excavation = null;
  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y);
    var ceilW = Math.ceil(w + x - floorX);
    var ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  var crossOrigin = imageSettings.crossOrigin;
  return {
    x,
    y,
    h,
    w,
    excavation,
    opacity,
    crossOrigin
  };
};
var getMarginSize = function getMarginSize2(needMargin, marginSize) {
  if (marginSize != null) {
    return Math.max(Math.floor(marginSize), 0);
  }
  return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
};
var isSupportPath2d = (function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (_unused) {
    return false;
  }
  return true;
})();

// node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var import_react105 = __toESM(require_react());

// node_modules/@rc-component/qrcode/es/hooks/useQRCode.js
var import_react104 = __toESM(require_react());
var useQRCode = function useQRCode2(opt) {
  var value = opt.value, level = opt.level, minVersion = opt.minVersion, includeMargin = opt.includeMargin, marginSize = opt.marginSize, imageSettings = opt.imageSettings, size = opt.size, boostLevel = opt.boostLevel;
  var memoizedQrcode = import_react104.default.useMemo(function() {
    var values = Array.isArray(value) ? value : [value];
    var segments = values.reduce(function(acc, val) {
      acc.push.apply(acc, _toConsumableArray(QrSegment.makeSegments(val)));
      return acc;
    }, []);
    return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);
  }, [value, level, minVersion, boostLevel]);
  return import_react104.default.useMemo(function() {
    var cs = memoizedQrcode.getModules();
    var mg = getMarginSize(includeMargin, marginSize);
    var ncs = cs.length + mg * 2;
    var cis = getImageSettings(cs, size, mg, imageSettings);
    return {
      cells: cs,
      margin: mg,
      numCells: ncs,
      calculatedImageSettings: cis,
      qrcode: memoizedQrcode
    };
  }, [memoizedQrcode, size, imageSettings, includeMargin, marginSize]);
};

// node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var _excluded7 = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "marginSize", "style", "imageSettings", "boostLevel"];
var QRCodeCanvas = import_react105.default.forwardRef(function(props, ref) {
  var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE4 : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, marginSize = props.marginSize, style = props.style, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties5(props, _excluded7);
  var imgSrc = imageSettings === null || imageSettings === void 0 ? void 0 : imageSettings.src;
  var _canvas = import_react105.default.useRef(null);
  var _image = import_react105.default.useRef(null);
  var setCanvasRef = import_react105.default.useCallback(function(node) {
    _canvas.current = node;
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref]);
  var _React$useState = import_react105.default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), setIsImageLoaded = _React$useState2[1];
  var _useQRCode = useQRCode({
    value,
    level,
    minVersion,
    includeMargin,
    marginSize,
    imageSettings,
    size,
    boostLevel
  }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
  import_react105.default.useEffect(function() {
    if (_canvas.current) {
      var canvas = _canvas.current;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      var cellsToDraw = cells;
      var image = _image.current;
      var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
      if (haveImageToRender) {
        if (calculatedImageSettings.excavation != null) {
          cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
        }
      }
      var pixelRatio = window.devicePixelRatio || 1;
      canvas.height = canvas.width = size * pixelRatio;
      var scale = size / numCells * pixelRatio;
      ctx.scale(scale, scale);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = fgColor;
      if (isSupportPath2d) {
        ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
      } else {
        cells.forEach(function(row, rdx) {
          row.forEach(function(cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
      if (calculatedImageSettings) {
        ctx.globalAlpha = calculatedImageSettings.opacity;
      }
      if (haveImageToRender) {
        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
      }
    }
  });
  import_react105.default.useEffect(function() {
    setIsImageLoaded(false);
  }, [imgSrc]);
  var canvasStyle = _objectSpread2({
    height: size,
    width: size
  }, style);
  var img = null;
  if (imgSrc != null) {
    img = import_react105.default.createElement("img", {
      alt: "QR-Code",
      src: imgSrc,
      key: imgSrc,
      style: {
        display: "none"
      },
      onLoad: function onLoad() {
        setIsImageLoaded(true);
      },
      ref: _image,
      crossOrigin: calculatedImageSettings === null || calculatedImageSettings === void 0 ? void 0 : calculatedImageSettings.crossOrigin
    });
  }
  return import_react105.default.createElement(import_react105.default.Fragment, null, import_react105.default.createElement("canvas", _extends({
    style: canvasStyle,
    height: size,
    width: size,
    ref: setCanvasRef,
    role: "img"
  }, otherProps)), img);
});
if (true) {
  QRCodeCanvas.displayName = "QRCodeCanvas";
}

// node_modules/@rc-component/qrcode/es/QRCodeSVG.js
var import_react106 = __toESM(require_react());
var _excluded8 = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "title", "marginSize", "imageSettings", "boostLevel"];
var QRCodeSVG = import_react106.default.forwardRef(function(props, ref) {
  var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE4 : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, title = props.title, marginSize = props.marginSize, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties5(props, _excluded8);
  var _useQRCode = useQRCode({
    value,
    level,
    minVersion,
    includeMargin,
    marginSize,
    imageSettings,
    size,
    boostLevel
  }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
  var cellsToDraw = cells;
  var image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image = import_react106.default.createElement("image", {
      href: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none",
      opacity: calculatedImageSettings.opacity,
      crossOrigin: calculatedImageSettings.crossOrigin
    });
  }
  var fgPath = generatePath(cellsToDraw, margin);
  return import_react106.default.createElement("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 ".concat(numCells, " ").concat(numCells),
    ref,
    role: "img"
  }, otherProps), !!title && import_react106.default.createElement("title", null, title), import_react106.default.createElement("path", {
    fill: bgColor,
    d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),
    shapeRendering: "crispEdges"
  }), import_react106.default.createElement("path", {
    fill: fgColor,
    d: fgPath,
    shapeRendering: "crispEdges"
  }), image);
});
if (true) {
  QRCodeSVG.displayName = "QRCodeSVG";
}

// node_modules/antd/es/qr-code/QrcodeStatus.js
var import_react107 = __toESM(require_react());
var defaultSpin = import_react107.default.createElement(spin_default, null);
function QRcodeStatus({
  prefixCls,
  locale: locale2,
  onRefresh,
  statusRender,
  status
}) {
  const defaultExpiredNode = import_react107.default.createElement(import_react107.default.Fragment, null, import_react107.default.createElement("p", {
    className: `${prefixCls}-expired`
  }, locale2?.expired), onRefresh && import_react107.default.createElement(Button_default, {
    type: "link",
    icon: import_react107.default.createElement(ReloadOutlined_default, null),
    onClick: onRefresh
  }, locale2?.refresh));
  const defaultScannedNode = import_react107.default.createElement("p", {
    className: `${prefixCls}-scanned`
  }, locale2?.scanned);
  const defaultNodes = {
    expired: defaultExpiredNode,
    loading: defaultSpin,
    scanned: defaultScannedNode
  };
  const defaultStatusRender = (info) => defaultNodes[info.status];
  const mergedStatusRender = statusRender ?? defaultStatusRender;
  return mergedStatusRender({
    status,
    locale: locale2,
    onRefresh
  });
}

// node_modules/antd/es/qr-code/style/index.js
var genQRCodeStyle = (token) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorSplit
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: token.paddingSM,
      backgroundColor: token.colorWhite,
      borderRadius: token.borderRadiusLG,
      border: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      [`& > ${componentCls}-cover`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: token.colorText,
        lineHeight: token.lineHeight,
        background: token.QRCodeCoverBackgroundColor,
        textAlign: "center",
        [`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: {
          color: token.QRCodeTextColor
        }
      },
      "> canvas": {
        alignSelf: "stretch",
        flex: "auto",
        minWidth: 0
      },
      "&-icon": {
        marginBlockEnd: token.marginXS,
        fontSize: token.controlHeight
      }
    },
    [`${componentCls}-borderless`]: {
      borderColor: "transparent",
      padding: 0,
      borderRadius: 0
    }
  };
};
var prepareComponentToken36 = (token) => ({
  QRCodeCoverBackgroundColor: new FastColor(token.colorBgContainer).setA(0.96).toRgbString()
});
var style_default42 = genStyleHooks("QRCode", (token) => {
  const mergedToken = merge(token, {
    QRCodeTextColor: token.colorText
  });
  return genQRCodeStyle(mergedToken);
}, prepareComponentToken36);

// node_modules/antd/es/qr-code/index.js
var QRCode = (props) => {
  const [, token] = useToken();
  const {
    value,
    type = "canvas",
    icon = "",
    size = 160,
    iconSize,
    color = token.colorText,
    errorLevel = "M",
    status = "active",
    bordered = true,
    onRefresh,
    style,
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    bgColor = "transparent",
    statusRender,
    classNames,
    styles,
    boostLevel,
    ...rest
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("qrcode");
  const mergedProps = {
    ...props,
    bgColor,
    type,
    size,
    status,
    bordered,
    errorLevel
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
  const [hashId, cssVarCls] = style_default42(prefixCls);
  const imageSettings = {
    src: icon,
    x: void 0,
    y: void 0,
    height: typeof iconSize === "number" ? iconSize : iconSize?.height ?? 40,
    width: typeof iconSize === "number" ? iconSize : iconSize?.width ?? 40,
    excavate: true,
    crossOrigin: "anonymous"
  };
  const a11yProps = pickAttrs(rest, true);
  const restProps = omit(rest, Object.keys(a11yProps));
  const qrCodeProps = {
    value,
    size,
    level: errorLevel,
    bgColor,
    fgColor: color,
    style: {
      width: style?.width,
      height: style?.height
    },
    imageSettings: icon ? imageSettings : void 0,
    boostLevel,
    ...a11yProps
  };
  const [locale2] = useLocale_default("QRCode");
  if (true) {
    const warning2 = devUseWarning("QRCode");
    true ? warning2(!!value, "usage", "need to receive `value` props") : void 0;
    true ? warning2(!(icon && errorLevel === "L"), "usage", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.") : void 0;
  }
  if (!value) {
    return null;
  }
  const rootClassNames = clsx(prefixCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-borderless`]: !bordered
  });
  const rootStyle = {
    backgroundColor: bgColor,
    ...mergedStyles.root,
    ...contextStyle,
    ...style,
    width: style?.width ?? size,
    height: style?.height ?? size
  };
  return import_react108.default.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: rootStyle
  }, status !== "active" && import_react108.default.createElement("div", {
    className: clsx(`${prefixCls}-cover`, mergedClassNames.cover),
    style: mergedStyles.cover
  }, import_react108.default.createElement(QRcodeStatus, {
    prefixCls,
    locale: locale2,
    status,
    onRefresh,
    statusRender
  })), type === "canvas" ? import_react108.default.createElement(QRCodeCanvas, {
    ...qrCodeProps
  }) : import_react108.default.createElement(QRCodeSVG, {
    ...qrCodeProps
  }));
};
if (true) {
  QRCode.displayName = "QRCode";
}
var qr_code_default = QRCode;

// node_modules/antd/es/rate/index.js
var React317 = __toESM(require_react());

// node_modules/@rc-component/rate/es/Rate.js
var import_react110 = __toESM(require_react());

// node_modules/@rc-component/rate/es/Star.js
var import_react109 = __toESM(require_react());
function Star(props, ref) {
  const {
    disabled,
    prefixCls,
    character,
    characterRender,
    index: index2,
    count,
    value,
    allowHalf,
    focused,
    onHover,
    onClick
  } = props;
  const onInternalHover = (e3) => {
    onHover(e3, index2);
  };
  const onInternalClick = (e3) => {
    onClick(e3, index2);
  };
  const onInternalKeyDown = (e3) => {
    if (e3.keyCode === KeyCode_default.ENTER) {
      onClick(e3, index2);
    }
  };
  const starValue = index2 + 1;
  const classNameList = /* @__PURE__ */ new Set([prefixCls]);
  if (value === 0 && index2 === 0 && focused) {
    classNameList.add(`${prefixCls}-focused`);
  } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
    classNameList.add(`${prefixCls}-half`);
    classNameList.add(`${prefixCls}-active`);
    if (focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  } else {
    if (starValue <= value) {
      classNameList.add(`${prefixCls}-full`);
    } else {
      classNameList.add(`${prefixCls}-zero`);
    }
    if (starValue === value && focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  }
  const characterNode = typeof character === "function" ? character(props) : character;
  let start = import_react109.default.createElement("li", {
    className: clsx(Array.from(classNameList)),
    ref
  }, import_react109.default.createElement("div", {
    onClick: disabled ? null : onInternalClick,
    onKeyDown: disabled ? null : onInternalKeyDown,
    onMouseMove: disabled ? null : onInternalHover,
    role: "radio",
    "aria-checked": value > index2 ? "true" : "false",
    "aria-posinset": index2 + 1,
    "aria-setsize": count,
    tabIndex: disabled ? -1 : 0
  }, import_react109.default.createElement("div", {
    className: `${prefixCls}-first`
  }, characterNode), import_react109.default.createElement("div", {
    className: `${prefixCls}-second`
  }, characterNode)));
  if (characterRender) {
    start = characterRender(start, props);
  }
  return start;
}
var Star_default = import_react109.default.forwardRef(Star);

// node_modules/@rc-component/rate/es/useRefs.js
var React315 = __toESM(require_react());
function useRefs2() {
  const nodeRef = React315.useRef({});
  function getRef(index2) {
    return nodeRef.current[index2];
  }
  function setRef(index2) {
    return (node) => {
      nodeRef.current[index2] = node;
    };
  }
  return [getRef, setRef];
}

// node_modules/@rc-component/rate/es/util.js
function getScroll3(w) {
  let ret = w.pageXOffset;
  const method = "scrollLeft";
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method];
    if (typeof ret !== "number") {
      ret = d.body[method];
    }
  }
  return ret;
}
function getClientPosition(elem) {
  let x;
  let y;
  const doc = elem.ownerDocument;
  const {
    body
  } = doc;
  const docElem = doc && doc.documentElement;
  const box2 = elem.getBoundingClientRect();
  x = box2.left;
  y = box2.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getOffsetLeft(el) {
  const pos = getClientPosition(el);
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll3(w);
  return pos.left;
}

// node_modules/@rc-component/rate/es/Rate.js
function _extends54() {
  _extends54 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends54.apply(this, arguments);
}
function Rate(props, ref) {
  const {
    // Base
    prefixCls = "rc-rate",
    className,
    // Value
    defaultValue,
    value: propValue,
    count = 5,
    allowHalf = false,
    allowClear = true,
    keyboard = true,
    // Display
    character = "",
    characterRender,
    // Meta
    disabled,
    direction = "ltr",
    tabIndex = 0,
    autoFocus,
    // Events
    onHoverChange,
    onChange,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onMouseLeave,
    ...restProps
  } = props;
  const [getStarRef, setStarRef] = useRefs2();
  const rateRef = import_react110.default.useRef(null);
  const triggerFocus2 = () => {
    if (!disabled) {
      rateRef.current?.focus();
    }
  };
  import_react110.default.useImperativeHandle(ref, () => ({
    focus: triggerFocus2,
    blur: () => {
      if (!disabled) {
        rateRef.current?.blur();
      }
    }
  }));
  const [value, setValue] = useControlledState(defaultValue || 0, propValue);
  const [cleanedValue, setCleanedValue] = useControlledState(null);
  const getStarValue = (index2, x) => {
    const reverse = direction === "rtl";
    let starValue = index2 + 1;
    if (allowHalf) {
      const starEle = getStarRef(index2);
      const leftDis = getOffsetLeft(starEle);
      const width = starEle.clientWidth;
      if (reverse && x - leftDis > width / 2) {
        starValue -= 0.5;
      } else if (!reverse && x - leftDis < width / 2) {
        starValue -= 0.5;
      }
    }
    return starValue;
  };
  const changeValue = (nextValue) => {
    setValue(nextValue);
    onChange?.(nextValue);
  };
  const [focused, setFocused] = import_react110.default.useState(false);
  const onInternalFocus = () => {
    setFocused(true);
    onFocus?.();
  };
  const onInternalBlur = () => {
    setFocused(false);
    onBlur?.();
  };
  const [hoverValue, setHoverValue] = import_react110.default.useState(null);
  const onHover = (event, index2) => {
    const nextHoverValue = getStarValue(index2, event.pageX);
    if (nextHoverValue !== cleanedValue) {
      setHoverValue(nextHoverValue);
      setCleanedValue(null);
    }
    onHoverChange?.(nextHoverValue);
  };
  const onMouseLeaveCallback = (event) => {
    if (!disabled) {
      setHoverValue(null);
      setCleanedValue(null);
      onHoverChange?.(void 0);
    }
    if (event) {
      onMouseLeave?.(event);
    }
  };
  const onClick = (event, index2) => {
    const newValue = getStarValue(index2, event.pageX);
    let isReset = false;
    if (allowClear) {
      isReset = newValue === value;
    }
    onMouseLeaveCallback();
    changeValue(isReset ? 0 : newValue);
    setCleanedValue(isReset ? newValue : null);
  };
  const onInternalKeyDown = (event) => {
    const {
      keyCode
    } = event;
    const reverse = direction === "rtl";
    const step = allowHalf ? 0.5 : 1;
    if (keyboard) {
      if (keyCode === KeyCode_default.RIGHT && value < count && !reverse) {
        changeValue(value + step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && value > 0 && !reverse) {
        changeValue(value - step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.RIGHT && value > 0 && reverse) {
        changeValue(value - step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && value < count && reverse) {
        changeValue(value + step);
        event.preventDefault();
      }
    }
    onKeyDown2?.(event);
  };
  import_react110.default.useEffect(() => {
    if (autoFocus && !disabled) {
      triggerFocus2();
    }
  }, []);
  const starNodes = new Array(count).fill(0).map((item, index2) => import_react110.default.createElement(Star_default, {
    ref: setStarRef(index2),
    index: index2,
    count,
    disabled,
    prefixCls: `${prefixCls}-star`,
    allowHalf,
    value: hoverValue === null ? value : hoverValue,
    onClick,
    onHover,
    key: item || index2,
    character,
    characterRender,
    focused
  }));
  const classString = clsx(prefixCls, className, {
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  return import_react110.default.createElement("ul", _extends54({
    className: classString,
    onMouseLeave: onMouseLeaveCallback,
    tabIndex: disabled ? -1 : tabIndex,
    onFocus: disabled ? null : onInternalFocus,
    onBlur: disabled ? null : onInternalBlur,
    onKeyDown: disabled ? null : onInternalKeyDown,
    ref: rateRef
  }, pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  })), starNodes);
}
var Rate_default = import_react110.default.forwardRef(Rate);

// node_modules/@rc-component/rate/es/index.js
var es_default20 = Rate_default;

// node_modules/antd/es/rate/style/index.js
var genRateStarStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: token.marginXS
      },
      "> div": {
        transition: `all ${token.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: token.starHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${unit(token.lineWidth)} dashed ${token.starColor}`,
          transform: token.starHoverScale
        }
      },
      "&-first, &-second": {
        color: token.starBg,
        transition: `all ${token.motionDurationMid}`,
        userSelect: "none"
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: {
        opacity: 1
      },
      [`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: {
        color: "inherit"
      }
    }
  };
};
var genRateRtlStyle = (token) => ({
  [`&-rtl${token.componentCls}`]: {
    direction: "rtl"
  }
});
var genRateStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: token.starColor,
      fontSize: token.starSize,
      lineHeight: 1,
      listStyle: "none",
      outline: "none",
      "&-small": {
        fontSize: token.starSizeSM
      },
      "&-large": {
        fontSize: token.starSizeLG
      },
      // disable styles
      [`&-disabled${componentCls} ${componentCls}-star`]: {
        cursor: "default",
        "> div:hover": {
          transform: "scale(1)"
        }
      },
      // star styles
      ...genRateStarStyle(token),
      // rtl styles
      ...genRateRtlStyle(token)
    }
  };
};
var prepareComponentToken37 = (token) => ({
  starColor: token.yellow6,
  starSize: token.controlHeight * 0.625,
  starSizeSM: token.controlHeightSM * 0.625,
  starSizeLG: token.controlHeightLG * 0.625,
  starHoverScale: "scale(1.1)",
  starBg: token.colorFillContent
});
var style_default43 = genStyleHooks("Rate", (token) => {
  const rateToken = merge(token, {});
  return genRateStyle(rateToken);
}, prepareComponentToken37);

// node_modules/antd/es/rate/index.js
var isTooltipProps = (item) => {
  return typeof item === "object" && item !== null;
};
var Rate2 = React317.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    rootClassName,
    style,
    tooltips,
    character = React317.createElement(StarFilled_default, null),
    disabled: customDisabled,
    size = "middle",
    ...rest
  } = props;
  const characterRender = (node, {
    index: index2
  }) => {
    if (!tooltips) {
      return node;
    }
    const tooltipsItem = tooltips[index2];
    if (isTooltipProps(tooltipsItem)) {
      return React317.createElement(tooltip_default, {
        ...tooltipsItem
      }, node);
    }
    return React317.createElement(tooltip_default, {
      title: tooltipsItem
    }, node);
  };
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("rate");
  const ratePrefixCls = getPrefixCls("rate", prefixCls);
  const [hashId, cssVarCls] = style_default43(ratePrefixCls);
  const mergedStyle = {
    ...contextStyle,
    ...style
  };
  const disabled = React317.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  return React317.createElement(es_default20, {
    ref,
    character,
    characterRender,
    disabled: mergedDisabled,
    ...rest,
    className: clsx(`${ratePrefixCls}-${size}`, className, rootClassName, hashId, cssVarCls, contextClassName),
    style: mergedStyle,
    prefixCls: ratePrefixCls,
    direction
  });
});
if (true) {
  Rate2.displayName = "Rate";
}
var rate_default = Rate2;

// node_modules/antd/es/result/index.js
var React321 = __toESM(require_react());

// node_modules/antd/es/result/noFound.js
var React318 = __toESM(require_react());
var NoFound = () => React318.createElement("svg", {
  width: "252",
  height: "294"
}, React318.createElement("title", null, "No Found"), React318.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React318.createElement("circle", {
  cx: "126.75",
  cy: "128.1",
  r: "126",
  fill: "#E4EBF7"
}), React318.createElement("circle", {
  cx: "31.55",
  cy: "130.8",
  r: "8.3",
  fill: "#FFF"
}), React318.createElement("path", {
  stroke: "#FFF",
  d: "m37 134.3 10.5 6m.9 6.2-12.7 10.8",
  strokeWidth: "2"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M39.9 159.4a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m17.7-16.2a5.7 5.7 0 1 1-11.4-1.1 5.7 5.7 0 0 1 11.4 1.1M99 27h29.8a4.6 4.6 0 1 0 0-9.2H99a4.6 4.6 0 1 0 0 9.2m11.4 18.3h29.8a4.6 4.6 0 0 0 0-9.2h-29.8a4.6 4.6 0 1 0 0 9.2"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M112.8 26.9h15.8a4.6 4.6 0 1 0 0 9.1h-15.8a4.6 4.6 0 0 0 0-9.1m71.7 108.8a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), React318.createElement("path", {
  stroke: "#FFF",
  d: "m179.3 141.8 12.6 7.1m1.1 7.6-15.2 13",
  strokeWidth: "2"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M184.7 170a6.8 6.8 0 1 1-13.6-1.3 6.8 6.8 0 0 1 13.6 1.4m18.6-16.8a6.9 6.9 0 1 1-13.7-1.4 6.9 6.9 0 0 1 13.7 1.4"
}), React318.createElement("path", {
  stroke: "#FFF",
  d: "M152 192.3a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm73.3-76.2a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm-9 35a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.5 0zM177 107.6a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.4-15.4a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm6.8 88.5a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0z",
  strokeWidth: "2"
}), React318.createElement("path", {
  stroke: "#FFF",
  d: "m214.4 153.3-2 20.2-10.8 6m-28-4.7-6.3 9.8H156l-4.5 6.5m23.5-66v-15.7m46 7.8-13 8-15.2-8V94.4",
  strokeWidth: "2"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M166.6 66h-4a4.8 4.8 0 0 1-4.7-4.8 4.8 4.8 0 0 1 4.7-4.7h4a4.8 4.8 0 0 1 4.7 4.7 4.8 4.8 0 0 1-4.7 4.7"
}), React318.createElement("circle", {
  cx: "204.3",
  cy: "30",
  r: "29.5",
  fill: "#1677ff"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M206 38.4c.5.5.7 1.1.7 2s-.2 1.4-.7 1.9a3 3 0 0 1-2 .7c-.8 0-1.5-.3-2-.8s-.8-1.1-.8-1.9.3-1.4.8-2c.5-.4 1.2-.7 2-.7.7 0 1.4.3 2 .8m4.2-19.5c1.5 1.3 2.2 3 2.2 5.2a7.2 7.2 0 0 1-1.5 4.5l-3 2.7a5 5 0 0 0-1.3 1.7 5.2 5.2 0 0 0-.6 2.4v.5h-4v-.5c0-1.4.1-2.5.6-3.5s1.9-2.5 4.2-4.5l.4-.5a4 4 0 0 0 1-2.6c0-1.2-.4-2-1-2.8-.7-.6-1.6-1-2.9-1-1.5 0-2.6.5-3.3 1.5-.4.5-.6 1-.8 1.9a2 2 0 0 1-2 1.6 2 2 0 0 1-2-2.4c.4-1.6 1-2.8 2.1-3.8a8.5 8.5 0 0 1 6.3-2.3c2.3 0 4.2.6 5.6 2"
}), React318.createElement("path", {
  fill: "#FFB594",
  d: "M52 76.1s21.8 5.4 27.3 16c5.6 10.7-6.3 9.2-15.7 5C52.8 92 39 85 52 76"
}), React318.createElement("path", {
  fill: "#FFC6A0",
  d: "m90.5 67.5-.5 2.9c-.7.5-4.7-2.7-4.7-2.7l-1.7.8-1.3-5.7s6.8-4.6 9-5c2.4-.5 9.8 1 10.6 2.3 0 0 1.3.4-2.2.6-3.6.3-5 .5-6.8 3.2l-2.4 3.6"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M128 111.4a36.7 36.7 0 0 0-8.9-15.5c-3.5-3-9.3-2.2-11.3-4.2-1.3-1.2-3.2-1.2-3.2-1.2L87.7 87c-2.3-.4-2.1-.7-6-1.4-1.6-1.9-3-1.1-3-1.1l-7-1.4c-1-1.5-2.5-1-2.5-1l-2.4-.9C65 91.2 59 95 59 95c1.8 1.1 15.7 8.3 15.7 8.3l5.1 37.1s-3.3 5.7 1.4 9.1c0 0 19.9-3.7 34.9-.3 0 0 3-2.6 1-8.8.5-3 1.4-8.3 1.7-11.6.4.7 2 1.9 3.1 3.4 0 0 9.4-7.3 11-14a17 17 0 0 1-2.2-2.4c-.5-.8-.3-2-.7-2.8-.7-1-1.8-1.3-2-1.6"
}), React318.createElement("path", {
  fill: "#CBD1D1",
  d: "M101 290s4.4 2 7.4 1c2.9-1 4.6.7 7.1 1.2 2.6.5 6.9 1.1 11.7-1.3 0-5.5-6.9-4-12-6.7-2.5-1.4-3.7-4.7-3.5-8.8h-9.5s-1.2 10.6-1 14.6"
}), React318.createElement("path", {
  fill: "#2B0849",
  d: "M101 289.8s2.5 1.3 6.8.7c3-.5 3.7.5 7.4 1 3.8.6 10.8 0 11.9-.9.4 1.1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.6-.5-1.8-1.4-5.2-1.9-5.7-.2-4 1-7.4-.3-7.4-.3l-.1-2.7z"
}), React318.createElement("path", {
  fill: "#A4AABA",
  d: "M108.3 276h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), React318.createElement("path", {
  fill: "#CBD1D1",
  d: "M57.5 272.4s-2 7.4-4.4 12.3c-1.8 3.7-4.3 7.5 5.4 7.5 6.7 0 9-.5 7.4-6.6-1.5-6.1.3-13.2.3-13.2h-8.7z"
}), React318.createElement("path", {
  fill: "#2B0849",
  d: "M51.5 289.8s2 1.2 6.6 1.2c6 0 8.3-1.7 8.3-1.7s.6 1.1-.7 2.2c-1 .8-3.6 1.6-7.4 1.5-4.1 0-5.8-.5-6.7-1.1-.8-.6-.7-1.6-.1-2.1"
}), React318.createElement("path", {
  fill: "#A4AABA",
  d: "M58.4 274.3s0 1.5-.3 3c-.3 1.4-1 3-1.1 4 0 1.2 4.5 1.7 5.1.1.6-1.5 1.3-6.4 2-7.2.6-.9-5-2.2-5.7.1"
}), React318.createElement("path", {
  fill: "#7BB2F9",
  d: "m99.7 278.5 13.3.1s1.3-54.5 1.9-64.4c.5-9.9 3.8-43.4 1-63.1l-12.6-.7-22.8.8-1.2 10c0 .5-.7.8-.7 1.4-.1.5.4 1.3.3 2-2.4 14-6.4 33-8.8 46.6 0 .7-1.2 1-1.4 2.7 0 .3.2 1.5 0 1.8-6.8 18.7-10.9 47.8-14.2 61.9h14.6s2.2-8.6 4-17c2.9-12.9 23.2-85 23.2-85l3-.5 1 46.3s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.8-1 11.8c-.4 4.8 0 39.2 0 39.2"
}), React318.createElement("path", {
  stroke: "#648BD8",
  d: "M76 221.6c1.2.1 4.1-2 7-5m23.4 8.5s2.7-1 6-3.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#648BD8",
  d: "M107.3 222.1s2.7-1.1 6-3.9",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}), React318.createElement("path", {
  stroke: "#648BD8",
  d: "M74.7 224.8s2.7-.6 6.5-3.4m4.8-69.8c-.2 3.1.3 8.6-4.3 9.2m22-11s0 14-1.4 15.1a15 15 0 0 1-3 2m.5-16.5s0 13-1.2 24.4m-5 1.1s7.3-1.7 9.5-1.7M74.3 206a212 212 0 0 1-1 4.5s-1.4 1.9-1 3.8c.5 2-1 2-5 15.4A353 353 0 0 0 61 257l-.2 1.2m14.9-60.5a321 321 0 0 1-.9 4.8m7.8-50.4-1.2 10.5s-1.1.1-.5 2.2c.1 1.4-2.7 15.8-5.2 30.5m-19.6 79h13.3",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  fill: "#192064",
  d: "M116.2 148.2s-17-3-35.9.2c.2 2.5 0 4.2 0 4.2s14.7-2.8 35.7-.3c.3-2.4.2-4 .2-4"
}), React318.createElement("path", {
  fill: "#FFF",
  d: "M106.3 151.2v-5a.8.8 0 0 0-.8-.8h-7.8a.8.8 0 0 0-.8.8v5a.8.8 0 0 0 .8.8h7.8a.8.8 0 0 0 .8-.8"
}), React318.createElement("path", {
  fill: "#192064",
  d: "M105.2 150.2v-3a.6.6 0 0 0-.6-.7 94.3 94.3 0 0 0-5.9 0 .7.7 0 0 0-.6.6v3.1a.6.6 0 0 0 .6.7 121.1 121.1 0 0 1 5.8 0c.4 0 .7-.3.7-.7"
}), React318.createElement("path", {
  stroke: "#648BD8",
  d: "M100.3 275.4h12.3m-11.2-4.9.1 6.5m0-12.5a915.8 915.8 0 0 0 0 4.4m-.5-94 .9 44.7s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.2 0 3.4-.6 1.5-1 21.1-1.1 35.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  fill: "#FFC6A0",
  d: "M46.9 83.4s-.5 6 7.2 5.6c11.2-.7 9.2-9.4 31.5-21.7-.7-2.7-2.4-4.7-2.4-4.7s-11 3-22.6 8c-6.8 3-13.4 6.4-13.7 12.8m57.6 7.7.9-5.4-8.9-11.4-5 5.3-1.8 7.9a.3.3 0 0 0 .1.3c1 .8 6.5 5 14.4 3.5a.3.3 0 0 0 .3-.2"
}), React318.createElement("path", {
  fill: "#FFC6A0",
  d: "M94 79.4s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.1-3.7c.6-1 1.6-4.1 1.6-4.1l13.5 3c0 5.3-2.3 19.5-7.8 20-8.9.6-12.5-9.5-12.5-9.5"
}), React318.createElement("path", {
  fill: "#520038",
  d: "M113.9 73.4c2.6-2 3.4-9.7 3.4-9.7s-2.4-.5-6.6-2c-4.7-2.1-12.8-4.8-17.5 1-9.6 3.2-2 19.8-2 19.8l2.7-3s-4-3.3-2-6.3c2-3.5 3.8 1 3.8 1s.7-2.3 3.6-3.3c.4-.7 1-2.6 1.4-3.8a1 1 0 0 1 1.3-.7l11.4 2.6c.5.2.8.7.8 1.2l-.3 3.2z"
}), React318.createElement("path", {
  fill: "#552950",
  d: "M105 76c-.1.7-.6 1.1-1 1-.6 0-.9-.6-.8-1.2.1-.6.6-1 1-1 .6 0 .9.7.8 1.3m7.1 1.6c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.5-1 1-1 .5.1.8.7.7 1.3"
}), React318.createElement("path", {
  stroke: "#DB836E",
  d: "m110.1 74.8-.9 1.7-.3 4.3h-2.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#5C2552",
  d: "M110.8 74.5s1.8-.7 2.6.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#DB836E",
  d: "M92.4 74.3s.5-1.1 1.1-.7c.6.4 1.3 1.4.6 2-.8.5.1 1.6.1 1.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#5C2552",
  d: "M103.3 73s1.8 1 4.1.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#DB836E",
  d: "M103.7 81.8s2.2 1.2 4.4 1.2m-3.5 1.3s1 .4 1.6.3m-11.5-3.4s2.3 7.4 10.4 7.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#E4EBF7",
  d: "M81.5 89.4s.4 5.6-5 12.8M69 82.7s-.7 9.2-8.2 14.2m68.6 26s-5.3 7.4-9.4 10.7m-.7-26.3s.5 4.4-2.1 32",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  fill: "#F2D7AD",
  d: "M150 151.2h-49.8a1 1 0 0 1-1-1v-31.7c0-.5.4-1 1-1H150c.6 0 1 .5 1 1v31.7a1 1 0 0 1-1 1"
}), React318.createElement("path", {
  fill: "#F4D19D",
  d: "M150.3 151.2h-19.9v-33.7h20.8v32.8a1 1 0 0 1-1 1"
}), React318.createElement("path", {
  fill: "#F2D7AD",
  d: "M123.6 127.9H92.9a.5.5 0 0 1-.4-.8l6.4-9.1c.2-.3.5-.5.8-.5h31.1l-7.2 10.4z"
}), React318.createElement("path", {
  fill: "#CC9B6E",
  d: "M123.7 128.4H99.2v-.5h24.2l7.2-10.2.4.3z"
}), React318.createElement("path", {
  fill: "#F4D19D",
  d: "M158.3 127.9h-18.7a2 2 0 0 1-1.6-.8l-7.2-9.6h20c.5 0 1 .3 1.2.6l6.7 9a.5.5 0 0 1-.4.8"
}), React318.createElement("path", {
  fill: "#CC9B6E",
  d: "M157.8 128.5h-19.3l-7.9-10.5.4-.3 7.7 10.3h19.1zm-27.2 22.2v-8.2h.4v8.2zm-.1-10.9v-21.4h.4l.1 21.4zm-18.6 1.1-.5-.1 1.5-5.2.5.2zm-3.5.2-2.6-3 2.6-3.4.4.3-2.4 3.1 2.4 2.6zm8.2 0-.4-.4 2.4-2.6-2.4-3 .4-.4 2.7 3.4z"
}), React318.createElement("path", {
  fill: "#FFC6A0",
  d: "m154.3 131.9-3.1-2v3.5l-1 .1a85 85 0 0 1-4.8.3c-1.9 0-2.7 2.2 2.2 2.6l-2.6-.6s-2.2 1.3.5 2.3c0 0-1.6 1.2.6 2.6-.6 3.5 5.2 4 7 3.6a6.1 6.1 0 0 0 4.6-5.2 8 8 0 0 0-3.4-7.2"
}), React318.createElement("path", {
  stroke: "#DB836E",
  d: "M153.7 133.6s-6.5.4-8.4.3c-1.8 0-1.9 2.2 2.4 2.3 3.7.2 5.4 0 5.4 0",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  stroke: "#DB836E",
  d: "M145.2 135.9c-1.9 1.3.5 2.3.5 2.3s3.5 1 6.8.6m-.6 2.9s-6.3.1-6.7-2.1c-.3-1.4.4-1.4.4-1.4m.5 2.7s-1 3.1 5.5 3.5m-.4-14.5v3.5M52.8 89.3a18 18 0 0 0 13.6-7.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React318.createElement("path", {
  fill: "#5BA02E",
  d: "M168.6 248.3a6.6 6.6 0 0 1-6.7-6.6v-66.5a6.6 6.6 0 1 1 13.3 0v66.5a6.6 6.6 0 0 1-6.6 6.6"
}), React318.createElement("path", {
  fill: "#92C110",
  d: "M176.5 247.7a6.6 6.6 0 0 1-6.6-6.7v-33.2a6.6 6.6 0 1 1 13.3 0V241a6.6 6.6 0 0 1-6.7 6.7"
}), React318.createElement("path", {
  fill: "#F2D7AD",
  d: "M186.4 293.6H159a3.2 3.2 0 0 1-3.2-3.2v-46.1a3.2 3.2 0 0 1 3.2-3.2h27.5a3.2 3.2 0 0 1 3.2 3.2v46.1a3.2 3.2 0 0 1-3.2 3.2"
}), React318.createElement("path", {
  stroke: "#E4EBF7",
  d: "M89 89.5s7.8 5.4 16.6 2.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
})));
var noFound_default = NoFound;

// node_modules/antd/es/result/serverError.js
var React319 = __toESM(require_react());
var ServerError = () => React319.createElement("svg", {
  width: "254",
  height: "294"
}, React319.createElement("title", null, "Server Error"), React319.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React319.createElement("path", {
  fill: "#E4EBF7",
  d: "M0 128.1v-2C0 56.5 56.3.2 125.7.2h2.1C197.2.3 253.5 56.6 253.5 126v2.1c0 69.5-56.3 125.7-125.7 125.7h-2.1A125.7 125.7 0 0 1 0 128.1"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M40 132.1a8.3 8.3 0 1 1-16.6-1.7 8.3 8.3 0 0 1 16.6 1.7"
}), React319.createElement("path", {
  stroke: "#FFF",
  d: "m37.2 135.6 10.5 6m1 6.3-12.8 10.8",
  strokeWidth: "2"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M40.1 160.8a5.7 5.7 0 1 1-11.3-1.1 5.7 5.7 0 0 1 11.3 1.1M58 144.6a5.7 5.7 0 1 1-11.4-1.2 5.7 5.7 0 0 1 11.4 1.2M99.7 27.4h30a4.6 4.6 0 1 0 0-9.2h-30a4.6 4.6 0 0 0 0 9.2M111 46h30a4.6 4.6 0 1 0 0-9.3h-30a4.6 4.6 0 1 0 0 9.3m2.5-18.6h16a4.6 4.6 0 1 0 0 9.3h-16a4.6 4.6 0 0 0 0-9.3m36.7 42.7h-4a4.8 4.8 0 0 1-4.8-4.8 4.8 4.8 0 0 1 4.8-4.8h4a4.8 4.8 0 0 1 4.7 4.8 4.8 4.8 0 0 1-4.7 4.8"
}), React319.createElement("circle", {
  cx: "201.35",
  cy: "30.2",
  r: "29.7",
  fill: "#FF603B"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "m203.6 19.4-.7 15a1.5 1.5 0 0 1-3 0l-.7-15a2.2 2.2 0 1 1 4.4 0m-.3 19.4c.5.5.8 1.1.8 1.9s-.3 1.4-.8 1.9a3 3 0 0 1-2 .7 2.5 2.5 0 0 1-1.8-.7c-.6-.6-.8-1.2-.8-2 0-.7.2-1.3.8-1.8.5-.5 1.1-.7 1.8-.7.8 0 1.5.2 2 .7"
}), React319.createElement("path", {
  fill: "#FFB594",
  d: "M119.3 133.3c4.4-.6 3.6-1.2 4-4.8.8-5.2-3-17-8.2-25.1-1-10.7-12.6-11.3-12.6-11.3s4.3 5 4.2 16.2c1.4 5.3.8 14.5.8 14.5s5.3 11.4 11.8 10.5"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M101 91.6s1.4-.6 3.2.6c8 1.4 10.3 6.7 11.3 11.4 1.8 1.2 1.8 2.3 1.8 3.5l1.5 3s-7.2 1.7-11 6.7c-1.3-6.4-6.9-25.2-6.9-25.2"
}), React319.createElement("path", {
  fill: "#FFB594",
  d: "m94 90.5 1-5.8-9.2-11.9-5.2 5.6-2.6 9.9s8.4 5 16 2.2"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M83 78.2s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.2-3.7c.5-1 1.5-4.2 1.5-4.2l13.6 3.2c0 5.2-2.3 19.5-7.9 20-8.9.6-12.5-9.6-12.5-9.6"
}), React319.createElement("path", {
  fill: "#520038",
  d: "M103 72.2c2.6-2 3.5-9.7 3.5-9.7s-2.5-.5-6.7-2c-4.7-2.2-12.9-4.9-17.6.9-9.5 4.4-2 20-2 20l2.7-3.1s-4-3.3-2.1-6.3c2.2-3.5 4 1 4 1s.6-2.3 3.5-3.3c.4-.7 1-2.7 1.5-3.8A1 1 0 0 1 91 65l11.5 2.7c.5.1.8.6.8 1.2l-.3 3.2z"
}), React319.createElement("path", {
  fill: "#552950",
  d: "M101.2 76.5c0 .6-.6 1-1 1-.5-.1-.9-.7-.8-1.3.1-.6.6-1 1.1-1 .5.1.8.7.7 1.3m-7-1.4c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.6-1 1-1 .5.1.9.7.8 1.3"
}), React319.createElement("path", {
  stroke: "#DB836E",
  d: "m99.2 73.6-.9 1.7-.3 4.3h-2.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#5C2552",
  d: "M100 73.3s1.7-.7 2.4.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#DB836E",
  d: "M81.4 73s.4-1 1-.6c.7.4 1.4 1.4.6 2s.2 1.6.2 1.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#5C2552",
  d: "M92.3 71.7s1.9 1.1 4.2 1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#DB836E",
  d: "M92.7 80.6s2.3 1.2 4.4 1.2m-3.4 1.4s1 .4 1.5.3M83.7 80s1.8 6.6 9.2 8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#E4EBF7",
  d: "M95.5 91.7s-1 2.8-8.2 2c-7.3-.6-10.3-5-10.3-5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M78.1 87.5s6.6 5 16.5 2.5c0 0 9.6 1 11.5 5.3 5.4 11.8.6 36.8 0 40 3.5 4-.4 8.4-.4 8.4-15.7-3.5-35.8-.6-35.8-.6-4.9-3.5-1.3-9-1.3-9l-6.2-23.8c-2.5-15.2.8-19.8 3.5-20.7 3-1 8-1.3 8-1.3.6 0 1.1 0 1.4-.2 2.4-1.3 2.8-.6 2.8-.6"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M65.8 89.8s-6.8.5-7.6 8.2c-.4 8.8 3 11 3 11s6.1 22 16.9 22.9c8.4-2.2 4.7-6.7 4.6-11.4-.2-11.3-7-17-7-17s-4.3-13.7-9.9-13.7"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M71.7 124.2s.9 11.3 9.8 6.5c4.8-2.5 7.6-13.8 9.8-22.6A201 201 0 0 0 94 96l-5-1.7s-2.4 5.6-7.7 12.3c-4.4 5.5-9.2 11.1-9.5 17.7"
}), React319.createElement("path", {
  stroke: "#E4EBF7",
  d: "M108.5 105.2s1.7 2.7-2.4 30.5c2.4 2.2 1 6-.2 7.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M123.3 131.5s-.5 2.8-11.8 2c-15.2-1-25.3-3.2-25.3-3.2l.9-5.8s.7.2 9.7-.1c11.9-.4 18.7-6 25-1 4 3.2 1.5 8.1 1.5 8.1"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M70.2 91s-5.6-4.8-11 2.7c-3.3 7.2.5 15.2 2.6 19.5-.3 3.8 2.4 4.3 2.4 4.3s0 1 1.5 2.7c4-7 6.7-9.1 13.7-12.5-.3-.7-1.9-3.3-1.8-3.8.2-1.7-1.3-2.6-1.3-2.6s-.3-.2-1.2-2.8c-.8-2.3-2-5.1-4.9-7.5"
}), React319.createElement("path", {
  fill: "#CBD1D1",
  d: "M90.2 288s4.9 2.3 8.3 1.2c3.2-1 5.2.7 8 1.3a20 20 0 0 0 13.3-1.4c-.2-6.2-7.8-4.5-13.6-7.6-2.9-1.6-4.2-5.3-4-10H91.5s-1.5 12-1.3 16.5"
}), React319.createElement("path", {
  fill: "#2B0849",
  d: "M90.2 287.8s2.8 1.5 7.6.8c3.5-.5 3.3.6 7.5 1.3 4.2.6 13-.2 14.3-1.2.5 1.3-.4 2.4-.4 2.4s-1.7.6-5.4.9c-2.3.1-8.1.3-10.2-.6-2-1.6-4.9-1.5-6-.3-4.5 1.1-7.2-.3-7.2-.3l-.2-3z"
}), React319.createElement("path", {
  fill: "#A4AABA",
  d: "M98.4 272.3h3.5s0 7.5 5.2 9.6c-5.3.7-9.7-2.6-8.7-9.6"
}), React319.createElement("path", {
  fill: "#CBD1D1",
  d: "M44.4 272s-2.2 7.8-4.7 13c-1.9 3.8-4.4 7.8 5.8 7.8 7 0 9.3-.5 7.7-7-1.6-6.3.3-13.8.3-13.8h-9z"
}), React319.createElement("path", {
  fill: "#2B0849",
  d: "M38 290.3s2.3 1.2 7 1.2c6.4 0 8.7-1.7 8.7-1.7s.6 1.1-.7 2.2c-1 1-3.8 1.7-7.7 1.7-4.4 0-6.1-.6-7-1.3-1-.5-.8-1.6-.2-2.1"
}), React319.createElement("path", {
  fill: "#A4AABA",
  d: "M45.3 274s0 1.6-.3 3.1-1.1 3.3-1.2 4.4c0 1.2 4.8 1.6 5.4 0 .7-1.6 1.4-6.8 2-7.6.7-.9-5.1-2.2-5.9.1"
}), React319.createElement("path", {
  fill: "#7BB2F9",
  d: "M89.5 277.6h13.9s1.3-56.6 1.9-66.8c.6-10.3 4-45.1 1-65.6l-13-.7-23.7.8-1.3 10.4c0 .5-.7.9-.8 1.4 0 .6.5 1.4.4 2L59.6 206c-.1.7-1.3 1-1.5 2.8 0 .3.2 1.6.1 1.8-7.1 19.5-12.2 52.6-15.6 67.2h15.1L62 259c3-13.3 24-88.3 24-88.3l3.2-1-.2 48.6s-.2 1.3.4 2.1c.5.8-.6 1.2-.4 2.4l.4 1.8-1 12.4c-.4 4.9 1.2 40.7 1.2 40.7"
}), React319.createElement("path", {
  stroke: "#648BD8",
  d: "M64.6 218.9c1.2 0 4.2-2.1 7.2-5.1m24.2 8.7s3-1.1 6.4-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#648BD8",
  d: "M97 219.4s2.9-1.2 6.3-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1"
}), React319.createElement("path", {
  stroke: "#648BD8",
  d: "M63.2 222.1s2.7-.6 6.7-3.5m5-72.4c-.3 3.2.3 8.8-4.5 9.4m22.8-11.3s.1 14.6-1.4 15.7c-2.3 1.7-3 2-3 2m.4-17s.3 13-1 25m-4.7.7s6.8-1 9.1-1M46 270l-.9 4.6m1.8-11.3-.8 4.1m16.6-64.9c-.3 1.6 0 2-.4 3.4 0 0-2.8 2-2.3 4s-.3 3.4-4.5 17.2c-1.8 5.8-4.3 19-6.2 28.3l-1.1 5.8m16-67-1 4.9m8.1-52.3-1.2 10.9s-1.2.1-.5 2.3c0 1.4-2.8 16.4-5.4 31.6m-20 82.1h13.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#192064",
  d: "M106.2 142.1c-3-.5-18.8-2.7-36.2.2a.6.6 0 0 0-.6.7v3a.6.6 0 0 0 .8.6c3.3-.5 17-2.4 35.6-.3.4 0 .7-.2.7-.5.2-1.4.2-2.5.2-3a.6.6 0 0 0-.5-.7"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M96.4 145.3v-5.1a.8.8 0 0 0-.8-.9 114.1 114.1 0 0 0-8.1 0 .8.8 0 0 0-.9.8v5.1c0 .5.4.9.9.9h8a.8.8 0 0 0 .9-.8"
}), React319.createElement("path", {
  fill: "#192064",
  d: "M95.2 144.3v-3.2a.7.7 0 0 0-.6-.7h-6.1a.7.7 0 0 0-.6.7v3.2c0 .4.3.7.6.7h6c.4 0 .7-.3.7-.7"
}), React319.createElement("path", {
  stroke: "#648BD8",
  d: "M90.1 273.5h12.8m-11.7-3.7v6.3m-.3-12.6v4.5m-.5-97.6 1 46.4s.7 1.6-.3 2.8c-.9 1.1 2.6.7 1 2.3-1.7 1.6.9 1.2 0 3.5-.6 1.6-1 22-1.2 36.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#E4EBF7",
  d: "M73.7 98.7 76 103s2 .8 1.8 2.7l.8 2.2m-14.3 8.7c.2-1 2.2-7.1 12.6-10.5m.7-16s7.7 6 16.5 2.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M92 87s5.5-.9 7.5-4.6c1.3-.3.8 2.2-.3 3.7l-1 1.5s.2.3.2.9c0 .6-.2.6-.3 1v1l-.4 1c-.1.2 0 .6-.2.9-.2.4-1.6 1.8-2.6 2.8-3.8 3.6-5 1.7-6-.4-1-1.8-.7-5.1-.9-6.9-.3-2.9-2.6-3-2-4.4.4-.7 3 .7 3.4 1.8.7 2 2.9 1.8 2.6 1.7"
}), React319.createElement("path", {
  stroke: "#DB836E",
  d: "M99.8 82.4c-.5.1-.3.3-1 1.3-.6 1-4.8 2.9-6.4 3.2-2.5.5-2.2-1.6-4.2-2.9-1.7-1-3.6-.6-1.4 1.4 1 1 1 1.1 1.4 3.2.3 1.5-.7 3.7.7 5.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React319.createElement("path", {
  stroke: "#E59788",
  d: "M79.5 108.7c-2 2.9-4.2 6.1-5.5 8.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React319.createElement("path", {
  fill: "#FFC6A0",
  d: "M87.7 124.8s-2-2-5.1-2.8c-3-.7-3.6-.1-5.5.1-2 .3-4-.9-3.7.7.3 1.7 5 1 5.2 2.1.2 1.1-6.3 2.8-8.3 2.2-.8.8.5 1.9 2 2.2.3 1.5 2.3 1.5 2.3 1.5s.7 1 2.6 1.1c2.5 1.3 9-.7 11-1.5 2-.9-.5-5.6-.5-5.6"
}), React319.createElement("path", {
  stroke: "#E59788",
  d: "M73.4 122.8s.7 1.2 3.2 1.4c2.3.3 2.6.6 2.6.6s-2.6 3-9.1 2.3m2.3 2.2s3.8 0 5-.7m-2.4 2.2s2 0 3.3-.6m-1 1.7s1.7 0 2.8-.5m-6.8-9s-.6-1.1 1.3-.5c1.7.5 2.8 0 5.1.1 1.4.1 3-.2 4 .2 1.6.8 3.6 2.2 3.6 2.2s10.6 1.2 19-1.1M79 108s-8.4 2.8-13.2 12.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React319.createElement("path", {
  stroke: "#E4EBF7",
  d: "M109.3 112.5s3.4-3.6 7.6-4.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  stroke: "#E59788",
  d: "M107.4 123s9.7-2.7 11.4-.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React319.createElement("path", {
  stroke: "#BFCDDD",
  d: "m194.6 83.7 4-4M187.2 91l3.7-3.6m.9-3-4.5-4.7m11.2 11.5-4.2-4.3m-65 76.3 3.7-3.7M122.3 170l3.5-3.5m.8-2.9-4.3-4.2M133 170l-4-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "2"
}), React319.createElement("path", {
  fill: "#A3B4C6",
  d: "M190.2 211.8h-1.6a4 4 0 0 1-4-4v-32.1a4 4 0 0 1 4-4h1.6a4 4 0 0 1 4 4v32a4 4 0 0 1-4 4"
}), React319.createElement("path", {
  fill: "#A3B4C6",
  d: "M237.8 213a4.8 4.8 0 0 1-4.8 4.8h-86.6a4.8 4.8 0 0 1 0-9.6H233a4.8 4.8 0 0 1 4.8 4.8"
}), React319.createElement("path", {
  fill: "#A3B4C6",
  d: "M154.1 190.1h70.5v-84.6h-70.5z"
}), React319.createElement("path", {
  fill: "#BFCDDD",
  d: "M225 190.1h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2m0-59.3h-71.1a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.3v19a3.2 3.2 0 0 1-3.2 3.1"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M159.6 120.5a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8v-3.2c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8"
}), React319.createElement("path", {
  fill: "#BFCDDD",
  d: "M225 160.5h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2"
}), React319.createElement("path", {
  stroke: "#7C90A5",
  d: "M173.5 130.8h49.3m-57.8 0h6m-15 0h6.7m11.1 29.8h49.3m-57.7 0h6m-15.8 0h6.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#FFF",
  d: "M159.6 151a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V147c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8m-63 29a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.5 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V176c0-.5.3-.8.8-.8h22.4c.5 0 .8.3.8.8v3.2c0 .4-.3.8-.8.8"
}), React319.createElement("path", {
  fill: "#BFCDDD",
  d: "M203 221.1h-27.3a2.4 2.4 0 0 1-2.4-2.4v-11.4a2.4 2.4 0 0 1 2.4-2.5H203a2.4 2.4 0 0 1 2.4 2.5v11.4a2.4 2.4 0 0 1-2.4 2.4"
}), React319.createElement("path", {
  stroke: "#A3B4C6",
  d: "M177.3 207.2v11.5m23.8-11.5v11.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React319.createElement("path", {
  fill: "#5BA02E",
  d: "M162.9 267.9a9.4 9.4 0 0 1-9.4-9.4v-14.8a9.4 9.4 0 0 1 18.8 0v14.8a9.4 9.4 0 0 1-9.4 9.4"
}), React319.createElement("path", {
  fill: "#92C110",
  d: "M171.2 267.8a9.4 9.4 0 0 1-9.4-9.4V255a9.4 9.4 0 0 1 18.8 0v3.4a9.4 9.4 0 0 1-9.4 9.4"
}), React319.createElement("path", {
  fill: "#F2D7AD",
  d: "M181.3 293.7h-27.7a3.2 3.2 0 0 1-3.2-3.2v-20.7a3.2 3.2 0 0 1 3.2-3.2h27.7a3.2 3.2 0 0 1 3.2 3.2v20.7a3.2 3.2 0 0 1-3.2 3.2"
})));
var serverError_default = ServerError;

// node_modules/antd/es/result/style/index.js
var genBaseStyle10 = (token) => {
  const {
    componentCls,
    lineHeightHeading3,
    iconCls,
    padding,
    paddingXL,
    paddingXS,
    paddingLG,
    marginXS,
    lineHeight
  } = token;
  return {
    // Result
    [componentCls]: {
      padding: `${unit(token.calc(paddingLG).mul(2).equal())} ${unit(paddingXL)}`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${componentCls} ${componentCls}-image`]: {
      width: token.imageWidth,
      height: token.imageHeight,
      margin: "auto"
    },
    [`${componentCls} ${componentCls}-icon`]: {
      marginBottom: paddingLG,
      textAlign: "center",
      [`& > ${iconCls}`]: {
        fontSize: token.iconFontSize
      }
    },
    [`${componentCls} ${componentCls}-title`]: {
      color: token.colorTextHeading,
      fontSize: token.titleFontSize,
      lineHeight: lineHeightHeading3,
      marginBlock: marginXS,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-subtitle`]: {
      color: token.colorTextDescription,
      fontSize: token.subtitleFontSize,
      lineHeight,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-body`]: {
      marginTop: paddingLG,
      padding: `${unit(paddingLG)} ${unit(token.calc(padding).mul(2.5).equal())}`,
      backgroundColor: token.colorFillAlter
    },
    [`${componentCls} ${componentCls}-extra`]: {
      margin: token.extraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: paddingXS,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
};
var genStatusIconStyle = (token) => {
  const {
    componentCls,
    iconCls
  } = token;
  return {
    [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultSuccessIconColor
    },
    [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultErrorIconColor
    },
    [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultInfoIconColor
    },
    [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
      color: token.resultWarningIconColor
    }
  };
};
var genResultStyle = (token) => [genBaseStyle10(token), genStatusIconStyle(token)];
var getStyle2 = (token) => genResultStyle(token);
var prepareComponentToken38 = (token) => ({
  titleFontSize: token.fontSizeHeading3,
  subtitleFontSize: token.fontSize,
  iconFontSize: token.fontSizeHeading3 * 3,
  extraMargin: `${token.paddingLG}px 0 0 0`
});
var style_default44 = genStyleHooks("Result", (token) => {
  const resultInfoIconColor = token.colorInfo;
  const resultErrorIconColor = token.colorError;
  const resultSuccessIconColor = token.colorSuccess;
  const resultWarningIconColor = token.colorWarning;
  const resultToken = merge(token, {
    resultInfoIconColor,
    resultErrorIconColor,
    resultSuccessIconColor,
    resultWarningIconColor,
    imageWidth: 250,
    imageHeight: 295
  });
  return [getStyle2(resultToken)];
}, prepareComponentToken38);

// node_modules/antd/es/result/unauthorized.js
var React320 = __toESM(require_react());
var Unauthorized = () => React320.createElement("svg", {
  width: "251",
  height: "294"
}, React320.createElement("title", null, "Unauthorized"), React320.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React320.createElement("path", {
  fill: "#E4EBF7",
  d: "M0 129v-2C0 58.3 55.6 2.7 124.2 2.7h2c68.6 0 124.2 55.6 124.2 124.1v2.1c0 68.6-55.6 124.2-124.1 124.2h-2.1A124.2 124.2 0 0 1 0 129"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M41.4 133a8.2 8.2 0 1 1-16.4-1.7 8.2 8.2 0 0 1 16.4 1.6"
}), React320.createElement("path", {
  stroke: "#FFF",
  d: "m38.7 136.4 10.4 5.9m.9 6.2-12.6 10.7",
  strokeWidth: "2"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M41.5 161.3a5.6 5.6 0 1 1-11.2-1.2 5.6 5.6 0 0 1 11.2 1.2m17.7-16a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m41.2-115.8H130a4.6 4.6 0 1 0 0-9.1h-29.6a4.6 4.6 0 0 0 0 9.1m11.3 18.3h29.7a4.6 4.6 0 1 0 0-9.2h-29.7a4.6 4.6 0 1 0 0 9.2"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M114 29.5h15.8a4.6 4.6 0 1 0 0 9.1H114a4.6 4.6 0 0 0 0-9.1m71.3 108.2a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), React320.createElement("path", {
  stroke: "#FFF",
  d: "m180.2 143.8 12.5 7.1m1.1 7.5-15.1 13",
  strokeWidth: "2"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M185.6 172a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.5 1.3m18.6-16.6a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.6 1.4"
}), React320.createElement("path", {
  stroke: "#FFF",
  d: "M153 194a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm73-75.8a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm-9 34.9a2.2 2.2 0 1 1-4.3 0 2.2 2.2 0 0 1 4.4 0zm-39.2-43.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.3-15.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm6.7 88a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0z",
  strokeWidth: "2"
}), React320.createElement("path", {
  stroke: "#FFF",
  d: "m215.1 155.3-1.9 20-10.8 6m-27.8-4.7-6.3 9.8H157l-4.5 6.4m23.4-65.5v-15.7m45.6 7.8-12.8 7.9-15.2-7.9V96.7",
  strokeWidth: "2"
}), React320.createElement("path", {
  fill: "#A26EF4",
  d: "M180.7 29.3a29.3 29.3 0 1 1 58.6 0 29.3 29.3 0 0 1-58.6 0"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "m221.4 41.7-21.5-.1a1.7 1.7 0 0 1-1.7-1.8V27.6a1.7 1.7 0 0 1 1.8-1.7h21.5c1 0 1.8.9 1.8 1.8l-.1 12.3a1.7 1.7 0 0 1-1.7 1.7"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M215.1 29.2c0 2.6-2 4.6-4.5 4.6a4.6 4.6 0 0 1-4.5-4.7v-6.9c0-2.6 2-4.6 4.6-4.6 2.5 0 4.5 2 4.4 4.7v6.9zm-4.5-14a6.9 6.9 0 0 0-7 6.8v7.3a6.9 6.9 0 0 0 13.8.1V22a6.9 6.9 0 0 0-6.8-6.9zm-43 53.2h-4a4.7 4.7 0 0 1-4.7-4.8 4.7 4.7 0 0 1 4.7-4.7h4a4.7 4.7 0 0 1 4.7 4.8 4.7 4.7 0 0 1-4.7 4.7"
}), React320.createElement("path", {
  fill: "#5BA02E",
  d: "M168.2 248.8a6.6 6.6 0 0 1-6.6-6.6v-66a6.6 6.6 0 0 1 13.2 0v66a6.6 6.6 0 0 1-6.6 6.6"
}), React320.createElement("path", {
  fill: "#92C110",
  d: "M176.1 248.2a6.6 6.6 0 0 1-6.6-6.6v-33a6.6 6.6 0 1 1 13.3 0v33a6.6 6.6 0 0 1-6.7 6.6"
}), React320.createElement("path", {
  fill: "#F2D7AD",
  d: "M186 293.9h-27.4a3.2 3.2 0 0 1-3.2-3.2v-45.9a3.2 3.2 0 0 1 3.2-3.1H186a3.2 3.2 0 0 1 3.2 3.1v46a3.2 3.2 0 0 1-3.2 3"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M82 147.7s6.3-1 17.5-1.3c11.8-.4 17.6 1 17.6 1s3.7-3.8 1-8.3c1.3-12.1 6-32.9.3-48.3-1.1-1.4-3.7-1.5-7.5-.6-1.4.3-7.2-.2-8-.1l-15.3-.4-8-.5c-1.6-.1-4.3-1.7-5.5-.3-.4.4-2.4 5.6-2 16l8.7 35.7s-3.2 3.6 1.2 7"
}), React320.createElement("path", {
  fill: "#FFC6A0",
  d: "m75.8 73.3-1-6.4 12-6.5s7.4-.1 8 1.2c.8 1.3-5.5 1-5.5 1s-1.9 1.4-2.6 2.5c-1.7 2.4-1 6.5-8.4 6-1.7.3-2.5 2.2-2.5 2.2"
}), React320.createElement("path", {
  fill: "#FFB594",
  d: "M52.4 77.7S66.7 87 77.4 92c1 .5-2 16.2-11.9 11.8-7.4-3.3-20.1-8.4-21.5-14.5-.7-3.2 2.6-7.6 8.4-11.7M142 80s-6.7 3-13.9 6.9c-3.9 2.1-10.1 4.7-12.3 8-6.2 9.3 3.5 11.2 13 7.5 6.6-2.7 29-12.1 13.2-22.4"
}), React320.createElement("path", {
  fill: "#FFC6A0",
  d: "m76.2 66.4 3 3.8S76.4 73 73 76c-7 6.2-12.8 14.3-16 16.4-4 2.7-9.7 3.3-12.2 0-3.5-5.1.5-14.7 31.5-26"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M64.7 85.1s-2.4 8.4-9 14.5c.7.5 18.6 10.5 22.2 10 5.2-.6 6.4-19 1.2-20.5-.8-.2-6-1.3-8.9-2.2-.9-.2-1.6-1.7-3.5-1l-2-.8zm63.7.7s5.3 2 7.3 13.8c-.6.2-17.6 12.3-21.8 7.8-6.6-7-.8-17.4 4.2-18.6 4.7-1.2 5-1.4 10.3-3"
}), React320.createElement("path", {
  stroke: "#E4EBF7",
  d: "M78.2 94.7s.9 7.4-5 13",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  stroke: "#E4EBF7",
  d: "M87.4 94.7s3.1 2.6 10.3 2.6c7.1 0 9-3.5 9-3.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".9"
}), React320.createElement("path", {
  fill: "#FFC6A0",
  d: "m117.2 68.6-6.8-6.1s-5.4-4.4-9.2-1c-3.9 3.5 4.4 2.2 5.6 4.2 1.2 2.1.9 1.2-2 .5-5.7-1.4-2.1.9 3 5.3 2 1.9 7 1 7 1l2.4-3.9z"
}), React320.createElement("path", {
  fill: "#FFB594",
  d: "m105.3 91.3-.3-11H89l-.5 10.5c0 .4.2.8.6 1 2 1.3 9.3 5 15.8.4.2-.2.4-.5.4-.9"
}), React320.createElement("path", {
  fill: "#5C2552",
  d: "M107.6 74.2c.8-1.1 1-9 1-11.9a1 1 0 0 0-1-1l-4.6-.4c-7.7-1-17 .6-18.3 6.3-5.4 5.9-.4 13.3-.4 13.3s2 3.5 4.3 6.8c.8 1 .4-3.8 3-6a47.9 47.9 0 0 1 16-7"
}), React320.createElement("path", {
  fill: "#FFC6A0",
  d: "M88.4 83.2s2.7 6.2 11.6 6.5c7.8.3 9-7 7.5-17.5l-1-5.5c-6-2.9-15.4.6-15.4.6s-.6 2-.2 5.5c-2.3 2-1.8 5.6-1.8 5.6s-1-2-2-2.3c-.9-.3-2 0-2.3 2-1 4.6 3.6 5.1 3.6 5.1"
}), React320.createElement("path", {
  stroke: "#DB836E",
  d: "m100.8 77.1 1.7-1-1-4.3.7-1.4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  fill: "#552950",
  d: "M105.5 74c0 .8-.4 1.4-1 1.4-.4 0-.8-.7-.8-1.4s.5-1.2 1-1.2.9.6.8 1.3m-8 .2c0 .8-.4 1.3-.9 1.3s-.9-.6-.9-1.3c0-.7.5-1.3 1-1.3s1 .6.9 1.3"
}), React320.createElement("path", {
  stroke: "#DB836E",
  d: "M91.1 86.8s5.3 5 12.7 2.3",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  fill: "#DB836E",
  d: "M99.8 81.9s-3.6.2-1.5-2.8c1.6-1.5 5-.4 5-.4s1 3.9-3.5 3.2"
}), React320.createElement("path", {
  stroke: "#5C2552",
  d: "M102.9 70.6s2.5.8 3.4.7m-12.4.7s2.5-1.2 4.8-1.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.5"
}), React320.createElement("path", {
  stroke: "#DB836E",
  d: "M86.3 77.4s1 .9 1.5 2c-.4.6-1 1.2-.3 1.9m11.8 2.4s2 .2 2.5-.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  stroke: "#E4EBF7",
  d: "m87.8 115.8 15.7-3m-3.3 3 10-2m-43.7-27s-1.6 8.8-6.7 14M128.3 88s3 4 4 11.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  stroke: "#DB836E",
  d: "M64 84.8s-6 10-13.5 10",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React320.createElement("path", {
  fill: "#FFC6A0",
  d: "m112.4 66-.2 5.2 12 9.2c4.5 3.6 8.9 7.5 11 8.7 4.8 2.8 8.9 3.3 11 1.8 4.1-2.9 4.4-9.9-8.1-15.3-4.3-1.8-16.1-6.3-25.7-9.7"
}), React320.createElement("path", {
  stroke: "#DB836E",
  d: "M130.5 85.5s4.6 5.7 11.7 6.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React320.createElement("path", {
  stroke: "#E4EBF7",
  d: "M121.7 105.7s-.4 8.6-1.3 13.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  stroke: "#648BD8",
  d: "M115.8 161.5s-3.6-1.5-2.7-7.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  fill: "#CBD1D1",
  d: "M101.5 290.2s4.3 2.1 7.4 1c2.9-.9 4.6.7 7.2 1.3 2.5.5 6.9 1 11.7-1.3 0-5.6-7-4-12-6.8-2.6-1.4-3.8-4.7-3.6-8.8h-9.5s-1.4 10.6-1.2 14.6"
}), React320.createElement("path", {
  fill: "#2B0849",
  d: "M101.5 290s2.4 1.4 6.8.7c3-.4 3.7.5 7.5 1 3.7.6 10.8 0 11.9-.8.4 1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.7-.5-1.8-1.4-5.2-2-5.7-.3-4 1-7.4-.3-7.4-.3l-.2-2.6z"
}), React320.createElement("path", {
  fill: "#A4AABA",
  d: "M108.8 276.2h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), React320.createElement("path", {
  fill: "#CBD1D1",
  d: "M57.6 272.5s-2 7.5-4.5 12.4c-1.8 3.7-4.2 7.6 5.5 7.6 6.7 0 9-.5 7.5-6.7-1.5-6.1.3-13.3.3-13.3h-8.8z"
}), React320.createElement("path", {
  fill: "#2B0849",
  d: "M51.5 290s2.2 1.2 6.7 1.2c6.1 0 8.3-1.6 8.3-1.6s.6 1-.6 2.1c-1 .9-3.6 1.6-7.4 1.6-4.2 0-6-.6-6.8-1.2-.9-.5-.7-1.6-.2-2"
}), React320.createElement("path", {
  fill: "#A4AABA",
  d: "M58.5 274.4s0 1.6-.3 3-1 3.1-1.1 4.2c0 1.1 4.5 1.5 5.2 0 .6-1.6 1.3-6.5 1.9-7.3.6-.8-5-2.1-5.7.1"
}), React320.createElement("path", {
  fill: "#7BB2F9",
  d: "m100.9 277 13.3.1s1.3-54.2 1.8-64c.6-9.9 3.8-43.2 1-62.8l-12.4-.7-22.8.8-1.2 10c0 .4-.6.8-.7 1.3 0 .6.4 1.3.3 2-2.3 14-6.3 32.9-8.7 46.4-.1.6-1.2 1-1.4 2.6 0 .3.2 1.6 0 1.8-6.8 18.7-10.8 47.6-14.1 61.6h14.5s2.2-8.6 4-17a3984 3984 0 0 1 23-84.5l3-.5 1 46.1s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.7-1 11.9c-.4 4.6 0 39 0 39"
}), React320.createElement("path", {
  stroke: "#648BD8",
  d: "M77.4 220.4c1.2.1 4-2 7-4.9m23.1 8.4s2.8-1 6.1-3.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  stroke: "#648BD8",
  d: "M108.5 221s2.7-1.2 6-4",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}), React320.createElement("path", {
  stroke: "#648BD8",
  d: "M76.1 223.6s2.6-.6 6.5-3.4m4.7-69.4c-.2 3.1.3 8.5-4.3 9m21.8-10.7s.1 14-1.3 15c-2.2 1.6-3 1.9-3 1.9m.5-16.4s0 12.8-1.2 24.3m-4.9 1s7.2-1.6 9.4-1.6m-28.6 31.5-1 4.5s-1.5 1.8-1 3.7c.4 2-1 2-5 15.3-1.7 5.6-4.4 18.5-6.3 27.5l-4 18.4M77 196.7a313.3 313.3 0 0 1-.8 4.8m7.7-50-1.2 10.3s-1 .2-.5 2.3c.1 1.3-2.6 15.6-5.1 30.2M57.6 273h13.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React320.createElement("path", {
  fill: "#192064",
  d: "M117.4 147.4s-17-3-35.7.2v4.2s14.6-2.9 35.5-.4l.2-4"
}), React320.createElement("path", {
  fill: "#FFF",
  d: "M107.5 150.4v-5a.8.8 0 0 0-.8-.7H99a.8.8 0 0 0-.7.8v4.8c0 .5.3.9.8.8a140.8 140.8 0 0 1 7.7 0 .8.8 0 0 0 .8-.7"
}), React320.createElement("path", {
  fill: "#192064",
  d: "M106.4 149.4v-3a.6.6 0 0 0-.6-.7 94.1 94.1 0 0 0-5.8 0 .6.6 0 0 0-.7.7v3c0 .4.3.7.7.7h5.7c.4 0 .7-.3.7-.7"
}), React320.createElement("path", {
  stroke: "#648BD8",
  d: "M101.5 274h12.3m-11.1-5v6.5m0-12.4v4.3m-.5-93.4.9 44.4s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.1 0 3.4-.6 1.5-1 21-1.1 35",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
})));
var unauthorized_default = Unauthorized;

// node_modules/antd/es/result/index.js
var IconMap = {
  success: CheckCircleFilled_default,
  error: CloseCircleFilled_default,
  info: ExclamationCircleFilled_default,
  warning: WarningFilled_default
};
var ExceptionMap = {
  "404": noFound_default,
  "500": serverError_default,
  "403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon3 = ({
  icon,
  status,
  className,
  style
}) => {
  if (true) {
    const warning2 = devUseWarning("Result");
    true ? warning2(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  if (ExceptionStatus.includes(`${status}`)) {
    const SVGComponent = ExceptionMap[status];
    return React321.createElement("div", {
      className,
      style
    }, React321.createElement(SVGComponent, null));
  }
  const iconNode = React321.createElement(IconMap[status]);
  if (icon === null || icon === false) {
    return null;
  }
  return React321.createElement("div", {
    className,
    style
  }, icon || iconNode);
};
var Extra = ({
  className,
  extra,
  style
}) => {
  if (!extra) {
    return null;
  }
  return React321.createElement("div", {
    className,
    style
  }, extra);
};
var Result = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className: customizeClassName,
    rootClassName,
    subTitle,
    title,
    style,
    children,
    status = "info",
    icon,
    extra,
    styles,
    classNames,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("result");
  const mergedProps = {
    ...props,
    status
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("result", customizePrefixCls);
  const [hashId, cssVarCls] = style_default44(prefixCls);
  const rootClassNames = clsx(prefixCls, `${prefixCls}-${status}`, customizeClassName, contextClassName, rootClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, cssVarCls, mergedClassNames.root);
  const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
  const subTitleClassNames = clsx(`${prefixCls}-subtitle`, mergedClassNames.subTitle);
  const extraClassNames = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
  const bodyClassNames = clsx(`${prefixCls}-body`, mergedClassNames.body);
  const iconClassNames = clsx(`${prefixCls}-icon`, {
    [`${prefixCls}-image`]: ExceptionStatus.includes(`${status}`)
  }, mergedClassNames.icon);
  const rootStyles = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const restProps = pickAttrs(rest, {
    aria: true,
    data: true
  });
  return React321.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: rootStyles
  }, React321.createElement(Icon3, {
    className: iconClassNames,
    style: mergedStyles.icon,
    status,
    icon
  }), React321.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title), subTitle && React321.createElement("div", {
    className: subTitleClassNames,
    style: mergedStyles.subTitle
  }, subTitle), React321.createElement(Extra, {
    className: extraClassNames,
    extra,
    style: mergedStyles.extra
  }), children && React321.createElement("div", {
    className: bodyClassNames,
    style: mergedStyles.body
  }, children));
};
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
if (true) {
  Result.displayName = "Result";
}
var result_default = Result;

// node_modules/antd/es/row/index.js
var row_default2 = row_default;

// node_modules/antd/es/splitter/Panel.js
var import_react111 = __toESM(require_react());
var InternalPanel = (0, import_react111.forwardRef)((props, ref) => {
  const {
    prefixCls,
    className,
    children,
    size,
    style = {}
  } = props;
  const panelClassName = clsx(`${prefixCls}-panel`, {
    [`${prefixCls}-panel-hidden`]: size === 0
  }, className);
  const hasSize = size !== void 0;
  return import_react111.default.createElement("div", {
    ref,
    className: panelClassName,
    style: {
      ...style,
      // Use auto when start from ssr
      flexBasis: hasSize ? size : "auto",
      flexGrow: hasSize ? 0 : 1
    }
  }, children);
});
if (true) {
  InternalPanel.displayName = "Panel";
}
var Panel3 = () => null;
var Panel_default3 = Panel3;

// node_modules/antd/es/splitter/Splitter.js
var import_react114 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/useItems.js
var React323 = __toESM(require_react());
function getCollapsible(collapsible) {
  if (collapsible && typeof collapsible === "object") {
    return {
      ...collapsible,
      showCollapsibleIcon: collapsible.showCollapsibleIcon === void 0 ? "auto" : collapsible.showCollapsibleIcon
    };
  }
  const mergedCollapsible = !!collapsible;
  return {
    start: mergedCollapsible,
    end: mergedCollapsible,
    showCollapsibleIcon: "auto"
  };
}
function useItems3(children) {
  const items = React323.useMemo(() => toArray(children).filter((item) => React323.isValidElement(item)).map((node) => {
    const {
      props
    } = node;
    const {
      collapsible,
      ...restProps
    } = props;
    return {
      ...restProps,
      collapsible: getCollapsible(collapsible)
    };
  }), [children]);
  return items;
}
var useItems_default = useItems3;

// node_modules/antd/es/splitter/hooks/useResizable.js
var React324 = __toESM(require_react());
function getShowCollapsibleIcon(prev, next) {
  if (prev.collapsible && next.collapsible) {
    if (prev.showCollapsibleIcon === true || next.showCollapsibleIcon === true) {
      return true;
    }
    if (prev.showCollapsibleIcon === "auto" || next.showCollapsibleIcon === "auto") {
      return "auto";
    }
    return false;
  }
  if (prev.collapsible) {
    return prev.showCollapsibleIcon;
  }
  if (next.collapsible) {
    return next.showCollapsibleIcon;
  }
  return false;
}
function useResizable(items, pxSizes, reverse) {
  return React324.useMemo(() => {
    const resizeInfos = [];
    for (let i = 0; i < items.length - 1; i += 1) {
      const prevItem = items[i];
      const nextItem = items[i + 1];
      const prevSize = pxSizes[i];
      const nextSize = pxSizes[i + 1];
      const {
        resizable: prevResizable = true,
        min: prevMin,
        collapsible: prevCollapsible
      } = prevItem;
      const {
        resizable: nextResizable = true,
        min: nextMin,
        collapsible: nextCollapsible
      } = nextItem;
      const mergedResizable = (
        // Both need to be resizable
        prevResizable && nextResizable && // Prev is not collapsed and limit min size
        (prevSize !== 0 || !prevMin) && // Next is not collapsed and limit min size
        (nextSize !== 0 || !nextMin)
      );
      const prevEndCollapsible = !!prevCollapsible.end && prevSize > 0;
      const nextStartExpandable = !!nextCollapsible.start && nextSize === 0 && prevSize > 0;
      const startCollapsible = prevEndCollapsible || nextStartExpandable;
      const nextStartCollapsible = !!nextCollapsible.start && nextSize > 0;
      const prevEndExpandable = !!prevCollapsible.end && prevSize === 0 && nextSize > 0;
      const endCollapsible = nextStartCollapsible || prevEndExpandable;
      const showStartCollapsibleIcon = getShowCollapsibleIcon({
        collapsible: prevEndCollapsible,
        showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
      }, {
        collapsible: nextStartExpandable,
        showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
      });
      const showEndCollapsibleIcon = getShowCollapsibleIcon({
        collapsible: nextStartCollapsible,
        showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
      }, {
        collapsible: prevEndExpandable,
        showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
      });
      resizeInfos[i] = {
        resizable: mergedResizable,
        startCollapsible: !!(reverse ? endCollapsible : startCollapsible),
        endCollapsible: !!(reverse ? startCollapsible : endCollapsible),
        showStartCollapsibleIcon: reverse ? showEndCollapsibleIcon : showStartCollapsibleIcon,
        showEndCollapsibleIcon: reverse ? showStartCollapsibleIcon : showEndCollapsibleIcon
      };
    }
    return resizeInfos;
  }, [pxSizes, items, reverse]);
}

// node_modules/antd/es/splitter/hooks/useResize.js
var React326 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/useSizes.js
var import_react112 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/sizeUtil.js
function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {
  let currentTotalPtg = 0;
  const undefinedIndexes = [];
  ptgSizes.forEach((size, index2) => {
    if (size === void 0) {
      undefinedIndexes.push(index2);
    } else {
      currentTotalPtg += size;
    }
  });
  const restPtg = 1 - currentTotalPtg;
  const undefinedCount = undefinedIndexes.length;
  if (ptgSizes.length && !undefinedIndexes.length && currentTotalPtg !== 1) {
    if (currentTotalPtg === 0) {
      const avg = 1 / ptgSizes.length;
      return ptgSizes.map(() => avg);
    }
    const scale = 1 / currentTotalPtg;
    return ptgSizes.map((size) => size * scale);
  }
  if (restPtg < 0) {
    const scale = 1 / currentTotalPtg;
    return ptgSizes.map((size) => size === void 0 ? 0 : size * scale);
  }
  let sumMin = 0;
  let sumMax = 0;
  let limitMin = 0;
  let limitMax = 1;
  for (const index2 of undefinedIndexes) {
    const min = minPtgSizes[index2] || 0;
    const max = maxPtgSizes[index2] || 1;
    sumMin += min;
    sumMax += max;
    limitMin = Math.max(limitMin, min);
    limitMax = Math.min(limitMax, max);
  }
  if (sumMin > 1 && sumMax < 1) {
    const avg = 1 / undefinedCount;
    return ptgSizes.map((size) => size === void 0 ? avg : size);
  }
  const restAvg = restPtg / undefinedCount;
  if (limitMin <= restAvg && restAvg <= limitMax) {
    return ptgSizes.map((size) => size === void 0 ? restAvg : size);
  }
  const result = _toConsumableArray(ptgSizes);
  let remain = restPtg - sumMin;
  for (let i = 0; i < undefinedCount; i += 1) {
    const index2 = undefinedIndexes[i];
    const min = minPtgSizes[index2] || 0;
    const max = maxPtgSizes[index2] || 1;
    result[index2] = min;
    const canAdd = max - min;
    const add = Math.min(canAdd, remain);
    result[index2] += add;
    remain -= add;
  }
  return result;
}

// node_modules/antd/es/splitter/hooks/useSizes.js
function getPtg(str) {
  return Number(str.slice(0, -1)) / 100;
}
function isPtg(itemSize) {
  return typeof itemSize === "string" && itemSize.endsWith("%");
}
function useSizes(items, containerSize) {
  const propSizes = items.map((item) => item.size);
  const itemsCount = items.length;
  const mergedContainerSize = containerSize || 0;
  const ptg2px = (ptg) => ptg * mergedContainerSize;
  const [innerSizes, setInnerSizes] = import_react112.default.useState(() => items.map((item) => item.defaultSize));
  const sizes2 = import_react112.default.useMemo(() => {
    const mergedSizes = [];
    for (let i = 0; i < itemsCount; i += 1) {
      mergedSizes[i] = propSizes[i] ?? innerSizes[i];
    }
    return mergedSizes;
  }, [itemsCount, innerSizes, propSizes]);
  const postPercentMinSizes = import_react112.default.useMemo(() => items.map((item) => {
    if (isPtg(item.min)) {
      return getPtg(item.min);
    }
    return (item.min || 0) / mergedContainerSize;
  }), [items, mergedContainerSize]);
  const postPercentMaxSizes = import_react112.default.useMemo(() => items.map((item) => {
    if (isPtg(item.max)) {
      return getPtg(item.max);
    }
    return (item.max || mergedContainerSize) / mergedContainerSize;
  }), [items, mergedContainerSize]);
  const postPercentSizes = import_react112.default.useMemo(() => {
    const ptgList = [];
    for (let i = 0; i < itemsCount; i += 1) {
      const itemSize = sizes2[i];
      if (isPtg(itemSize)) {
        ptgList[i] = getPtg(itemSize);
      } else if (itemSize || itemSize === 0) {
        const num = Number(itemSize);
        if (!Number.isNaN(num)) {
          ptgList[i] = num / mergedContainerSize;
        }
      } else {
        ptgList[i] = void 0;
      }
    }
    return autoPtgSizes(ptgList, postPercentMinSizes, postPercentMaxSizes);
  }, [itemsCount, sizes2, mergedContainerSize, postPercentMinSizes, postPercentMaxSizes]);
  const postPxSizes = import_react112.default.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);
  const panelSizes = import_react112.default.useMemo(() => containerSize ? postPxSizes : sizes2, [postPxSizes, sizes2, containerSize]);
  return [panelSizes, postPxSizes, postPercentSizes, postPercentMinSizes, postPercentMaxSizes, setInnerSizes];
}

// node_modules/antd/es/splitter/hooks/useResize.js
function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, reverse) {
  const limitSizes = items.map((item) => [item.min, item.max]);
  const mergedContainerSize = containerSize || 0;
  const ptg2px = (ptg) => ptg * mergedContainerSize;
  function getLimitSize(str, defaultLimit) {
    if (typeof str === "string") {
      return ptg2px(getPtg(str));
    }
    return str ?? defaultLimit;
  }
  const [cacheSizes, setCacheSizes] = React326.useState([]);
  const cacheCollapsedSize = React326.useRef([]);
  const [movingIndex, setMovingIndex] = React326.useState(null);
  const getPxSizes = () => percentSizes.map(ptg2px);
  const onOffsetStart = (index2) => {
    setCacheSizes(getPxSizes());
    setMovingIndex({
      index: index2,
      confirmed: false
    });
  };
  const onOffsetUpdate = (index2, offset3) => {
    let confirmedIndex = null;
    if ((!movingIndex || !movingIndex.confirmed) && offset3 !== 0) {
      if (offset3 > 0) {
        confirmedIndex = index2;
        setMovingIndex({
          index: index2,
          confirmed: true
        });
      } else {
        for (let i = index2; i >= 0; i -= 1) {
          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {
            confirmedIndex = i;
            setMovingIndex({
              index: i,
              confirmed: true
            });
            break;
          }
        }
      }
    }
    const mergedIndex = confirmedIndex ?? movingIndex?.index ?? index2;
    const numSizes = _toConsumableArray(cacheSizes);
    const nextIndex = mergedIndex + 1;
    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);
    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);
    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);
    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);
    let mergedOffset = offset3;
    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {
      mergedOffset = startMinSize - numSizes[mergedIndex];
    }
    if (numSizes[nextIndex] - mergedOffset < endMinSize) {
      mergedOffset = numSizes[nextIndex] - endMinSize;
    }
    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {
      mergedOffset = startMaxSize - numSizes[mergedIndex];
    }
    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {
      mergedOffset = numSizes[nextIndex] - endMaxSize;
    }
    numSizes[mergedIndex] += mergedOffset;
    numSizes[nextIndex] -= mergedOffset;
    updateSizes(numSizes);
    return numSizes;
  };
  const onOffsetEnd = () => {
    setMovingIndex(null);
  };
  const onCollapse = (index2, type) => {
    const currentSizes = getPxSizes();
    const adjustedType = reverse ? type === "start" ? "end" : "start" : type;
    const currentIndex = adjustedType === "start" ? index2 : index2 + 1;
    const targetIndex = adjustedType === "start" ? index2 + 1 : index2;
    const currentSize = currentSizes[currentIndex];
    const targetSize = currentSizes[targetIndex];
    if (currentSize !== 0 && targetSize !== 0) {
      currentSizes[currentIndex] = 0;
      currentSizes[targetIndex] += currentSize;
      cacheCollapsedSize.current[index2] = currentSize;
    } else {
      const totalSize = currentSize + targetSize;
      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);
      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);
      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);
      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);
      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);
      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);
      const halfOffset = targetSizeMin || (limitEnd - limitStart) / 2;
      const targetCacheCollapsedSize = cacheCollapsedSize.current[index2];
      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;
      if (shouldUseCache) {
        currentSizes[targetIndex] = targetCacheCollapsedSize;
        currentSizes[currentIndex] = currentCacheCollapsedSize;
      } else {
        currentSizes[currentIndex] -= halfOffset;
        currentSizes[targetIndex] += halfOffset;
      }
    }
    updateSizes(currentSizes);
    return currentSizes;
  };
  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex?.index];
}

// node_modules/antd/es/splitter/SplitBar.js
var import_react113 = __toESM(require_react());
function getValidNumber(num) {
  return typeof num === "number" && !Number.isNaN(num) && Number.isFinite(num) ? Math.round(num) : 0;
}
var SplitBar = (props) => {
  const {
    prefixCls,
    vertical,
    index: index2,
    active,
    ariaNow,
    ariaMin,
    ariaMax,
    resizable,
    draggerIcon,
    draggerStyle,
    draggerClassName,
    collapsibleIcon,
    startCollapsible,
    endCollapsible,
    onOffsetStart,
    onOffsetUpdate,
    onOffsetEnd,
    onCollapse,
    lazy,
    containerSize,
    showStartCollapsibleIcon,
    showEndCollapsibleIcon
  } = props;
  const splitBarPrefixCls = `${prefixCls}-bar`;
  const [startPos, setStartPos] = (0, import_react113.useState)(null);
  const [constrainedOffset, setConstrainedOffset] = (0, import_react113.useState)(0);
  const constrainedOffsetX = vertical ? 0 : constrainedOffset;
  const constrainedOffsetY = vertical ? constrainedOffset : 0;
  const onMouseDown = (e3) => {
    if (resizable && e3.currentTarget) {
      setStartPos([e3.pageX, e3.pageY]);
      onOffsetStart(index2);
    }
  };
  const onTouchStart = (e3) => {
    if (resizable && e3.touches.length === 1) {
      const touch = e3.touches[0];
      setStartPos([touch.pageX, touch.pageY]);
      onOffsetStart(index2);
    }
  };
  const getConstrainedOffset = (rawOffset) => {
    const currentPos = containerSize * ariaNow / 100;
    const newPos = currentPos + rawOffset;
    const minAllowed = Math.max(0, containerSize * ariaMin / 100);
    const maxAllowed = Math.min(containerSize, containerSize * ariaMax / 100);
    const clampedPos = Math.max(minAllowed, Math.min(maxAllowed, newPos));
    return clampedPos - currentPos;
  };
  const handleLazyMove = useEvent_default((offsetX, offsetY) => {
    const constrainedOffsetValue = getConstrainedOffset(vertical ? offsetY : offsetX);
    setConstrainedOffset(constrainedOffsetValue);
  });
  const handleLazyEnd = useEvent_default(() => {
    onOffsetUpdate(index2, constrainedOffsetX, constrainedOffsetY, true);
    setConstrainedOffset(0);
    onOffsetEnd(true);
  });
  const getVisibilityClass = (mode) => {
    switch (mode) {
      case true:
        return `${splitBarPrefixCls}-collapse-bar-always-visible`;
      case false:
        return `${splitBarPrefixCls}-collapse-bar-always-hidden`;
      case "auto":
        return `${splitBarPrefixCls}-collapse-bar-hover-only`;
    }
  };
  useLayoutEffect_default(() => {
    if (!startPos) {
      return;
    }
    const onMouseMove = (e3) => {
      const {
        pageX,
        pageY
      } = e3;
      const offsetX = pageX - startPos[0];
      const offsetY = pageY - startPos[1];
      if (lazy) {
        handleLazyMove(offsetX, offsetY);
      } else {
        onOffsetUpdate(index2, offsetX, offsetY);
      }
    };
    const onMouseUp = () => {
      if (lazy) {
        handleLazyEnd();
      } else {
        onOffsetEnd();
      }
      setStartPos(null);
    };
    const handleTouchMove = (e3) => {
      if (e3.touches.length === 1) {
        const touch = e3.touches[0];
        const offsetX = touch.pageX - startPos[0];
        const offsetY = touch.pageY - startPos[1];
        if (lazy) {
          handleLazyMove(offsetX, offsetY);
        } else {
          onOffsetUpdate(index2, offsetX, offsetY);
        }
      }
    };
    const handleTouchEnd = () => {
      if (lazy) {
        handleLazyEnd();
      } else {
        onOffsetEnd();
      }
      setStartPos(null);
    };
    const eventHandlerMap = {
      mousemove: onMouseMove,
      mouseup: onMouseUp,
      touchmove: handleTouchMove,
      touchend: handleTouchEnd
    };
    for (const [event, handler] of Object.entries(eventHandlerMap)) {
      window.addEventListener(event, handler);
    }
    return () => {
      for (const [event, handler] of Object.entries(eventHandlerMap)) {
        window.removeEventListener(event, handler);
      }
    };
  }, [startPos, index2, lazy]);
  const transformStyle = {
    [`--${splitBarPrefixCls}-preview-offset`]: `${constrainedOffset}px`
  };
  const [startIcon, endIcon, startCustomize, endCustomize] = import_react113.default.useMemo(() => {
    let startIcon2 = null;
    let endIcon2 = null;
    const startCustomize2 = collapsibleIcon?.start !== void 0;
    const endCustomize2 = collapsibleIcon?.end !== void 0;
    if (vertical) {
      startIcon2 = startCustomize2 ? collapsibleIcon.start : import_react113.default.createElement(UpOutlined_default, null);
      endIcon2 = endCustomize2 ? collapsibleIcon.end : import_react113.default.createElement(DownOutlined_default, null);
    } else {
      startIcon2 = startCustomize2 ? collapsibleIcon.start : import_react113.default.createElement(LeftOutlined_default, null);
      endIcon2 = endCustomize2 ? collapsibleIcon.end : import_react113.default.createElement(RightOutlined_default, null);
    }
    return [startIcon2, endIcon2, startCustomize2, endCustomize2];
  }, [collapsibleIcon, vertical]);
  return import_react113.default.createElement("div", {
    className: splitBarPrefixCls,
    role: "separator",
    "aria-valuenow": getValidNumber(ariaNow),
    "aria-valuemin": getValidNumber(ariaMin),
    "aria-valuemax": getValidNumber(ariaMax)
  }, lazy && import_react113.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-preview`, {
      [`${splitBarPrefixCls}-preview-active`]: !!constrainedOffset
    }),
    style: transformStyle
  }), import_react113.default.createElement("div", {
    style: draggerStyle,
    className: clsx(`${splitBarPrefixCls}-dragger`, {
      [`${splitBarPrefixCls}-dragger-disabled`]: !resizable,
      [`${splitBarPrefixCls}-dragger-active`]: active,
      [`${splitBarPrefixCls}-dragger-customize`]: draggerIcon !== void 0
    }, draggerClassName?.default, active && draggerClassName?.active),
    onMouseDown,
    onTouchStart
  }, draggerIcon !== void 0 ? import_react113.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-dragger-icon`)
  }, draggerIcon) : null), startCollapsible && import_react113.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-start`, {
      [`${splitBarPrefixCls}-collapse-bar-customize`]: startCustomize
    }, getVisibilityClass(showStartCollapsibleIcon)),
    onClick: () => onCollapse(index2, "start")
  }, import_react113.default.createElement("span", {
    className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-start`)
  }, startIcon)), endCollapsible && import_react113.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-end`, {
      [`${splitBarPrefixCls}-collapse-bar-customize`]: endCustomize
    }, getVisibilityClass(showEndCollapsibleIcon)),
    onClick: () => onCollapse(index2, "end")
  }, import_react113.default.createElement("span", {
    className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-end`)
  }, endIcon)));
};
var SplitBar_default = SplitBar;

// node_modules/antd/es/splitter/style/index.js
var centerStyle = {
  position: "absolute",
  top: "50%",
  left: {
    _skip_check_: true,
    value: "50%"
  },
  transform: "translate(-50%, -50%)"
};
var genSplitterStyle = (token) => {
  const {
    componentCls,
    colorFill,
    splitBarDraggableSize,
    splitBarSize,
    splitTriggerSize,
    controlItemBgHover,
    controlItemBgActive,
    controlItemBgActiveHover,
    prefixCls,
    colorPrimary
  } = token;
  const splitBarCls = `${componentCls}-bar`;
  const splitMaskCls = `${componentCls}-mask`;
  const splitPanelCls = `${componentCls}-panel`;
  const halfTriggerSize = token.calc(splitTriggerSize).div(2).equal();
  const splitterBarPreviewOffsetVar = `${prefixCls}-bar-preview-offset`;
  const splitterBarPreviewStyle = {
    position: "absolute",
    background: token.colorPrimary,
    opacity: 0.2,
    pointerEvents: "none",
    transition: "none",
    zIndex: 1,
    display: "none"
  };
  return {
    [componentCls]: {
      ...resetComponent(token),
      display: "flex",
      width: "100%",
      height: "100%",
      alignItems: "stretch",
      // ======================== SplitBar ========================
      // Use `>` to avoid conflict with mix layout
      [`> ${splitBarCls}`]: {
        flex: "none",
        position: "relative",
        userSelect: "none",
        // ======================= Dragger =======================
        [`${splitBarCls}-dragger`]: {
          ...centerStyle,
          zIndex: 1,
          // Hover background
          "&::before": {
            content: '""',
            background: controlItemBgHover,
            ...centerStyle
          },
          // Spinner
          "&::after": {
            content: '""',
            background: colorFill,
            ...centerStyle
          },
          // Hover
          [`&:hover:not(${splitBarCls}-dragger-active)`]: {
            "&::before": {
              background: controlItemBgActive
            }
          },
          // Active
          "&-active": {
            zIndex: 2,
            "&::before": {
              background: controlItemBgActiveHover
            }
          },
          [`&-active${splitBarCls}-dragger-customize`]: {
            [`${splitBarCls}-dragger-icon`]: {
              color: colorPrimary
            }
          },
          // Disabled, not use `pointer-events: none` since still need trigger collapse
          [`&-disabled${splitBarCls}-dragger`]: {
            zIndex: 0,
            "&, &:hover, &-active": {
              cursor: "default",
              "&::before": {
                background: controlItemBgHover
              }
            },
            "&::after": {
              display: "none"
            },
            [`${splitBarCls}-dragger-icon`]: {
              display: "none"
            }
          },
          // customize dragger icon
          "&-customize": {
            [`${splitBarCls}-dragger-icon`]: {
              ...centerStyle,
              display: "flex",
              alignItems: "center",
              color: colorFill
            },
            "&::after": {
              display: "none"
            }
          }
        },
        // ======================= Collapse =======================
        [`${splitBarCls}-collapse-bar`]: {
          ...centerStyle,
          zIndex: token.zIndexPopupBase,
          background: controlItemBgHover,
          fontSize: token.fontSizeSM,
          borderRadius: token.borderRadiusXS,
          color: token.colorText,
          cursor: "pointer",
          opacity: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          // Hover
          [`&:hover:not(${splitBarCls}-collapse-bar-customize)`]: {
            background: controlItemBgActive
          },
          // Active
          [`&:active:not(${splitBarCls}-collapse-bar-customize)`]: {
            background: controlItemBgActiveHover
          },
          [`${splitBarCls}-collapse-icon`]: {
            display: "flex",
            alignItems: "center"
          }
        },
        [`${splitBarCls}-collapse-bar-customize`]: {
          background: "transparent"
        },
        "&:hover, &:active": {
          [`${splitBarCls}-collapse-bar-hover-only`]: {
            opacity: 1
          }
        },
        [`${splitBarCls}-collapse-bar-hover-only`]: {
          "@media(hover:none)": {
            opacity: 1
          }
        },
        [`${splitBarCls}-collapse-bar-always-hidden`]: {
          display: "none"
        },
        [`${splitBarCls}-collapse-bar-always-visible`]: {
          opacity: 1
        }
      },
      // =========================== Mask =========================
      // Util dom for handle cursor
      [splitMaskCls]: {
        position: "fixed",
        zIndex: token.zIndexPopupBase,
        inset: 0,
        "&-horizontal": {
          cursor: "col-resize"
        },
        "&-vertical": {
          cursor: "row-resize"
        }
      },
      // ==========================================================
      // ==                        Layout                        ==
      // ==========================================================
      "&-horizontal": {
        flexDirection: "row",
        [`> ${splitBarCls}`]: {
          width: 0,
          // ======================= Preview =======================
          [`${splitBarCls}-preview`]: {
            height: "100%",
            width: splitBarSize,
            ...splitterBarPreviewStyle,
            [`&${splitBarCls}-preview-active`]: {
              display: "block",
              transform: `translateX(var(--${splitterBarPreviewOffsetVar}))`
            }
          },
          // ======================= Dragger =======================
          [`${splitBarCls}-dragger`]: {
            cursor: "col-resize",
            height: "100%",
            width: splitTriggerSize,
            "&::before": {
              height: "100%",
              width: splitBarSize
            },
            "&::after": {
              height: splitBarDraggableSize,
              width: splitBarSize
            }
          },
          // ======================= Collapse =======================
          [`${splitBarCls}-collapse-bar`]: {
            width: token.fontSizeSM,
            height: token.controlHeightSM,
            "&-start": {
              left: {
                _skip_check_: true,
                value: "auto"
              },
              right: {
                _skip_check_: true,
                value: halfTriggerSize
              },
              transform: "translateY(-50%)"
            },
            "&-end": {
              left: {
                _skip_check_: true,
                value: halfTriggerSize
              },
              right: {
                _skip_check_: true,
                value: "auto"
              },
              transform: "translateY(-50%)"
            }
          }
        }
      },
      "&-vertical": {
        flexDirection: "column",
        [`> ${splitBarCls}`]: {
          height: 0,
          // ======================= Preview =======================
          [`${splitBarCls}-preview`]: {
            height: splitBarSize,
            width: "100%",
            ...splitterBarPreviewStyle,
            [`&${splitBarCls}-preview-active`]: {
              display: "block",
              transform: `translateY(var(--${splitterBarPreviewOffsetVar}))`
            }
          },
          // ======================= Dragger =======================
          [`${splitBarCls}-dragger`]: {
            cursor: "row-resize",
            width: "100%",
            height: splitTriggerSize,
            "&::before": {
              width: "100%",
              height: splitBarSize
            },
            "&::after": {
              width: splitBarDraggableSize,
              height: splitBarSize
            }
          },
          // ======================= Collapse =======================
          [`${splitBarCls}-collapse-bar`]: {
            height: token.fontSizeSM,
            width: token.controlHeightSM,
            "&-start": {
              top: "auto",
              bottom: halfTriggerSize,
              transform: "translateX(-50%)"
            },
            "&-end": {
              top: halfTriggerSize,
              bottom: "auto",
              transform: "translateX(-50%)"
            }
          }
        }
      },
      // ========================= Panels =========================
      [splitPanelCls]: {
        overflow: "auto",
        padding: "0 1px",
        scrollbarWidth: "thin",
        boxSizing: "border-box",
        "&-hidden": {
          padding: 0,
          overflow: "hidden"
        },
        [`&:has(${componentCls}:only-child)`]: {
          overflow: "hidden"
        }
      }
    }
  };
};
var prepareComponentToken39 = (token) => {
  const splitBarSize = token.splitBarSize || 2;
  const splitTriggerSize = token.splitTriggerSize || 6;
  const resizeSpinnerSize = token.resizeSpinnerSize || 20;
  const splitBarDraggableSize = token.splitBarDraggableSize ?? resizeSpinnerSize;
  return {
    splitBarSize,
    splitTriggerSize,
    splitBarDraggableSize,
    resizeSpinnerSize
  };
};
var style_default45 = genStyleHooks("Splitter", genSplitterStyle, prepareComponentToken39);

// node_modules/antd/es/splitter/Splitter.js
var Splitter = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    style,
    styles,
    layout,
    orientation,
    vertical,
    children,
    draggerIcon,
    collapsibleIcon,
    rootClassName,
    onResizeStart,
    onResize,
    onResizeEnd,
    lazy
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("splitter");
  const prefixCls = getPrefixCls("splitter", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default45(prefixCls, rootCls);
  const [mergedOrientation, isVertical] = useOrientation(orientation, vertical, layout);
  const isRTL = direction === "rtl";
  const reverse = !isVertical && isRTL;
  const items = useItems_default(children);
  if (true) {
    const warning2 = devUseWarning("Splitter");
    const existSize = items.some((item) => item.size !== void 0);
    const existUndefinedSize = items.some((item) => item.size === void 0);
    if (existSize && existUndefinedSize && !onResize) {
      true ? warning2(false, "usage", "When part of `Splitter.Panel` has `size`, `onResize` is required or change `size` to `defaultSize`.") : void 0;
    }
    warning2.deprecated(!layout, "layout", "orientation");
  }
  const [containerSize, setContainerSize] = (0, import_react114.useState)();
  const onContainerResize = (size) => {
    const {
      offsetWidth,
      offsetHeight
    } = size;
    const containerSize2 = isVertical ? offsetHeight : offsetWidth;
    if (containerSize2 === 0) {
      return;
    }
    setContainerSize(containerSize2);
  };
  const [panelSizes, itemPxSizes, itemPtgSizes, itemPtgMinSizes, itemPtgMaxSizes, updateSizes] = useSizes(items, containerSize);
  const resizableInfos = useResizable(items, itemPxSizes, reverse);
  const [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex] = useResize(items, resizableInfos, itemPtgSizes, containerSize, updateSizes, reverse);
  const onInternalResizeStart = useEvent_default((index2) => {
    onOffsetStart(index2);
    onResizeStart?.(itemPxSizes);
  });
  const onInternalResizeUpdate = useEvent_default((index2, offset3, lazyEnd) => {
    const nextSizes = onOffsetUpdate(index2, offset3);
    if (lazyEnd) {
      onResizeEnd?.(nextSizes);
    } else {
      onResize?.(nextSizes);
    }
  });
  const onInternalResizeEnd = useEvent_default((lazyEnd) => {
    onOffsetEnd();
    if (!lazyEnd) {
      onResizeEnd?.(itemPxSizes);
    }
  });
  const onInternalCollapse = useEvent_default((index2, type) => {
    const nextSizes = onCollapse(index2, type);
    onResize?.(nextSizes);
    onResizeEnd?.(nextSizes);
    const collapsed = nextSizes.map((size) => Math.abs(size) < Number.EPSILON);
    props.onCollapse?.(collapsed, nextSizes);
  });
  const mergedProps = {
    ...props,
    vertical: isVertical,
    orientation: mergedOrientation
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    // Convert `classNames.dragger: 'a'` to
    // `classNames.dragger: { default: 'a' }`
    dragger: {
      _default: "default"
    }
  });
  const containerClassName = clsx(prefixCls, className, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-rtl`]: isRTL
  }, rootClassName, mergedClassNames.root, contextClassName, cssVarCls, rootCls, hashId);
  const maskCls = `${prefixCls}-mask`;
  const stackSizes = import_react114.default.useMemo(() => {
    const mergedSizes = [];
    let stack = 0;
    const len = items.length;
    for (let i = 0; i < len; i += 1) {
      stack += itemPtgSizes[i];
      mergedSizes.push(stack);
    }
    return mergedSizes;
  }, [itemPtgSizes, items.length]);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  return import_react114.default.createElement(es_default3, {
    onResize: onContainerResize
  }, import_react114.default.createElement("div", {
    style: mergedStyle,
    className: containerClassName
  }, items.map((item, idx) => {
    const panelProps = {
      ...item,
      className: clsx(mergedClassNames.panel, item.className),
      style: {
        ...mergedStyles.panel,
        ...item.style
      }
    };
    const panel = import_react114.default.createElement(InternalPanel, {
      ...panelProps,
      prefixCls,
      size: panelSizes[idx]
    });
    let splitBar = null;
    const resizableInfo = resizableInfos[idx];
    if (resizableInfo) {
      const ariaMinStart = (stackSizes[idx - 1] || 0) + itemPtgMinSizes[idx];
      const ariaMinEnd = (stackSizes[idx + 1] || 100) - itemPtgMaxSizes[idx + 1];
      const ariaMaxStart = (stackSizes[idx - 1] || 0) + itemPtgMaxSizes[idx];
      const ariaMaxEnd = (stackSizes[idx + 1] || 100) - itemPtgMinSizes[idx + 1];
      splitBar = import_react114.default.createElement(SplitBar_default, {
        lazy,
        index: idx,
        active: movingIndex === idx,
        prefixCls,
        vertical: isVertical,
        resizable: resizableInfo.resizable,
        draggerStyle: mergedStyles.dragger,
        draggerClassName: mergedClassNames.dragger,
        draggerIcon,
        collapsibleIcon,
        ariaNow: stackSizes[idx] * 100,
        ariaMin: Math.max(ariaMinStart, ariaMinEnd) * 100,
        ariaMax: Math.min(ariaMaxStart, ariaMaxEnd) * 100,
        startCollapsible: resizableInfo.startCollapsible,
        endCollapsible: resizableInfo.endCollapsible,
        showStartCollapsibleIcon: resizableInfo.showStartCollapsibleIcon,
        showEndCollapsibleIcon: resizableInfo.showEndCollapsibleIcon,
        onOffsetStart: onInternalResizeStart,
        onOffsetUpdate: (index2, offsetX, offsetY, lazyEnd) => {
          let offset3 = isVertical ? offsetY : offsetX;
          if (reverse) {
            offset3 = -offset3;
          }
          onInternalResizeUpdate(index2, offset3, lazyEnd);
        },
        onOffsetEnd: onInternalResizeEnd,
        onCollapse: onInternalCollapse,
        containerSize: containerSize || 0
      });
    }
    return import_react114.default.createElement(import_react114.default.Fragment, {
      key: `split-panel-${idx}`
    }, panel, splitBar);
  }), typeof movingIndex === "number" && import_react114.default.createElement("div", {
    "aria-hidden": true,
    className: clsx(maskCls, `${maskCls}-${mergedOrientation}`)
  })));
};
if (true) {
  Splitter.displayName = "Splitter";
}
var Splitter_default = Splitter;

// node_modules/antd/es/splitter/index.js
var Splitter2 = Splitter_default;
Splitter2.Panel = Panel_default3;
var splitter_default = Splitter2;

// node_modules/antd/es/statistic/Countdown.js
var React332 = __toESM(require_react());

// node_modules/antd/es/statistic/Timer.js
var React331 = __toESM(require_react());

// node_modules/antd/es/statistic/Statistic.js
var React330 = __toESM(require_react());

// node_modules/antd/es/statistic/Number.js
var React329 = __toESM(require_react());
var StatisticNumber = (props) => {
  const {
    value,
    formatter,
    precision,
    decimalSeparator,
    groupSeparator = "",
    prefixCls
  } = props;
  let valueNode;
  if (typeof formatter === "function") {
    valueNode = formatter(value);
  } else {
    const val = String(value);
    const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!cells || val === "-") {
      valueNode = val;
    } else {
      const negative = cells[1];
      let int = cells[2] || "0";
      let decimal = cells[4] || "";
      int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      if (typeof precision === "number") {
        decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
      }
      if (decimal) {
        decimal = `${decimalSeparator}${decimal}`;
      }
      valueNode = [React329.createElement("span", {
        key: "int",
        className: `${prefixCls}-content-value-int`
      }, negative, int), decimal && React329.createElement("span", {
        key: "decimal",
        className: `${prefixCls}-content-value-decimal`
      }, decimal)];
    }
  }
  return React329.createElement("span", {
    className: `${prefixCls}-content-value`
  }, valueNode);
};
var Number_default = StatisticNumber;

// node_modules/antd/es/statistic/style/index.js
var genStatisticStyle = (token) => {
  const {
    componentCls,
    marginXXS,
    padding,
    colorTextDescription,
    titleFontSize,
    colorTextHeading,
    contentFontSize,
    fontFamily
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      [`${componentCls}-header`]: {
        paddingBottom: marginXXS,
        [`${componentCls}-title`]: {
          color: colorTextDescription,
          fontSize: titleFontSize
        }
      },
      [`${componentCls}-skeleton`]: {
        paddingTop: padding
      },
      [`${componentCls}-content`]: {
        color: colorTextHeading,
        fontSize: contentFontSize,
        fontFamily,
        [`${componentCls}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: {
          display: "inline-block"
        },
        [`${componentCls}-content-prefix`]: {
          marginInlineEnd: marginXXS
        },
        [`${componentCls}-content-suffix`]: {
          marginInlineStart: marginXXS
        }
      }
    }
  };
};
var prepareComponentToken40 = (token) => {
  const {
    fontSizeHeading3,
    fontSize
  } = token;
  return {
    titleFontSize: fontSize,
    contentFontSize: fontSizeHeading3
  };
};
var style_default46 = genStyleHooks("Statistic", (token) => {
  const statisticToken = merge(token, {});
  return genStatisticStyle(statisticToken);
}, prepareComponentToken40);

// node_modules/antd/es/statistic/Statistic.js
var Statistic = React330.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    valueStyle,
    value = 0,
    title,
    valueRender,
    prefix,
    suffix,
    loading = false,
    /* --- FormatConfig starts --- */
    formatter,
    precision,
    decimalSeparator = ".",
    groupSeparator = ",",
    /* --- FormatConfig starts --- */
    onMouseEnter,
    onMouseLeave,
    styles,
    classNames,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("statistic");
  const prefixCls = getPrefixCls("statistic", customizePrefixCls);
  const [hashId, cssVarCls] = style_default46(prefixCls);
  const mergedProps = {
    ...props,
    decimalSeparator,
    groupSeparator,
    loading,
    value
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning2 = devUseWarning("Statistic");
    [["valueStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const valueNode = React330.createElement(Number_default, {
    decimalSeparator,
    groupSeparator,
    prefixCls,
    formatter,
    precision,
    value
  });
  const rootClassNames = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const headerClassNames = clsx(`${prefixCls}-header`, mergedClassNames.header);
  const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
  const contentClassNames = clsx(`${prefixCls}-content`, mergedClassNames.content);
  const prefixClassNames = clsx(`${prefixCls}-content-prefix`, mergedClassNames.prefix);
  const suffixClassNames = clsx(`${prefixCls}-content-suffix`, mergedClassNames.suffix);
  const internalRef = React330.useRef(null);
  React330.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const restProps = pickAttrs(rest, {
    aria: true,
    data: true
  });
  return React330.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    },
    ref: internalRef,
    onMouseEnter,
    onMouseLeave
  }, title && React330.createElement("div", {
    className: headerClassNames,
    style: mergedStyles.header
  }, React330.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title)), React330.createElement(skeleton_default, {
    paragraph: false,
    loading,
    className: `${prefixCls}-skeleton`,
    active: true
  }, React330.createElement("div", {
    className: contentClassNames,
    style: {
      ...valueStyle,
      ...mergedStyles.content
    }
  }, prefix && React330.createElement("span", {
    className: prefixClassNames,
    style: mergedStyles.prefix
  }, prefix), valueRender ? valueRender(valueNode) : valueNode, suffix && React330.createElement("span", {
    className: suffixClassNames,
    style: mergedStyles.suffix
  }, suffix))));
});
if (true) {
  Statistic.displayName = "Statistic";
}
var Statistic_default = Statistic;

// node_modules/antd/es/statistic/utils.js
var timeUnits = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  // years
  ["M", 1e3 * 60 * 60 * 24 * 30],
  // months
  ["D", 1e3 * 60 * 60 * 24],
  // days
  ["H", 1e3 * 60 * 60],
  // hours
  ["m", 1e3 * 60],
  // minutes
  ["s", 1e3],
  // seconds
  ["S", 1]
  // million seconds
];
function formatTimeStr(duration, format2) {
  let leftDuration = duration;
  const escapeRegex = /\[[^\]]*]/g;
  const keepList = (format2.match(escapeRegex) || []).map((str) => str.slice(1, -1));
  const templateText = format2.replace(escapeRegex, "[]");
  const replacedText = timeUnits.reduce((current, [name, unit2]) => {
    if (current.includes(name)) {
      const value = Math.floor(leftDuration / unit2);
      leftDuration -= value * unit2;
      return current.replace(new RegExp(`${name}+`, "g"), (match) => {
        const len = match.length;
        return value.toString().padStart(len, "0");
      });
    }
    return current;
  }, templateText);
  let index2 = 0;
  return replacedText.replace(escapeRegex, () => {
    const match = keepList[index2];
    index2 += 1;
    return match;
  });
}
function formatCounter(value, config, down) {
  const {
    format: format2 = ""
  } = config;
  const target = new Date(value).getTime();
  const current = Date.now();
  const diff = down ? Math.max(target - current, 0) : Math.max(current - target, 0);
  return formatTimeStr(diff, format2);
}

// node_modules/antd/es/statistic/Timer.js
var UPDATE_INTERVAL = 1e3 / 60;
function getTime(value) {
  return new Date(value).getTime();
}
var StatisticTimer = (props) => {
  const {
    value,
    format: format2 = "HH:mm:ss",
    onChange,
    onFinish,
    type,
    ...rest
  } = props;
  const down = type === "countdown";
  const [showTime, setShowTime] = React331.useState(null);
  const update = useEvent_default(() => {
    const now2 = Date.now();
    const timestamp = getTime(value);
    setShowTime({});
    const timeDiff = !down ? now2 - timestamp : timestamp - now2;
    onChange?.(timeDiff);
    if (down && timestamp < now2) {
      onFinish?.();
      return false;
    }
    return true;
  });
  React331.useEffect(() => {
    let intervalId;
    const tick = () => {
      if (!update()) {
        window.clearInterval(intervalId);
      }
    };
    const startTimer = () => {
      intervalId = window.setInterval(tick, UPDATE_INTERVAL);
    };
    const stopTimer = () => {
      window.clearInterval(intervalId);
    };
    startTimer();
    return () => {
      stopTimer();
    };
  }, [value, down]);
  React331.useEffect(() => {
    setShowTime({});
  }, []);
  const formatter = (formatValue2, config) => showTime ? formatCounter(formatValue2, {
    ...config,
    format: format2
  }, down) : "-";
  const valueRender = (node) => cloneElement(node, {
    title: void 0
  });
  return React331.createElement(Statistic_default, {
    ...rest,
    value,
    valueRender,
    formatter
  });
};
var Timer_default = StatisticTimer;

// node_modules/antd/es/statistic/Countdown.js
var Countdown = (props) => {
  if (true) {
    const warning2 = devUseWarning("Countdown");
    warning2.deprecated(false, "<Statistic.Countdown />", '<Statistic.Timer type="countdown" />');
  }
  return React332.createElement(Timer_default, {
    ...props,
    type: "countdown"
  });
};
var Countdown_default = React332.memo(Countdown);

// node_modules/antd/es/statistic/index.js
Statistic_default.Timer = Timer_default;
Statistic_default.Countdown = Countdown_default;
var statistic_default = Statistic_default;

// node_modules/antd/es/steps/index.js
var React342 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Steps.js
var import_react115 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Step.js
var React337 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Rail.js
var React333 = __toESM(require_react());
function Rail(props) {
  const {
    prefixCls,
    className,
    style,
    status
  } = props;
  const railCls = `${prefixCls}-rail`;
  return React333.createElement("div", {
    className: clsx(railCls, `${railCls}-${status}`, className),
    style
  });
}

// node_modules/@rc-component/steps/es/UnstableContext.js
var React334 = __toESM(require_react());
var UnstableContext2 = React334.createContext({});

// node_modules/@rc-component/steps/es/StepIcon.js
var React336 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Context.js
var React335 = __toESM(require_react());
var StepsContext = React335.createContext(null);

// node_modules/@rc-component/steps/es/StepIcon.js
function _extends55() {
  _extends55 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends55.apply(this, arguments);
}
var StepIconSemanticContext = React336.createContext({});
var StepIcon = React336.forwardRef((props, ref) => {
  const {
    className,
    style,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    classNames,
    styles
  } = React336.useContext(StepsContext);
  const {
    className: itemClassName,
    style: itemStyle
  } = React336.useContext(StepIconSemanticContext);
  const itemCls = `${prefixCls}-item`;
  return React336.createElement("div", _extends55({}, pickAttrs(restProps, false), {
    ref,
    className: clsx(`${itemCls}-icon`, classNames.itemIcon, itemClassName, className),
    style: {
      ...styles.itemIcon,
      ...itemStyle,
      ...style
    }
  }), children);
});
var StepIcon_default = StepIcon;

// node_modules/@rc-component/steps/es/Step.js
function _extends56() {
  _extends56 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends56.apply(this, arguments);
}
function hasContent(value) {
  return value !== void 0 && value !== null;
}
function Step(props) {
  const {
    // style
    prefixCls,
    classNames,
    styles,
    // data
    data,
    last,
    nextStatus,
    active,
    index: index2,
    // render
    itemRender,
    iconRender,
    itemWrapperRender,
    // events
    onClick
  } = props;
  const itemCls = `${prefixCls}-item`;
  const {
    railFollowPrevStatus
  } = React337.useContext(UnstableContext2);
  const {
    ItemComponent
  } = React337.useContext(StepsContext);
  const {
    onClick: onItemClick,
    title,
    subTitle,
    content,
    description,
    disabled,
    icon,
    status,
    className,
    style,
    classNames: itemClassNames = {},
    styles: itemStyles = {},
    ...restItemProps
  } = data;
  const mergedContent = content ?? description;
  const renderInfo = {
    item: {
      ...data,
      content: mergedContent
    },
    index: index2,
    active
  };
  const clickable = !!(onClick || onItemClick) && !disabled;
  const accessibilityProps = {};
  if (clickable) {
    accessibilityProps.role = "button";
    accessibilityProps.tabIndex = 0;
    accessibilityProps.onClick = (e3) => {
      onItemClick?.(e3);
      onClick(index2);
    };
    accessibilityProps.onKeyDown = (e3) => {
      const {
        which
      } = e3;
      if (which === KeyCode_default.ENTER || which === KeyCode_default.SPACE) {
        onClick(index2);
      }
    };
  }
  const mergedStatus = status || "wait";
  const hasTitle = hasContent(title);
  const hasSubTitle = hasContent(subTitle);
  const classString = clsx(itemCls, `${itemCls}-${mergedStatus}`, {
    [`${itemCls}-custom`]: icon,
    [`${itemCls}-active`]: active,
    [`${itemCls}-disabled`]: disabled === true,
    [`${itemCls}-empty-header`]: !hasTitle && !hasSubTitle
  }, className, classNames.item, itemClassNames.root);
  let iconNode = React337.createElement(StepIcon_default, null);
  if (iconRender) {
    iconNode = iconRender(iconNode, {
      ...renderInfo,
      components: {
        Icon: StepIcon_default
      }
    });
  }
  const wrapperNode = React337.createElement("div", {
    className: clsx(`${itemCls}-wrapper`, classNames.itemWrapper, itemClassNames.wrapper),
    style: {
      ...styles.itemWrapper,
      ...itemStyles.wrapper
    }
  }, React337.createElement(StepIconSemanticContext.Provider, {
    value: {
      className: itemClassNames.icon,
      style: itemStyles.icon
    }
  }, iconNode), React337.createElement("div", {
    className: clsx(`${itemCls}-section`, classNames.itemSection, itemClassNames.section),
    style: {
      ...styles.itemSection,
      ...itemStyles.section
    }
  }, React337.createElement("div", {
    className: clsx(`${itemCls}-header`, classNames.itemHeader, itemClassNames.header),
    style: {
      ...styles.itemHeader,
      ...itemStyles.header
    }
  }, hasTitle && React337.createElement("div", {
    className: clsx(`${itemCls}-title`, classNames.itemTitle, itemClassNames.title),
    style: {
      ...styles.itemTitle,
      ...itemStyles.title
    }
  }, title), hasSubTitle && React337.createElement("div", {
    title: typeof subTitle === "string" ? subTitle : void 0,
    className: clsx(`${itemCls}-subtitle`, classNames.itemSubtitle, itemClassNames.subtitle),
    style: {
      ...styles.itemSubtitle,
      ...itemStyles.subtitle
    }
  }, subTitle), !last && React337.createElement(Rail, {
    prefixCls: itemCls,
    className: clsx(classNames.itemRail, itemClassNames.rail),
    style: {
      ...styles.itemRail,
      ...itemStyles.rail
    },
    status: railFollowPrevStatus ? status : nextStatus
  })), hasContent(mergedContent) && React337.createElement("div", {
    className: clsx(`${itemCls}-content`, classNames.itemContent, itemClassNames.content),
    style: {
      ...styles.itemContent,
      ...itemStyles.content
    }
  }, mergedContent)));
  let stepNode = React337.createElement(ItemComponent, _extends56({}, restItemProps, accessibilityProps, {
    className: classString,
    style: {
      ...styles.item,
      ...itemStyles.root,
      ...style
    }
  }), itemWrapperRender ? itemWrapperRender(wrapperNode) : wrapperNode);
  if (itemRender) {
    stepNode = itemRender(stepNode, renderInfo) || null;
  }
  return stepNode;
}

// node_modules/@rc-component/steps/es/Steps.js
function _extends57() {
  _extends57 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends57.apply(this, arguments);
}
var EmptyObject = {};
function Steps2(props) {
  const {
    // style
    prefixCls = "rc-steps",
    style,
    className,
    classNames = EmptyObject,
    styles = EmptyObject,
    rootClassName,
    // layout
    orientation,
    titlePlacement,
    components,
    // data
    status = "process",
    current = 0,
    initial = 0,
    onChange,
    items,
    // render
    iconRender,
    itemRender,
    itemWrapperRender,
    ...restProps
  } = props;
  const isVertical = orientation === "vertical";
  const mergedOrientation = isVertical ? "vertical" : "horizontal";
  const mergeTitlePlacement = !isVertical && titlePlacement === "vertical" ? "vertical" : "horizontal";
  const classString = clsx(prefixCls, `${prefixCls}-${mergedOrientation}`, `${prefixCls}-title-${mergeTitlePlacement}`, rootClassName, className, classNames.root);
  const mergedItems = import_react115.default.useMemo(() => (items || []).filter(Boolean), [items]);
  const statuses = import_react115.default.useMemo(() => mergedItems.map(({
    status: itemStatus
  }, index2) => {
    const stepNumber = initial + index2;
    if (!itemStatus) {
      if (stepNumber === current) {
        return status;
      } else if (stepNumber < current) {
        return "finish";
      }
      return "wait";
    }
    return itemStatus;
  }), [mergedItems, status, current, initial]);
  const onStepClick = (next) => {
    if (onChange && current !== next) {
      onChange(next);
    }
  };
  const {
    root: RootComponent = "div",
    item: ItemComponent = "div"
  } = components || {};
  const stepIconContext = import_react115.default.useMemo(() => ({
    prefixCls,
    classNames,
    styles,
    ItemComponent
  }), [prefixCls, classNames, styles, ItemComponent]);
  const renderStep = (item, index2) => {
    const stepIndex = initial + index2;
    const itemStatus = statuses[index2];
    const nextStatus = statuses[index2 + 1];
    const data = {
      ...item,
      status: itemStatus
    };
    return import_react115.default.createElement(Step, {
      key: stepIndex,
      prefixCls,
      classNames,
      styles,
      data,
      nextStatus,
      active: stepIndex === current,
      index: stepIndex,
      last: mergedItems.length - 1 === index2,
      iconRender,
      itemRender,
      itemWrapperRender,
      onClick: onChange && onStepClick
    });
  };
  return import_react115.default.createElement(RootComponent, _extends57({
    className: classString,
    style: {
      ...style,
      ...styles?.root
    }
  }, restProps), import_react115.default.createElement(StepsContext.Provider, {
    value: stepIconContext
  }, mergedItems.map(renderStep)));
}

// node_modules/@rc-component/steps/es/index.js
var es_default21 = Steps2;

// node_modules/antd/es/steps/context.js
var React339 = __toESM(require_react());
var InternalContext = React339.createContext(null);

// node_modules/antd/es/steps/PanelArrow.js
var React340 = __toESM(require_react());
function PanelArrow(props) {
  const {
    prefixCls
  } = props;
  return React340.createElement("svg", {
    className: `${prefixCls}-panel-arrow`,
    viewBox: "0 0 100 100",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "none"
  }, React340.createElement("title", null, "Arrow"), React340.createElement("path", {
    d: "M 0 0 L 100 50 L 0 100"
  }));
}

// node_modules/antd/es/steps/ProgressIcon.js
var React341 = __toESM(require_react());
function ProgressIcon(props) {
  const {
    prefixCls,
    children,
    percent
  } = props;
  const progressCls = `${prefixCls}-item-progress-icon`;
  const circleCls = `${progressCls}-circle`;
  const dashArray = `calc(var(--progress-r) * 2 * ${Math.PI * percent / 100}) 9999`;
  return React341.createElement(React341.Fragment, null, React341.createElement("svg", {
    className: `${progressCls}-svg`,
    viewBox: "0 0 100 100",
    width: "100%",
    height: "100%",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-valuemax": 100,
    "aria-valuemin": 0,
    "aria-valuenow": percent
  }, React341.createElement("title", null, "Progress"), React341.createElement("circle", {
    className: clsx(circleCls, `${circleCls}-rail`)
  }), React341.createElement("circle", {
    className: clsx(circleCls, `${circleCls}-ptg`),
    strokeDasharray: dashArray,
    transform: "rotate(-90 50 50)"
  })), children);
}

// node_modules/antd/es/steps/style/horizontal.js
var genHorizontalStyle2 = (token) => {
  const {
    componentCls
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-horizontal`]: {
      [`> ${itemCls}`]: {
        flex: "1 1 auto",
        minWidth: token.iconSize,
        [`${itemCls}-rail`]: {
          "--steps-horizontal-rail-margin": "calc(var(--steps-icon-size-max) / 2 + var(--steps-item-wrapper-padding-top))",
          position: "static",
          marginTop: "var(--steps-horizontal-rail-margin)",
          width: "auto",
          borderBlockStartWidth: "var(--steps-rail-size)",
          flex: 1,
          minWidth: 0,
          alignSelf: "flex-start",
          transform: "translateY(-50%)"
        }
      }
    }
  };
};
var horizontal_default2 = genHorizontalStyle2;

// node_modules/antd/es/steps/style/icon.js
var genIconStyle = (token) => {
  const {
    componentCls,
    customIconFontSize,
    motionDurationSlow
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      "--steps-icon-size": token.iconSize,
      "--steps-icon-border-width": token.lineWidth,
      [`${itemCls}-icon`]: {
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)",
        margin: 0,
        flex: "none",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: token.iconFontSize,
        fontFamily: token.fontFamily,
        lineHeight: "var(--steps-icon-size)",
        textAlign: "center",
        borderRadius: "var(--steps-icon-size)",
        border: `var(--steps-icon-border-width) ${token.lineType} transparent`,
        transition: ["background", "border", "color", "inset", "transform"].map((key) => `${key} ${motionDurationSlow}`).join(", "),
        zIndex: 1
      },
      // ==================== Custom ====================
      [`${itemCls}-custom ${itemCls}-icon`]: {
        background: "none",
        border: 0,
        fontSize: customIconFontSize
      }
    }
  };
};
var icon_default = genIconStyle;

// node_modules/antd/es/steps/style/inline.js
var genInlineStyle2 = (token) => {
  const {
    componentCls,
    inlineDotSize
  } = token;
  const containerPaddingTop = token.calc(token.paddingXS).add(token.lineWidth).equal();
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-inline`]: {
      "--steps-items-offset": "0",
      "--steps-item-wrapper-padding-top": containerPaddingTop,
      display: "inline-flex",
      "&:before": {
        content: '""',
        flex: "var(--steps-items-offset)"
      },
      [itemCls]: {
        // ========================= Variable =========================
        // Item
        "--steps-title-vertical-row-gap": token.paddingXS,
        // Icon
        "--steps-icon-size": inlineDotSize,
        "--steps-icon-size-active": inlineDotSize,
        // Title
        "--steps-title-font-size": token.fontSizeSM,
        "--steps-title-line-height": token.lineHeightSM,
        "--steps-item-title-color": token.colorTextSecondary,
        "--steps-subtitle-font-size": token.fontSizeSM,
        "--steps-subtitle-line-height": token.lineHeightSM,
        "--steps-item-subtitle-color": token.colorTextQuaternary,
        // Rail
        "--steps-rail-size": token.lineWidth,
        "--steps-title-horizontal-rail-gap": "0px",
        // ========================== Styles ==========================
        flex: 1,
        "&-wrapper": {
          paddingInline: token.paddingXXS,
          marginInline: token.calc(token.marginXXS).div(2).equal(),
          borderRadius: token.borderRadiusSM,
          cursor: "pointer",
          transition: `background ${token.motionDurationMid}`,
          "&:hover": {
            background: token.controlItemBgHover
          }
        },
        // Icon
        "&-icon": {
          [`${itemCls}-icon-dot`]: {
            "&:after": {
              display: "none"
            }
          }
        },
        // Header
        "&-title": {
          fontWeight: "normal",
          whiteSpace: "nowrap"
        },
        "&-content": {
          display: "none"
        }
      }
    }
  };
};
var inline_default = genInlineStyle2;

// node_modules/antd/es/steps/style/util.js
function withoutVar(cssVar) {
  return (cssVar || "--ant-not-exist").replace(/var\((.*)\)/, "$1");
}
function getItemWithWidthStyle(token, marginSize, optionalStyle) {
  const {
    calc,
    componentCls,
    descriptionMaxWidth
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`@container style(${withoutVar(descriptionMaxWidth)})`]: [{
      // Icon
      [`${itemCls}-icon`]: {
        marginInlineStart: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).equal()
      },
      // >>> Rail
      [`${itemCls}-rail`]: {
        width: "auto",
        insetInlineStart: calc(descriptionMaxWidth).add(`var(--steps-icon-size)`).div(2).add(marginSize).equal(),
        insetInlineEnd: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).sub(marginSize).mul(-1).equal()
      }
    }, optionalStyle]
  };
}

// node_modules/antd/es/steps/style/label-placement.js
var genLabelPlacementStyle = (token) => {
  const {
    componentCls,
    descriptionMaxWidth,
    marginXS,
    fontHeightLG,
    calc
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    // ====================== Shared ======================
    [componentCls]: {
      // Dot Steps active icon size is 2px larger than the default icon size
      "--steps-icon-size-max": "max(var(--steps-icon-size), var(--steps-icon-size-active, var(--steps-icon-size)))",
      // Icon
      [`${itemCls}-icon`]: {
        marginBlockStart: `calc((var(--steps-heading-height) - var(--steps-icon-size)) / 2)`
      }
    },
    // ==================== Horizontal ====================
    [`${componentCls}-title-horizontal`]: {
      "--steps-title-horizontal-item-margin": token.margin,
      "--steps-title-horizontal-rail-margin": token.margin,
      "--steps-title-horizontal-title-height": fontHeightLG,
      "--steps-heading-height": `max(var(--steps-icon-size), var(--steps-title-horizontal-title-height))`,
      // Horizontal only
      [`&${componentCls}-horizontal, &${componentCls}-horizontal-alternate`]: {
        [`${itemCls}:not(:first-child)`]: {
          marginInlineStart: `var(--steps-title-horizontal-item-margin)`
        },
        [`${itemCls}:last-child`]: {
          flex: "0 1 auto"
        },
        [`${itemCls}-wrapper`]: {
          columnGap: token.marginXS
        }
      },
      // Vertical only
      [`&${componentCls}-vertical`]: {
        [`${itemCls}-wrapper`]: {
          columnGap: token.margin
        },
        [`${itemCls}-empty-header`]: {
          [`${itemCls}-header`]: {
            minHeight: "auto"
          },
          [`${itemCls}-content`]: {
            marginTop: calc("var(--steps-heading-height)").sub(token.fontHeight).div(2).equal()
          }
        }
      },
      // Shared
      [`${itemCls}-section`]: {
        flex: 1,
        minWidth: 0
      },
      [`${itemCls}-header`]: {
        minHeight: "var(--steps-heading-height)"
      },
      [`${itemCls}-title`]: {
        flex: "0 1 auto"
      },
      [`${itemCls}-content`]: {
        maxWidth: descriptionMaxWidth
      },
      [`${itemCls}-subtitle`]: {
        flex: "0 9999 auto"
      },
      [`&${componentCls}-horizontal ${itemCls}-rail`]: {
        "--steps-item-wrapper-padding-top": "0px",
        flex: 1,
        marginInlineStart: `var(--steps-title-horizontal-rail-margin)`
      }
    },
    // ===================== Vertical =====================
    [`${componentCls}-title-vertical`]: {
      "--steps-title-vertical-row-gap": token.paddingSM,
      "--steps-title-horizontal-rail-gap": token.marginXXS,
      "--steps-heading-height": "var(--steps-icon-size-max)",
      [`> ${itemCls}`]: {
        flex: 1,
        [`${itemCls}-wrapper`]: {
          flexDirection: "column",
          rowGap: `var(--steps-title-vertical-row-gap)`,
          alignItems: "center"
        },
        // Section
        [`${itemCls}-section`]: {
          alignSelf: "stretch"
        },
        // Header
        [`${itemCls}-header`]: {
          flexDirection: "column",
          alignItems: "center"
        },
        // >>> title & subtitle & Content
        [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
          textAlign: "center",
          maxWidth: "100%"
        },
        [`${itemCls}-subtitle`]: {
          margin: 0
        },
        // >>> rail
        [`${itemCls}-rail`]: {
          position: "absolute",
          top: 0,
          width: `calc(100% - var(--steps-icon-size) - var(--steps-title-horizontal-rail-gap) * 2)`,
          insetInlineStart: `calc(50% + var(--steps-icon-size) / 2 + var(--steps-title-horizontal-rail-gap))`
        }
      },
      // With descriptionMaxWidth
      ...getItemWithWidthStyle(token, marginXS, {
        [`${itemCls}:last-child`]: {
          flex: "none"
        },
        // Icon
        [`${itemCls}-icon`]: {
          alignSelf: "flex-start"
        },
        // Section
        [`${itemCls}-section`]: {
          width: descriptionMaxWidth
        }
      })
    }
  };
};
var label_placement_default = genLabelPlacementStyle;

// node_modules/antd/es/steps/style/nav.js
var genLegacyNavStyle = (token) => {
  const {
    componentCls,
    fontSizeIcon,
    calc,
    navContentMaxWidth,
    navArrowColor,
    colorPrimary,
    motionDurationSlow
  } = token;
  const itemCls = `${componentCls}-item`;
  const stepsNavActiveColor = colorPrimary;
  return {
    [`${componentCls}${componentCls}-navigation`]: {
      // ==========================================================
      // ==                        Shared                        ==
      // ==========================================================
      // ========================== Item ==========================
      [itemCls.repeat(4)]: {
        display: "flex",
        justifyContent: "center",
        position: "relative",
        flex: 1,
        marginInlineStart: 0,
        [`${itemCls}-wrapper`]: {
          paddingBlock: token.paddingSM
        },
        // Section
        [`${itemCls}-section`]: {
          maxWidth: navContentMaxWidth
        },
        // Rail
        [`${itemCls}-rail`]: {
          display: "none"
        },
        // ======================== Active ========================
        "&:before": {
          position: "absolute",
          display: "block",
          backgroundColor: stepsNavActiveColor,
          transition: `all ${motionDurationSlow}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        },
        "&:not(:last-child):after": {
          position: "absolute",
          display: "block",
          borderTop: `${unit(token.lineWidth)} ${token.lineType} ${navArrowColor}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${unit(token.lineWidth)} ${token.lineType} ${navArrowColor}`,
          content: '""'
        },
        // Reset active item style to same as default
        [`&${itemCls}-active`]: {
          "--steps-item-content-active-color": `var(--steps-item-content-color)`,
          "--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
          "--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
          "--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)"
        }
      },
      // ==========================================================
      // ==                       Horizontal                     ==
      // ==========================================================
      [`&${componentCls}-horizontal`]: {
        [itemCls]: {
          "&:before": {
            bottom: 0,
            insetInlineStart: "50%",
            width: 0,
            height: token.lineWidthBold
          },
          [`&${itemCls}-active:before`]: {
            insetInlineStart: 0,
            width: "100%"
          },
          "&:not(:last-child):after": {
            top: `50%`,
            insetInlineStart: calc(fontSizeIcon).div(2).mul(-1).add("100%").equal(),
            width: fontSizeIcon,
            height: fontSizeIcon,
            transform: "translateY(-50%) rotate(45deg)"
          }
        }
      },
      // ==========================================================
      // ==                        Vertical                      ==
      // ==========================================================
      [`&${componentCls}-vertical`]: {
        [itemCls.repeat(4)]: {
          [`${itemCls}-content`]: {
            padding: 0
          },
          "&:before": {
            insetInlineEnd: 0,
            top: "50%",
            width: token.lineWidthBold,
            height: 0
          },
          [`&${itemCls}-active::before`]: {
            top: 0,
            height: "100%"
          },
          "&:not(:last-child):after": {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            top: "100%",
            width: calc(fontSizeIcon).div(3).mul(2).equal(),
            height: calc(fontSizeIcon).div(3).mul(2).equal(),
            transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
          }
        }
      }
      // ========================= Legacy =========================
    }
  };
};
var nav_default = genLegacyNavStyle;

// node_modules/antd/es/steps/style/panel.js
var genPanelStyle3 = (token) => {
  const {
    componentCls,
    calc,
    lineWidthBold,
    borderRadius,
    borderRadiusSM,
    motionDurationMid
  } = token;
  const itemCls = `${componentCls}-item`;
  const borderStyle = `${unit(lineWidthBold)} ${token.lineType} var(--steps-panel-border-color)`;
  return {
    [`${componentCls}${componentCls}-panel`]: [
      // ==========================================================
      // ==                       Clean up                       ==
      // ==========================================================
      {
        // ====================== Shared ======================
        [`${itemCls}-rail`]: {
          display: "none"
        },
        // ==================== Horizontal ====================
        [`&${componentCls}-horizontal`]: {
          alignItems: "stretch",
          [itemCls]: {
            flex: 1,
            margin: 0
          }
        }
      },
      // ==========================================================
      // ==                       Template                       ==
      // ==========================================================
      {
        "&": {
          "--steps-panel-padding": token.paddingSM,
          "--steps-item-border-radius": borderRadius,
          [itemCls]: {
            // Panel background
            "--steps-panel-bg-color": "var(--steps-item-icon-bg-color)",
            "--steps-panel-border-color": "var(--steps-item-icon-border-color)",
            "--steps-panel-active-bg-color": "var(--steps-item-icon-active-bg-color)",
            "--steps-panel-active-border-color": "var(--steps-item-icon-active-border-color)",
            "--steps-panel-title-height": `calc(var(--steps-title-font-size) * var(--steps-title-line-height))`,
            // Base height = padding * 2 + iconSize + contentHeight
            "--steps-item-base-height": calc("var(--steps-panel-padding)").mul(2).add("var(--steps-icon-size)").add("var(--steps-panel-title-height)").equal(),
            "--steps-item-base-width": "calc(var(--steps-item-base-height) * 0.7071)",
            transition: `background ${motionDurationMid}`
          }
        },
        // ======================= Icon =======================
        [`${itemCls}-icon`]: {
          display: "none"
        },
        // ====================== Header ======================
        [`${itemCls}-header`]: {
          minHeight: "auto"
        },
        // ====================== Arrow =======================
        [`${componentCls}-panel-arrow`]: {
          position: "absolute",
          top: calc(lineWidthBold).mul(-1).equal(),
          insetInlineStart: "100%",
          zIndex: 1,
          height: calc(lineWidthBold).mul(2).add("100%").equal(),
          width: "var(--steps-item-base-width)",
          overflow: "visible",
          strokeLinecap: "round",
          path: {
            fill: "var(--steps-panel-bg-color)",
            stroke: "var(--steps-panel-border-color)",
            strokeWidth: lineWidthBold,
            vectorEffect: "non-scaling-stroke",
            transition: `fill ${motionDurationMid}`
          }
        },
        [`${itemCls}:last-child ${componentCls}-panel-arrow`]: {
          display: "none"
        },
        // ======================= Item =======================
        [itemCls]: {
          padding: "var(--steps-panel-padding)",
          background: "var(--steps-panel-bg-color)",
          position: "relative",
          borderBlock: borderStyle,
          "&:not(:first-child)": {
            paddingInlineStart: `calc(var(--steps-panel-padding) + var(--steps-item-base-width))`
          },
          "&:first-child": {
            borderInlineStart: borderStyle,
            borderStartStartRadius: "var(--steps-item-border-radius)",
            borderEndStartRadius: "var(--steps-item-border-radius)"
          },
          "&:last-child": {
            borderInlineEnd: borderStyle,
            borderStartEndRadius: "var(--steps-item-border-radius)",
            borderEndEndRadius: "var(--steps-item-border-radius)"
          },
          "&-active": {
            background: "var(--steps-panel-active-bg-color)",
            borderColor: "var(--steps-panel-active-border-color)",
            [`${componentCls}-panel-arrow`]: {
              path: {
                fill: "var(--steps-panel-active-bg-color)",
                stroke: "var(--steps-panel-active-border-color)"
              }
            },
            [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
              color: "var(--steps-item-icon-active-text-color)"
            }
          }
        }
      },
      // ==========================================================
      // ==                         Size                         ==
      // ==========================================================
      {
        [`&${componentCls}-small`]: {
          "--steps-panel-padding": token.paddingXS,
          "--steps-item-border-radius": borderRadiusSM
        }
      },
      // ==========================================================
      // ==                        Filled                        ==
      // ==========================================================
      {
        [`&${componentCls}-filled`]: {
          [itemCls]: {
            "&:not(:first-child)": {
              clipPath: `polygon(${[`${unit(lineWidthBold)} 0`, "calc(100% + var(--steps-item-base-width)) 0", "calc(100% + var(--steps-item-base-width)) 100%", `${unit(lineWidthBold)} 100%`, `calc(var(--steps-item-base-width) + ${unit(lineWidthBold)}) 50%`].join(",")})`
            }
          }
        }
      },
      // ==========================================================
      // ==                       Outlined                       ==
      // ==========================================================
      {
        [`&${componentCls}-outlined`]: {
          [`${componentCls}-panel-arrow`]: {
            top: calc(lineWidthBold).div(2).mul(-1).equal(),
            height: calc(lineWidthBold).add("100%").equal()
          }
        }
      }
    ]
  };
};
var panel_default3 = genPanelStyle3;

// node_modules/antd/es/steps/style/progress.js
var genStepsProgressStyle = (token) => {
  const {
    calc,
    antCls,
    componentCls,
    iconSize,
    iconSizeSM,
    lineWidthBold,
    paddingXXS
  } = token;
  const itemCls = `${componentCls}-item`;
  const progressSize = token.calc(iconSize).add(token.calc(lineWidthBold).mul(4).equal()).equal();
  const progressSizeSM = token.calc(iconSizeSM).add(token.calc(token.lineWidth).mul(4).equal()).equal();
  const enhanceSize = calc(lineWidthBold).add(lineWidthBold).equal();
  return {
    [`${componentCls}${componentCls}-with-progress`]: {
      "--steps-item-wrapper-padding-top": enhanceSize,
      [`${itemCls}${itemCls}-process`]: {
        [`${itemCls}-icon`]: {
          position: "relative"
        }
      },
      [`${itemCls}-progress-icon`]: {
        "&-svg": {
          "--steps-svg-size": calc(enhanceSize).mul(2).add(`var(--steps-icon-size)`).equal(),
          "--icon-size-ptg-unitless": `calc(100 / tan(atan2(var(--steps-svg-size),1px)))`,
          fontSize: `var(--steps-svg-size)`,
          lineHeight: `var(--icon-size-ptg-unitless)`,
          position: "absolute",
          inset: calc(enhanceSize).mul(-1).equal(),
          width: "auto",
          height: "auto"
        },
        "&-circle": {
          lineHeight: `var(--icon-size-ptg-unitless)`,
          strokeWidth: calc(`var(--icon-size-ptg-unitless)`).mul(lineWidthBold).equal(),
          "--progress-r": calc(`var(--steps-svg-size)`).sub(lineWidthBold).mul(`var(--icon-size-ptg-unitless)`).div(2).equal(),
          r: `var(--progress-r)`,
          fill: "none",
          cx: 50,
          cy: 50,
          transition: `all ${token.motionDurationSlow} ease-in-out`,
          "&-rail": {
            stroke: token.colorSplit
          },
          "&-ptg": {
            stroke: token.colorPrimary
          }
        }
      }
    },
    [`&${componentCls}-with-progress11`]: {
      // ==========================================================
      // ==                        Shared                        ==
      // ==========================================================
      [itemCls]: {
        paddingTop: paddingXXS,
        paddingInlineStart: paddingXXS
      },
      [`${itemCls}-icon`]: {
        position: "relative",
        [`${antCls}-progress`]: {
          position: "absolute",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          top: "50%",
          transform: "translate(-50%, -50%)",
          "&-body": {
            width: `${unit(progressSize)} !important`,
            height: `${unit(progressSize)} !important`
          }
        }
      },
      [`&${componentCls}-small`]: {
        [`${itemCls}-icon ${antCls}-progress-body`]: {
          width: `${unit(progressSizeSM)} !important`,
          height: `${unit(progressSizeSM)} !important`
        }
      }
    }
  };
};
var progress_default3 = genStepsProgressStyle;

// node_modules/antd/es/steps/style/progress-dot.js
var genDotStyle = (token) => {
  const {
    componentCls,
    iconSize,
    dotSize,
    dotCurrentSize,
    marginXXS,
    lineWidthBold,
    fontSizeSM
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}${componentCls}-dot`]: {
      "--steps-icon-size-active": dotCurrentSize,
      "--steps-icon-size": dotSize,
      "--steps-dot-icon-size": dotSize,
      "--steps-dot-icon-border-width": token.lineWidthBold,
      "--steps-rail-size": lineWidthBold,
      "--steps-icon-border-width": lineWidthBold,
      // ========================= Shared ==========================
      // Icon
      [`${itemCls}-custom ${itemCls}-icon`]: {
        fontSize: fontSizeSM
      },
      [`${itemCls}-icon`]: {
        position: "relative",
        "&:after": {
          content: '""',
          width: iconSize,
          height: iconSize,
          display: "block",
          position: "absolute",
          top: "50%",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translate(-50%, -50%)"
        }
      },
      // // >>> active
      [`${itemCls}-active ${itemCls}-icon`]: {
        "--steps-icon-size": "var(--steps-icon-size-active)"
      },
      // ======================= Horizontal ========================
      [`&${componentCls}-horizontal`]: {
        // With descriptionMaxWidth
        [`&, &${componentCls}-small`]: getItemWithWidthStyle(token, marginXXS)
      }
    }
  };
};
var progress_dot_default = genDotStyle;

// node_modules/antd/es/steps/style/rtl.js
var genRTLStyle2 = (token) => {
  const {
    componentCls,
    lineWidthBold
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}${componentCls}-rtl`]: {
      direction: "rtl",
      // nav
      [`&${componentCls}-navigation${componentCls}-horizontal`]: {
        [`${itemCls}:after`]: {
          transform: "translateY(-50%) rotate(-45deg)"
        }
      },
      // panel
      [`&${componentCls}-panel`]: {
        [`${componentCls}-panel-arrow`]: {
          transform: `scaleX(-1)`
        },
        [`&${componentCls}-filled`]: {
          [itemCls]: {
            "&:not(:first-child)": {
              clipPath: `polygon(${[`calc(0px - var(--steps-item-base-width)) 0px`, `calc(100% - ${unit(lineWidthBold)}) 0px`, `calc(100% - var(--steps-item-base-width) - ${unit(lineWidthBold)}) 50%`, `calc(100% - ${unit(lineWidthBold)}) 100%`, `calc(0px - var(--steps-item-base-width)) 100%`].join(",")})`
            }
          }
        }
      }
    }
  };
};
var rtl_default2 = genRTLStyle2;

// node_modules/antd/es/steps/style/small.js
var genSmallStyle = (token) => {
  const {
    componentCls,
    iconSizeSM,
    fontSize,
    lineHeight,
    marginXS
  } = token;
  return {
    [`${componentCls}${componentCls}-small`]: {
      "--steps-icon-size": iconSizeSM,
      "--steps-title-horizontal-item-margin": token.marginSM,
      "--steps-title-vertical-row-gap": token.paddingXS,
      "--steps-title-font-size": fontSize,
      "--steps-title-line-height": lineHeight,
      "--steps-title-horizontal-rail-margin": token.marginXS,
      "--steps-title-horizontal-title-height": token.fontHeight,
      // Horizontal: label vertical
      [`&${componentCls}-horizontal${componentCls}-title-vertical`]: getItemWithWidthStyle(token, marginXS)
    }
  };
};
var small_default = genSmallStyle;

// node_modules/antd/es/steps/style/status.js
var STATUS_WAIT = "wait";
var STATUS_PROCESS = "process";
var STATUS_FINISH = "finish";
var STATUS_ERROR = "error";
var genStatusStyle2 = (token) => {
  const {
    componentCls,
    colorTextDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorTextLabel,
    colorError,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorPrimaryHover
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: [{
      // ========================= Variable =========================
      [itemCls]: {
        // Normal
        // >>> line
        "--steps-item-solid-line-color": "#000",
        // >>> text
        "--steps-item-title-color": "#000",
        "--steps-item-content-color": "#000",
        "--steps-item-subtitle-color": "var(--steps-item-content-color)",
        // >>> icon
        "--steps-item-icon-custom-color": "#000",
        "--steps-item-icon-bg-color": "#000",
        "--steps-item-icon-border-color": "#000",
        "--steps-item-icon-text-color": "#fff",
        // >>> dot
        "--steps-item-icon-dot-color": "#000",
        "--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-color)",
        "--steps-item-icon-dot-border-color": "var(--steps-item-icon-dot-color)",
        // Hover
        // >>> text
        "--steps-item-text-hover-color": "#000",
        // >>> icon
        "--steps-item-icon-bg-hover-color": `var(--steps-item-icon-bg-color)`,
        "--steps-item-icon-border-hover-color": `var(--steps-item-icon-border-color)`,
        "--steps-item-icon-text-hover-color": `var(--steps-item-icon-text-color)`,
        // Active
        // >>> text
        "--steps-item-content-active-color": `var(--steps-item-content-color)`,
        // >>> icon
        "--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
        "--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
        "--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)",
        // Status
        "--steps-item-process-rail-line-style": token.lineType
      },
      // ========================= Template =========================
      // Normal
      // >>> line
      [`${itemCls}-rail`]: {
        borderColor: `var(--steps-item-solid-line-color)`
      },
      // >>> icon
      [`${itemCls}-custom ${itemCls}-icon`]: {
        color: `var(--steps-item-icon-custom-color)`
      },
      // >>> text
      [`${itemCls}-title`]: {
        color: `var(--steps-item-title-color)`
      },
      [`${itemCls}-subtitle`]: {
        color: `var(--steps-item-subtitle-color)`
      },
      [`${itemCls}-content`]: {
        color: `var(--steps-item-content-color)`
      },
      // Active
      // >>> icon
      [`${itemCls}-active ${itemCls}-icon`]: {},
      // >>> text
      [`${itemCls}-active ${itemCls}-content`]: {
        color: `var(--steps-item-content-active-color)`
      },
      // Hover
      // >>> text
      [`${itemCls}[role='button']:not(${itemCls}-active):hover`]: {
        [`${itemCls}-title, ${itemCls}-content`]: {
          color: `var(--steps-item-text-hover-color)`
        }
      },
      // Not dot
      [`&:not(${componentCls}-dot)`]: {
        [`${itemCls}:not(${itemCls}-custom)`]: {
          [`${itemCls}-icon`]: {
            background: `var(--steps-item-icon-bg-color)`,
            borderColor: `var(--steps-item-icon-border-color)`,
            color: `var(--steps-item-icon-text-color)`
          },
          // Hover
          [`&[role='button']:not(${itemCls}-active):hover`]: {
            [`${itemCls}-icon`]: {
              background: `var(--steps-item-icon-bg-hover-color)`,
              borderColor: `var(--steps-item-icon-border-hover-color)`,
              color: `var(--steps-item-icon-text-hover-color)`
            }
          },
          // Active
          [`&${itemCls}-active`]: {
            [`${itemCls}-icon`]: {
              background: `var(--steps-item-icon-active-bg-color)`,
              borderColor: `var(--steps-item-icon-active-border-color)`,
              color: `var(--steps-item-icon-active-text-color)`
            }
          }
        }
      },
      // Dot
      [`&${componentCls}-dot`]: {
        [`${itemCls}-icon`]: {
          background: `var(--steps-item-icon-dot-bg-color)`,
          borderColor: `var(--steps-item-icon-dot-border-color)`,
          color: `var(--steps-item-icon-dot-color)`,
          [`&${itemCls}-icon-dot-custom`]: {
            background: "transparent",
            border: "none"
          }
        }
      }
    }, {
      // ========================== Shared ==========================
      // Wait
      [`${itemCls}-${STATUS_WAIT}`]: {
        "--steps-item-icon-custom-color": colorTextDisabled,
        "--steps-item-title-color": colorTextDescription,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_WAIT}`]: {
        "--steps-item-solid-line-color": colorTextDisabled
      },
      // Process
      [`${itemCls}-${STATUS_PROCESS}`]: {
        "--steps-item-icon-custom-color": colorPrimary,
        "--steps-item-title-color": colorText,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_PROCESS}`]: {
        "--steps-item-solid-line-color": colorPrimary,
        // Special for Timeline usage
        "--steps-rail-line-style": "var(--steps-item-process-rail-line-style)"
      },
      // Finish
      [`${itemCls}-${STATUS_FINISH}`]: {
        "--steps-item-icon-custom-color": colorPrimary,
        "--steps-item-title-color": colorText,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_FINISH}`]: {
        "--steps-item-solid-line-color": colorPrimary
      },
      // Error
      [`${itemCls}-${STATUS_ERROR}`]: {
        "--steps-item-icon-custom-color": colorError,
        "--steps-item-title-color": colorError,
        "--steps-item-content-color": colorError,
        "--steps-item-content-active-color": colorError,
        "--steps-item-text-hover-color": token.colorErrorHover
      },
      [`${itemCls}-rail-${STATUS_ERROR}`]: {
        "--steps-item-solid-line-color": colorError
      }
    }, {
      // ========================== Filled ==========================
      [`&${componentCls}-filled`]: {
        [itemCls]: {
          "--steps-item-icon-dot-border-color": "transparent"
        },
        // Wait
        [`${itemCls}-${STATUS_WAIT}`]: {
          "--steps-item-icon-bg-color": token.colorFillTertiary,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorTextLabel,
          "--steps-item-icon-dot-bg-color": colorTextDisabled,
          // Hover
          "--steps-item-icon-bg-hover-color": token.colorPrimaryBgHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorPrimary,
          // Active
          "--steps-item-icon-active-bg-color": colorPrimary,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        },
        // Finish & Process
        [`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
          "--steps-item-icon-bg-color": token.colorPrimaryBg,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorPrimary,
          "--steps-item-icon-dot-bg-color": colorPrimary,
          // Hover
          "--steps-item-icon-bg-hover-color": token.colorPrimaryBgHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorPrimary,
          // Active
          "--steps-item-icon-active-bg-color": colorPrimary,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        },
        // Error
        [`${itemCls}-${STATUS_ERROR}`]: {
          "--steps-item-icon-bg-color": token.colorErrorBg,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorError,
          "--steps-item-icon-dot-bg-color": colorError,
          // Hover
          "--steps-item-icon-bg-hover-color": token.colorErrorBgFilledHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorError,
          // Active
          "--steps-item-icon-active-bg-color": colorError,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        }
      }
    }, {
      // ========================= Outlined =========================
      [`&${componentCls}-outlined`]: {
        [itemCls]: {
          "--steps-item-icon-dot-bg-color": "transparent"
        },
        // Wait
        [`${itemCls}-${STATUS_WAIT}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorTextDisabled,
          "--steps-item-icon-text-color": colorTextDisabled,
          "--steps-item-icon-dot-color": colorTextDisabled,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": colorPrimaryHover,
          "--steps-item-icon-text-hover-color": colorPrimaryHover,
          // Active
          "--steps-item-icon-active-bg-color": token.colorFillTertiary
        },
        // Finish & Process
        [`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorPrimary,
          "--steps-item-icon-text-color": colorPrimary,
          "--steps-item-icon-dot-color": colorPrimary,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": token.colorPrimaryHover,
          "--steps-item-icon-text-hover-color": token.colorPrimaryHover,
          // Active
          "--steps-item-icon-active-bg-color": token.colorPrimaryBg
        },
        // Error
        [`${itemCls}-${STATUS_ERROR}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorError,
          "--steps-item-icon-text-color": colorError,
          "--steps-item-icon-dot-color": colorError,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": token.colorErrorHover,
          "--steps-item-icon-text-hover-color": token.colorErrorHover,
          // Active
          "--steps-item-icon-active-bg-color": token.colorErrorBg
        }
      }
    }]
  };
};
var status_default2 = genStatusStyle2;

// node_modules/antd/es/steps/style/vertical.js
var genVerticalStyle2 = (token) => {
  const {
    componentCls,
    calc
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-vertical`]: {
      "--steps-vertical-rail-margin": calc(token.marginXXS).mul(1.5).equal(),
      flexDirection: "column",
      alignItems: "stretch",
      // Item
      [`> ${itemCls}`]: {
        minHeight: calc(token.controlHeight).mul(1.5).equal(),
        paddingBottom: token.paddingSM,
        "&:last-child": {
          paddingBottom: 0
        },
        // Icon
        [`${itemCls}-icon`]: {
          marginInlineStart: "calc((var(--steps-icon-size-max) - var(--steps-icon-size)) / 2)"
        },
        // >>> Rail
        [`${itemCls}-rail`]: {
          "--steps-rail-offset": calc("var(--steps-heading-height)").sub("var(--steps-icon-size)").div(2).equal(),
          borderInlineStartWidth: "var(--steps-rail-size)",
          position: "absolute",
          top: calc(`var(--steps-icon-size)`).add("var(--steps-item-wrapper-padding-top)").add("var(--steps-rail-offset)").add("var(--steps-vertical-rail-margin)").equal(),
          insetInlineStart: calc(`var(--steps-icon-size-max)`).div(2).equal(),
          bottom: calc("var(--steps-vertical-rail-margin)").sub("var(--steps-rail-offset)").equal(),
          marginInlineStart: `calc(var(--steps-rail-size) / -2)`
        }
      }
    }
  };
};
var vertical_default2 = genVerticalStyle2;

// node_modules/antd/es/steps/style/index.js
var genBasicStyle = (token) => {
  const {
    componentCls
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      // TODO: use `genCssVar` hook to generate css variables
      "--steps-title-font-size": token.fontSizeLG,
      "--steps-title-line-height": token.lineHeightLG,
      "--steps-subtitle-font-size": token.fontSize,
      "--steps-subtitle-line-height": token.lineHeight,
      "--steps-item-wrapper-padding-top": "0px",
      "--steps-rail-size": token.lineWidth,
      "--steps-rail-line-style": token.lineType,
      ...resetComponent(token),
      display: "flex",
      flexWrap: "nowrap",
      alignItems: "flex-start",
      [itemCls]: {
        flex: "none",
        position: "relative"
      },
      [`${itemCls}-wrapper`]: {
        display: "flex",
        flexWrap: "nowrap",
        paddingTop: `var(--steps-item-wrapper-padding-top)`
      },
      // Icon
      // Check `./icon.ts`
      // Header
      [`${itemCls}-header`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "center"
      },
      // >>> Title
      [`${itemCls}-title`]: {
        color: token.colorText,
        fontSize: `var(--steps-title-font-size)`,
        lineHeight: `var(--steps-title-line-height)`,
        wordBreak: "break-word"
      },
      // >>> Sub Title
      [`${itemCls}-subtitle`]: {
        color: token.colorTextDescription,
        fontWeight: "normal",
        fontSize: `var(--steps-subtitle-font-size)`,
        lineHeight: `var(--steps-subtitle-line-height)`,
        marginInlineStart: token.marginXS,
        wordBreak: "break-word"
      },
      // Content
      [`${itemCls}-content`]: {
        color: token.colorTextDescription,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        wordBreak: "break-word"
      },
      // Rail
      [`${itemCls}-rail`]: {
        borderStyle: "var(--steps-rail-line-style)",
        borderWidth: 0
      },
      // Motion
      [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content, ${itemCls}-rail`]: {
        transition: `all ${token.motionDurationSlow}`
      },
      // ========================== Ellipsis ==========================
      [`&${componentCls}-ellipsis`]: {
        [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: textEllipsis
      },
      // ========================= Clickable ==========================
      [`${itemCls}[role='button']:not(${itemCls}-active):hover`]: {
        cursor: "pointer"
      }
    }
  };
};
var prepareComponentToken41 = (token) => ({
  titleLineHeight: token.controlHeight,
  customIconSize: token.controlHeight,
  customIconTop: 0,
  customIconFontSize: token.controlHeightSM,
  iconSize: token.controlHeight,
  iconTop: -0.5,
  // magic for ui experience
  iconFontSize: token.fontSize,
  iconSizeSM: token.fontSizeHeading3,
  dotSize: token.controlHeight / 4,
  dotCurrentSize: token.controlHeightLG / 4,
  navArrowColor: token.colorTextDisabled,
  navContentMaxWidth: "unset",
  descriptionMaxWidth: void 0,
  // should be `undefined` to create css var
  waitIconColor: token.wireframe ? token.colorTextDisabled : token.colorTextLabel,
  waitIconBgColor: token.wireframe ? token.colorBgContainer : token.colorFillContent,
  waitIconBorderColor: token.wireframe ? token.colorTextDisabled : "transparent",
  finishIconBgColor: token.wireframe ? token.colorBgContainer : token.controlItemBgActive,
  finishIconBorderColor: token.wireframe ? token.colorPrimary : token.controlItemBgActive
});
var style_default47 = genStyleHooks("Steps", (token) => {
  const stepsToken = merge(token, {
    inlineDotSize: 6
  });
  return [genBasicStyle(stepsToken), icon_default(stepsToken), vertical_default2(stepsToken), horizontal_default2(stepsToken), label_placement_default(stepsToken), small_default(stepsToken), progress_dot_default(stepsToken), status_default2(stepsToken), nav_default(stepsToken), panel_default3(stepsToken), inline_default(stepsToken), progress_default3(stepsToken), rtl_default2(stepsToken)];
}, prepareComponentToken41);

// node_modules/antd/es/steps/index.js
var waveEffectClassNames = {
  itemIcon: TARGET_CLS
};
var Steps3 = (props) => {
  const {
    // Style
    size,
    className,
    rootClassName,
    style,
    variant = "filled",
    type,
    classNames,
    styles,
    // Layout
    direction,
    orientation,
    responsive = true,
    progressDot,
    labelPlacement,
    titlePlacement,
    ellipsis,
    offset: offset3 = 0,
    // Data
    items,
    percent,
    current = 0,
    onChange,
    // Render
    iconRender,
    // MISC
    ...restProps
  } = props;
  const internalContent = React342.useContext(InternalContext);
  const contextContent = useComponentConfig("steps");
  const {
    getPrefixCls,
    direction: rtlDirection,
    className: contextClassName,
    style: contextStyle
  } = contextContent;
  let contextClassNames;
  let contextStyles;
  let components = {};
  if (internalContent) {
    components = {
      root: internalContent.rootComponent,
      item: internalContent.itemComponent
    };
  } else {
    ({
      classNames: contextClassNames,
      styles: contextStyles
    } = contextContent);
  }
  const prefixCls = getPrefixCls("steps", props.prefixCls);
  const itemIconCls = `${prefixCls}-item-icon`;
  const [hashId, cssVarCls] = style_default47(prefixCls);
  const mergedSize = useSize_default(size);
  const mergedItems = React342.useMemo(() => (items || []).filter(Boolean), [items]);
  const {
    xs
  } = useBreakpoint_default(responsive);
  const mergedType = React342.useMemo(() => {
    if (type && type !== "default") {
      return type;
    }
    if (progressDot) {
      return "dot";
    }
    return type;
  }, [progressDot, type]);
  const isInline = mergedType === "inline";
  const isDot = mergedType === "dot" || mergedType === "inline";
  const legacyProgressDotRender = React342.useMemo(() => {
    return mergedType === "dot" && typeof progressDot === "function" ? progressDot : void 0;
  }, [mergedType, progressDot]);
  const mergedOrientation = React342.useMemo(() => {
    const nextOrientation = orientation || direction;
    if (mergedType === "panel") {
      return "horizontal";
    }
    return responsive && xs || nextOrientation === "vertical" ? "vertical" : "horizontal";
  }, [orientation, direction, mergedType, responsive, xs]);
  const mergedTitlePlacement = React342.useMemo(() => {
    if (isDot || mergedOrientation === "vertical") {
      return mergedOrientation === "vertical" ? "horizontal" : "vertical";
    }
    if (type === "navigation") {
      return "horizontal";
    }
    return titlePlacement || labelPlacement || "horizontal";
  }, [isDot, labelPlacement, mergedOrientation, titlePlacement, type]);
  const mergedPercent = isInline ? void 0 : percent;
  const mergedProps = {
    ...props,
    variant,
    size: mergedSize,
    type: mergedType,
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    current,
    percent: mergedPercent,
    responsive,
    offset: offset3
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([waveEffectClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const internalIconRender = (_, info) => {
    const {
      item,
      index: index2,
      active,
      components: {
        Icon: StepIcon2
      }
    } = info;
    const {
      status,
      icon
    } = item;
    let iconContent = null;
    if (isDot || icon) {
      iconContent = icon;
    } else {
      switch (status) {
        case "finish":
          iconContent = React342.createElement(CheckOutlined_default, {
            className: `${itemIconCls}-finish`
          });
          break;
        case "error":
          iconContent = React342.createElement(CloseOutlined_default, {
            className: `${itemIconCls}-error`
          });
          break;
        default: {
          let numNode = React342.createElement("span", {
            className: `${itemIconCls}-number`
          }, info.index + 1);
          if (status === "process" && mergedPercent !== void 0) {
            numNode = React342.createElement(ProgressIcon, {
              prefixCls,
              percent: mergedPercent
            }, numNode);
          }
          iconContent = numNode;
        }
      }
    }
    let iconNode = React342.createElement(StepIcon2, null, iconContent);
    if (iconRender) {
      iconNode = iconRender(iconNode, {
        index: index2,
        active,
        item,
        components: {
          Icon: StepIcon2
        }
      });
    } else if (typeof legacyProgressDotRender === "function") {
      iconNode = legacyProgressDotRender(iconNode, {
        index: index2,
        ...item
      });
    }
    return iconNode;
  };
  const itemRender = (itemNode, itemInfo) => {
    let content = itemNode;
    if (isInline && itemInfo.item.content) {
      content = React342.createElement(tooltip_default, {
        destroyOnHidden: true,
        title: itemInfo.item.content
      }, itemNode);
    }
    return React342.createElement(wave_default, {
      component: "Steps",
      disabled: itemInfo.item.disabled || !onChange,
      colorSource: variant === "filled" ? "color" : null
    }, content);
  };
  const itemWrapperRender = mergedType === "panel" ? (itemNode) => {
    return React342.createElement(React342.Fragment, null, itemNode, React342.createElement(PanelArrow, {
      prefixCls
    }));
  } : void 0;
  const mergedStyle = {
    "--steps-items-offset": `${offset3}`,
    ...contextStyle,
    ...style
  };
  const stepsClassName = clsx(contextClassName, `${prefixCls}-${variant}`, {
    [`${prefixCls}-${mergedType}`]: mergedType !== "dot" ? mergedType : false,
    [`${prefixCls}-rtl`]: rtlDirection === "rtl",
    [`${prefixCls}-dot`]: isDot,
    [`${prefixCls}-ellipsis`]: ellipsis,
    [`${prefixCls}-with-progress`]: mergedPercent !== void 0,
    [`${prefixCls}-${mergedSize}`]: mergedSize
  }, className, rootClassName, hashId, cssVarCls);
  if (true) {
    const warning2 = devUseWarning("Steps");
    warning2.deprecated(!labelPlacement, "labelPlacement", "titlePlacement");
    warning2.deprecated(!progressDot, "progressDot", 'type="dot"');
    warning2.deprecated(!direction, "direction", "orientation");
    warning2.deprecated(mergedItems.every((item) => !item.description), "items.description", "items.content");
  }
  return React342.createElement(es_default21, {
    ...restProps,
    // Style
    prefixCls,
    className: stepsClassName,
    style: mergedStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    // Layout
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    components,
    // Data
    current,
    items: mergedItems,
    onChange,
    // Render
    iconRender: internalIconRender,
    itemRender,
    itemWrapperRender
  });
};
if (true) {
  Steps3.displayName = "Steps";
}
var steps_default = Steps3;

// node_modules/antd/es/switch/index.js
var React344 = __toESM(require_react());

// node_modules/@rc-component/switch/es/index.js
var React343 = __toESM(require_react());
function _extends58() {
  _extends58 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends58.apply(this, arguments);
}
var Switch = React343.forwardRef(({
  prefixCls = "rc-switch",
  className,
  checked,
  defaultChecked,
  disabled,
  loadingIcon,
  checkedChildren,
  unCheckedChildren,
  onClick,
  onChange,
  onKeyDown: onKeyDown2,
  styles,
  classNames: switchClassNames,
  ...restProps
}, ref) => {
  const [innerChecked, setInnerChecked] = useControlledState(defaultChecked ?? false, checked);
  function triggerChange(newChecked, event) {
    let mergedChecked = innerChecked;
    if (!disabled) {
      mergedChecked = newChecked;
      setInnerChecked(mergedChecked);
      onChange?.(mergedChecked, event);
    }
    return mergedChecked;
  }
  function onInternalKeyDown(e3) {
    if (e3.which === KeyCode_default.LEFT) {
      triggerChange(false, e3);
    } else if (e3.which === KeyCode_default.RIGHT) {
      triggerChange(true, e3);
    }
    onKeyDown2?.(e3);
  }
  function onInternalClick(e3) {
    const ret = triggerChange(!innerChecked, e3);
    onClick?.(ret, e3);
  }
  const switchClassName = clsx(prefixCls, className, {
    [`${prefixCls}-checked`]: innerChecked,
    [`${prefixCls}-disabled`]: disabled
  });
  return React343.createElement("button", _extends58({}, restProps, {
    type: "button",
    role: "switch",
    "aria-checked": innerChecked,
    disabled,
    className: switchClassName,
    ref,
    onKeyDown: onInternalKeyDown,
    onClick: onInternalClick
  }), loadingIcon, React343.createElement("span", {
    className: `${prefixCls}-inner`
  }, React343.createElement("span", {
    className: clsx(`${prefixCls}-inner-checked`, switchClassNames?.content),
    style: styles?.content
  }, checkedChildren), React343.createElement("span", {
    className: clsx(`${prefixCls}-inner-unchecked`, switchClassNames?.content),
    style: styles?.content
  }, unCheckedChildren)));
});
Switch.displayName = "Switch";
var es_default22 = Switch;

// node_modules/antd/es/switch/style/index.js
var genSwitchSmallStyle = (token) => {
  const {
    componentCls,
    trackHeightSM,
    trackPadding,
    trackMinWidthSM,
    innerMinMarginSM,
    innerMaxMarginSM,
    handleSizeSM,
    calc
  } = token;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMarginSM).mul(2).equal());
  return {
    [componentCls]: {
      [`&${componentCls}-small`]: {
        minWidth: trackMinWidthSM,
        height: trackHeightSM,
        lineHeight: unit(trackHeightSM),
        [`${componentCls}-inner`]: {
          paddingInlineStart: innerMaxMarginSM,
          paddingInlineEnd: innerMinMarginSM,
          [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
            minHeight: trackHeightSM
          },
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
            marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: calc(trackHeightSM).mul(-1).equal(),
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${componentCls}-handle`]: {
          width: handleSizeSM,
          height: handleSizeSM
        },
        [`${componentCls}-loading-icon`]: {
          top: calc(calc(handleSizeSM).sub(token.switchLoadingIconSize)).div(2).equal(),
          fontSize: token.switchLoadingIconSize
        },
        [`&${componentCls}-checked`]: {
          [`${componentCls}-inner`]: {
            paddingInlineStart: innerMinMarginSM,
            paddingInlineEnd: innerMaxMarginSM,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
            }
          },
          [`${componentCls}-handle`]: {
            insetInlineStart: `calc(100% - ${unit(calc(handleSizeSM).add(trackPadding).equal())})`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: calc(token.marginXXS).div(2).equal(),
              marginInlineEnd: calc(token.marginXXS).mul(-1).div(2).equal()
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: calc(token.marginXXS).mul(-1).div(2).equal(),
              marginInlineEnd: calc(token.marginXXS).div(2).equal()
            }
          }
        }
      }
    }
  };
};
var genSwitchLoadingStyle = (token) => {
  const {
    componentCls,
    handleSize,
    calc
  } = token;
  return {
    [componentCls]: {
      [`${componentCls}-loading-icon${token.iconCls}`]: {
        position: "relative",
        top: calc(calc(handleSize).sub(token.fontSize)).div(2).equal(),
        color: token.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
        color: token.switchColor
      }
    }
  };
};
var genSwitchHandleStyle = (token) => {
  const {
    componentCls,
    trackPadding,
    handleBg,
    handleShadow,
    handleSize,
    calc
  } = token;
  const switchHandleCls = `${componentCls}-handle`;
  return {
    [componentCls]: {
      [switchHandleCls]: {
        position: "absolute",
        top: trackPadding,
        insetInlineStart: trackPadding,
        width: handleSize,
        height: handleSize,
        transition: `all ${token.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: handleBg,
          borderRadius: calc(handleSize).div(2).equal(),
          boxShadow: handleShadow,
          transition: `all ${token.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${componentCls}-checked ${switchHandleCls}`]: {
        insetInlineStart: `calc(100% - ${unit(calc(handleSize).add(trackPadding).equal())})`
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`${switchHandleCls}::before`]: {
          insetInlineEnd: token.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${componentCls}-checked ${switchHandleCls}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: token.switchHandleActiveInset
        }
      }
    }
  };
};
var genSwitchInnerStyle = (token) => {
  const {
    componentCls,
    trackHeight,
    trackPadding,
    innerMinMargin,
    innerMaxMargin,
    handleSize,
    calc
  } = token;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMargin).mul(2).equal());
  return {
    [componentCls]: {
      [switchInnerCls]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: innerMaxMargin,
        paddingInlineEnd: innerMinMargin,
        transition: `padding-inline-start ${token.switchDuration} ease-in-out, padding-inline-end ${token.switchDuration} ease-in-out`,
        [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
          display: "block",
          color: token.colorTextLightSolid,
          fontSize: token.fontSizeSM,
          transition: `margin-inline-start ${token.switchDuration} ease-in-out, margin-inline-end ${token.switchDuration} ease-in-out`,
          pointerEvents: "none",
          minHeight: trackHeight
        },
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
        },
        [`${switchInnerCls}-unchecked`]: {
          marginTop: calc(trackHeight).mul(-1).equal(),
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${componentCls}-checked ${switchInnerCls}`]: {
        paddingInlineStart: innerMinMargin,
        paddingInlineEnd: innerMaxMargin,
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${switchInnerCls}-unchecked`]: {
          marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
        }
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: calc(trackPadding).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(2).equal()
          }
        }
      }
    }
  };
};
var genSwitchStyle = (token) => {
  const {
    componentCls,
    trackHeight,
    trackMinWidth
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: trackMinWidth,
      height: trackHeight,
      lineHeight: unit(trackHeight),
      verticalAlign: "middle",
      background: token.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${token.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${componentCls}-disabled)`]: {
        background: token.colorTextTertiary
      },
      ...genFocusStyle(token),
      [`&${componentCls}-checked`]: {
        background: token.switchColor,
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token.colorPrimaryHover
        }
      },
      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
        cursor: "not-allowed",
        opacity: token.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken42 = (token) => {
  const {
    fontSize,
    lineHeight,
    controlHeight,
    colorWhite
  } = token;
  const height = fontSize * lineHeight;
  const heightSM = controlHeight / 2;
  const padding = 2;
  const handleSize = height - padding * 2;
  const handleSizeSM = heightSM - padding * 2;
  return {
    trackHeight: height,
    trackHeightSM: heightSM,
    trackMinWidth: handleSize * 2 + padding * 4,
    trackMinWidthSM: handleSizeSM * 2 + padding * 2,
    trackPadding: padding,
    // Fixed value
    handleBg: colorWhite,
    handleSize,
    handleSizeSM,
    handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(0.2).toRgbString()}`,
    innerMinMargin: handleSize / 2,
    innerMaxMargin: handleSize + padding + padding * 2,
    innerMinMarginSM: handleSizeSM / 2,
    innerMaxMarginSM: handleSizeSM + padding + padding * 2
  };
};
var style_default48 = genStyleHooks("Switch", (token) => {
  const switchToken = merge(token, {
    switchDuration: token.motionDurationMid,
    switchColor: token.colorPrimary,
    switchDisabledOpacity: token.opacityLoading,
    switchLoadingIconSize: token.calc(token.fontSizeIcon).mul(0.75).equal(),
    switchLoadingIconColor: `rgba(0, 0, 0, ${token.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    genSwitchStyle(switchToken),
    // inner style
    genSwitchInnerStyle(switchToken),
    // handle style
    genSwitchHandleStyle(switchToken),
    // loading style
    genSwitchLoadingStyle(switchToken),
    // small style
    genSwitchSmallStyle(switchToken)
  ];
}, prepareComponentToken42);

// node_modules/antd/es/switch/index.js
var InternalSwitch = React344.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    loading,
    className,
    rootClassName,
    style,
    checked: checkedProp,
    value,
    defaultChecked: defaultCheckedProp,
    defaultValue,
    onChange,
    styles,
    classNames,
    ...restProps
  } = props;
  const [checked, setChecked] = useControlledState(defaultCheckedProp ?? defaultValue ?? false, checkedProp ?? value);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("switch");
  const disabled = React344.useContext(DisabledContext_default);
  const mergedDisabled = (customDisabled ?? disabled) || loading;
  const prefixCls = getPrefixCls("switch", customizePrefixCls);
  const loadingIcon = React344.createElement("div", {
    className: `${prefixCls}-handle`
  }, loading && React344.createElement(LoadingOutlined_default, {
    className: `${prefixCls}-loading-icon`
  }));
  const [hashId, cssVarCls] = style_default48(prefixCls);
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const classes = clsx(contextClassName, {
    [`${prefixCls}-small`]: mergedSize === "small",
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const changeHandler = (...args) => {
    setChecked(args[0]);
    onChange?.(...args);
  };
  return React344.createElement(wave_default, {
    component: "Switch",
    disabled: mergedDisabled
  }, React344.createElement(es_default22, {
    ...restProps,
    classNames: mergedClassNames,
    styles: mergedStyles,
    checked,
    onChange: changeHandler,
    prefixCls,
    className: classes,
    style: mergedStyle,
    disabled: mergedDisabled,
    ref,
    loadingIcon
  }));
});
var Switch2 = InternalSwitch;
Switch2.__ANT_SWITCH = true;
if (true) {
  Switch2.displayName = "Switch";
}
var switch_default = Switch2;

// node_modules/antd/es/table/Table.js
var React402 = __toESM(require_react());

// node_modules/@rc-component/table/es/constant.js
var EXPAND_COLUMN = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";

// node_modules/@rc-component/context/es/context.js
var React345 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
function createContext29(defaultValue) {
  const Context = React345.createContext(void 0);
  const Provider = ({
    value,
    children
  }) => {
    const valueRef = React345.useRef(value);
    valueRef.current = value;
    const [context] = React345.useState(() => ({
      getValue: () => valueRef.current,
      listeners: /* @__PURE__ */ new Set()
    }));
    useLayoutEffect_default(() => {
      (0, import_react_dom3.unstable_batchedUpdates)(() => {
        context.listeners.forEach((listener) => {
          listener(value);
        });
      });
    }, [value]);
    return React345.createElement(Context.Provider, {
      value: context
    }, children);
  };
  return {
    Context,
    Provider,
    defaultValue
  };
}
function useContext129(holder, selector) {
  const eventSelector = useEvent_default(typeof selector === "function" ? selector : (ctx) => {
    if (selector === void 0) {
      return ctx;
    }
    if (!Array.isArray(selector)) {
      return ctx[selector];
    }
    const obj = {};
    selector.forEach((key) => {
      obj[key] = ctx[key];
    });
    return obj;
  });
  const context = React345.useContext(holder?.Context);
  const {
    listeners,
    getValue
  } = context || {};
  const valueRef = React345.useRef();
  valueRef.current = eventSelector(context ? getValue() : holder?.defaultValue);
  const [, forceUpdate] = React345.useState({});
  useLayoutEffect_default(() => {
    if (!context) {
      return;
    }
    function trigger(nextValue) {
      const nextSelectorValue = eventSelector(nextValue);
      if (!isEqual_default(valueRef.current, nextSelectorValue, true)) {
        forceUpdate({});
      }
    }
    listeners.add(trigger);
    return () => {
      listeners.delete(trigger);
    };
  }, [context]);
  return valueRef.current;
}

// node_modules/@rc-component/context/es/Immutable.js
var React346 = __toESM(require_react());
function _extends59() {
  _extends59 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends59.apply(this, arguments);
}
function createImmutable() {
  const ImmutableContext = React346.createContext(null);
  function useImmutableMark3() {
    return React346.useContext(ImmutableContext);
  }
  function makeImmutable3(Component6, shouldTriggerRender) {
    const refAble = supportRef(Component6);
    const ImmutableComponent = (props, ref) => {
      const refProps = refAble ? {
        ref
      } : {};
      const renderTimesRef = React346.useRef(0);
      const prevProps = React346.useRef(props);
      const mark = useImmutableMark3();
      if (mark !== null) {
        return React346.createElement(Component6, _extends59({}, props, refProps));
      }
      if (
        // Always trigger re-render if `shouldTriggerRender` is not provided
        !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
      ) {
        renderTimesRef.current += 1;
      }
      prevProps.current = props;
      return React346.createElement(ImmutableContext.Provider, {
        value: renderTimesRef.current
      }, React346.createElement(Component6, _extends59({}, props, refProps)));
    };
    if (true) {
      ImmutableComponent.displayName = `ImmutableRoot(${Component6.displayName || Component6.name})`;
    }
    return refAble ? React346.forwardRef(ImmutableComponent) : ImmutableComponent;
  }
  function responseImmutable3(Component6, propsAreEqual) {
    const refAble = supportRef(Component6);
    const ImmutableComponent = (props, ref) => {
      const refProps = refAble ? {
        ref
      } : {};
      useImmutableMark3();
      return React346.createElement(Component6, _extends59({}, props, refProps));
    };
    if (true) {
      ImmutableComponent.displayName = `ImmutableResponse(${Component6.displayName || Component6.name})`;
    }
    return React346.memo(refAble ? React346.forwardRef(ImmutableComponent) : ImmutableComponent, propsAreEqual);
  }
  return {
    makeImmutable: makeImmutable3,
    responseImmutable: responseImmutable3,
    useImmutableMark: useImmutableMark3
  };
}

// node_modules/@rc-component/context/es/index.js
var {
  makeImmutable,
  responseImmutable,
  useImmutableMark
} = createImmutable();

// node_modules/@rc-component/table/es/Footer/index.js
var React354 = __toESM(require_react());

// node_modules/@rc-component/table/es/context/TableContext.js
var {
  makeImmutable: makeImmutable2,
  responseImmutable: responseImmutable2,
  useImmutableMark: useImmutableMark2
} = createImmutable();
var TableContext = createContext29();
var TableContext_default = TableContext;

// node_modules/@rc-component/table/es/hooks/useRenderTimes.js
var React347 = __toESM(require_react());
function useRenderTimes(props, debug) {
  const timesRef = React347.useRef(0);
  timesRef.current += 1;
  const propsRef = React347.useRef(props);
  const keys = [];
  Object.keys(props || {}).map((key) => {
    if (props?.[key] !== propsRef.current?.[key]) {
      keys.push(key);
    }
  });
  propsRef.current = props;
  const keysRef = React347.useRef([]);
  if (keys.length) {
    keysRef.current = keys;
  }
  React347.useDebugValue(timesRef.current);
  React347.useDebugValue(keysRef.current.join(", "));
  if (debug) {
    console.log(`${debug}:`, timesRef.current, keysRef.current);
  }
  return timesRef.current;
}
var useRenderTimes_default = true ? useRenderTimes : () => {
};
var RenderBlock = React347.memo(() => {
  const times = useRenderTimes();
  return React347.createElement("h1", null, "Render Times: ", times);
});
if (true) {
  RenderBlock.displayName = "RenderBlock";
}

// node_modules/@rc-component/table/es/Footer/Cell.js
var React352 = __toESM(require_react());

// node_modules/@rc-component/table/es/Cell/index.js
var React350 = __toESM(require_react());

// node_modules/@rc-component/table/es/Cell/useCellRender.js
var React349 = __toESM(require_react());

// node_modules/@rc-component/table/es/context/PerfContext.js
var React348 = __toESM(require_react());
var PerfContext = React348.createContext({
  renderWithProps: false
});
var PerfContext_default = PerfContext;

// node_modules/@rc-component/table/es/utils/valueUtil.js
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray5(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getColumnsKey(columns) {
  const columnKeys = [];
  const keys = {};
  columns.forEach((column) => {
    const {
      key,
      dataIndex
    } = column || {};
    let mergedKey = key || toArray5(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys[mergedKey]) {
      mergedKey = `${mergedKey}_next`;
    }
    keys[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
function validNumberValue(value) {
  return typeof value === "number" && !Number.isNaN(value);
}

// node_modules/@rc-component/table/es/Cell/useCellRender.js
function isRenderCell(data) {
  return data && typeof data === "object" && !Array.isArray(data) && !React349.isValidElement(data);
}
function useCellRender2(record, dataIndex, renderIndex, children, render2, shouldCellUpdate) {
  const perfRecord = React349.useContext(PerfContext_default);
  const mark = useImmutableMark2();
  const retData = useMemo(() => {
    if (validateValue(children)) {
      return [children];
    }
    const path2 = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
    const value = get(record, path2);
    let returnChildNode = value;
    let returnCellProps = void 0;
    if (render2) {
      const renderData = render2(value, record, renderIndex);
      if (isRenderCell(renderData)) {
        if (true) {
          warning_default(false, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead.");
        }
        returnChildNode = renderData.children;
        returnCellProps = renderData.props;
        perfRecord.renderWithProps = true;
      } else {
        returnChildNode = renderData;
      }
    }
    return [returnChildNode, returnCellProps];
  }, [
    // Force update deps
    mark,
    // Normal deps
    record,
    children,
    dataIndex,
    render2,
    renderIndex
  ], (prev, next) => {
    if (shouldCellUpdate) {
      const [, prevRecord] = prev;
      const [, nextRecord] = next;
      return shouldCellUpdate(nextRecord, prevRecord);
    }
    if (perfRecord.renderWithProps) {
      return true;
    }
    return !isEqual_default(prev, next, true);
  });
  return retData;
}

// node_modules/@rc-component/table/es/Cell/useHoverState.js
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  const cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function useHoverState(rowIndex, rowSpan) {
  return useContext129(TableContext_default, (ctx) => {
    const hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
    return [hovering, ctx.onHover];
  });
}

// node_modules/@rc-component/table/es/Cell/index.js
function _extends60() {
  _extends60 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends60.apply(this, arguments);
}
var getTitleFromCellRenderChildren = ({
  ellipsis,
  rowType,
  children
}) => {
  let title;
  const ellipsisConfig = ellipsis === true ? {
    showTitle: true
  } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
    if (typeof children === "string" || typeof children === "number") {
      title = children.toString();
    } else if (React350.isValidElement(children) && typeof children.props?.children === "string") {
      title = children.props?.children;
    }
  }
  return title;
};
var Cell2 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    component: Component6,
    children,
    ellipsis,
    scope,
    // Style
    prefixCls,
    className,
    style,
    align,
    // Value
    record,
    render: render2,
    dataIndex,
    renderIndex,
    shouldCellUpdate,
    // Row
    index: index2,
    rowType,
    // Span
    colSpan,
    rowSpan,
    // Fixed
    fixStart,
    fixEnd,
    fixedStartShadow,
    fixedEndShadow,
    offsetFixedStartShadow,
    offsetFixedEndShadow,
    zIndex,
    zIndexReverse,
    // Private
    appendNode,
    additionalProps = {},
    isSticky
  } = props;
  const cellPrefixCls = `${prefixCls}-cell`;
  const {
    allColumnsFixedLeft,
    rowHoverable
  } = useContext129(TableContext_default, ["allColumnsFixedLeft", "rowHoverable"]);
  const [childNode, legacyCellProps] = useCellRender2(record, dataIndex, renderIndex, children, render2, shouldCellUpdate);
  const fixedStyle2 = {};
  const isFixStart = typeof fixStart === "number" && !allColumnsFixedLeft;
  const isFixEnd = typeof fixEnd === "number" && !allColumnsFixedLeft;
  const [showFixStartShadow, showFixEndShadow] = useContext129(TableContext_default, ({
    scrollInfo
  }) => {
    if (!isFixStart && !isFixEnd) {
      return [false, false];
    }
    const [absScroll, scrollWidth] = scrollInfo;
    const showStartShadow = (isFixStart && fixedStartShadow && absScroll) - // For precision, we not show shadow by default which has better user experience.
    offsetFixedStartShadow >= 1;
    const showEndShadow = (isFixEnd && fixedEndShadow && scrollWidth - absScroll) - // Same as above
    offsetFixedEndShadow > 1;
    return [showStartShadow, showEndShadow];
  });
  if (isFixStart) {
    fixedStyle2.insetInlineStart = fixStart;
    fixedStyle2["--z-offset"] = zIndex;
    fixedStyle2["--z-offset-reverse"] = zIndexReverse;
  }
  if (isFixEnd) {
    fixedStyle2.insetInlineEnd = fixEnd;
    fixedStyle2["--z-offset"] = zIndex;
    fixedStyle2["--z-offset-reverse"] = zIndexReverse;
  }
  const mergedColSpan = legacyCellProps?.colSpan ?? additionalProps.colSpan ?? colSpan ?? 1;
  const mergedRowSpan = legacyCellProps?.rowSpan ?? additionalProps.rowSpan ?? rowSpan ?? 1;
  const [hovering, onHover] = useHoverState(index2, mergedRowSpan);
  const onMouseEnter = useEvent_default((event) => {
    if (record) {
      onHover(index2, index2 + mergedRowSpan - 1);
    }
    additionalProps?.onMouseEnter?.(event);
  });
  const onMouseLeave = useEvent_default((event) => {
    if (record) {
      onHover(-1, -1);
    }
    additionalProps?.onMouseLeave?.(event);
  });
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  }
  const title = additionalProps.title ?? getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  });
  const mergedClassName = clsx(cellPrefixCls, className, {
    // Fixed
    [`${cellPrefixCls}-fix`]: isFixStart || isFixEnd,
    [`${cellPrefixCls}-fix-start`]: isFixStart,
    [`${cellPrefixCls}-fix-end`]: isFixEnd,
    // Fixed shadow
    [`${cellPrefixCls}-fix-start-shadow`]: fixedStartShadow,
    [`${cellPrefixCls}-fix-start-shadow-show`]: fixedStartShadow && showFixStartShadow,
    [`${cellPrefixCls}-fix-end-shadow`]: fixedEndShadow,
    [`${cellPrefixCls}-fix-end-shadow-show`]: fixedEndShadow && showFixEndShadow,
    [`${cellPrefixCls}-ellipsis`]: ellipsis,
    [`${cellPrefixCls}-with-append`]: appendNode,
    [`${cellPrefixCls}-fix-sticky`]: (isFixStart || isFixEnd) && isSticky,
    [`${cellPrefixCls}-row-hover`]: !legacyCellProps && hovering
  }, additionalProps.className, legacyCellProps?.className);
  const alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  }
  const mergedStyle = {
    ...legacyCellProps?.style,
    ...fixedStyle2,
    ...alignStyle,
    ...additionalProps.style,
    ...style
  };
  let mergedChildNode = childNode;
  if (typeof mergedChildNode === "object" && !Array.isArray(mergedChildNode) && !React350.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (fixedStartShadow || fixedEndShadow)) {
    mergedChildNode = React350.createElement("span", {
      className: `${cellPrefixCls}-content`
    }, mergedChildNode);
  }
  return React350.createElement(Component6, _extends60({}, legacyCellProps, additionalProps, {
    className: mergedClassName,
    style: mergedStyle,
    title,
    scope,
    onMouseEnter: rowHoverable ? onMouseEnter : void 0,
    onMouseLeave: rowHoverable ? onMouseLeave : void 0,
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
  }), appendNode, mergedChildNode);
};
var Cell_default2 = React350.memo(Cell2);

// node_modules/@rc-component/table/es/utils/fixUtil.js
function isFixedStart(column) {
  return column.fixed === "start";
}
function isFixedEnd(column) {
  return column.fixed === "end";
}
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets) {
  const startColumn = columns[colStart] || {};
  const endColumn = columns[colEnd] || {};
  let fixStart = null;
  let fixEnd = null;
  if (isFixedStart(startColumn) && isFixedStart(endColumn)) {
    fixStart = stickyOffsets.start[colStart];
  } else if (isFixedEnd(endColumn) && isFixedEnd(startColumn)) {
    fixEnd = stickyOffsets.end[colEnd];
  }
  let fixedStartShadow = false;
  let fixedEndShadow = false;
  let zIndex = 0;
  let zIndexReverse = 0;
  if (fixStart !== null) {
    fixedStartShadow = !columns[colEnd + 1] || !isFixedStart(columns[colEnd + 1]);
    zIndex = columns.length * 2 - colStart;
    zIndexReverse = columns.length + colStart;
  }
  if (fixEnd !== null) {
    fixedEndShadow = !columns[colStart - 1] || !isFixedEnd(columns[colStart - 1]);
    zIndex = colEnd;
    zIndexReverse = columns.length - colEnd;
  }
  let offsetFixedStartShadow = 0;
  let offsetFixedEndShadow = 0;
  if (fixedStartShadow) {
    for (let i = 0; i < colStart; i += 1) {
      if (!isFixedStart(columns[i])) {
        offsetFixedStartShadow += stickyOffsets.widths[i] || 0;
      }
    }
  }
  if (fixedEndShadow) {
    for (let i = columns.length - 1; i > colEnd; i -= 1) {
      if (!isFixedEnd(columns[i])) {
        offsetFixedEndShadow += stickyOffsets.widths[i] || 0;
      }
    }
  }
  return {
    fixStart,
    fixEnd,
    fixedStartShadow,
    fixedEndShadow,
    offsetFixedStartShadow,
    offsetFixedEndShadow,
    isSticky: stickyOffsets.isSticky,
    zIndex,
    zIndexReverse
  };
}

// node_modules/@rc-component/table/es/Footer/SummaryContext.js
var React351 = __toESM(require_react());
var SummaryContext = React351.createContext({});
var SummaryContext_default = SummaryContext;

// node_modules/@rc-component/table/es/Footer/Cell.js
function _extends61() {
  _extends61 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends61.apply(this, arguments);
}
var SummaryCell = (props) => {
  const {
    className,
    index: index2,
    children,
    colSpan = 1,
    rowSpan,
    align
  } = props;
  const {
    prefixCls
  } = useContext129(TableContext_default, ["prefixCls"]);
  const {
    scrollColumnIndex,
    stickyOffsets,
    flattenColumns
  } = React352.useContext(SummaryContext_default);
  const lastIndex = index2 + colSpan - 1;
  const mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  const fixedInfo = React352.useMemo(() => getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets), [index2, mergedColSpan, flattenColumns, stickyOffsets]);
  return React352.createElement(Cell_default2, _extends61({
    className,
    index: index2,
    component: "td",
    prefixCls,
    record: null,
    dataIndex: null,
    align,
    colSpan: mergedColSpan,
    rowSpan,
    render: () => children
  }, fixedInfo));
};
var Cell_default3 = SummaryCell;

// node_modules/@rc-component/table/es/Footer/Row.js
var React353 = __toESM(require_react());
var FooterRow = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return React353.createElement("tr", restProps, children);
};
var Row_default2 = FooterRow;

// node_modules/@rc-component/table/es/Footer/Summary.js
var Summary = (props) => {
  const {
    children
  } = props;
  return children;
};
Summary.Row = Row_default2;
Summary.Cell = Cell_default3;
var Summary_default = Summary;

// node_modules/@rc-component/table/es/Footer/index.js
var Footer5 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    children,
    stickyOffsets,
    flattenColumns
  } = props;
  const prefixCls = useContext129(TableContext_default, "prefixCls");
  const lastColumnIndex = flattenColumns.length - 1;
  const scrollColumn = flattenColumns[lastColumnIndex];
  const summaryContext = React354.useMemo(() => ({
    stickyOffsets,
    flattenColumns,
    scrollColumnIndex: scrollColumn?.scrollbar ? lastColumnIndex : null
  }), [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return React354.createElement(SummaryContext_default.Provider, {
    value: summaryContext
  }, React354.createElement("tfoot", {
    className: `${prefixCls}-summary`
  }, children));
};
var Footer_default = responseImmutable2(Footer5);
var FooterComponents = Summary_default;

// node_modules/@rc-component/table/es/sugar/Column.js
function Column2(_) {
  return null;
}
var Column_default = Column2;

// node_modules/@rc-component/table/es/sugar/ColumnGroup.js
function ColumnGroup(_) {
  return null;
}
var ColumnGroup_default = ColumnGroup;

// node_modules/@rc-component/table/es/Table.js
var React374 = __toESM(require_react());

// node_modules/@rc-component/table/es/Body/index.js
var React361 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useFlattenRecords.js
var React355 = __toESM(require_react());
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  const key = getRowKey(record, index2);
  list.push({
    record,
    indent,
    index: index2,
    rowKey: key
  });
  const expanded = expandedKeys?.has(key);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (let i = 0; i < record[childrenColumnName].length; i += 1) {
      fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
    }
  }
}
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
  const arr = React355.useMemo(() => {
    if (expandedKeys?.size) {
      const list = [];
      for (let i = 0; i < data?.length; i += 1) {
        const record = data[i];
        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
      }
      return list;
    }
    return data?.map((item, index2) => {
      return {
        record: item,
        indent: 0,
        index: index2,
        rowKey: getRowKey(item, index2)
      };
    });
  }, [data, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}

// node_modules/@rc-component/table/es/Body/BodyRow.js
var React358 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useRowInfo.js
function useRowInfo(record, rowKey, recordIndex, indent) {
  const context = useContext129(TableContext_default, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex", "expandedKeys", "childrenColumnName", "rowExpandable", "onRow"]);
  const {
    flattenColumns,
    expandableType,
    expandedKeys,
    childrenColumnName,
    onTriggerExpand,
    rowExpandable,
    onRow,
    expandRowByClick,
    rowClassName
  } = context;
  const nestExpandable = expandableType === "nest";
  const rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
  const mergedExpandable = rowSupportExpand || nestExpandable;
  const expanded = expandedKeys && expandedKeys.has(rowKey);
  const hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  const onInternalTriggerExpand = useEvent_default(onTriggerExpand);
  const rowProps = onRow?.(record, recordIndex);
  const onRowClick = rowProps?.onClick;
  const onClick = (event, ...args) => {
    if (expandRowByClick && mergedExpandable) {
      onTriggerExpand(record, event);
    }
    onRowClick?.(event, ...args);
  };
  let computeRowClassName;
  if (typeof rowClassName === "string") {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === "function") {
    computeRowClassName = rowClassName(record, recordIndex, indent);
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return {
    ...context,
    columnsKey,
    nestExpandable,
    expanded,
    hasNestChildren,
    record,
    onTriggerExpand: onInternalTriggerExpand,
    rowSupportExpand,
    expandable: mergedExpandable,
    rowProps: {
      ...rowProps,
      className: clsx(computeRowClassName, rowProps?.className),
      onClick
    }
  };
}

// node_modules/@rc-component/table/es/Body/ExpandedRow.js
var React356 = __toESM(require_react());
var ExpandedRow = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    prefixCls,
    children,
    component: Component6,
    cellComponent,
    className,
    expanded,
    colSpan,
    isEmpty,
    stickyOffset = 0
  } = props;
  const {
    scrollbarSize,
    fixHeader,
    fixColumn,
    componentWidth,
    horizonScroll
  } = useContext129(TableContext_default, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]);
  let contentNode = children;
  if (isEmpty ? horizonScroll && componentWidth : fixColumn) {
    contentNode = React356.createElement("div", {
      style: {
        width: componentWidth - stickyOffset - (fixHeader && !isEmpty ? scrollbarSize : 0),
        position: "sticky",
        left: stickyOffset,
        overflow: "hidden"
      },
      className: `${prefixCls}-expanded-row-fixed`
    }, contentNode);
  }
  return React356.createElement(Component6, {
    className,
    style: {
      display: expanded ? null : "none"
    }
  }, React356.createElement(Cell_default2, {
    component: cellComponent,
    prefixCls,
    colSpan
  }, contentNode));
};
var ExpandedRow_default = ExpandedRow;

// node_modules/@rc-component/table/es/utils/expandUtil.js
var React357 = __toESM(require_react());
function renderExpandIcon({
  prefixCls,
  record,
  onExpand,
  expanded,
  expandable
}) {
  const expandClassName = `${prefixCls}-row-expand-icon`;
  if (!expandable) {
    return React357.createElement("span", {
      className: clsx(expandClassName, `${prefixCls}-row-spaced`)
    });
  }
  const onClick = (event) => {
    onExpand(record, event);
    event.stopPropagation();
  };
  return React357.createElement("span", {
    className: clsx(expandClassName, {
      [`${prefixCls}-row-expanded`]: expanded,
      [`${prefixCls}-row-collapsed`]: !expanded
    }),
    onClick
  });
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  const keys = [];
  function dig(list) {
    (list || []).forEach((item, index2) => {
      keys.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data);
  return keys;
}
function computedExpandedClassName(cls, record, index2, indent) {
  if (typeof cls === "string") {
    return cls;
  }
  if (typeof cls === "function") {
    return cls(record, index2, indent);
  }
  return "";
}

// node_modules/@rc-component/table/es/Body/BodyRow.js
function _extends62() {
  _extends62 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends62.apply(this, arguments);
}
function getCellProps(rowInfo, column, colIndex, indent, index2, rowKeys = [], expandedRowOffset = 0) {
  const {
    record,
    prefixCls,
    columnsKey,
    fixedInfoList,
    expandIconColumnIndex,
    nestExpandable,
    indentSize,
    expandIcon,
    expanded,
    hasNestChildren,
    onTriggerExpand,
    expandable,
    expandedKeys
  } = rowInfo;
  const key = columnsKey[colIndex];
  const fixedInfo = fixedInfoList[colIndex];
  let appendCellNode;
  if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
    appendCellNode = React358.createElement(React358.Fragment, null, React358.createElement("span", {
      style: {
        paddingLeft: `${indentSize * indent}px`
      },
      className: `${prefixCls}-row-indent indent-level-${indent}`
    }), expandIcon({
      prefixCls,
      expanded,
      expandable: hasNestChildren,
      record,
      onExpand: onTriggerExpand
    }));
  }
  const additionalCellProps = column.onCell?.(record, index2) || {};
  if (expandedRowOffset) {
    const {
      rowSpan = 1
    } = additionalCellProps;
    if (expandable && rowSpan && colIndex < expandedRowOffset) {
      let currentRowSpan = rowSpan;
      for (let i = index2; i < index2 + rowSpan; i += 1) {
        const rowKey = rowKeys[i];
        if (expandedKeys.has(rowKey)) {
          currentRowSpan += 1;
        }
      }
      additionalCellProps.rowSpan = currentRowSpan;
    }
  }
  return {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps
  };
}
var BodyRow = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    style,
    classNames,
    styles,
    record,
    index: index2,
    renderIndex,
    rowKey,
    rowKeys,
    indent = 0,
    rowComponent: RowComponent,
    cellComponent,
    scopeCellComponent,
    expandedRowInfo
  } = props;
  const rowInfo = useRowInfo(record, rowKey, index2, indent);
  const {
    prefixCls,
    flattenColumns,
    expandedRowClassName,
    expandedRowRender,
    rowProps,
    // Misc
    expanded,
    rowSupportExpand
  } = rowInfo;
  const expandedRef = React358.useRef(false);
  expandedRef.current ||= expanded;
  if (true) {
    useRenderTimes_default(props);
  }
  const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent);
  const baseRowNode = React358.createElement(RowComponent, _extends62({}, rowProps, {
    "data-row-key": rowKey,
    className: clsx(className, `${prefixCls}-row`, `${prefixCls}-row-level-${indent}`, rowProps?.className, classNames.row, {
      [expandedClsName]: indent >= 1
    }),
    style: {
      ...style,
      ...rowProps?.style,
      ...styles.row
    }
  }), flattenColumns.map((column, colIndex) => {
    const {
      render: render2,
      dataIndex,
      className: columnClassName
    } = column;
    const {
      key,
      fixedInfo,
      appendCellNode,
      additionalCellProps
    } = getCellProps(rowInfo, column, colIndex, indent, index2, rowKeys, expandedRowInfo?.offset);
    return React358.createElement(Cell_default2, _extends62({
      className: clsx(columnClassName, classNames.cell),
      style: styles.cell,
      ellipsis: column.ellipsis,
      align: column.align,
      scope: column.rowScope,
      component: column.rowScope ? scopeCellComponent : cellComponent,
      prefixCls,
      key,
      record,
      index: index2,
      renderIndex,
      dataIndex,
      render: render2,
      shouldCellUpdate: column.shouldCellUpdate
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: additionalCellProps
    }));
  }));
  let expandRowNode;
  if (rowSupportExpand && (expandedRef.current || expanded)) {
    const expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    expandRowNode = React358.createElement(ExpandedRow_default, {
      expanded,
      className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName),
      prefixCls,
      component: RowComponent,
      cellComponent,
      colSpan: expandedRowInfo ? expandedRowInfo.colSpan : flattenColumns.length,
      isEmpty: false,
      stickyOffset: expandedRowInfo?.sticky
    }, expandContent);
  }
  return React358.createElement(React358.Fragment, null, baseRowNode, expandRowNode);
};
if (true) {
  BodyRow.displayName = "BodyRow";
}
var BodyRow_default = responseImmutable2(BodyRow);

// node_modules/@rc-component/table/es/Body/MeasureRow.js
var React360 = __toESM(require_react());

// node_modules/@rc-component/table/es/Body/MeasureCell.js
var React359 = __toESM(require_react());
var MeasureCell = (props) => {
  const {
    columnKey,
    onColumnResize,
    title
  } = props;
  const cellRef = React359.useRef(null);
  useLayoutEffect_default(() => {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return React359.createElement(es_default3, {
    data: columnKey
  }, React359.createElement("td", {
    ref: cellRef,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      borderTop: 0,
      borderBottom: 0,
      height: 0
    }
  }, React359.createElement("div", {
    style: {
      height: 0,
      overflow: "hidden",
      fontWeight: "bold"
    }
  }, title || "")));
};
var MeasureCell_default = MeasureCell;

// node_modules/@rc-component/table/es/Body/MeasureRow.js
var MeasureRow = ({
  prefixCls,
  columnsKey,
  onColumnResize,
  columns
}) => {
  const ref = React360.useRef(null);
  const {
    measureRowRender
  } = useContext129(TableContext_default, ["measureRowRender"]);
  const measureRow = React360.createElement("tr", {
    "aria-hidden": "true",
    className: `${prefixCls}-measure-row`,
    style: {
      height: 0
    },
    ref
  }, React360.createElement(es_default3.Collection, {
    onBatchResize: (infoList) => {
      if (isVisible_default(ref.current)) {
        infoList.forEach(({
          data: columnKey,
          size
        }) => {
          onColumnResize(columnKey, size.offsetWidth);
        });
      }
    }
  }, columnsKey.map((columnKey) => {
    const column = columns.find((col) => col.key === columnKey);
    const rawTitle = column?.title;
    const titleForMeasure = React360.isValidElement(rawTitle) ? React360.cloneElement(rawTitle, {
      ref: null
    }) : rawTitle;
    return React360.createElement(MeasureCell_default, {
      key: columnKey,
      columnKey,
      onColumnResize,
      title: titleForMeasure
    });
  })));
  return typeof measureRowRender === "function" ? measureRowRender(measureRow) : measureRow;
};
var MeasureRow_default = MeasureRow;

// node_modules/@rc-component/table/es/Body/index.js
var Body = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    data,
    measureColumnWidth
  } = props;
  const {
    prefixCls,
    getComponent,
    onColumnResize,
    flattenColumns,
    getRowKey,
    expandedKeys,
    childrenColumnName,
    emptyNode,
    classNames,
    styles,
    expandedRowOffset = 0,
    colWidths
  } = useContext129(TableContext_default, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns", "getRowKey", "expandedKeys", "childrenColumnName", "emptyNode", "classNames", "styles", "expandedRowOffset", "fixedInfoList", "colWidths"]);
  const {
    body: bodyCls = {}
  } = classNames || {};
  const {
    body: bodyStyles = {}
  } = styles || {};
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const rowKeys = React361.useMemo(() => flattenData2.map((item) => item.rowKey), [flattenData2]);
  const perfRef = React361.useRef({
    renderWithProps: false
  });
  const expandedRowInfo = React361.useMemo(() => {
    const expandedColSpan = flattenColumns.length - expandedRowOffset;
    let expandedStickyStart = 0;
    for (let i = 0; i < expandedRowOffset; i += 1) {
      expandedStickyStart += colWidths[i] || 0;
    }
    return {
      offset: expandedRowOffset,
      colSpan: expandedColSpan,
      sticky: expandedStickyStart
    };
  }, [flattenColumns.length, expandedRowOffset, colWidths]);
  const WrapperComponent = getComponent(["body", "wrapper"], "tbody");
  const trComponent = getComponent(["body", "row"], "tr");
  const tdComponent = getComponent(["body", "cell"], "td");
  const thComponent = getComponent(["body", "cell"], "th");
  let rows;
  if (data.length) {
    rows = flattenData2.map((item, idx) => {
      const {
        record,
        indent,
        index: renderIndex,
        rowKey
      } = item;
      return React361.createElement(BodyRow_default, {
        classNames: bodyCls,
        styles: bodyStyles,
        key: rowKey,
        rowKey,
        rowKeys,
        record,
        index: idx,
        renderIndex,
        rowComponent: trComponent,
        cellComponent: tdComponent,
        scopeCellComponent: thComponent,
        indent,
        expandedRowInfo
      });
    });
  } else {
    rows = React361.createElement(ExpandedRow_default, {
      expanded: true,
      className: `${prefixCls}-placeholder`,
      prefixCls,
      component: trComponent,
      cellComponent: tdComponent,
      colSpan: flattenColumns.length,
      isEmpty: true
    }, emptyNode);
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return React361.createElement(PerfContext_default.Provider, {
    value: perfRef.current
  }, React361.createElement(WrapperComponent, {
    style: bodyStyles.wrapper,
    className: clsx(`${prefixCls}-tbody`, bodyCls.wrapper)
  }, measureColumnWidth && React361.createElement(MeasureRow_default, {
    prefixCls,
    columnsKey,
    onColumnResize,
    columns: flattenColumns
  }), rows));
};
if (true) {
  Body.displayName = "Body";
}
var Body_default = responseImmutable2(Body);

// node_modules/@rc-component/table/es/ColGroup.js
var React362 = __toESM(require_react());

// node_modules/@rc-component/table/es/utils/legacyUtil.js
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  const {
    expandable,
    ...legacyExpandableConfig
  } = props;
  let config;
  if ("expandable" in props) {
    config = {
      ...legacyExpandableConfig,
      ...expandable
    };
  } else {
    if (["indentSize", "expandedRowKeys", "defaultExpandedRowKeys", "defaultExpandAllRows", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "expandedRowClassName", "expandIconColumnIndex", "showExpandColumn", "title"].some((prop) => prop in props)) {
      warning_default(false, "expanded related props have been moved into `expandable`.");
    }
    config = legacyExpandableConfig;
  }
  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }
  return config;
}

// node_modules/@rc-component/table/es/ColGroup.js
function _extends63() {
  _extends63 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends63.apply(this, arguments);
}
var ColGroup = (props) => {
  const {
    colWidths,
    columns,
    columCount
  } = props;
  const {
    tableLayout
  } = useContext129(TableContext_default, ["tableLayout"]);
  const cols = [];
  const len = columCount || columns.length;
  let mustInsert = false;
  for (let i = len - 1; i >= 0; i -= 1) {
    const width = colWidths[i];
    const column = columns && columns[i];
    let additionalProps;
    let minWidth;
    if (column) {
      additionalProps = column[INTERNAL_COL_DEFINE];
      if (tableLayout === "auto") {
        minWidth = column.minWidth;
      }
    }
    if (width || minWidth || additionalProps || mustInsert) {
      const {
        columnType,
        ...restAdditionalProps
      } = additionalProps || {};
      cols.unshift(React362.createElement("col", _extends63({
        key: i,
        style: {
          width,
          minWidth
        }
      }, restAdditionalProps)));
      mustInsert = true;
    }
  }
  return cols.length > 0 ? React362.createElement("colgroup", null, cols) : null;
};
var ColGroup_default = ColGroup;

// node_modules/@rc-component/table/es/FixedHolder/index.js
var React363 = __toESM(require_react());
var import_react116 = __toESM(require_react());
function useColumnWidth(colWidths, columCount) {
  return (0, import_react116.useMemo)(() => {
    const cloneColumns = [];
    for (let i = 0; i < columCount; i += 1) {
      const val = colWidths[i];
      if (val !== void 0) {
        cloneColumns[i] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
var FixedHolder = React363.forwardRef((props, ref) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    style,
    noData,
    columns,
    flattenColumns,
    colWidths,
    colGroup,
    columCount,
    stickyOffsets,
    direction,
    fixHeader,
    stickyTopOffset,
    stickyBottomOffset,
    stickyClassName,
    scrollX,
    tableLayout = "fixed",
    onScroll,
    maxContentScroll,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    scrollbarSize,
    isSticky,
    getComponent
  } = useContext129(TableContext_default, ["prefixCls", "scrollbarSize", "isSticky", "getComponent"]);
  const TableComponent = getComponent(["header", "table"], "table");
  const combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
  const scrollRef = React363.useRef(null);
  const setScrollRef = React363.useCallback((element) => {
    fillRef(ref, element);
    fillRef(scrollRef, element);
  }, []);
  React363.useEffect(() => {
    function onWheel(e3) {
      const {
        currentTarget,
        deltaX
      } = e3;
      if (deltaX) {
        const {
          scrollLeft,
          scrollWidth,
          clientWidth
        } = currentTarget;
        const maxScrollWidth = scrollWidth - clientWidth;
        let nextScroll = scrollLeft + deltaX;
        if (direction === "rtl") {
          nextScroll = Math.max(-maxScrollWidth, nextScroll);
          nextScroll = Math.min(0, nextScroll);
        } else {
          nextScroll = Math.min(maxScrollWidth, nextScroll);
          nextScroll = Math.max(0, nextScroll);
        }
        onScroll({
          currentTarget,
          scrollLeft: nextScroll
        });
        e3.preventDefault();
      }
    }
    const scrollEle = scrollRef.current;
    scrollEle?.addEventListener("wheel", onWheel, {
      passive: false
    });
    return () => {
      scrollEle?.removeEventListener("wheel", onWheel);
    };
  }, []);
  const lastColumn = flattenColumns[flattenColumns.length - 1];
  const ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: () => ({
      className: `${prefixCls}-cell-scrollbar`
    })
  };
  const columnsWithScrollbar = (0, import_react116.useMemo)(() => combinationScrollBarSize ? [...columns, ScrollBarColumn] : columns, [combinationScrollBarSize, columns]);
  const flattenColumnsWithScrollbar = (0, import_react116.useMemo)(() => combinationScrollBarSize ? [...flattenColumns, ScrollBarColumn] : flattenColumns, [combinationScrollBarSize, flattenColumns]);
  const headerStickyOffsets = (0, import_react116.useMemo)(() => {
    const {
      start,
      end
    } = stickyOffsets;
    return {
      ...stickyOffsets,
      // left:
      //   direction === 'rtl' ? [...left.map(width => width + combinationScrollBarSize), 0] : left,
      // right:
      //   direction === 'rtl' ? right : [...right.map(width => width + combinationScrollBarSize), 0],
      start,
      end: [...end.map((width) => width + combinationScrollBarSize), 0],
      isSticky
    };
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  const mergedColumnWidth = useColumnWidth(colWidths, columCount);
  const isColGroupEmpty = (0, import_react116.useMemo)(() => {
    const noWidth = !mergedColumnWidth || !mergedColumnWidth.length || mergedColumnWidth.every((w) => !w);
    return noData || noWidth;
  }, [noData, mergedColumnWidth]);
  return React363.createElement("div", {
    style: {
      overflow: "hidden",
      ...isSticky ? {
        top: stickyTopOffset,
        bottom: stickyBottomOffset
      } : {},
      ...style
    },
    ref: setScrollRef,
    className: clsx(className, {
      [stickyClassName]: !!stickyClassName
    })
  }, React363.createElement(TableComponent, {
    style: {
      tableLayout,
      minWidth: "100%",
      // https://github.com/ant-design/ant-design/issues/54894
      width: scrollX
    }
  }, isColGroupEmpty ? colGroup : React363.createElement(ColGroup_default, {
    colWidths: [...mergedColumnWidth, combinationScrollBarSize],
    columCount: columCount + 1,
    columns: flattenColumnsWithScrollbar
  }), children({
    ...restProps,
    stickyOffsets: headerStickyOffsets,
    columns: columnsWithScrollbar,
    flattenColumns: flattenColumnsWithScrollbar
  })));
});
if (true) {
  FixedHolder.displayName = "FixedHolder";
}
var FixedHolder_default = React363.memo(FixedHolder);

// node_modules/@rc-component/table/es/Header/Header.js
var React365 = __toESM(require_react());

// node_modules/@rc-component/table/es/Header/HeaderRow.js
var React364 = __toESM(require_react());
function _extends64() {
  _extends64 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends64.apply(this, arguments);
}
var HeaderRow = (props) => {
  const {
    cells,
    stickyOffsets,
    flattenColumns,
    rowComponent: RowComponent,
    cellComponent: CellComponent,
    onHeaderRow,
    index: index2,
    classNames,
    styles
  } = props;
  const {
    prefixCls
  } = useContext129(TableContext_default, ["prefixCls"]);
  let rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(cells.map((cell) => cell.column), index2);
  }
  const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
  return React364.createElement(RowComponent, _extends64({}, rowProps, {
    className: classNames.row,
    style: styles.row
  }), cells.map((cell, cellIndex) => {
    const {
      column,
      colStart,
      colEnd,
      colSpan
    } = cell;
    const fixedInfo = getCellFixedInfo(colStart, colEnd, flattenColumns, stickyOffsets);
    const additionalProps = column?.onHeaderCell?.(column) || {};
    return React364.createElement(Cell_default2, _extends64({}, cell, {
      scope: column.title ? colSpan > 1 ? "colgroup" : "col" : null,
      ellipsis: column.ellipsis,
      align: column.align,
      component: CellComponent,
      prefixCls,
      key: columnsKey[cellIndex]
    }, fixedInfo, {
      additionalProps,
      rowType: "header"
    }));
  }));
};
if (true) {
  HeaderRow.displayName = "HeaderRow";
}
var HeaderRow_default = HeaderRow;

// node_modules/@rc-component/table/es/Header/Header.js
function parseHeaderRows(rootColumns, classNames, styles) {
  const rows = [];
  function fillRowCells(columns, colIndex, rowIndex = 0) {
    rows[rowIndex] = rows[rowIndex] || [];
    let currentColIndex = colIndex;
    const colSpans = columns.filter(Boolean).map((column) => {
      const cell = {
        key: column.key,
        className: clsx(column.className, classNames.cell) || "",
        style: styles.cell,
        children: column.title,
        column,
        colStart: currentColIndex
      };
      let colSpan = 1;
      const subColumns = column.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total, count) => total + count, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column) {
        ({
          colSpan
        } = column);
      }
      if ("rowSpan" in column) {
        cell.rowSpan = column.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  const rowCount = rows.length;
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    rows[rowIndex].forEach((cell) => {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  }
  return rows;
}
var Header2 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    stickyOffsets,
    columns,
    flattenColumns,
    onHeaderRow
  } = props;
  const {
    prefixCls,
    getComponent,
    classNames,
    styles
  } = useContext129(TableContext_default, ["prefixCls", "getComponent", "classNames", "styles"]);
  const {
    header: headerCls = {}
  } = classNames || {};
  const {
    header: headerStyles = {}
  } = styles || {};
  const rows = React365.useMemo(() => parseHeaderRows(columns, headerCls, headerStyles), [columns, headerCls, headerStyles]);
  const WrapperComponent = getComponent(["header", "wrapper"], "thead");
  const trComponent = getComponent(["header", "row"], "tr");
  const thComponent = getComponent(["header", "cell"], "th");
  return React365.createElement(WrapperComponent, {
    className: clsx(`${prefixCls}-thead`, headerCls.wrapper),
    style: headerStyles.wrapper
  }, rows.map((row, rowIndex) => {
    const rowNode = React365.createElement(HeaderRow_default, {
      classNames: headerCls,
      styles: headerStyles,
      key: rowIndex,
      flattenColumns,
      cells: row,
      stickyOffsets,
      rowComponent: trComponent,
      cellComponent: thComponent,
      onHeaderRow,
      index: rowIndex
    });
    return rowNode;
  }));
};
var Header_default2 = responseImmutable2(Header2);

// node_modules/@rc-component/table/es/hooks/useColumns/index.js
var React367 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useColumns/useWidthColumns.js
var React366 = __toESM(require_react());
function parseColWidth(totalWidth, width = "") {
  if (typeof width === "number") {
    return width;
  }
  if (width.endsWith("%")) {
    return totalWidth * parseFloat(width) / 100;
  }
  return null;
}
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
  return React366.useMemo(() => {
    if (scrollWidth && scrollWidth > 0) {
      let totalWidth = 0;
      let missWidthCount = 0;
      flattenColumns.forEach((col) => {
        const colWidth = parseColWidth(scrollWidth, col.width);
        if (colWidth) {
          totalWidth += colWidth;
        } else {
          missWidthCount += 1;
        }
      });
      const maxFitWidth = Math.max(scrollWidth, clientWidth);
      let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
      let restCount = missWidthCount;
      const avgWidth = restWidth / missWidthCount;
      let realTotal = 0;
      const filledColumns = flattenColumns.map((col) => {
        const clone = {
          ...col
        };
        const colWidth = parseColWidth(scrollWidth, clone.width);
        if (colWidth) {
          clone.width = colWidth;
        } else {
          const colAvgWidth = Math.floor(avgWidth);
          clone.width = restCount === 1 ? restWidth : colAvgWidth;
          restWidth -= colAvgWidth;
          restCount -= 1;
        }
        realTotal += clone.width;
        return clone;
      });
      if (realTotal < maxFitWidth) {
        const scale = maxFitWidth / realTotal;
        restWidth = maxFitWidth;
        filledColumns.forEach((col, index2) => {
          const colWidth = Math.floor(col.width * scale);
          col.width = index2 === filledColumns.length - 1 ? restWidth : colWidth;
          restWidth -= colWidth;
        });
      }
      return [filledColumns, Math.max(realTotal, maxFitWidth)];
    }
    return [flattenColumns, scrollWidth];
  }, [flattenColumns, scrollWidth, clientWidth]);
}

// node_modules/@rc-component/table/es/hooks/useColumns/index.js
function convertChildrenToColumns(children) {
  return toArray(children).filter((node) => React367.isValidElement(node)).map((node) => {
    const {
      key,
      props
    } = node;
    const {
      children: nodeChildren,
      ...restProps
    } = props;
    const column = {
      key,
      ...restProps
    };
    if (nodeChildren) {
      column.children = convertChildrenToColumns(nodeChildren);
    }
    return column;
  });
}
function filterHiddenColumns(columns) {
  return columns.filter((column) => column && typeof column === "object" && !column.hidden).map((column) => {
    const subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return {
        ...column,
        children: filterHiddenColumns(subColumns)
      };
    }
    return column;
  });
}
function flatColumns(columns, parentKey = "key") {
  return columns.filter((column) => column && typeof column === "object").reduce((list, column, index2) => {
    const {
      fixed
    } = column;
    const parsedFixed = fixed === true || fixed === "left" ? "start" : fixed === "right" ? "end" : fixed;
    const mergedKey = `${parentKey}-${index2}`;
    const subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return [...list, ...flatColumns(subColumns, mergedKey).map((subColum) => ({
        ...subColum,
        fixed: subColum.fixed ?? parsedFixed
      }))];
    }
    return [...list, {
      key: mergedKey,
      ...column,
      fixed: parsedFixed
    }];
  }, []);
}
function useColumns({
  prefixCls,
  columns,
  children,
  expandable,
  expandedKeys,
  columnTitle,
  getRowKey,
  onTriggerExpand,
  expandIcon,
  rowExpandable,
  expandIconColumnIndex,
  expandedRowOffset = 0,
  direction,
  expandRowByClick,
  columnWidth,
  fixed,
  scrollWidth,
  clientWidth
}, transformColumns) {
  const baseColumns = React367.useMemo(() => {
    const newColumns = columns || convertChildrenToColumns(children) || [];
    return filterHiddenColumns(newColumns.slice());
  }, [columns, children]);
  const withExpandColumns = React367.useMemo(() => {
    if (expandable) {
      let cloneColumns = baseColumns.slice();
      if (expandIconColumnIndex >= 0) {
        warning_default(false, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead.");
      }
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        const expandColIndex = expandIconColumnIndex || 0;
        const insertIndex = expandColIndex === 0 && (fixed === "right" || fixed === "end") ? baseColumns.length : expandColIndex;
        if (insertIndex >= 0) {
          cloneColumns.splice(insertIndex, 0, EXPAND_COLUMN);
        }
      }
      if (cloneColumns.filter((c) => c === EXPAND_COLUMN).length > 1) {
        warning_default(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      }
      const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter((column, index2) => column !== EXPAND_COLUMN || index2 === expandColumnIndex);
      const prevColumn = baseColumns[expandColumnIndex];
      let fixedColumn;
      if (fixed) {
        fixedColumn = fixed;
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      const expandColumn = {
        [INTERNAL_COL_DEFINE]: {
          className: `${prefixCls}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: columnTitle,
        fixed: fixedColumn,
        className: `${prefixCls}-row-expand-icon-cell`,
        width: columnWidth,
        render: (_, record, index2) => {
          const rowKey = getRowKey(record, index2);
          const expanded = expandedKeys.has(rowKey);
          const recordExpandable = rowExpandable ? rowExpandable(record) : true;
          const icon = expandIcon({
            prefixCls,
            expanded,
            expandable: recordExpandable,
            record,
            onExpand: onTriggerExpand
          });
          if (expandRowByClick) {
            return React367.createElement("span", {
              onClick: (e3) => e3.stopPropagation()
            }, icon);
          }
          return icon;
        }
      };
      return cloneColumns.map((col, index2) => {
        const column = col === EXPAND_COLUMN ? expandColumn : col;
        if (index2 < expandedRowOffset) {
          return {
            ...column,
            fixed: column.fixed || "start"
          };
        }
        return column;
      });
    }
    if (baseColumns.includes(EXPAND_COLUMN)) {
      warning_default(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
    }
    return baseColumns.filter((col) => col !== EXPAND_COLUMN);
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction, expandedRowOffset]);
  const mergedColumns = React367.useMemo(() => {
    let finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        render: () => null
      }];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction]);
  const flattenColumns = React367.useMemo(
    () => flatColumns(mergedColumns),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [mergedColumns, direction, scrollWidth]
  );
  const [filledColumns, realScrollWidth] = useWidthColumns(flattenColumns, scrollWidth, clientWidth);
  return [mergedColumns, filledColumns, realScrollWidth];
}
var useColumns_default = useColumns;

// node_modules/@rc-component/table/es/hooks/useExpand.js
var React368 = __toESM(require_react());
function useExpand(props, mergedData, getRowKey) {
  const expandableConfig = getExpandableProps(props);
  const {
    expandIcon,
    expandedRowKeys,
    defaultExpandedRowKeys,
    defaultExpandAllRows,
    expandedRowRender,
    onExpand,
    onExpandedRowsChange,
    childrenColumnName
  } = expandableConfig;
  const mergedExpandIcon = expandIcon || renderExpandIcon;
  const mergedChildrenColumnName = childrenColumnName || "children";
  const expandableType = React368.useMemo(() => {
    if (expandedRowRender) {
      return "row";
    }
    if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some((record) => record && typeof record === "object" && record[mergedChildrenColumnName])) {
      return "nest";
    }
    return false;
  }, [!!expandedRowRender, mergedData]);
  const [innerExpandedKeys, setInnerExpandedKeys] = React368.useState(() => {
    if (defaultExpandedRowKeys) {
      return defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows) {
      return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
    }
    return [];
  });
  const mergedExpandedKeys = React368.useMemo(() => new Set(expandedRowKeys || innerExpandedKeys || []), [expandedRowKeys, innerExpandedKeys]);
  const onTriggerExpand = React368.useCallback((record) => {
    const key = getRowKey(record, mergedData.indexOf(record));
    let newExpandedKeys;
    const hasKey = mergedExpandedKeys.has(key);
    if (hasKey) {
      mergedExpandedKeys.delete(key);
      newExpandedKeys = [...mergedExpandedKeys];
    } else {
      newExpandedKeys = [...mergedExpandedKeys, key];
    }
    setInnerExpandedKeys(newExpandedKeys);
    if (onExpand) {
      onExpand(!hasKey, record);
    }
    if (onExpandedRowsChange) {
      onExpandedRowsChange(newExpandedKeys);
    }
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
  if (expandedRowRender && mergedData.some((record) => {
    return Array.isArray(record?.[mergedChildrenColumnName]);
  })) {
    warning_default(false, "`expandedRowRender` should not use with nested Table");
  }
  return [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
}

// node_modules/@rc-component/table/es/hooks/useFixedInfo.js
var React369 = __toESM(require_react());
function useFixedInfo(flattenColumns, stickyOffsets) {
  const fixedInfoList = React369.useMemo(() => flattenColumns.map((_, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets)), [flattenColumns, stickyOffsets]);
  return useMemo(() => fixedInfoList, [fixedInfoList], (prev, next) => !isEqual_default(prev, next));
}

// node_modules/@rc-component/table/es/hooks/useFrame.js
var import_react117 = __toESM(require_react());
function useLayoutState(defaultState) {
  const stateRef = (0, import_react117.useRef)(defaultState);
  const [, forceUpdate] = (0, import_react117.useState)({});
  const lastPromiseRef = (0, import_react117.useRef)(null);
  const updateBatchRef = (0, import_react117.useRef)([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    const promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(() => {
      if (lastPromiseRef.current === promise) {
        const prevBatch = updateBatchRef.current;
        const prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach((batchUpdater) => {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;
        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }
  (0, import_react117.useEffect)(() => () => {
    lastPromiseRef.current = null;
  }, []);
  return [stateRef.current, setFrameState];
}
function useTimeoutLock(defaultState) {
  const frameRef = (0, import_react117.useRef)(defaultState || null);
  const timeoutRef = (0, import_react117.useRef)(null);
  function cleanUp() {
    clearTimeout(timeoutRef.current);
  }
  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = setTimeout(() => {
      frameRef.current = null;
      timeoutRef.current = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.current;
  }
  (0, import_react117.useEffect)(() => cleanUp, []);
  return [setState, getState];
}

// node_modules/@rc-component/table/es/hooks/useHover.js
var React370 = __toESM(require_react());
function useHover() {
  const [startRow, setStartRow] = React370.useState(-1);
  const [endRow, setEndRow] = React370.useState(-1);
  const onHover = React370.useCallback((start, end) => {
    setStartRow(start);
    setEndRow(end);
  }, []);
  return [startRow, endRow, onHover];
}

// node_modules/@rc-component/table/es/hooks/useSticky.js
var React371 = __toESM(require_react());
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  const {
    offsetHeader = 0,
    offsetSummary = 0,
    offsetScroll = 0,
    getContainer = () => defaultContainer
  } = typeof sticky === "object" ? sticky : {};
  const container = getContainer() || defaultContainer;
  const isSticky = !!sticky;
  return React371.useMemo(() => {
    return {
      isSticky,
      stickyClassName: isSticky ? `${prefixCls}-sticky-holder` : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  }, [isSticky, offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}

// node_modules/@rc-component/table/es/hooks/useStickyOffsets.js
var import_react118 = __toESM(require_react());
function useStickyOffsets(colWidths, flattenColumns) {
  const stickyOffsets = (0, import_react118.useMemo)(() => {
    const columnCount = flattenColumns.length;
    const getOffsets = (startIndex, endIndex, offset3) => {
      const offsets = [];
      let total = 0;
      for (let i = startIndex; i !== endIndex; i += offset3) {
        offsets.push(total);
        if (flattenColumns[i].fixed) {
          total += colWidths[i] || 0;
        }
      }
      return offsets;
    };
    const startOffsets = getOffsets(0, columnCount, 1);
    const endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
    return {
      start: startOffsets,
      end: endOffsets,
      widths: colWidths
    };
  }, [colWidths, flattenColumns]);
  return stickyOffsets;
}
var useStickyOffsets_default = useStickyOffsets;

// node_modules/@rc-component/table/es/Panel/index.js
var React372 = __toESM(require_react());
var Panel4 = (props) => {
  const {
    children,
    className,
    style
  } = props;
  return React372.createElement("div", {
    className,
    style
  }, children);
};
var Panel_default4 = Panel4;

// node_modules/@rc-component/table/es/stickyScrollBar.js
var React373 = __toESM(require_react());

// node_modules/@rc-component/table/es/utils/offsetUtil.js
function getOffset3(node) {
  const element = getDOM(node);
  const box2 = element.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}

// node_modules/@rc-component/table/es/stickyScrollBar.js
var MOUSEUP_EVENT = "mouseup";
var MOUSEMOVE_EVENT = "mousemove";
var SCROLL_EVENT = "scroll";
var RESIZE_EVENT = "resize";
var StickyScrollBar = (props, ref) => {
  const {
    scrollBodyRef,
    onScroll,
    offsetScroll,
    container,
    direction
  } = props;
  const prefixCls = useContext129(TableContext_default, "prefixCls");
  const bodyScrollWidth = scrollBodyRef.current?.scrollWidth || 0;
  const bodyWidth = scrollBodyRef.current?.clientWidth || 0;
  const scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  const scrollBarRef = React373.useRef(null);
  const [scrollState, setScrollState] = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: true
  });
  const refState = React373.useRef({
    delta: 0,
    x: 0
  });
  const [isActive, setActive] = React373.useState(false);
  const rafRef = React373.useRef(null);
  React373.useEffect(() => () => {
    raf_default.cancel(rafRef.current);
  }, []);
  const onMouseUp = () => {
    setActive(false);
  };
  const onMouseDown = (event) => {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  };
  const onMouseMove = (event) => {
    const {
      buttons
    } = event || window?.event;
    if (!isActive || buttons === 0) {
      if (isActive) {
        setActive(false);
      }
      return;
    }
    let left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    const isRTL = direction === "rtl";
    left = Math.max(isRTL ? scrollBarWidth - bodyWidth : 0, Math.min(isRTL ? 0 : bodyWidth - scrollBarWidth, left));
    const shouldScroll = !isRTL || Math.abs(left) + Math.abs(scrollBarWidth) < bodyWidth;
    if (shouldScroll) {
      onScroll({
        scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
      });
      refState.current.x = event.pageX;
    }
  };
  const checkScrollBarVisible = () => {
    raf_default.cancel(rafRef.current);
    rafRef.current = raf_default(() => {
      if (!scrollBodyRef.current) {
        return;
      }
      const tableOffsetTop = getOffset3(scrollBodyRef.current).top;
      const tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
      const currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset3(container).top + container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: true
        }));
      } else {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: false
        }));
      }
    });
  };
  const setScrollLeft = (left) => {
    setScrollState((state) => {
      return {
        ...state,
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      };
    });
  };
  React373.useImperativeHandle(ref, () => ({
    setScrollLeft,
    checkScrollBarVisible
  }));
  React373.useEffect(() => {
    document.body.addEventListener(MOUSEUP_EVENT, onMouseUp, false);
    document.body.addEventListener(MOUSEMOVE_EVENT, onMouseMove, false);
    checkScrollBarVisible();
    return () => {
      document.body.removeEventListener(MOUSEUP_EVENT, onMouseUp);
      document.body.removeEventListener(MOUSEMOVE_EVENT, onMouseMove);
    };
  }, [scrollBarWidth, isActive]);
  React373.useEffect(() => {
    if (scrollBodyRef.current) {
      const scrollParents = [];
      let parent = getDOM(scrollBodyRef.current);
      while (parent) {
        scrollParents.push(parent);
        parent = parent.parentElement;
      }
      scrollParents.forEach((p) => {
        p.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      });
      window.addEventListener(RESIZE_EVENT, checkScrollBarVisible, false);
      window.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      container.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      return () => {
        scrollParents.forEach((p) => {
          p.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
        });
        window.removeEventListener(RESIZE_EVENT, checkScrollBarVisible);
        window.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
        container.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
      };
    }
  }, [container]);
  React373.useEffect(() => {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState((state) => {
        const bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state;
        }
        return {
          ...state,
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        };
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return React373.createElement("div", {
    style: {
      height: getScrollBarSize(),
      width: bodyWidth,
      bottom: offsetScroll
    },
    className: `${prefixCls}-sticky-scroll`
  }, React373.createElement("div", {
    onMouseDown,
    ref: scrollBarRef,
    className: clsx(`${prefixCls}-sticky-scroll-bar`, {
      [`${prefixCls}-sticky-scroll-bar-active`]: isActive
    }),
    style: {
      width: `${scrollBarWidth}px`,
      transform: `translate3d(${scrollState.scrollLeft}px, 0, 0)`
    }
  }));
};
var stickyScrollBar_default = React373.forwardRef(StickyScrollBar);

// node_modules/@rc-component/table/es/Table.js
function _extends65() {
  _extends65 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends65.apply(this, arguments);
}
var DEFAULT_PREFIX = "rc-table";
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
  return "No Data";
}
var Table = (tableProps, ref) => {
  const props = {
    rowKey: "key",
    prefixCls: DEFAULT_PREFIX,
    emptyText: defaultEmpty,
    ...tableProps
  };
  const {
    prefixCls,
    className,
    rowClassName,
    style,
    classNames,
    styles,
    data,
    rowKey,
    scroll,
    tableLayout,
    direction,
    // Additional Part
    title,
    footer,
    summary,
    caption,
    // Customize
    id,
    showHeader,
    components,
    emptyText,
    onRow,
    onHeaderRow,
    // Measure Row
    measureRowRender,
    // Events
    onScroll,
    // Internal
    internalHooks,
    transformColumns,
    internalRefs,
    tailor,
    getContainerWidth,
    sticky,
    rowHoverable = true
  } = props;
  const mergedData = data || EMPTY_DATA;
  const hasData = !!mergedData.length;
  const useInternalHooks = internalHooks === INTERNAL_HOOKS;
  if (true) {
    ["onRowClick", "onRowDoubleClick", "onRowContextMenu", "onRowMouseEnter", "onRowMouseLeave"].forEach((name) => {
      warning_default(props[name] === void 0, `\`${name}\` is removed, please use \`onRow\` instead.`);
    });
    warning_default(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead.");
  }
  const getComponent = React374.useCallback((path2, defaultComponent) => get(components, path2) || defaultComponent, [components]);
  const getRowKey = React374.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => {
      const key = record && record[rowKey];
      if (true) {
        warning_default(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key.");
      }
      return key;
    };
  }, [rowKey]);
  const customizeScrollBody = getComponent(["body"]);
  const [startRow, endRow, onHover] = useHover();
  const [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand] = useExpand(props, mergedData, getRowKey);
  const scrollX = scroll?.x;
  const [componentWidth, setComponentWidth] = React374.useState(0);
  const [columns, flattenColumns, flattenScrollX] = useColumns_default({
    ...props,
    ...expandableConfig,
    expandable: !!expandableConfig.expandedRowRender,
    columnTitle: expandableConfig.columnTitle,
    expandedKeys: mergedExpandedKeys,
    getRowKey,
    // https://github.com/ant-design/ant-design/issues/23894
    onTriggerExpand,
    expandIcon: mergedExpandIcon,
    expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
    direction,
    scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
    clientWidth: componentWidth
  }, useInternalHooks ? transformColumns : null);
  const mergedScrollX = flattenScrollX ?? scrollX;
  const columnContext = React374.useMemo(() => ({
    columns,
    flattenColumns
  }), [columns, flattenColumns]);
  const fullTableRef = React374.useRef(null);
  const scrollHeaderRef = React374.useRef(null);
  const scrollBodyRef = React374.useRef(null);
  const scrollBodyContainerRef = React374.useRef(null);
  React374.useImperativeHandle(ref, () => {
    return {
      nativeElement: fullTableRef.current,
      scrollTo: (config) => {
        if (scrollBodyRef.current instanceof HTMLElement) {
          const {
            index: index2,
            top,
            key,
            offset: offset3
          } = config;
          if (validNumberValue(top)) {
            scrollBodyRef.current?.scrollTo({
              top
            });
          } else {
            const mergedKey = key ?? getRowKey(mergedData[index2]);
            const targetElement = scrollBodyRef.current.querySelector(`[data-row-key="${mergedKey}"]`);
            if (targetElement) {
              if (!offset3) {
                targetElement.scrollIntoView();
              } else {
                const elementTop = targetElement.offsetTop;
                scrollBodyRef.current.scrollTo({
                  top: elementTop + offset3
                });
              }
            }
          }
        } else if (scrollBodyRef.current?.scrollTo) {
          scrollBodyRef.current.scrollTo(config);
        }
      }
    };
  });
  const scrollSummaryRef = React374.useRef(null);
  const [shadowStart, setShadowStart] = React374.useState(false);
  const [shadowEnd, setShadowEnd] = React374.useState(false);
  const [colsWidths, updateColsWidths] = React374.useState(/* @__PURE__ */ new Map());
  const colsKeys = getColumnsKey(flattenColumns);
  const pureColWidths = colsKeys.map((columnKey) => colsWidths.get(columnKey));
  const colWidths = React374.useMemo(() => pureColWidths, [pureColWidths.join("_")]);
  const stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns);
  const fixHeader = scroll && validateValue(scroll.y);
  const horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
  const fixColumn = horizonScroll && flattenColumns.some(({
    fixed
  }) => fixed);
  const stickyRef = React374.useRef(null);
  const {
    isSticky,
    offsetHeader,
    offsetSummary,
    offsetScroll,
    stickyClassName,
    container
  } = useSticky(sticky, prefixCls);
  const summaryNode = React374.useMemo(() => summary?.(mergedData), [summary, mergedData]);
  const fixFooter = (fixHeader || isSticky) && React374.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
  let scrollXStyle;
  let scrollYStyle;
  let scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: hasData ? "scroll" : "auto",
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = {
      overflowX: "auto"
    };
    if (!fixHeader) {
      scrollYStyle = {
        overflowY: "hidden"
      };
    }
    scrollTableStyle = {
      width: mergedScrollX === true ? "auto" : mergedScrollX,
      minWidth: "100%"
    };
  }
  const onColumnResize = React374.useCallback((columnKey, width) => {
    updateColsWidths((widths) => {
      if (widths.get(columnKey) !== width) {
        const newWidths = new Map(widths);
        newWidths.set(columnKey, width);
        return newWidths;
      }
      return widths;
    });
  }, []);
  const [setScrollTarget, getScrollTarget] = useTimeoutLock(null);
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === "function") {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
      if (target.scrollLeft !== scrollLeft) {
        setTimeout(() => {
          target.scrollLeft = scrollLeft;
        }, 0);
      }
    }
  }
  const [scrollInfo, setScrollInfo] = React374.useState([0, 0]);
  const onInternalScroll = useEvent_default(({
    currentTarget,
    scrollLeft
  }) => {
    const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
    const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      setScrollTarget(compareTarget);
      forceScroll(mergedScrollLeft, scrollHeaderRef.current);
      forceScroll(mergedScrollLeft, scrollBodyRef.current);
      forceScroll(mergedScrollLeft, scrollSummaryRef.current);
      forceScroll(mergedScrollLeft, stickyRef.current?.setScrollLeft);
    }
    const measureTarget = currentTarget || scrollHeaderRef.current;
    if (measureTarget) {
      const scrollWidth = (
        // Should use mergedScrollX in virtual table(useInternalHooks && tailor === true)
        useInternalHooks && tailor && typeof mergedScrollX === "number" ? mergedScrollX : measureTarget.scrollWidth
      );
      const clientWidth = measureTarget.clientWidth;
      const absScrollStart = Math.abs(mergedScrollLeft);
      setScrollInfo((ori) => {
        const nextScrollInfo = [absScrollStart, scrollWidth - clientWidth];
        return isEqual_default(ori, nextScrollInfo) ? ori : nextScrollInfo;
      });
      if (scrollWidth === clientWidth) {
        setShadowStart(false);
        setShadowEnd(false);
        return;
      }
      setShadowStart(absScrollStart > 0);
      setShadowEnd(absScrollStart < scrollWidth - clientWidth - 1);
    }
  });
  const onBodyScroll = useEvent_default((e3) => {
    onInternalScroll(e3);
    onScroll?.(e3);
  });
  const triggerOnScroll = () => {
    if (horizonScroll && scrollBodyRef.current) {
      onInternalScroll({
        currentTarget: getDOM(scrollBodyRef.current),
        scrollLeft: scrollBodyRef.current?.scrollLeft
      });
    } else {
      setShadowStart(false);
      setShadowEnd(false);
    }
  };
  const onFullTableResize = (offsetWidth) => {
    stickyRef.current?.checkScrollBarVisible();
    let mergedWidth = offsetWidth ?? fullTableRef.current?.offsetWidth ?? 0;
    if (useInternalHooks && getContainerWidth && fullTableRef.current) {
      mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
    }
    if (mergedWidth !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(mergedWidth);
    }
  };
  useLayoutEffect_default(() => {
    if (horizonScroll) {
      onFullTableResize();
    }
  }, [horizonScroll]);
  const mounted = React374.useRef(false);
  React374.useEffect(() => {
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data, columns.length]);
  React374.useEffect(() => {
    mounted.current = true;
  }, []);
  const [scrollbarSize, setScrollbarSize] = React374.useState(0);
  useLayoutEffect_default(() => {
    if (!tailor || !useInternalHooks) {
      if (scrollBodyRef.current instanceof Element) {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
      } else {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
      }
    }
  }, []);
  React374.useEffect(() => {
    if (useInternalHooks && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  });
  const renderFixedHeaderTable = React374.useCallback((fixedHolderPassProps) => React374.createElement(React374.Fragment, null, React374.createElement(Header_default2, fixedHolderPassProps), fixFooter === "top" && React374.createElement(Footer_default, fixedHolderPassProps, summaryNode)), [fixFooter, summaryNode]);
  const renderFixedFooterTable = React374.useCallback((fixedHolderPassProps) => React374.createElement(Footer_default, fixedHolderPassProps, summaryNode), [summaryNode]);
  const TableComponent = getComponent(["table"], "table");
  const mergedTableLayout = React374.useMemo(() => {
    if (tableLayout) {
      return tableLayout;
    }
    if (fixColumn) {
      return mergedScrollX === "max-content" ? "auto" : "fixed";
    }
    if (fixHeader || isSticky || flattenColumns.some(({
      ellipsis
    }) => ellipsis)) {
      return "fixed";
    }
    return "auto";
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  let groupTableNode;
  const headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  };
  const emptyNode = React374.useMemo(() => {
    if (hasData) {
      return null;
    }
    if (typeof emptyText === "function") {
      return emptyText();
    }
    return emptyText;
  }, [hasData, emptyText]);
  const bodyTable = React374.createElement(Body_default, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky
  });
  const bodyColGroup = React374.createElement(ColGroup_default, {
    colWidths: flattenColumns.map(({
      width
    }) => width),
    columns: flattenColumns
  });
  const captionElement = caption !== null && caption !== void 0 ? React374.createElement("caption", {
    className: `${prefixCls}-caption`
  }, caption) : void 0;
  const dataProps = pickAttrs(props, {
    data: true
  });
  const ariaProps = pickAttrs(props, {
    aria: true
  });
  if (fixHeader || isSticky) {
    let bodyContent;
    if (typeof customizeScrollBody === "function") {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize,
        ref: scrollBodyRef,
        onScroll: onInternalScroll
      });
      headerProps.colWidths = flattenColumns.map(({
        width
      }, index2) => {
        const colWidth = index2 === flattenColumns.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        if (true) {
          warning_default(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value.");
        }
        return 0;
      });
    } else {
      bodyContent = React374.createElement("div", {
        style: {
          ...scrollXStyle,
          ...scrollYStyle
        },
        onScroll: onBodyScroll,
        ref: scrollBodyRef,
        className: `${prefixCls}-body`
      }, React374.createElement(TableComponent, _extends65({
        style: {
          ...scrollTableStyle,
          tableLayout: mergedTableLayout
        }
      }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && React374.createElement(Footer_default, {
        stickyOffsets,
        flattenColumns
      }, summaryNode)));
    }
    const fixedHolderProps = {
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && mergedScrollX === "max-content",
      ...headerProps,
      ...columnContext,
      direction,
      stickyClassName,
      scrollX: mergedScrollX,
      tableLayout: mergedTableLayout,
      onScroll: onInternalScroll
    };
    groupTableNode = React374.createElement(React374.Fragment, null, showHeader !== false && React374.createElement(FixedHolder_default, _extends65({}, fixedHolderProps, {
      stickyTopOffset: offsetHeader,
      className: `${prefixCls}-header`,
      ref: scrollHeaderRef,
      colGroup: bodyColGroup
    }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && React374.createElement(FixedHolder_default, _extends65({}, fixedHolderProps, {
      stickyBottomOffset: offsetSummary,
      className: `${prefixCls}-summary`,
      ref: scrollSummaryRef,
      colGroup: bodyColGroup
    }), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && React374.createElement(stickyScrollBar_default, {
      ref: stickyRef,
      offsetScroll,
      scrollBodyRef,
      onScroll: onInternalScroll,
      container,
      direction
    }));
  } else {
    groupTableNode = React374.createElement("div", {
      style: {
        ...scrollXStyle,
        ...scrollYStyle,
        ...styles?.content
      },
      className: clsx(`${prefixCls}-content`, classNames?.content),
      onScroll: onInternalScroll,
      ref: scrollBodyRef
    }, React374.createElement(TableComponent, _extends65({
      style: {
        ...scrollTableStyle,
        tableLayout: mergedTableLayout
      }
    }, ariaProps), captionElement, bodyColGroup, showHeader !== false && React374.createElement(Header_default2, _extends65({}, headerProps, columnContext)), bodyTable, summaryNode && React374.createElement(Footer_default, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
  }
  const tableStyle = {
    ...style
  };
  if (isSticky) {
    tableStyle["--columns-count"] = flattenColumns.length;
  }
  let fullTable = React374.createElement("div", _extends65({
    className: clsx(prefixCls, className, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-fix-start-shadow`]: horizonScroll,
      [`${prefixCls}-fix-end-shadow`]: horizonScroll,
      [`${prefixCls}-fix-start-shadow-show`]: horizonScroll && shadowStart,
      [`${prefixCls}-fix-end-shadow-show`]: horizonScroll && shadowEnd,
      [`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
      [`${prefixCls}-fixed-header`]: fixHeader,
      /** No used but for compatible */
      [`${prefixCls}-fixed-column`]: fixColumn,
      [`${prefixCls}-scroll-horizontal`]: horizonScroll,
      [`${prefixCls}-has-fix-start`]: flattenColumns[0]?.fixed,
      [`${prefixCls}-has-fix-end`]: flattenColumns[flattenColumns.length - 1]?.fixed === "end"
    }),
    style: tableStyle,
    id,
    ref: fullTableRef
  }, dataProps), title && React374.createElement(Panel_default4, {
    className: clsx(`${prefixCls}-title`, classNames?.title),
    style: styles?.title
  }, title(mergedData)), React374.createElement("div", {
    ref: scrollBodyContainerRef,
    className: clsx(`${prefixCls}-container`, classNames?.section),
    style: styles?.section
  }, groupTableNode), footer && React374.createElement(Panel_default4, {
    className: clsx(`${prefixCls}-footer`, classNames?.footer),
    style: styles?.footer
  }, footer(mergedData)));
  if (horizonScroll) {
    fullTable = React374.createElement(es_default3, {
      onResize: ({
        offsetWidth
      }) => onFullTableResize(offsetWidth)
    }, fullTable);
  }
  const fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets);
  const TableContextValue = React374.useMemo(() => ({
    // Scroll
    scrollX: mergedScrollX,
    scrollInfo,
    classNames,
    styles,
    // Table
    prefixCls,
    getComponent,
    scrollbarSize,
    direction,
    fixedInfoList,
    isSticky,
    componentWidth,
    fixHeader,
    fixColumn,
    horizonScroll,
    // Body
    tableLayout: mergedTableLayout,
    rowClassName,
    expandedRowClassName: expandableConfig.expandedRowClassName,
    expandIcon: mergedExpandIcon,
    expandableType,
    expandRowByClick: expandableConfig.expandRowByClick,
    expandedRowRender: expandableConfig.expandedRowRender,
    expandedRowOffset: expandableConfig.expandedRowOffset,
    onTriggerExpand,
    expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
    indentSize: expandableConfig.indentSize,
    allColumnsFixedLeft: flattenColumns.every((col) => col.fixed === "start"),
    emptyNode,
    // Column
    columns,
    flattenColumns,
    onColumnResize,
    colWidths,
    // Row
    hoverStartRow: startRow,
    hoverEndRow: endRow,
    onHover,
    rowExpandable: expandableConfig.rowExpandable,
    onRow,
    getRowKey,
    expandedKeys: mergedExpandedKeys,
    childrenColumnName: mergedChildrenColumnName,
    rowHoverable,
    // Measure Row
    measureRowRender
  }), [
    // Scroll
    mergedScrollX,
    scrollInfo,
    classNames,
    styles,
    // Table
    prefixCls,
    getComponent,
    scrollbarSize,
    direction,
    fixedInfoList,
    isSticky,
    componentWidth,
    fixHeader,
    fixColumn,
    horizonScroll,
    // Body
    mergedTableLayout,
    rowClassName,
    expandableConfig.expandedRowClassName,
    mergedExpandIcon,
    expandableType,
    expandableConfig.expandRowByClick,
    expandableConfig.expandedRowRender,
    expandableConfig.expandedRowOffset,
    onTriggerExpand,
    expandableConfig.expandIconColumnIndex,
    expandableConfig.indentSize,
    emptyNode,
    // Column
    columns,
    flattenColumns,
    onColumnResize,
    colWidths,
    // Row
    startRow,
    endRow,
    onHover,
    expandableConfig.rowExpandable,
    onRow,
    getRowKey,
    mergedExpandedKeys,
    mergedChildrenColumnName,
    rowHoverable,
    measureRowRender
  ]);
  return React374.createElement(TableContext_default.Provider, {
    value: TableContextValue
  }, fullTable);
};
var RefTable = React374.forwardRef(Table);
if (true) {
  RefTable.displayName = "Table";
}
var genTable = (shouldTriggerRender) => {
  return makeImmutable2(RefTable, shouldTriggerRender);
};
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column_default;
ImmutableTable.ColumnGroup = ColumnGroup_default;
ImmutableTable.Summary = FooterComponents;
var Table_default = ImmutableTable;

// node_modules/@rc-component/table/es/VirtualTable/index.js
var React378 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/BodyGrid.js
var React377 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/BodyLine.js
var React376 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/VirtualCell.js
var React375 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/context.js
var StaticContext = createContext29(null);
var GridContext = createContext29(null);

// node_modules/@rc-component/table/es/VirtualTable/VirtualCell.js
function _extends66() {
  _extends66 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends66.apply(this, arguments);
}
function getColumnWidth(colIndex, colSpan, columnsOffset) {
  const mergedColSpan = colSpan || 1;
  return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
}
var VirtualCell = (props) => {
  const {
    rowInfo,
    column,
    colIndex,
    indent,
    index: index2,
    component,
    renderIndex,
    record,
    style,
    className,
    inverse,
    getHeight: getHeight3
  } = props;
  const {
    render: render2,
    dataIndex,
    className: columnClassName,
    width: colWidth
  } = column;
  const {
    columnsOffset
  } = useContext129(GridContext, ["columnsOffset"]);
  const {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps
  } = getCellProps(rowInfo, column, colIndex, indent, index2);
  const {
    style: cellStyle,
    colSpan = 1,
    rowSpan = 1
  } = additionalCellProps;
  const startColIndex = colIndex - 1;
  const concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
  const marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
  const mergedStyle = {
    ...cellStyle,
    ...style,
    flex: `0 0 ${concatColWidth}px`,
    width: `${concatColWidth}px`,
    marginRight: marginOffset,
    pointerEvents: "auto"
  };
  const needHide = React375.useMemo(() => {
    if (inverse) {
      return rowSpan <= 1;
    } else {
      return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
    }
  }, [rowSpan, colSpan, inverse]);
  if (needHide) {
    mergedStyle.visibility = "hidden";
  } else if (inverse) {
    mergedStyle.height = getHeight3?.(rowSpan);
  }
  const mergedRender = needHide ? () => null : render2;
  const cellSpan = {};
  if (rowSpan === 0 || colSpan === 0) {
    cellSpan.rowSpan = 1;
    cellSpan.colSpan = 1;
  }
  return React375.createElement(Cell_default2, _extends66({
    className: clsx(columnClassName, className),
    ellipsis: column.ellipsis,
    align: column.align,
    scope: column.rowScope,
    component,
    prefixCls: rowInfo.prefixCls,
    key,
    record,
    index: index2,
    renderIndex,
    dataIndex,
    render: mergedRender,
    shouldCellUpdate: column.shouldCellUpdate
  }, fixedInfo, {
    appendNode: appendCellNode,
    additionalProps: {
      ...additionalCellProps,
      style: mergedStyle,
      ...cellSpan
    }
  }));
};
var VirtualCell_default = VirtualCell;

// node_modules/@rc-component/table/es/VirtualTable/BodyLine.js
function _extends67() {
  _extends67 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends67.apply(this, arguments);
}
var BodyLine = React376.forwardRef((props, ref) => {
  const {
    data,
    index: index2,
    className,
    rowKey,
    style,
    extra,
    getHeight: getHeight3,
    ...restProps
  } = props;
  const {
    record,
    indent,
    index: renderIndex
  } = data;
  const {
    scrollX,
    flattenColumns,
    prefixCls,
    fixColumn,
    componentWidth
  } = useContext129(TableContext_default, ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]);
  const {
    getComponent
  } = useContext129(StaticContext, ["getComponent"]);
  const rowInfo = useRowInfo(record, rowKey, index2, indent);
  const RowComponent = getComponent(["body", "row"], "div");
  const cellComponent = getComponent(["body", "cell"], "div");
  const {
    rowSupportExpand,
    expanded,
    rowProps,
    expandedRowRender,
    expandedRowClassName
  } = rowInfo;
  let expandRowNode;
  if (rowSupportExpand && expanded) {
    const expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent);
    let additionalProps = {};
    if (fixColumn) {
      additionalProps = {
        style: {
          ["--virtual-width"]: `${componentWidth}px`
        }
      };
    }
    const rowCellCls = `${prefixCls}-expanded-row-cell`;
    expandRowNode = React376.createElement(RowComponent, {
      className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName)
    }, React376.createElement(Cell_default2, {
      component: cellComponent,
      prefixCls,
      className: clsx(rowCellCls, {
        [`${rowCellCls}-fixed`]: fixColumn
      }),
      additionalProps
    }, expandContent));
  }
  const rowStyle = {
    ...style,
    width: scrollX
  };
  if (extra) {
    rowStyle.position = "absolute";
    rowStyle.pointerEvents = "none";
  }
  const rowNode = React376.createElement(RowComponent, _extends67({}, rowProps, restProps, {
    "data-row-key": rowKey,
    ref: rowSupportExpand ? null : ref,
    className: clsx(className, `${prefixCls}-row`, rowProps?.className, {
      [`${prefixCls}-row-extra`]: extra
    }),
    style: {
      ...rowStyle,
      ...rowProps?.style
    }
  }), flattenColumns.map((column, colIndex) => {
    return React376.createElement(VirtualCell_default, {
      key: colIndex,
      component: cellComponent,
      rowInfo,
      column,
      colIndex,
      indent,
      index: index2,
      renderIndex,
      record,
      inverse: extra,
      getHeight: getHeight3
    });
  }));
  if (rowSupportExpand) {
    return React376.createElement("div", {
      ref
    }, rowNode, expandRowNode);
  }
  return rowNode;
});
var ResponseBodyLine = responseImmutable2(BodyLine);
if (true) {
  ResponseBodyLine.displayName = "BodyLine";
}
var BodyLine_default = ResponseBodyLine;

// node_modules/@rc-component/table/es/VirtualTable/BodyGrid.js
var Grid = React377.forwardRef((props, ref) => {
  const {
    data,
    onScroll
  } = props;
  const {
    flattenColumns,
    onColumnResize,
    getRowKey,
    expandedKeys,
    prefixCls,
    childrenColumnName,
    scrollX,
    direction
  } = useContext129(TableContext_default, ["flattenColumns", "onColumnResize", "getRowKey", "prefixCls", "expandedKeys", "childrenColumnName", "scrollX", "direction"]);
  const {
    sticky,
    scrollY,
    listItemHeight,
    getComponent,
    onScroll: onTablePropScroll
  } = useContext129(StaticContext);
  const listRef = React377.useRef(null);
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const columnsWidth = React377.useMemo(() => {
    let total = 0;
    return flattenColumns.map(({
      width,
      minWidth,
      key
    }) => {
      const finalWidth = Math.max(width || 0, minWidth || 0);
      total += finalWidth;
      return [key, finalWidth, total];
    });
  }, [flattenColumns]);
  const columnsOffset = React377.useMemo(() => columnsWidth.map((colWidth) => colWidth[2]), [columnsWidth]);
  React377.useEffect(() => {
    columnsWidth.forEach(([key, width]) => {
      onColumnResize(key, width);
    });
  }, [columnsWidth]);
  React377.useImperativeHandle(ref, () => {
    const obj = {
      scrollTo: (config) => {
        const {
          offset: offset3,
          ...restConfig
        } = config;
        if (offset3) {
          listRef.current?.scrollTo({
            ...restConfig,
            offset: offset3,
            align: "top"
          });
        } else {
          listRef.current?.scrollTo(config);
        }
      },
      nativeElement: listRef.current?.nativeElement
    };
    Object.defineProperty(obj, "scrollLeft", {
      get: () => listRef.current?.getScrollInfo().x || 0,
      set: (value) => {
        listRef.current?.scrollTo({
          left: value
        });
      }
    });
    Object.defineProperty(obj, "scrollTop", {
      get: () => listRef.current?.getScrollInfo().y || 0,
      set: (value) => {
        listRef.current?.scrollTo({
          top: value
        });
      }
    });
    return obj;
  });
  const getRowSpan = (column, index2) => {
    const record = flattenData2[index2]?.record;
    const {
      onCell
    } = column;
    if (onCell) {
      const cellProps = onCell(record, index2);
      return cellProps?.rowSpan ?? 1;
    }
    return 1;
  };
  const extraRender = (info) => {
    const {
      start,
      end,
      getSize: getSize3,
      offsetY
    } = info;
    if (end < 0) {
      return null;
    }
    let firstRowSpanColumns = flattenColumns.filter(
      // rowSpan is 0
      (column) => getRowSpan(column, start) === 0
    );
    let startIndex = start;
    for (let i = start; i >= 0; i -= 1) {
      firstRowSpanColumns = firstRowSpanColumns.filter((column) => getRowSpan(column, i) === 0);
      if (!firstRowSpanColumns.length) {
        startIndex = i;
        break;
      }
    }
    let lastRowSpanColumns = flattenColumns.filter(
      // rowSpan is not 1
      (column) => getRowSpan(column, end) !== 1
    );
    let endIndex = end;
    for (let i = end; i < flattenData2.length; i += 1) {
      lastRowSpanColumns = lastRowSpanColumns.filter((column) => getRowSpan(column, i) !== 1);
      if (!lastRowSpanColumns.length) {
        endIndex = Math.max(i - 1, end);
        break;
      }
    }
    const spanLines = [];
    for (let i = startIndex; i <= endIndex; i += 1) {
      const item = flattenData2[i];
      if (!item) {
        continue;
      }
      if (flattenColumns.some((column) => getRowSpan(column, i) > 1)) {
        spanLines.push(i);
      }
    }
    const nodes = spanLines.map((index2) => {
      const item = flattenData2[index2];
      const rowKey = getRowKey(item.record, index2);
      const getHeight3 = (rowSpan) => {
        const endItemIndex = index2 + rowSpan - 1;
        const endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex);
        const sizeInfo2 = getSize3(rowKey, endItemKey);
        return sizeInfo2.bottom - sizeInfo2.top;
      };
      const sizeInfo = getSize3(rowKey);
      return React377.createElement(BodyLine_default, {
        key: index2,
        data: item,
        rowKey,
        index: index2,
        style: {
          top: -offsetY + sizeInfo.top
        },
        extra: true,
        getHeight: getHeight3
      });
    });
    return nodes;
  };
  const gridContext = React377.useMemo(() => ({
    columnsOffset
  }), [columnsOffset]);
  const tblPrefixCls = `${prefixCls}-tbody`;
  const wrapperComponent = getComponent(["body", "wrapper"]);
  const horizontalScrollBarStyle = {};
  if (sticky) {
    horizontalScrollBarStyle.position = "sticky";
    horizontalScrollBarStyle.bottom = 0;
    if (typeof sticky === "object" && sticky.offsetScroll) {
      horizontalScrollBarStyle.bottom = sticky.offsetScroll;
    }
  }
  return React377.createElement(GridContext.Provider, {
    value: gridContext
  }, React377.createElement(es_default7, {
    fullHeight: false,
    ref: listRef,
    prefixCls: `${tblPrefixCls}-virtual`,
    styles: {
      horizontalScrollBar: horizontalScrollBarStyle
    },
    className: tblPrefixCls,
    height: scrollY,
    itemHeight: listItemHeight || 24,
    data: flattenData2,
    itemKey: (item) => getRowKey(item.record),
    component: wrapperComponent,
    scrollWidth: scrollX,
    direction,
    onVirtualScroll: ({
      x
    }) => {
      onScroll({
        currentTarget: listRef.current?.nativeElement,
        scrollLeft: x
      });
    },
    onScroll: onTablePropScroll,
    extraRender
  }, (item, index2, itemProps) => {
    const rowKey = getRowKey(item.record, index2);
    return React377.createElement(BodyLine_default, {
      data: item,
      rowKey,
      index: index2,
      style: itemProps.style
    });
  }));
});
var ResponseGrid = responseImmutable2(Grid);
if (true) {
  ResponseGrid.displayName = "ResponseGrid";
}
var BodyGrid_default = ResponseGrid;

// node_modules/@rc-component/table/es/VirtualTable/index.js
function _extends68() {
  _extends68 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends68.apply(this, arguments);
}
var renderBody = (rawData, props) => {
  const {
    ref,
    onScroll
  } = props;
  return React378.createElement(BodyGrid_default, {
    ref,
    data: rawData,
    onScroll
  });
};
var VirtualTable = (props, ref) => {
  const {
    data,
    columns,
    scroll,
    sticky,
    prefixCls = DEFAULT_PREFIX,
    className,
    listItemHeight,
    components,
    onScroll
  } = props;
  let {
    x: scrollX,
    y: scrollY
  } = scroll || {};
  if (typeof scrollX !== "number") {
    if (true) {
      warning_default(!scrollX, "`scroll.x` in virtual table must be number.");
    }
    scrollX = 1;
  }
  if (typeof scrollY !== "number") {
    scrollY = 500;
    if (true) {
      warning_default(false, "`scroll.y` in virtual table must be number.");
    }
  }
  const getComponent = useEvent_default((path2, defaultComponent) => get(components, path2) || defaultComponent);
  const onInternalScroll = useEvent_default(onScroll);
  const context = React378.useMemo(() => ({
    sticky,
    scrollY,
    listItemHeight,
    getComponent,
    onScroll: onInternalScroll
  }), [sticky, scrollY, listItemHeight, getComponent, onInternalScroll]);
  return React378.createElement(StaticContext.Provider, {
    value: context
  }, React378.createElement(Table_default, _extends68({}, props, {
    className: clsx(className, `${prefixCls}-virtual`),
    scroll: {
      ...scroll,
      x: scrollX
    },
    components: {
      ...components,
      // fix https://github.com/ant-design/ant-design/issues/48991
      body: data?.length ? renderBody : void 0
    },
    columns,
    internalHooks: INTERNAL_HOOKS,
    tailor: true,
    ref
  })));
};
var RefVirtualTable = React378.forwardRef(VirtualTable);
if (true) {
  RefVirtualTable.displayName = "VirtualTable";
}
var genVirtualTable = (shouldTriggerRender) => {
  return makeImmutable2(RefVirtualTable, shouldTriggerRender);
};
var VirtualTable_default = genVirtualTable();

// node_modules/antd/es/table/Column.js
var Column3 = (_) => null;
var Column_default2 = Column3;

// node_modules/antd/es/table/ColumnGroup.js
var ColumnGroup2 = (_) => null;
var ColumnGroup_default2 = ColumnGroup2;

// node_modules/antd/es/table/hooks/useSelection.js
var React383 = __toESM(require_react());
var import_react121 = __toESM(require_react());

// node_modules/@rc-component/tree/es/util.js
var import_react120 = __toESM(require_react());

// node_modules/@rc-component/tree/es/TreeNode.js
var import_react119 = __toESM(require_react());

// node_modules/@rc-component/tree/es/contextTypes.js
var React379 = __toESM(require_react());
var TreeContext = React379.createContext(null);
var UnstableContext3 = React379.createContext({});

// node_modules/@rc-component/tree/es/Indent.js
var React380 = __toESM(require_react());
var Indent = ({
  prefixCls,
  level,
  isStart,
  isEnd
}) => {
  const baseClassName = `${prefixCls}-indent-unit`;
  const list = [];
  for (let i = 0; i < level; i += 1) {
    list.push(React380.createElement("span", {
      key: i,
      className: clsx(baseClassName, {
        [`${baseClassName}-start`]: isStart[i],
        [`${baseClassName}-end`]: isEnd[i]
      })
    }));
  }
  return React380.createElement("span", {
    "aria-hidden": "true",
    className: `${prefixCls}-indent`
  }, list);
};
var Indent_default = React380.memo(Indent);

// node_modules/@rc-component/tree/es/TreeNode.js
function _extends69() {
  _extends69 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends69.apply(this, arguments);
}
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var TreeNode = (props) => {
  const {
    eventKey,
    className,
    style,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    isLeaf: isLeaf2,
    isStart,
    isEnd,
    expanded,
    selected,
    checked,
    halfChecked,
    loading,
    domRef,
    active,
    data,
    onMouseMove,
    selectable,
    ...otherProps
  } = props;
  const context = import_react119.default.useContext(TreeContext);
  const {
    classNames: treeClassNames,
    styles
  } = context || {};
  const unstableContext = import_react119.default.useContext(UnstableContext3);
  const selectHandleRef = import_react119.default.useRef(null);
  const [dragNodeHighlight, setDragNodeHighlight] = import_react119.default.useState(false);
  const isDisabled = !!(context.disabled || props.disabled || unstableContext.nodeDisabled?.(data));
  const isCheckable = import_react119.default.useMemo(() => {
    if (!context.checkable || props.checkable === false) {
      return false;
    }
    return context.checkable;
  }, [context.checkable, props.checkable]);
  const onSelect = (e3) => {
    if (isDisabled) {
      return;
    }
    context.onNodeSelect(e3, convertNodePropsToEventData(props));
  };
  const onCheck = (e3) => {
    if (isDisabled) {
      return;
    }
    if (!isCheckable || props.disableCheckbox) {
      return;
    }
    context.onNodeCheck(e3, convertNodePropsToEventData(props), !checked);
  };
  const isSelectable = import_react119.default.useMemo(() => {
    if (typeof selectable === "boolean") {
      return selectable;
    }
    return context.selectable;
  }, [selectable, context.selectable]);
  const onSelectorClick = (e3) => {
    context.onNodeClick(e3, convertNodePropsToEventData(props));
    if (isSelectable) {
      onSelect(e3);
    } else {
      onCheck(e3);
    }
  };
  const onSelectorDoubleClick = (e3) => {
    context.onNodeDoubleClick(e3, convertNodePropsToEventData(props));
  };
  const onMouseEnter = (e3) => {
    context.onNodeMouseEnter(e3, convertNodePropsToEventData(props));
  };
  const onMouseLeave = (e3) => {
    context.onNodeMouseLeave(e3, convertNodePropsToEventData(props));
  };
  const onContextMenu = (e3) => {
    context.onNodeContextMenu(e3, convertNodePropsToEventData(props));
  };
  const isDraggable = import_react119.default.useMemo(() => {
    return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
  }, [context.draggable, data]);
  const onDragStart = (e3) => {
    e3.stopPropagation();
    setDragNodeHighlight(true);
    context.onNodeDragStart(e3, props);
    try {
      e3.dataTransfer.setData("text/plain", "");
    } catch {
    }
  };
  const onDragEnter = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    context.onNodeDragEnter(e3, props);
  };
  const onDragOver = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    context.onNodeDragOver(e3, props);
  };
  const onDragLeave = (e3) => {
    e3.stopPropagation();
    context.onNodeDragLeave(e3, props);
  };
  const onDragEnd = (e3) => {
    e3.stopPropagation();
    setDragNodeHighlight(false);
    context.onNodeDragEnd(e3, props);
  };
  const onDrop = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    setDragNodeHighlight(false);
    context.onNodeDrop(e3, props);
  };
  const onExpand = (e3) => {
    if (loading) {
      return;
    }
    context.onNodeExpand(e3, convertNodePropsToEventData(props));
  };
  const hasChildren = import_react119.default.useMemo(() => {
    const {
      children
    } = getEntity(context.keyEntities, eventKey) || {};
    return Boolean((children || []).length);
  }, [context.keyEntities, eventKey]);
  const memoizedIsLeaf = import_react119.default.useMemo(() => {
    if (isLeaf2 === false) {
      return false;
    }
    return isLeaf2 || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
  }, [isLeaf2, context.loadData, hasChildren, props.loaded]);
  import_react119.default.useEffect(() => {
    if (loading) {
      return;
    }
    if (typeof context.loadData === "function" && expanded && !memoizedIsLeaf && !props.loaded) {
      context.onNodeLoad(convertNodePropsToEventData(props));
    }
  }, [loading, context.loadData, context.onNodeLoad, expanded, memoizedIsLeaf, props]);
  const dragHandlerNode = import_react119.default.useMemo(() => {
    if (!context.draggable?.icon) {
      return null;
    }
    return import_react119.default.createElement("span", {
      className: `${context.prefixCls}-draggable-icon`
    }, context.draggable.icon);
  }, [context.draggable]);
  const renderSwitcherIconDom = (isInternalLeaf) => {
    const switcherIcon = props.switcherIcon || context.switcherIcon;
    if (typeof switcherIcon === "function") {
      return switcherIcon({
        ...props,
        isLeaf: isInternalLeaf
      });
    }
    return switcherIcon;
  };
  const renderSwitcher = () => {
    if (memoizedIsLeaf) {
      const switcherIconDom2 = renderSwitcherIconDom(true);
      return switcherIconDom2 !== false ? import_react119.default.createElement("span", {
        className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher-noop`)
      }, switcherIconDom2) : null;
    }
    const switcherIconDom = renderSwitcherIconDom(false);
    return switcherIconDom !== false ? import_react119.default.createElement("span", {
      onClick: onExpand,
      className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher_${expanded ? ICON_OPEN : ICON_CLOSE}`)
    }, switcherIconDom) : null;
  };
  const checkboxNode = import_react119.default.useMemo(() => {
    if (!isCheckable) {
      return null;
    }
    const $custom = typeof isCheckable !== "boolean" ? isCheckable : null;
    return import_react119.default.createElement("span", {
      className: clsx(`${context.prefixCls}-checkbox`, {
        [`${context.prefixCls}-checkbox-checked`]: checked,
        [`${context.prefixCls}-checkbox-indeterminate`]: !checked && halfChecked,
        [`${context.prefixCls}-checkbox-disabled`]: isDisabled || props.disableCheckbox
      }),
      onClick: onCheck,
      role: "checkbox",
      "aria-checked": halfChecked ? "mixed" : checked,
      "aria-disabled": isDisabled || props.disableCheckbox,
      "aria-label": `Select ${typeof props.title === "string" ? props.title : "tree node"}`
    }, $custom);
  }, [isCheckable, checked, halfChecked, isDisabled, props.disableCheckbox, props.title]);
  const nodeState = import_react119.default.useMemo(() => {
    if (memoizedIsLeaf) {
      return null;
    }
    return expanded ? ICON_OPEN : ICON_CLOSE;
  }, [memoizedIsLeaf, expanded]);
  const iconNode = import_react119.default.useMemo(() => {
    return import_react119.default.createElement("span", {
      className: clsx(treeClassNames?.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__${nodeState || "docu"}`, {
        [`${context.prefixCls}-icon_loading`]: loading
      }),
      style: styles?.itemIcon
    });
  }, [context.prefixCls, nodeState, loading]);
  const dropIndicatorNode = import_react119.default.useMemo(() => {
    const rootDraggable = Boolean(context.draggable);
    const showIndicator = !props.disabled && rootDraggable && context.dragOverNodeKey === eventKey;
    if (!showIndicator) {
      return null;
    }
    return context.dropIndicatorRender({
      dropPosition: context.dropPosition,
      dropLevelOffset: context.dropLevelOffset,
      indent: context.indent,
      prefixCls: context.prefixCls,
      direction: context.direction
    });
  }, [context.dropPosition, context.dropLevelOffset, context.indent, context.prefixCls, context.direction, context.draggable, context.dragOverNodeKey, context.dropIndicatorRender]);
  const selectorNode = import_react119.default.useMemo(() => {
    const {
      title = defaultTitle
    } = props;
    const wrapClass = `${context.prefixCls}-node-content-wrapper`;
    let $icon;
    if (context.showIcon) {
      const currentIcon = props.icon || context.icon;
      $icon = currentIcon ? import_react119.default.createElement("span", {
        className: clsx(treeClassNames?.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__customize`),
        style: styles?.itemIcon
      }, typeof currentIcon === "function" ? currentIcon(props) : currentIcon) : iconNode;
    } else if (context.loadData && loading) {
      $icon = iconNode;
    }
    let titleNode;
    if (typeof title === "function") {
      titleNode = title(data);
    } else if (context.titleRender) {
      titleNode = context.titleRender(data);
    } else {
      titleNode = title;
    }
    return import_react119.default.createElement("span", {
      ref: selectHandleRef,
      title: typeof title === "string" ? title : "",
      className: clsx(wrapClass, `${wrapClass}-${nodeState || "normal"}`, {
        [`${context.prefixCls}-node-selected`]: !isDisabled && (selected || dragNodeHighlight)
      }),
      onMouseEnter,
      onMouseLeave,
      onContextMenu,
      onClick: onSelectorClick,
      onDoubleClick: onSelectorDoubleClick
    }, $icon, import_react119.default.createElement("span", {
      className: clsx(`${context.prefixCls}-title`, treeClassNames?.itemTitle),
      style: styles?.itemTitle
    }, titleNode), dropIndicatorNode);
  }, [context.prefixCls, context.showIcon, props, context.icon, iconNode, context.titleRender, data, nodeState, onMouseEnter, onMouseLeave, onContextMenu, onSelectorClick, onSelectorDoubleClick]);
  const dataOrAriaAttributeProps = pickAttrs(otherProps, {
    aria: true,
    data: true
  });
  const {
    level
  } = getEntity(context.keyEntities, eventKey) || {};
  const isEndNode = isEnd[isEnd.length - 1];
  const draggableWithoutDisabled = !isDisabled && isDraggable;
  const dragging = context.draggingNodeKey === eventKey;
  const ariaSelected = selectable !== void 0 ? {
    "aria-selected": !!selectable
  } : void 0;
  return import_react119.default.createElement("div", _extends69({
    ref: domRef,
    role: "treeitem",
    "aria-expanded": isLeaf2 ? void 0 : expanded,
    className: clsx(className, `${context.prefixCls}-treenode`, treeClassNames?.item, {
      [`${context.prefixCls}-treenode-disabled`]: isDisabled,
      [`${context.prefixCls}-treenode-switcher-${expanded ? "open" : "close"}`]: !isLeaf2,
      [`${context.prefixCls}-treenode-checkbox-checked`]: checked,
      [`${context.prefixCls}-treenode-checkbox-indeterminate`]: halfChecked,
      [`${context.prefixCls}-treenode-selected`]: selected,
      [`${context.prefixCls}-treenode-loading`]: loading,
      [`${context.prefixCls}-treenode-active`]: active,
      [`${context.prefixCls}-treenode-leaf-last`]: isEndNode,
      [`${context.prefixCls}-treenode-draggable`]: isDraggable,
      dragging,
      "drop-target": context.dropTargetKey === eventKey,
      "drop-container": context.dropContainerKey === eventKey,
      "drag-over": !isDisabled && dragOver,
      "drag-over-gap-top": !isDisabled && dragOverGapTop,
      "drag-over-gap-bottom": !isDisabled && dragOverGapBottom,
      "filter-node": context.filterTreeNode?.(convertNodePropsToEventData(props)),
      [`${context.prefixCls}-treenode-leaf`]: memoizedIsLeaf
    }),
    style: {
      ...style,
      ...styles?.item
    },
    draggable: draggableWithoutDisabled,
    onDragStart: draggableWithoutDisabled ? onDragStart : void 0,
    onDragEnter: isDraggable ? onDragEnter : void 0,
    onDragOver: isDraggable ? onDragOver : void 0,
    onDragLeave: isDraggable ? onDragLeave : void 0,
    onDrop: isDraggable ? onDrop : void 0,
    onDragEnd: isDraggable ? onDragEnd : void 0,
    onMouseMove
  }, ariaSelected, dataOrAriaAttributeProps), import_react119.default.createElement(Indent_default, {
    prefixCls: context.prefixCls,
    level,
    isStart,
    isEnd
  }), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
};
TreeNode.isTreeNode = 1;
if (true) {
  TreeNode.displayName = "TreeNode";
}
var TreeNode_default = TreeNode;

// node_modules/@rc-component/tree/es/util.js
function arrDel(list, value) {
  if (!list) return [];
  const clone = list.slice();
  const index2 = clone.indexOf(value);
  if (index2 >= 0) {
    clone.splice(index2, 1);
  }
  return clone;
}
function arrAdd(list, value) {
  const clone = (list || []).slice();
  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }
  return clone;
}
function posToArr(pos) {
  return pos.split("-");
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  const dragChildrenKeys = [];
  const entity = getEntity(keyEntities, dragNodeKey);
  function dig(list = []) {
    list.forEach(({
      key,
      children
    }) => {
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    const posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  const posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
  const {
    clientX,
    clientY
  } = event;
  const {
    top,
    height
  } = event.target.getBoundingClientRect();
  const horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * ((startMousePosition?.x || 0) - clientX);
  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  const filteredExpandKeys = expandKeys.filter((key) => keyEntities[key]?.children?.length);
  let abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);
  if (clientY < top + height / 2) {
    const nodeIndex = flattenedNodes.findIndex((flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key);
    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    const prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
  }
  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  const abstractDragOverEntity = abstractDropNodeEntity;
  const dragOverNodeKey = abstractDropNodeEntity.key;
  let dropPosition = 0;
  let dropLevelOffset = 0;
  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {
    for (let i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  const abstractDragDataNode = dragNodeProps.data;
  const abstractDropDataNode = abstractDropNodeEntity.node;
  let dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : abstractDropNodeEntity.parent?.key || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) return void 0;
  const {
    multiple
  } = props;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  }
  let keyProps;
  if (Array.isArray(keys)) {
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: void 0
    };
  } else if (typeof keys === "object") {
    keyProps = {
      checkedKeys: keys.checked || void 0,
      halfCheckedKeys: keys.halfChecked || void 0
    };
  } else {
    warning_default(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  const expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key) {
    if (expandedKeys.has(key)) return;
    const entity = getEntity(keyEntities, key);
    if (!entity) return;
    expandedKeys.add(key);
    const {
      parent,
      node
    } = entity;
    if (node.disabled) return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach((key) => {
    conductUp(key);
  });
  return [...expandedKeys];
}

// node_modules/antd/es/table/hooks/useSelection.js
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST4 = [];
var flattenData = (childrenColumnName, data, list = []) => {
  (data || []).forEach((record) => {
    list.push(record);
    if (record && typeof record === "object" && childrenColumnName in record) {
      flattenData(childrenColumnName, record[childrenColumnName], list);
    }
  });
  return list;
};
var useSelection = (config, rowSelection) => {
  const {
    preserveSelectedRowKeys,
    selectedRowKeys,
    defaultSelectedRowKeys,
    getCheckboxProps,
    getTitleCheckboxProps,
    onChange: onSelectionChange,
    onSelect,
    onSelectAll,
    onSelectInvert,
    onSelectNone,
    onSelectMultiple,
    columnWidth: selectionColWidth,
    type: selectionType,
    selections,
    fixed,
    renderCell: customizeRenderCell,
    hideSelectAll,
    checkStrictly = true
  } = rowSelection || {};
  const {
    prefixCls,
    data,
    pageData,
    getRecordByKey,
    getRowKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  } = config;
  const warning2 = devUseWarning("Table");
  const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
  const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(defaultSelectedRowKeys || EMPTY_LIST4, selectedRowKeys);
  const preserveRecordsRef = React383.useRef(/* @__PURE__ */ new Map());
  const updatePreserveRecordsCache = (0, import_react121.useCallback)((keys) => {
    if (preserveSelectedRowKeys) {
      const newCache = /* @__PURE__ */ new Map();
      keys.forEach((key) => {
        let record = getRecordByKey(key);
        if (!record && preserveRecordsRef.current.has(key)) {
          record = preserveRecordsRef.current.get(key);
        }
        newCache.set(key, record);
      });
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  React383.useEffect(() => {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  const flattedData = (0, import_react121.useMemo)(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
  const {
    keyEntities
  } = (0, import_react121.useMemo)(() => {
    if (checkStrictly) {
      return {
        keyEntities: null
      };
    }
    let convertData = data;
    if (preserveSelectedRowKeys) {
      const keysSet = new Set(flattedData.map(getRowKey));
      const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, [key, value]) => keysSet.has(key) ? total : total.concat(value), []);
      convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
    }
    return convertDataToEntities(convertData, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys, flattedData]);
  const checkboxPropsMap = (0, import_react121.useMemo)(() => {
    const map = /* @__PURE__ */ new Map();
    flattedData.forEach((record, index2) => {
      const key = getRowKey(record, index2);
      const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps);
      true ? warning2(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.") : void 0;
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  const isCheckboxDisabled = (0, import_react121.useCallback)((r2) => {
    const rowKey = getRowKey(r2);
    let checkboxProps;
    if (checkboxPropsMap.has(rowKey)) {
      checkboxProps = checkboxPropsMap.get(getRowKey(r2));
    } else {
      checkboxProps = getCheckboxProps ? getCheckboxProps(r2) : void 0;
    }
    return !!checkboxProps?.disabled;
  }, [checkboxPropsMap, getRowKey]);
  const [derivedSelectedKeys, derivedHalfSelectedKeys] = (0, import_react121.useMemo)(() => {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
  const derivedSelectedKeySet = (0, import_react121.useMemo)(() => {
    const keys = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys);
  }, [derivedSelectedKeys, selectionType]);
  const derivedHalfSelectedKeySet = (0, import_react121.useMemo)(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
  React383.useEffect(() => {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST4);
    }
  }, [!!rowSelection]);
  const setSelectedKeys = (0, import_react121.useCallback)((keys, method) => {
    let availableKeys;
    let records;
    updatePreserveRecordsCache(keys);
    if (preserveSelectedRowKeys) {
      availableKeys = keys;
      records = keys.map((key) => preserveRecordsRef.current.get(key));
    } else {
      availableKeys = [];
      records = [];
      keys.forEach((key) => {
        const record = getRecordByKey(key);
        if (record !== void 0) {
          availableKeys.push(key);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange?.(availableKeys, records, {
      type: method
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  const triggerSingleSelection = (0, import_react121.useCallback)((key, selected, keys, event) => {
    if (onSelect) {
      const rows = keys.map((k) => getRecordByKey(k));
      onSelect(getRecordByKey(key), selected, rows, event);
    }
    setSelectedKeys(keys, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  const mergedSelections = (0, import_react121.useMemo)(() => {
    if (!selections || hideSelectAll) {
      return null;
    }
    const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map((selection) => {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect() {
            setSelectedKeys(data.map((record, index2) => getRowKey(record, index2)).filter((key) => {
              const checkProps = checkboxPropsMap.get(key);
              return !checkProps?.disabled || derivedSelectedKeySet.has(key);
            }), "all");
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect() {
            const keySet = new Set(derivedSelectedKeySet);
            pageData.forEach((record, index2) => {
              const key = getRowKey(record, index2);
              const checkProps = checkboxPropsMap.get(key);
              if (!checkProps?.disabled) {
                if (keySet.has(key)) {
                  keySet.delete(key);
                } else {
                  keySet.add(key);
                }
              }
            });
            const keys = Array.from(keySet);
            if (onSelectInvert) {
              warning2.deprecated(false, "onSelectInvert", "onChange");
              onSelectInvert(keys);
            }
            setSelectedKeys(keys, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect() {
            onSelectNone?.();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
              const checkProps = checkboxPropsMap.get(key);
              return checkProps?.disabled;
            }), "none");
          }
        };
      }
      return selection;
    }).map((selection) => ({
      ...selection,
      onSelect: (...rest) => {
        selection.onSelect?.(...rest);
        updatePrevSelectedIndex(null);
      }
    }));
  }, [selections, hideSelectAll, tableLocale.selectionAll, tableLocale.selectInvert, tableLocale.selectNone, checkboxPropsMap, derivedSelectedKeySet, data, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  const transformColumns = (0, import_react121.useCallback)((columns) => {
    if (!rowSelection) {
      true ? warning2(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.") : void 0;
      return columns.filter((col) => col !== SELECTION_COLUMN);
    }
    let cloneColumns = _toConsumableArray(columns);
    const keySet = new Set(derivedSelectedKeySet);
    const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
    const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
    const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
    const onSelectAllChange = () => {
      const changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach((key) => {
          keySet.delete(key);
          changeKeys.push(key);
        });
      } else {
        recordKeys.forEach((key) => {
          if (!keySet.has(key)) {
            keySet.add(key);
            changeKeys.push(key);
          }
        });
      }
      const keys = Array.from(keySet);
      onSelectAll?.(!checkedCurrentAll, keys.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k)));
      setSelectedKeys(keys, "all");
      updatePrevSelectedIndex(null);
    };
    let title;
    let columnTitleCheckbox;
    if (selectionType !== "radio") {
      let customizeSelections;
      if (mergedSelections) {
        const menu = {
          getPopupContainer,
          items: mergedSelections.map((selection, index2) => {
            const {
              key,
              text,
              onSelect: onSelectionClick
            } = selection;
            return {
              key: key ?? index2,
              onClick: () => {
                onSelectionClick?.(recordKeys);
              },
              label: text
            };
          })
        };
        customizeSelections = React383.createElement("div", {
          className: `${prefixCls}-selection-extra`
        }, React383.createElement(dropdown_default2, {
          menu,
          getPopupContainer
        }, React383.createElement("span", null, React383.createElement(DownOutlined_default, null))));
      }
      const allDisabledData = flattedData.map((record, index2) => {
        const key = getRowKey(record, index2);
        const checkboxProps = checkboxPropsMap.get(key) || {};
        return {
          checked: keySet.has(key),
          ...checkboxProps
        };
      }).filter(({
        disabled: disabled2
      }) => disabled2);
      const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      const allDisabledAndChecked = allDisabled && allDisabledData.every(({
        checked
      }) => checked);
      const allDisabledSomeChecked = allDisabled && allDisabledData.some(({
        checked
      }) => checked);
      const customCheckboxProps = getTitleCheckboxProps?.() || {};
      const {
        onChange,
        disabled
      } = customCheckboxProps;
      columnTitleCheckbox = React383.createElement(checkbox_default, {
        "aria-label": customizeSelections ? "Custom selection" : "Select all",
        ...customCheckboxProps,
        checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
        indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        onChange: (e3) => {
          onSelectAllChange();
          onChange?.(e3);
        },
        disabled: disabled ?? (flattedData.length === 0 || allDisabled),
        skipGroup: true
      });
      title = !hideSelectAll && React383.createElement("div", {
        className: `${prefixCls}-selection`
      }, columnTitleCheckbox, customizeSelections);
    }
    let renderCell;
    if (selectionType === "radio") {
      renderCell = (_, record, index2) => {
        const key = getRowKey(record, index2);
        const checked = keySet.has(key);
        const checkboxProps = checkboxPropsMap.get(key);
        return {
          node: React383.createElement(radio_default2, {
            ...checkboxProps,
            checked,
            onClick: (e3) => {
              e3.stopPropagation();
              checkboxProps?.onClick?.(e3);
            },
            onChange: (event) => {
              if (!keySet.has(key)) {
                triggerSingleSelection(key, true, [key], event.nativeEvent);
              }
              checkboxProps?.onChange?.(event);
            }
          }),
          checked
        };
      };
    } else {
      renderCell = (_, record, index2) => {
        const key = getRowKey(record, index2);
        const checked = keySet.has(key);
        const indeterminate = derivedHalfSelectedKeySet.has(key);
        const checkboxProps = checkboxPropsMap.get(key);
        let mergedIndeterminate;
        if (expandType === "nest") {
          mergedIndeterminate = indeterminate;
          true ? warning2(typeof checkboxProps?.indeterminate !== "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.") : void 0;
        } else {
          mergedIndeterminate = checkboxProps?.indeterminate ?? indeterminate;
        }
        return {
          node: React383.createElement(checkbox_default, {
            ...checkboxProps,
            indeterminate: mergedIndeterminate,
            checked,
            skipGroup: true,
            onClick: (e3) => {
              e3.stopPropagation();
              checkboxProps?.onClick?.(e3);
            },
            onChange: (event) => {
              const {
                nativeEvent
              } = event;
              const {
                shiftKey
              } = nativeEvent;
              const currentSelectedIndex = recordKeys.indexOf(key);
              const isMultiple = derivedSelectedKeys.some((item) => recordKeys.includes(item));
              if (shiftKey && checkStrictly && isMultiple) {
                const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
                const keys = Array.from(keySet);
                onSelectMultiple?.(!checked, keys.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                setSelectedKeys(keys, "multiple");
              } else {
                const originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                  triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                } else {
                  const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                  const {
                    checkedKeys,
                    halfCheckedKeys
                  } = result;
                  let nextCheckedKeys = checkedKeys;
                  if (checked) {
                    const tempKeySet = new Set(checkedKeys);
                    tempKeySet.delete(key);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                updatePrevSelectedIndex(null);
              } else {
                updatePrevSelectedIndex(currentSelectedIndex);
              }
              checkboxProps?.onChange?.(event);
            }
          }),
          checked
        };
      };
    }
    const renderSelectionCell = (_, record, index2) => {
      const {
        node,
        checked
      } = renderCell(_, record, index2);
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex((col) => col[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN") === 0) {
        const [expandColumn, ...restColumns] = cloneColumns;
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    true ? warning2(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`.") : void 0;
    cloneColumns = cloneColumns.filter((column, index2) => column !== SELECTION_COLUMN || index2 === selectionColumnIndex);
    const prevCol = cloneColumns[selectionColumnIndex - 1];
    const nextCol = cloneColumns[selectionColumnIndex + 1];
    let mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if (nextCol?.fixed !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if (prevCol?.fixed !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && prevCol[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    const columnCls = clsx(`${prefixCls}-selection-col`, {
      [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
    });
    const renderColumnTitle2 = () => {
      if (!rowSelection?.columnTitle) {
        return title;
      }
      if (typeof rowSelection.columnTitle === "function") {
        return rowSelection.columnTitle(columnTitleCheckbox);
      }
      return rowSelection.columnTitle;
    };
    const selectionColumn = {
      fixed: mergedFixed,
      width: selectionColWidth,
      className: `${prefixCls}-selection-column`,
      title: renderColumnTitle2(),
      render: renderSelectionCell,
      onCell: rowSelection.onCell,
      align: rowSelection.align,
      [INTERNAL_COL_DEFINE]: {
        className: columnCls
      }
    };
    return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
};
var useSelection_default = useSelection;

// node_modules/antd/es/table/InternalTable.js
var React401 = __toESM(require_react());

// node_modules/antd/es/table/ExpandIcon.js
var React384 = __toESM(require_react());
function renderExpandIcon2(locale2) {
  return (props) => {
    const {
      prefixCls,
      onExpand,
      record,
      expanded,
      expandable
    } = props;
    const iconPrefix = `${prefixCls}-row-expand-icon`;
    return React384.createElement("button", {
      type: "button",
      onClick: (e3) => {
        onExpand(record, e3);
        e3.stopPropagation();
      },
      className: clsx(iconPrefix, {
        [`${iconPrefix}-spaced`]: !expandable,
        [`${iconPrefix}-expanded`]: expandable && expanded,
        [`${iconPrefix}-collapsed`]: expandable && !expanded
      }),
      "aria-label": expanded ? locale2.collapse : locale2.expand,
      "aria-expanded": expanded
    });
  };
}
var ExpandIcon_default = renderExpandIcon2;

// node_modules/antd/es/table/hooks/useContainerWidth.js
function useContainerWidth(prefixCls) {
  const getContainerWidth = (ele, width) => {
    const container = ele.querySelector(`.${prefixCls}-container`);
    let returnWidth = width;
    if (container) {
      const style = getComputedStyle(container);
      const borderLeft = Number.parseInt(style.borderLeftWidth, 10);
      const borderRight = Number.parseInt(style.borderRightWidth, 10);
      returnWidth = width - borderLeft - borderRight;
    }
    return returnWidth;
  };
  return getContainerWidth;
}

// node_modules/antd/es/table/hooks/useFilter/index.js
var React397 = __toESM(require_react());

// node_modules/antd/es/table/util.js
var getColumnKey = (column, defaultKey) => {
  if ("key" in column && column.key !== void 0 && column.key !== null) {
    return column.key;
  }
  if (column.dataIndex) {
    return Array.isArray(column.dataIndex) ? column.dataIndex.join(".") : column.dataIndex;
  }
  return defaultKey;
};
function getColumnPos(index2, pos) {
  return pos ? `${pos}-${index2}` : `${index2}`;
}
var renderColumnTitle = (title, props) => {
  if (typeof title === "function") {
    return title(props);
  }
  return title;
};
var safeColumnTitle = (title, props) => {
  const res = renderColumnTitle(title, props);
  if (Object.prototype.toString.call(res) === "[object Object]") {
    return "";
  }
  return res;
};

// node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
var React396 = __toESM(require_react());

// node_modules/@rc-component/tree/es/Tree.js
var React389 = __toESM(require_react());

// node_modules/@rc-component/tree/es/DropIndicator.js
var import_react122 = __toESM(require_react());
var DropIndicator = (props) => {
  const {
    dropPosition,
    dropLevelOffset,
    indent
  } = props;
  const style = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style.top = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 1:
      style.bottom = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 0:
      style.bottom = 0;
      style.left = indent;
      break;
  }
  return import_react122.default.createElement("div", {
    style
  });
};
if (true) {
  DropIndicator.displayName = "DropIndicator";
}
var DropIndicator_default = DropIndicator;

// node_modules/@rc-component/tree/es/NodeList.js
var React388 = __toESM(require_react());

// node_modules/@rc-component/tree/es/MotionTreeNode.js
var React387 = __toESM(require_react());

// node_modules/@rc-component/tree/es/useUnmount.js
var React386 = __toESM(require_react());
function useUnmount(triggerStart, triggerEnd) {
  const [firstMount, setFirstMount] = React386.useState(false);
  useLayoutEffect_default(() => {
    if (firstMount) {
      triggerStart();
      return () => {
        triggerEnd();
      };
    }
  }, [firstMount]);
  useLayoutEffect_default(() => {
    setFirstMount(true);
    return () => {
      setFirstMount(false);
    };
  }, []);
}
var useUnmount_default = useUnmount;

// node_modules/@rc-component/tree/es/MotionTreeNode.js
function _extends70() {
  _extends70 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends70.apply(this, arguments);
}
var MotionTreeNode = React387.forwardRef((oriProps, ref) => {
  const {
    className,
    style,
    motion: motion2,
    motionNodes,
    motionType,
    onMotionStart: onOriginMotionStart,
    onMotionEnd: onOriginMotionEnd,
    active,
    treeNodeRequiredProps,
    ...props
  } = oriProps;
  const [visible, setVisible] = React387.useState(true);
  const {
    prefixCls
  } = React387.useContext(TreeContext);
  const targetVisible = motionNodes && motionType !== "hide";
  useLayoutEffect_default(() => {
    if (motionNodes) {
      if (targetVisible !== visible) {
        setVisible(targetVisible);
      }
    }
  }, [motionNodes]);
  const triggerMotionStart = () => {
    if (motionNodes) {
      onOriginMotionStart();
    }
  };
  const triggerMotionEndRef = React387.useRef(false);
  const triggerMotionEnd = () => {
    if (motionNodes && !triggerMotionEndRef.current) {
      triggerMotionEndRef.current = true;
      onOriginMotionEnd();
    }
  };
  useUnmount_default(triggerMotionStart, triggerMotionEnd);
  const onVisibleChanged = (nextVisible) => {
    if (targetVisible === nextVisible) {
      triggerMotionEnd();
    }
  };
  if (motionNodes) {
    return React387.createElement(es_default4, _extends70({
      ref,
      visible
    }, motion2, {
      motionAppear: motionType === "show",
      onVisibleChanged
    }), ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => React387.createElement("div", {
      ref: motionRef,
      className: clsx(`${prefixCls}-treenode-motion`, motionClassName),
      style: motionStyle
    }, motionNodes.map((treeNode) => {
      const {
        data: {
          ...restProps
        },
        title,
        key,
        isStart,
        isEnd
      } = treeNode;
      delete restProps.children;
      const treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
      return React387.createElement(TreeNode_default, _extends70({}, restProps, treeNodeProps, {
        title,
        active,
        data: treeNode.data,
        key,
        isStart,
        isEnd
      }));
    })));
  }
  return React387.createElement(TreeNode_default, _extends70({
    domRef: ref,
    className,
    style
  }, props, {
    active
  }));
});
if (true) {
  MotionTreeNode.displayName = "MotionTreeNode";
}
var MotionTreeNode_default = MotionTreeNode;

// node_modules/@rc-component/tree/es/utils/diffUtil.js
function findExpandedKeys(prev = [], next = []) {
  const prevLen = prev.length;
  const nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find(shorter, longer) {
    const cache = /* @__PURE__ */ new Map();
    shorter.forEach((key) => {
      cache.set(key, true);
    });
    const keys = longer.filter((key) => !cache.has(key));
    return keys.length === 1 ? keys[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev, next)
    };
  }
  return {
    add: false,
    key: find(next, prev)
  };
}
function getExpandRange(shorter, longer, key) {
  const shorterStartIndex = shorter.findIndex((data) => data.key === key);
  const shorterEndNode = shorter[shorterStartIndex + 1];
  const longerStartIndex = longer.findIndex((data) => data.key === key);
  if (shorterEndNode) {
    const longerEndIndex = longer.findIndex((data) => data.key === shorterEndNode.key);
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}

// node_modules/@rc-component/tree/es/NodeList.js
function _extends71() {
  _extends71 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends71.apply(this, arguments);
}
var HIDDEN_STYLE2 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop3 = () => {
};
var MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  const {
    key,
    pos
  } = item;
  return getKey3(key, pos);
}
function getAccessibilityPath(item) {
  let path2 = String(item.data.key);
  let current = item;
  while (current.parent) {
    current = current.parent;
    path2 = `${current.data.key} > ${path2}`;
  }
  return path2;
}
var NodeList = React388.forwardRef((props, ref) => {
  const {
    prefixCls,
    data,
    selectable,
    checkable,
    expandedKeys,
    selectedKeys,
    checkedKeys,
    loadedKeys,
    loadingKeys,
    halfCheckedKeys,
    keyEntities,
    disabled,
    dragging,
    dragOverNodeKey,
    dropPosition,
    motion: motion2,
    height,
    itemHeight,
    virtual,
    scrollWidth,
    focusable,
    activeItem,
    focused,
    tabIndex,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    onActiveChange,
    onListChangeStart,
    onListChangeEnd,
    ...domProps
  } = props;
  const listRef = React388.useRef(null);
  const indentMeasurerRef = React388.useRef(null);
  React388.useImperativeHandle(ref, () => ({
    scrollTo: (scroll) => {
      listRef.current.scrollTo(scroll);
    },
    getIndentWidth: () => indentMeasurerRef.current.offsetWidth
  }));
  const [prevExpandedKeys, setPrevExpandedKeys] = React388.useState(expandedKeys);
  const [prevData, setPrevData] = React388.useState(data);
  const [transitionData, setTransitionData] = React388.useState(data);
  const [transitionRange, setTransitionRange] = React388.useState([]);
  const [motionType, setMotionType] = React388.useState(null);
  const dataRef = React388.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    const latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  useLayoutEffect_default(() => {
    setPrevExpandedKeys(expandedKeys);
    const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        const keyIndex2 = prevData.findIndex(({
          key
        }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
        const newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        const keyIndex2 = data.findIndex(({
          key
        }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
        const newTransitionData = data.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data) {
      setPrevData(data);
      setTransitionData(data);
    }
  }, [expandedKeys, data]);
  React388.useEffect(() => {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  const mergedData = motion2 ? transitionData : data;
  const treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return React388.createElement(React388.Fragment, null, focused && activeItem && React388.createElement("span", {
    style: HIDDEN_STYLE2,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), React388.createElement("div", null, React388.createElement("input", {
    style: HIDDEN_STYLE2,
    disabled: focusable === false || disabled,
    tabIndex: focusable !== false ? tabIndex : null,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    value: "",
    onChange: noop3,
    "aria-label": "for screen reader"
  })), React388.createElement("div", {
    className: `${prefixCls}-treenode`,
    "aria-hidden": true,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden",
      border: 0,
      padding: 0
    }
  }, React388.createElement("div", {
    className: `${prefixCls}-indent`
  }, React388.createElement("div", {
    ref: indentMeasurerRef,
    className: `${prefixCls}-indent-unit`
  }))), React388.createElement(es_default7, _extends71({}, domProps, {
    data: mergedData,
    itemKey,
    height,
    fullHeight: false,
    virtual,
    itemHeight,
    scrollWidth,
    prefixCls: `${prefixCls}-list`,
    ref: listRef,
    role: "tree",
    onVisibleChange: (originList) => {
      if (originList.every((item) => itemKey(item) !== MOTION_KEY)) {
        onMotionEnd();
      }
    }
  }), (treeNode) => {
    const {
      pos,
      data: {
        ...restProps
      },
      title,
      key,
      isStart,
      isEnd
    } = treeNode;
    const mergedKey = getKey3(key, pos);
    delete restProps.key;
    delete restProps.children;
    const treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return React388.createElement(MotionTreeNode_default, _extends71({}, restProps, treeNodeProps, {
      title,
      active: !!activeItem && key === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion: motion2,
      motionNodes: key === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: () => {
        onActiveChange(null);
      }
    }));
  }));
});
if (true) {
  NodeList.displayName = "NodeList";
}
var NodeList_default = NodeList;

// node_modules/@rc-component/tree/es/Tree.js
function _extends72() {
  _extends72 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends72.apply(this, arguments);
}
var MAX_RETRY_TIMES = 10;
var Tree = class extends React389.Component {
  static defaultProps = {
    prefixCls: "rc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator_default,
    allowDrop: () => true,
    expandAction: false
  };
  static TreeNode = TreeNode_default;
  destroyed = false;
  delayedDragEnterLogic;
  loadingRetryTimes = {};
  state = {
    keyEntities: {},
    indent: null,
    selectedKeys: [],
    checkedKeys: [],
    halfCheckedKeys: [],
    loadedKeys: [],
    loadingKeys: [],
    expandedKeys: [],
    draggingNodeKey: null,
    dragChildrenKeys: [],
    // dropTargetKey is the key of abstract-drop-node
    // the abstract-drop-node is the real drop node when drag and drop
    // not the DOM drag over node
    dropTargetKey: null,
    dropPosition: null,
    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
    dropContainerKey: null,
    // the container key of abstract-drop-node if dropPosition is -1 or 1
    dropLevelOffset: null,
    // the drop level offset of abstract-drag-over-node
    dropTargetPos: null,
    // the pos of abstract-drop-node
    dropAllowed: true,
    // if drop to abstract-drop-node is allowed
    // the abstract-drag-over-node
    // if mouse is on the bottom of top dom node or no the top of the bottom dom node
    // abstract-drag-over-node is the top node
    dragOverNodeKey: null,
    treeData: [],
    flattenNodes: [],
    focused: false,
    activeKey: null,
    listChanging: false,
    prevProps: null,
    fieldNames: fillFieldNames2()
  };
  dragStartMousePosition = null;
  dragNodeProps = null;
  currentMouseOverDroppableNodeKey = null;
  listRef = React389.createRef();
  componentDidMount() {
    this.destroyed = false;
    this.onUpdated();
  }
  componentDidUpdate() {
    this.onUpdated();
  }
  onUpdated() {
    const {
      activeKey,
      itemScrollOffset = 0
    } = this.props;
    if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
      this.setState({
        activeKey
      });
      if (activeKey !== null) {
        this.scrollTo({
          key: activeKey,
          offset: itemScrollOffset
        });
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("dragend", this.onWindowDragEnd);
    this.destroyed = true;
  }
  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps
    } = prevState;
    const newState = {
      prevProps: props
    };
    function needSync(name) {
      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
    }
    let treeData;
    let {
      fieldNames
    } = prevState;
    if (needSync("fieldNames")) {
      fieldNames = fillFieldNames2(props.fieldNames);
      newState.fieldNames = fieldNames;
    }
    if (needSync("treeData")) {
      ({
        treeData
      } = props);
    } else if (needSync("children")) {
      warning_default(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
      treeData = convertTreeToData(props.children);
    }
    if (treeData) {
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData, {
        fieldNames
      });
      newState.keyEntities = {
        [MOTION_KEY]: MotionEntity,
        ...entitiesMap.keyEntities
      };
      if (true) {
        warningWithoutKey(treeData, fieldNames);
      }
    }
    const keyEntities = newState.keyEntities || prevState.keyEntities;
    if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
    } else if (!prevProps && props.defaultExpandAll) {
      const cloneKeyEntities = {
        ...keyEntities
      };
      delete cloneKeyEntities[MOTION_KEY];
      const nextExpandedKeys = [];
      Object.keys(cloneKeyEntities).forEach((key) => {
        const entity = cloneKeyEntities[key];
        if (entity.children && entity.children.length) {
          nextExpandedKeys.push(entity.key);
        }
      });
      newState.expandedKeys = nextExpandedKeys;
    } else if (!prevProps && props.defaultExpandedKeys) {
      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
    }
    if (!newState.expandedKeys) {
      delete newState.expandedKeys;
    }
    if (treeData || newState.expandedKeys) {
      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
      newState.flattenNodes = flattenNodes;
    }
    if (props.selectable) {
      if (needSync("selectedKeys")) {
        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
      } else if (!prevProps && props.defaultSelectedKeys) {
        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
      }
    }
    if (props.checkable) {
      let checkedKeyEntity;
      if (needSync("checkedKeys")) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
      } else if (!prevProps && props.defaultCheckedKeys) {
        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
      } else if (treeData) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
          checkedKeys: prevState.checkedKeys,
          halfCheckedKeys: prevState.halfCheckedKeys
        };
      }
      if (checkedKeyEntity) {
        let {
          checkedKeys = [],
          halfCheckedKeys = []
        } = checkedKeyEntity;
        if (!props.checkStrictly) {
          const conductKeys = conductCheck(checkedKeys, true, keyEntities);
          ({
            checkedKeys,
            halfCheckedKeys
          } = conductKeys);
        }
        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
      }
    }
    if (needSync("loadedKeys")) {
      newState.loadedKeys = props.loadedKeys;
    }
    return newState;
  }
  onNodeDragStart = (event, nodeProps) => {
    const {
      expandedKeys,
      keyEntities
    } = this.state;
    const {
      onDragStart
    } = this.props;
    const {
      eventKey
    } = nodeProps;
    this.dragNodeProps = nodeProps;
    this.dragStartMousePosition = {
      x: event.clientX,
      y: event.clientY
    };
    const newExpandedKeys = arrDel(expandedKeys, eventKey);
    this.setState({
      draggingNodeKey: eventKey,
      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
      indent: this.listRef.current.getIndentWidth()
    });
    this.setExpandedKeys(newExpandedKeys);
    window.addEventListener("dragend", this.onWindowDragEnd);
    onDragStart?.({
      event,
      node: convertNodePropsToEventData(nodeProps)
    });
  };
  /**
   * [Legacy] Select handler is smaller than node,
   * so that this will trigger when drag enter node or select handler.
   * This is a little tricky if customize css without padding.
   * Better for use mouse move event to refresh drag state.
   * But let's just keep it to avoid event trigger logic change.
   */
  onNodeDragEnter = (event, nodeProps) => {
    const {
      expandedKeys,
      keyEntities,
      dragChildrenKeys,
      flattenNodes,
      indent
    } = this.state;
    const {
      onDragEnter,
      onExpand,
      allowDrop,
      direction
    } = this.props;
    const {
      pos,
      eventKey
    } = nodeProps;
    if (this.currentMouseOverDroppableNodeKey !== eventKey) {
      this.currentMouseOverDroppableNodeKey = eventKey;
    }
    if (!this.dragNodeProps) {
      this.resetDragState();
      return;
    }
    const {
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropTargetPos,
      dropAllowed,
      dragOverNodeKey
    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
    if (
      // don't allow drop inside its children
      dragChildrenKeys.includes(dropTargetKey) || // don't allow drop when drop is not allowed caculated by calcDropPosition
      !dropAllowed
    ) {
      this.resetDragState();
      return;
    }
    if (!this.delayedDragEnterLogic) {
      this.delayedDragEnterLogic = {};
    }
    Object.keys(this.delayedDragEnterLogic).forEach((key) => {
      clearTimeout(this.delayedDragEnterLogic[key]);
    });
    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {
      event.persist();
      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {
        if (this.state.draggingNodeKey === null) {
          return;
        }
        let newExpandedKeys = [...expandedKeys];
        const entity = getEntity(keyEntities, nodeProps.eventKey);
        if (entity && (entity.children || []).length) {
          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);
        }
        if (!this.props.hasOwnProperty("expandedKeys")) {
          this.setExpandedKeys(newExpandedKeys);
        }
        onExpand?.(newExpandedKeys, {
          node: convertNodePropsToEventData(nodeProps),
          expanded: true,
          nativeEvent: event.nativeEvent
        });
      }, 800);
    }
    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
      this.resetDragState();
      return;
    }
    this.setState({
      dragOverNodeKey,
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropTargetPos,
      dropAllowed
    });
    onDragEnter?.({
      event,
      node: convertNodePropsToEventData(nodeProps),
      expandedKeys
    });
  };
  onNodeDragOver = (event, nodeProps) => {
    const {
      dragChildrenKeys,
      flattenNodes,
      keyEntities,
      expandedKeys,
      indent
    } = this.state;
    const {
      onDragOver,
      allowDrop,
      direction
    } = this.props;
    if (!this.dragNodeProps) {
      return;
    }
    const {
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropTargetPos,
      dropAllowed,
      dragOverNodeKey
    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {
      return;
    }
    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {
        this.resetDragState();
      }
    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {
      this.setState({
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed,
        dragOverNodeKey
      });
    }
    onDragOver?.({
      event,
      node: convertNodePropsToEventData(nodeProps)
    });
  };
  onNodeDragLeave = (event, nodeProps) => {
    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
      this.resetDragState();
      this.currentMouseOverDroppableNodeKey = null;
    }
    const {
      onDragLeave
    } = this.props;
    onDragLeave?.({
      event,
      node: convertNodePropsToEventData(nodeProps)
    });
  };
  // since stopPropagation() is called in treeNode
  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared
  onWindowDragEnd = (event) => {
    this.onNodeDragEnd(event, null, true);
    window.removeEventListener("dragend", this.onWindowDragEnd);
  };
  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called
  onNodeDragEnd = (event, nodeProps) => {
    const {
      onDragEnd
    } = this.props;
    this.setState({
      dragOverNodeKey: null
    });
    this.cleanDragState();
    onDragEnd?.({
      event,
      node: convertNodePropsToEventData(nodeProps)
    });
    this.dragNodeProps = null;
    window.removeEventListener("dragend", this.onWindowDragEnd);
  };
  onNodeDrop = (event, _, outsideTree = false) => {
    const {
      dragChildrenKeys,
      dropPosition,
      dropTargetKey,
      dropTargetPos,
      dropAllowed
    } = this.state;
    if (!dropAllowed) {
      return;
    }
    const {
      onDrop
    } = this.props;
    this.setState({
      dragOverNodeKey: null
    });
    this.cleanDragState();
    if (dropTargetKey === null) return;
    const abstractDropNodeProps = {
      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),
      active: this.getActiveItem()?.key === dropTargetKey,
      data: getEntity(this.state.keyEntities, dropTargetKey).node
    };
    const dropToChild = dragChildrenKeys.includes(dropTargetKey);
    warning_default(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
    const posArr = posToArr(dropTargetPos);
    const dropResult = {
      event,
      node: convertNodePropsToEventData(abstractDropNodeProps),
      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,
      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),
      dropToGap: dropPosition !== 0,
      dropPosition: dropPosition + Number(posArr[posArr.length - 1])
    };
    if (!outsideTree) {
      onDrop?.(dropResult);
    }
    this.dragNodeProps = null;
  };
  resetDragState() {
    this.setState({
      dragOverNodeKey: null,
      dropPosition: null,
      dropLevelOffset: null,
      dropTargetKey: null,
      dropContainerKey: null,
      dropTargetPos: null,
      dropAllowed: false
    });
  }
  cleanDragState = () => {
    const {
      draggingNodeKey
    } = this.state;
    if (draggingNodeKey !== null) {
      this.setState({
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: true,
        dragOverNodeKey: null
      });
    }
    this.dragStartMousePosition = null;
    this.currentMouseOverDroppableNodeKey = null;
  };
  triggerExpandActionExpand = (e3, treeNode) => {
    const {
      expandedKeys,
      flattenNodes
    } = this.state;
    const {
      expanded,
      key,
      isLeaf: isLeaf2
    } = treeNode;
    if (isLeaf2 || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
      return;
    }
    const node = flattenNodes.filter((nodeItem) => nodeItem.key === key)[0];
    const eventNode = convertNodePropsToEventData({
      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),
      data: node.data
    });
    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
    this.onNodeExpand(e3, eventNode);
  };
  onNodeClick = (e3, treeNode) => {
    const {
      onClick,
      expandAction
    } = this.props;
    if (expandAction === "click") {
      this.triggerExpandActionExpand(e3, treeNode);
    }
    onClick?.(e3, treeNode);
  };
  onNodeDoubleClick = (e3, treeNode) => {
    const {
      onDoubleClick,
      expandAction
    } = this.props;
    if (expandAction === "doubleClick") {
      this.triggerExpandActionExpand(e3, treeNode);
    }
    onDoubleClick?.(e3, treeNode);
  };
  onNodeSelect = (e3, treeNode) => {
    let {
      selectedKeys
    } = this.state;
    const {
      keyEntities,
      fieldNames
    } = this.state;
    const {
      onSelect,
      multiple
    } = this.props;
    const {
      selected
    } = treeNode;
    const key = treeNode[fieldNames.key];
    const targetSelected = !selected;
    if (!targetSelected) {
      selectedKeys = arrDel(selectedKeys, key);
    } else if (!multiple) {
      selectedKeys = [key];
    } else {
      selectedKeys = arrAdd(selectedKeys, key);
    }
    const selectedNodes = selectedKeys.map((selectedKey) => {
      const entity = getEntity(keyEntities, selectedKey);
      return entity ? entity.node : null;
    }).filter(Boolean);
    this.setUncontrolledState({
      selectedKeys
    });
    onSelect?.(selectedKeys, {
      event: "select",
      selected: targetSelected,
      node: treeNode,
      selectedNodes,
      nativeEvent: e3.nativeEvent
    });
  };
  onNodeCheck = (e3, treeNode, checked) => {
    const {
      keyEntities,
      checkedKeys: oriCheckedKeys,
      halfCheckedKeys: oriHalfCheckedKeys
    } = this.state;
    const {
      checkStrictly,
      onCheck
    } = this.props;
    const {
      key
    } = treeNode;
    let checkedObj;
    const eventObj = {
      event: "check",
      node: treeNode,
      checked,
      nativeEvent: e3.nativeEvent
    };
    if (checkStrictly) {
      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
      checkedObj = {
        checked: checkedKeys,
        halfChecked: halfCheckedKeys
      };
      eventObj.checkedNodes = checkedKeys.map((checkedKey) => getEntity(keyEntities, checkedKey)).filter(Boolean).map((entity) => entity.node);
      this.setUncontrolledState({
        checkedKeys
      });
    } else {
      let {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);
      if (!checked) {
        const keySet = new Set(checkedKeys);
        keySet.delete(key);
        ({
          checkedKeys,
          halfCheckedKeys
        } = conductCheck(Array.from(keySet), {
          checked: false,
          halfCheckedKeys
        }, keyEntities));
      }
      checkedObj = checkedKeys;
      eventObj.checkedNodes = [];
      eventObj.checkedNodesPositions = [];
      eventObj.halfCheckedKeys = halfCheckedKeys;
      checkedKeys.forEach((checkedKey) => {
        const entity = getEntity(keyEntities, checkedKey);
        if (!entity) return;
        const {
          node,
          pos
        } = entity;
        eventObj.checkedNodes.push(node);
        eventObj.checkedNodesPositions.push({
          node,
          pos
        });
      });
      this.setUncontrolledState({
        checkedKeys
      }, false, {
        halfCheckedKeys
      });
    }
    onCheck?.(checkedObj, eventObj);
  };
  onNodeLoad = (treeNode) => {
    const {
      key
    } = treeNode;
    const {
      keyEntities
    } = this.state;
    const entity = getEntity(keyEntities, key);
    if (entity?.children?.length) {
      return;
    }
    const loadPromise = new Promise((resolve, reject) => {
      this.setState(({
        loadedKeys = [],
        loadingKeys = []
      }) => {
        const {
          loadData,
          onLoad
        } = this.props;
        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {
          return null;
        }
        const promise = loadData(treeNode);
        promise.then(() => {
          const {
            loadedKeys: currentLoadedKeys
          } = this.state;
          const newLoadedKeys = arrAdd(currentLoadedKeys, key);
          onLoad?.(newLoadedKeys, {
            event: "load",
            node: treeNode
          });
          this.setUncontrolledState({
            loadedKeys: newLoadedKeys
          });
          this.setState((prevState) => ({
            loadingKeys: arrDel(prevState.loadingKeys, key)
          }));
          resolve();
        }).catch((e3) => {
          this.setState((prevState) => ({
            loadingKeys: arrDel(prevState.loadingKeys, key)
          }));
          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;
          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
            const {
              loadedKeys: currentLoadedKeys
            } = this.state;
            warning_default(false, "Retry for `loadData` many times but still failed. No more retry.");
            this.setUncontrolledState({
              loadedKeys: arrAdd(currentLoadedKeys, key)
            });
            resolve();
          }
          reject(e3);
        });
        return {
          loadingKeys: arrAdd(loadingKeys, key)
        };
      });
    });
    loadPromise.catch(() => {
    });
    return loadPromise;
  };
  onNodeMouseEnter = (event, node) => {
    const {
      onMouseEnter
    } = this.props;
    onMouseEnter?.({
      event,
      node
    });
  };
  onNodeMouseLeave = (event, node) => {
    const {
      onMouseLeave
    } = this.props;
    onMouseLeave?.({
      event,
      node
    });
  };
  onNodeContextMenu = (event, node) => {
    const {
      onRightClick
    } = this.props;
    if (onRightClick) {
      event.preventDefault();
      onRightClick({
        event,
        node
      });
    }
  };
  onFocus = (...args) => {
    const {
      onFocus
    } = this.props;
    this.setState({
      focused: true
    });
    onFocus?.(...args);
  };
  onBlur = (...args) => {
    const {
      onBlur
    } = this.props;
    this.setState({
      focused: false
    });
    this.onActiveChange(null);
    onBlur?.(...args);
  };
  getTreeNodeRequiredProps = () => {
    const {
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      dragOverNodeKey,
      dropPosition,
      keyEntities
    } = this.state;
    return {
      expandedKeys: expandedKeys || [],
      selectedKeys: selectedKeys || [],
      loadedKeys: loadedKeys || [],
      loadingKeys: loadingKeys || [],
      checkedKeys: checkedKeys || [],
      halfCheckedKeys: halfCheckedKeys || [],
      dragOverNodeKey,
      dropPosition,
      keyEntities
    };
  };
  // =========================== Expanded ===========================
  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
  setExpandedKeys = (expandedKeys) => {
    const {
      treeData,
      fieldNames
    } = this.state;
    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
    this.setUncontrolledState({
      expandedKeys,
      flattenNodes
    }, true);
  };
  onNodeExpand = (e3, treeNode) => {
    let {
      expandedKeys
    } = this.state;
    const {
      listChanging,
      fieldNames
    } = this.state;
    const {
      onExpand,
      loadData
    } = this.props;
    const {
      expanded
    } = treeNode;
    const key = treeNode[fieldNames.key];
    if (listChanging) {
      return;
    }
    const certain = expandedKeys.includes(key);
    const targetExpanded = !expanded;
    warning_default(expanded && certain || !expanded && !certain, "Expand state not sync with index check");
    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);
    this.setExpandedKeys(expandedKeys);
    onExpand?.(expandedKeys, {
      node: treeNode,
      expanded: targetExpanded,
      nativeEvent: e3.nativeEvent
    });
    if (targetExpanded && loadData) {
      const loadPromise = this.onNodeLoad(treeNode);
      if (loadPromise) {
        loadPromise.then(() => {
          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);
          this.setUncontrolledState({
            flattenNodes: newFlattenTreeData
          });
        }).catch(() => {
          const {
            expandedKeys: currentExpandedKeys
          } = this.state;
          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);
          this.setExpandedKeys(expandedKeysToRestore);
        });
      }
    }
  };
  onListChangeStart = () => {
    this.setUncontrolledState({
      listChanging: true
    });
  };
  onListChangeEnd = () => {
    setTimeout(() => {
      this.setUncontrolledState({
        listChanging: false
      });
    });
  };
  // =========================== Keyboard ===========================
  onActiveChange = (newActiveKey) => {
    const {
      activeKey
    } = this.state;
    const {
      onActiveChange,
      itemScrollOffset = 0
    } = this.props;
    if (activeKey === newActiveKey) {
      return;
    }
    this.setState({
      activeKey: newActiveKey
    });
    if (newActiveKey !== null) {
      this.scrollTo({
        key: newActiveKey,
        offset: itemScrollOffset
      });
    }
    onActiveChange?.(newActiveKey);
  };
  getActiveItem = () => {
    const {
      activeKey,
      flattenNodes
    } = this.state;
    if (activeKey === null) {
      return null;
    }
    return flattenNodes.find(({
      key
    }) => key === activeKey) || null;
  };
  offsetActiveKey = (offset3) => {
    const {
      flattenNodes,
      activeKey
    } = this.state;
    let index2 = flattenNodes.findIndex(({
      key
    }) => key === activeKey);
    if (index2 === -1 && offset3 < 0) {
      index2 = flattenNodes.length;
    }
    index2 = (index2 + offset3 + flattenNodes.length) % flattenNodes.length;
    const item = flattenNodes[index2];
    if (item) {
      const {
        key
      } = item;
      this.onActiveChange(key);
    } else {
      this.onActiveChange(null);
    }
  };
  onKeyDown = (event) => {
    const {
      activeKey,
      expandedKeys,
      checkedKeys,
      fieldNames
    } = this.state;
    const {
      onKeyDown: onKeyDown2,
      checkable,
      selectable
    } = this.props;
    switch (event.which) {
      case KeyCode_default.UP: {
        this.offsetActiveKey(-1);
        event.preventDefault();
        break;
      }
      case KeyCode_default.DOWN: {
        this.offsetActiveKey(1);
        event.preventDefault();
        break;
      }
    }
    const activeItem = this.getActiveItem();
    if (activeItem && activeItem.data) {
      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();
      const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
      const eventNode = convertNodePropsToEventData({
        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),
        data: activeItem.data,
        active: true
      });
      switch (event.which) {
        // >>> Expand
        case KeyCode_default.LEFT: {
          if (expandable && expandedKeys.includes(activeKey)) {
            this.onNodeExpand({}, eventNode);
          } else if (activeItem.parent) {
            this.onActiveChange(activeItem.parent.key);
          }
          event.preventDefault();
          break;
        }
        case KeyCode_default.RIGHT: {
          if (expandable && !expandedKeys.includes(activeKey)) {
            this.onNodeExpand({}, eventNode);
          } else if (activeItem.children && activeItem.children.length) {
            this.onActiveChange(activeItem.children[0].key);
          }
          event.preventDefault();
          break;
        }
        // Selection
        case KeyCode_default.ENTER:
        case KeyCode_default.SPACE: {
          if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
            this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
          } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
            this.onNodeSelect({}, eventNode);
          }
          break;
        }
      }
    }
    onKeyDown2?.(event);
  };
  /**
   * Only update the value which is not in props
   */
  setUncontrolledState = (state, atomic = false, forceState = null) => {
    if (!this.destroyed) {
      let needSync = false;
      let allPassed = true;
      const newState = {};
      Object.keys(state).forEach((name) => {
        if (this.props.hasOwnProperty(name)) {
          allPassed = false;
          return;
        }
        needSync = true;
        newState[name] = state[name];
      });
      if (needSync && (!atomic || allPassed)) {
        this.setState({
          ...newState,
          ...forceState
        });
      }
    }
  };
  scrollTo = (scroll) => {
    this.listRef.current.scrollTo(scroll);
  };
  render() {
    const {
      focused,
      flattenNodes,
      keyEntities,
      draggingNodeKey,
      activeKey,
      dropLevelOffset,
      dropContainerKey,
      dropTargetKey,
      dropPosition,
      dragOverNodeKey,
      indent
    } = this.state;
    const {
      prefixCls,
      className,
      style,
      styles,
      classNames: treeClassNames,
      showLine,
      focusable,
      tabIndex = 0,
      selectable,
      showIcon,
      icon,
      switcherIcon,
      draggable,
      checkable,
      checkStrictly,
      disabled,
      motion: motion2,
      loadData,
      filterTreeNode,
      height,
      itemHeight,
      scrollWidth,
      virtual,
      titleRender,
      dropIndicatorRender: dropIndicatorRender2,
      onContextMenu,
      onScroll,
      direction,
      rootClassName,
      rootStyle
    } = this.props;
    const domProps = pickAttrs(this.props, {
      aria: true,
      data: true
    });
    let draggableConfig;
    if (draggable) {
      if (typeof draggable === "object") {
        draggableConfig = draggable;
      } else if (typeof draggable === "function") {
        draggableConfig = {
          nodeDraggable: draggable
        };
      } else {
        draggableConfig = {};
      }
    }
    const contextValue = {
      styles,
      classNames: treeClassNames,
      prefixCls,
      selectable,
      showIcon,
      icon,
      switcherIcon,
      draggable: draggableConfig,
      draggingNodeKey,
      checkable,
      checkStrictly,
      disabled,
      keyEntities,
      dropLevelOffset,
      dropContainerKey,
      dropTargetKey,
      dropPosition,
      dragOverNodeKey,
      indent,
      direction,
      dropIndicatorRender: dropIndicatorRender2,
      loadData,
      filterTreeNode,
      titleRender,
      onNodeClick: this.onNodeClick,
      onNodeDoubleClick: this.onNodeDoubleClick,
      onNodeExpand: this.onNodeExpand,
      onNodeSelect: this.onNodeSelect,
      onNodeCheck: this.onNodeCheck,
      onNodeLoad: this.onNodeLoad,
      onNodeMouseEnter: this.onNodeMouseEnter,
      onNodeMouseLeave: this.onNodeMouseLeave,
      onNodeContextMenu: this.onNodeContextMenu,
      onNodeDragStart: this.onNodeDragStart,
      onNodeDragEnter: this.onNodeDragEnter,
      onNodeDragOver: this.onNodeDragOver,
      onNodeDragLeave: this.onNodeDragLeave,
      onNodeDragEnd: this.onNodeDragEnd,
      onNodeDrop: this.onNodeDrop
    };
    return React389.createElement(TreeContext.Provider, {
      value: contextValue
    }, React389.createElement("div", {
      className: clsx(prefixCls, className, rootClassName, {
        [`${prefixCls}-show-line`]: showLine,
        [`${prefixCls}-focused`]: focused,
        [`${prefixCls}-active-focused`]: activeKey !== null
      }),
      style: rootStyle
    }, React389.createElement(NodeList_default, _extends72({
      ref: this.listRef,
      prefixCls,
      style,
      data: flattenNodes,
      disabled,
      selectable,
      checkable: !!checkable,
      motion: motion2,
      dragging: draggingNodeKey !== null,
      height,
      itemHeight,
      virtual,
      focusable,
      focused,
      tabIndex,
      activeItem: this.getActiveItem(),
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onKeyDown: this.onKeyDown,
      onActiveChange: this.onActiveChange,
      onListChangeStart: this.onListChangeStart,
      onListChangeEnd: this.onListChangeEnd,
      onContextMenu,
      onScroll,
      scrollWidth
    }, this.getTreeNodeRequiredProps(), domProps))));
  }
};
var Tree_default = Tree;

// node_modules/@rc-component/tree/es/index.js
var es_default23 = Tree_default;

// node_modules/antd/es/tree/DirectoryTree.js
var React393 = __toESM(require_react());

// node_modules/antd/es/tree/Tree.js
var import_react124 = __toESM(require_react());

// node_modules/antd/es/tree/style/directory.js
var genDirectoryStyle = ({
  treeCls,
  treeNodeCls,
  directoryNodeSelectedBg,
  directoryNodeSelectedColor,
  motionDurationMid,
  borderRadius,
  controlItemBgHover
}) => ({
  [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
    // >>> Title
    [`${treeCls}-node-content-wrapper`]: {
      position: "static",
      [`&:has(${treeCls}-drop-indicator)`]: {
        position: "relative"
      },
      [`> *:not(${treeCls}-drop-indicator)`]: {
        position: "relative"
      },
      "&:hover": {
        background: "transparent"
      },
      // Expand interactive area to whole line
      "&:before": {
        position: "absolute",
        inset: 0,
        transition: `background-color ${motionDurationMid}`,
        content: '""',
        borderRadius
      },
      "&:hover:before": {
        background: controlItemBgHover
      }
    },
    [`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: {
      zIndex: 1
    },
    // ============= Selected =============
    "&-selected": {
      background: directoryNodeSelectedBg,
      borderRadius,
      [`${treeCls}-switcher, ${treeCls}-draggable-icon`]: {
        color: directoryNodeSelectedColor
      },
      // >>> Title
      [`${treeCls}-node-content-wrapper`]: {
        color: directoryNodeSelectedColor,
        background: "transparent",
        "&, &:hover": {
          color: directoryNodeSelectedColor
        },
        "&:before, &:hover:before": {
          background: directoryNodeSelectedBg
        }
      }
    }
  }
});

// node_modules/antd/es/tree/style/index.js
var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var getSwitchStyle = (prefixCls, token) => ({
  [`.${prefixCls}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${token.motionDurationSlow}`
    }
  }
});
var getDropIndicatorStyle = (prefixCls, token) => ({
  [`.${prefixCls}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${unit(token.lineWidthBold)} solid ${token.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
});
var genBaseStyle11 = (prefixCls, token) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    titleHeight,
    indentSize,
    nodeSelectedBg,
    nodeHoverBg,
    colorTextQuaternary,
    controlItemBgActiveDisabled
  } = token;
  return {
    [treeCls]: {
      ...resetComponent(token),
      // fix https://github.com/ant-design/ant-design/issues/50316
      ["--rc-virtual-list-scrollbar-bg"]: token.colorSplit,
      background: token.colorBgContainer,
      borderRadius: token.borderRadius,
      transition: `background-color ${token.motionDurationSlow}`,
      "&-rtl": {
        direction: "rtl"
      },
      [`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: {
        transform: "rotate(90deg)"
      },
      [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: genFocusOutline(token),
      // =================== Virtual List ===================
      [`${treeCls}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${treeCls}-block-node`]: {
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${treeNodeCls}.dragging:after`]: {
            position: "absolute",
            inset: 0,
            border: `1px solid ${token.colorPrimary}`,
            opacity: 0,
            animationName: treeNodeFX,
            animationDuration: token.motionDurationSlow,
            animationPlayState: "running",
            animationFillMode: "forwards",
            content: '""',
            pointerEvents: "none",
            borderRadius: token.borderRadius
          }
        }
      },
      // ===================== TreeNode =====================
      [treeNodeCls]: {
        display: "flex",
        alignItems: "flex-start",
        marginBottom: treeNodePadding,
        lineHeight: unit(titleHeight),
        position: "relative",
        //  drop-indicator 
        "&:before": {
          content: '""',
          position: "absolute",
          zIndex: 1,
          insetInlineStart: 0,
          width: "100%",
          top: "100%",
          height: treeNodePadding
        },
        // Disabled
        [`&-disabled ${treeCls}-node-content-wrapper`]: {
          color: token.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover": {
            background: "transparent"
          }
        },
        [`${treeCls}-checkbox-disabled + ${treeCls}-node-selected,&${treeNodeCls}-disabled${treeNodeCls}-selected ${treeCls}-node-content-wrapper`]: {
          backgroundColor: controlItemBgActiveDisabled
        },
        // we can not set pointer-events to none for checkbox in tree
        // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-2605234058
        [`${treeCls}-checkbox-disabled`]: {
          pointerEvents: "unset"
        },
        // not disable
        [`&:not(${treeNodeCls}-disabled)`]: {
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            "&:hover": {
              color: token.nodeHoverColor
            }
          }
        },
        [`&-active ${treeCls}-node-content-wrapper`]: {
          background: token.controlItemBgHover
        },
        [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
          color: token.colorPrimary,
          fontWeight: token.fontWeightStrong
        },
        "&-draggable": {
          cursor: "grab",
          [`${treeCls}-draggable-icon`]: {
            // https://github.com/ant-design/ant-design/issues/41915
            flexShrink: 0,
            width: titleHeight,
            textAlign: "center",
            visibility: "visible",
            color: colorTextQuaternary
          },
          [`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: {
            visibility: "hidden"
          }
        }
      },
      // >>> Indent
      [`${treeCls}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: indentSize
        }
      },
      // >>> Drag Handler
      [`${treeCls}-draggable-icon`]: {
        visibility: "hidden"
      },
      // Switcher / Checkbox
      [`${treeCls}-switcher, ${treeCls}-checkbox`]: {
        marginInlineEnd: token.calc(token.calc(titleHeight).sub(token.controlInteractiveSize)).div(2).equal()
      },
      // >>> Switcher
      [`${treeCls}-switcher`]: {
        ...getSwitchStyle(prefixCls, token),
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: titleHeight,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        transition: `all ${token.motionDurationSlow}`,
        "&-noop": {
          cursor: "unset"
        },
        "&:before": {
          pointerEvents: "none",
          content: '""',
          width: titleHeight,
          height: titleHeight,
          position: "absolute",
          left: {
            _skip_check_: true,
            value: 0
          },
          top: 0,
          borderRadius: token.borderRadius,
          transition: `all ${token.motionDurationSlow}`
        },
        [`&:not(${treeCls}-switcher-noop):hover:before`]: {
          backgroundColor: token.colorBgTextHover
        },
        [`&_close ${treeCls}-switcher-icon svg`]: {
          transform: "rotate(-90deg)"
        },
        "&-loading-icon": {
          color: token.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token.calc(titleHeight).div(2).equal(),
            bottom: token.calc(treeNodePadding).mul(-1).equal(),
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${token.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: token.calc(token.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
            height: token.calc(titleHeight).div(2).equal(),
            borderBottom: `1px solid ${token.colorBorder}`,
            content: '""'
          }
        }
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${treeCls}-node-content-wrapper`]: {
        position: "relative",
        minHeight: titleHeight,
        paddingBlock: 0,
        paddingInline: token.paddingXS,
        background: "transparent",
        borderRadius: token.borderRadius,
        cursor: "pointer",
        transition: `all ${token.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        ...getDropIndicatorStyle(prefixCls, token),
        "&:hover": {
          backgroundColor: nodeHoverBg
        },
        [`&${treeCls}-node-selected`]: {
          color: token.nodeSelectedColor,
          backgroundColor: nodeSelectedBg
        },
        // Icon
        [`${treeCls}-iconEle`]: {
          display: "inline-block",
          width: titleHeight,
          height: titleHeight,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      [`${treeNodeCls}.drop-container > [draggable]`]: {
        boxShadow: `0 0 0 2px ${token.colorPrimary}`
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${treeCls}-indent-unit`]: {
          position: "relative",
          height: "100%",
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token.calc(titleHeight).div(2).equal(),
            bottom: token.calc(treeNodePadding).mul(-1).equal(),
            borderInlineEnd: `1px solid ${token.colorBorder}`,
            content: '""'
          },
          "&-end:before": {
            display: "none"
          }
        },
        // ============== Cover Background ==============
        [`${treeCls}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
        top: "auto !important",
        bottom: "auto !important",
        height: `${unit(token.calc(titleHeight).div(2).equal())} !important`
      }
    }
  };
};
var genTreeStyle = (prefixCls, token, enableDirectory = true) => {
  const treeCls = `.${prefixCls}`;
  const treeNodeCls = `${treeCls}-treenode`;
  const treeNodePadding = token.calc(token.paddingXS).div(2).equal();
  const treeToken = merge(token, {
    treeCls,
    treeNodeCls,
    treeNodePadding
  });
  return [
    // Basic
    genBaseStyle11(prefixCls, treeToken),
    // Directory
    enableDirectory && genDirectoryStyle(treeToken)
  ].filter(Boolean);
};
var initComponentToken2 = (token) => {
  const {
    controlHeightSM,
    controlItemBgHover,
    controlItemBgActive
  } = token;
  const titleHeight = controlHeightSM;
  return {
    titleHeight,
    indentSize: titleHeight,
    nodeHoverBg: controlItemBgHover,
    nodeHoverColor: token.colorText,
    nodeSelectedBg: controlItemBgActive,
    nodeSelectedColor: token.colorText
  };
};
var prepareComponentToken43 = (token) => {
  const {
    colorTextLightSolid,
    colorPrimary
  } = token;
  return {
    ...initComponentToken2(token),
    directoryNodeSelectedColor: colorTextLightSolid,
    directoryNodeSelectedBg: colorPrimary
  };
};
var style_default49 = genStyleHooks("Tree", (token, {
  prefixCls
}) => [{
  [token.componentCls]: getStyle(`${prefixCls}-checkbox`, token)
}, genTreeStyle(prefixCls, token), collapse_default(token)], prepareComponentToken43);

// node_modules/antd/es/tree/utils/dropIndicator.js
var import_react123 = __toESM(require_react());
var offset2 = 4;
function dropIndicatorRender(props) {
  const {
    dropPosition,
    dropLevelOffset,
    prefixCls,
    indent,
    direction = "ltr"
  } = props;
  const startPosition = direction === "ltr" ? "left" : "right";
  const endPosition = direction === "ltr" ? "right" : "left";
  const style = {
    [startPosition]: -dropLevelOffset * indent + offset2,
    [endPosition]: 0
  };
  switch (dropPosition) {
    case -1:
      style.top = -3;
      break;
    case 1:
      style.bottom = -3;
      break;
    default:
      style.bottom = -3;
      style[startPosition] = indent + offset2;
      break;
  }
  return import_react123.default.createElement("div", {
    style,
    className: `${prefixCls}-drop-indicator`
  });
}
var dropIndicator_default = dropIndicatorRender;

// node_modules/antd/es/tree/utils/iconUtil.js
var React391 = __toESM(require_react());
var SwitcherIconCom = (props) => {
  const {
    prefixCls,
    switcherIcon,
    treeNodeProps,
    showLine,
    switcherLoadingIcon
  } = props;
  const {
    isLeaf: isLeaf2,
    expanded,
    loading
  } = treeNodeProps;
  if (loading) {
    if (React391.isValidElement(switcherLoadingIcon)) {
      return switcherLoadingIcon;
    }
    return React391.createElement(LoadingOutlined_default, {
      className: `${prefixCls}-switcher-loading-icon`
    });
  }
  let showLeafIcon;
  if (showLine && typeof showLine === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf2) {
    if (!showLine) {
      return null;
    }
    if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
      const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
      const leafCls = `${prefixCls}-switcher-line-custom-icon`;
      if (React391.isValidElement(leafIcon)) {
        return cloneElement(leafIcon, {
          className: clsx(leafIcon.props?.className, leafCls)
        });
      }
      return leafIcon;
    }
    return showLeafIcon ? React391.createElement(FileOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    }) : React391.createElement("span", {
      className: `${prefixCls}-switcher-leaf-line`
    });
  }
  const switcherCls = `${prefixCls}-switcher-icon`;
  const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  if (React391.isValidElement(switcher)) {
    return cloneElement(switcher, {
      className: clsx(switcher.props?.className, switcherCls)
    });
  }
  if (switcher !== void 0) {
    return switcher;
  }
  if (showLine) {
    return expanded ? React391.createElement(MinusSquareOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    }) : React391.createElement(PlusSquareOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    });
  }
  return React391.createElement(CaretDownFilled_default, {
    className: switcherCls
  });
};
var iconUtil_default = SwitcherIconCom;

// node_modules/antd/es/tree/Tree.js
var Tree2 = import_react124.default.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tree");
  const {
    virtual
  } = import_react124.default.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = false,
    showLine,
    switcherIcon,
    switcherLoadingIcon,
    blockNode = false,
    children,
    checkable = false,
    selectable = true,
    draggable,
    disabled,
    motion: customMotion,
    style,
    rootClassName,
    classNames,
    styles
  } = props;
  const contextDisabled = import_react124.default.useContext(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const motion2 = customMotion ?? {
    ...motion_default(rootPrefixCls),
    motionAppear: false
  };
  const mergedProps = {
    ...props,
    showIcon,
    blockNode,
    checkable,
    selectable,
    disabled: mergedDisabled,
    motion: motion2
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const newProps = {
    ...props,
    checkable,
    selectable,
    showIcon,
    motion: motion2,
    blockNode,
    disabled: mergedDisabled,
    showLine: Boolean(showLine),
    dropIndicatorRender: dropIndicator_default
  };
  const [hashId, cssVarCls] = style_default49(prefixCls);
  const [, token] = useToken();
  const itemHeight = token.paddingXS / 2 + (token.Tree?.titleHeight || token.controlHeightSM);
  const draggableConfig = import_react124.default.useMemo(() => {
    if (!draggable) {
      return false;
    }
    let mergedDraggable = {};
    switch (typeof draggable) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = {
          ...draggable
        };
        break;
      default:
        break;
    }
    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon || import_react124.default.createElement(HolderOutlined_default, null);
    }
    return mergedDraggable;
  }, [draggable]);
  const renderSwitcherIcon = (nodeProps) => import_react124.default.createElement(iconUtil_default, {
    prefixCls,
    switcherIcon,
    switcherLoadingIcon,
    treeNodeProps: nodeProps,
    showLine
  });
  return (
    // @ts-ignore
    import_react124.default.createElement(es_default23, {
      itemHeight,
      ref,
      virtual,
      ...newProps,
      // newProps may contain style so declare style below it
      prefixCls,
      className: clsx({
        [`${prefixCls}-icon-hide`]: !showIcon,
        [`${prefixCls}-block-node`]: blockNode,
        [`${prefixCls}-unselectable`]: !selectable,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-disabled`]: mergedDisabled
      }, contextClassName, className, hashId, cssVarCls),
      style: {
        ...contextStyle,
        ...style
      },
      rootClassName: clsx(mergedClassNames?.root, rootClassName),
      rootStyle: mergedStyles?.root,
      classNames: mergedClassNames,
      styles: mergedStyles,
      direction,
      checkable: checkable ? import_react124.default.createElement("span", {
        className: `${prefixCls}-checkbox-inner`
      }) : checkable,
      selectable,
      switcherIcon: renderSwitcherIcon,
      draggable: draggableConfig
    }, children)
  );
});
if (true) {
  Tree2.displayName = "Tree";
}
var Tree_default2 = Tree2;

// node_modules/antd/es/tree/utils/dictUtil.js
var RECORD_NONE = 0;
var RECORD_START = 1;
var RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
  const {
    key: fieldKey,
    children: fieldChildren
  } = fieldNames;
  function processNode(dataNode) {
    const key = dataNode[fieldKey];
    const children = dataNode[fieldChildren];
    if (callback(key, dataNode) !== false) {
      traverseNodesKey(children || [], callback, fieldNames);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys({
  treeData,
  expandedKeys,
  startKey,
  endKey,
  fieldNames
}) {
  const keys = [];
  let record = RECORD_NONE;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key) {
    return key === startKey || key === endKey;
  }
  traverseNodesKey(treeData, (key) => {
    if (record === RECORD_END) {
      return false;
    }
    if (matchKey(key)) {
      keys.push(key);
      if (record === RECORD_NONE) {
        record = RECORD_START;
      } else if (record === RECORD_START) {
        record = RECORD_END;
        return false;
      }
    } else if (record === RECORD_START) {
      keys.push(key);
    }
    return expandedKeys.includes(key);
  }, fillFieldNames2(fieldNames));
  return keys;
}
function convertDirectoryKeysToNodes(treeData, keys, fieldNames) {
  const restKeys = _toConsumableArray(keys);
  const nodes = [];
  traverseNodesKey(treeData, (key, node) => {
    const index2 = restKeys.indexOf(key);
    if (index2 !== -1) {
      nodes.push(node);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  }, fillFieldNames2(fieldNames));
  return nodes;
}

// node_modules/antd/es/tree/DirectoryTree.js
function getIcon(props) {
  const {
    isLeaf: isLeaf2,
    expanded
  } = props;
  if (isLeaf2) {
    return React393.createElement(FileOutlined_default, null);
  }
  return expanded ? React393.createElement(FolderOpenOutlined_default, null) : React393.createElement(FolderOutlined_default, null);
}
function getTreeData({
  treeData,
  children
}) {
  return treeData || convertTreeToData(children);
}
var DirectoryTree = ({
  defaultExpandAll,
  defaultExpandParent,
  defaultExpandedKeys,
  ...props
}, ref) => {
  const lastSelectedKey = React393.useRef(null);
  const cachedSelectedKeys = React393.useRef(null);
  const getInitExpandedKeys = () => {
    const {
      keyEntities
    } = convertDataToEntities(getTreeData(props), {
      fieldNames: props.fieldNames
    });
    let initExpandedKeys;
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
    }
    return initExpandedKeys;
  };
  const [selectedKeys, setSelectedKeys] = React393.useState(props.selectedKeys || props.defaultSelectedKeys || []);
  const [expandedKeys, setExpandedKeys] = React393.useState(() => getInitExpandedKeys());
  React393.useEffect(() => {
    if ("selectedKeys" in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  React393.useEffect(() => {
    if ("expandedKeys" in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  const onExpand = (keys, info) => {
    if (!("expandedKeys" in props)) {
      setExpandedKeys(keys);
    }
    return props.onExpand?.(keys, info);
  };
  const onSelect = (keys, event) => {
    const {
      multiple,
      fieldNames
    } = props;
    const {
      node,
      nativeEvent
    } = event;
    const {
      key = ""
    } = node;
    const treeData = getTreeData(props);
    const newEvent = {
      ...event,
      selected: true
      // Directory selected always true
    };
    const ctrlPick = nativeEvent?.ctrlKey || nativeEvent?.metaKey;
    const shiftPick = nativeEvent?.shiftKey;
    let newSelectedKeys;
    if (multiple && ctrlPick) {
      newSelectedKeys = keys;
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else if (multiple && shiftPick) {
      newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
        treeData,
        expandedKeys,
        startKey: key,
        endKey: lastSelectedKey.current,
        fieldNames
      })))));
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else {
      newSelectedKeys = [key];
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    }
    props.onSelect?.(newSelectedKeys, newEvent);
    if (!("selectedKeys" in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  };
  const {
    getPrefixCls,
    direction
  } = React393.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = true,
    expandAction = "click",
    ...otherProps
  } = props;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const connectClassName = clsx(`${prefixCls}-directory`, {
    [`${prefixCls}-directory-rtl`]: direction === "rtl"
  }, className);
  return React393.createElement(Tree_default2, {
    icon: getIcon,
    ref,
    blockNode: true,
    ...otherProps,
    showIcon,
    expandAction,
    prefixCls,
    className: connectClassName,
    expandedKeys,
    selectedKeys,
    onSelect,
    onExpand
  });
};
var ForwardDirectoryTree = React393.forwardRef(DirectoryTree);
if (true) {
  ForwardDirectoryTree.displayName = "DirectoryTree";
}
var DirectoryTree_default = ForwardDirectoryTree;

// node_modules/antd/es/tree/index.js
var Tree3 = Tree_default2;
Tree3.DirectoryTree = DirectoryTree_default;
Tree3.TreeNode = TreeNode_default;
var tree_default = Tree3;

// node_modules/antd/es/table/hooks/useFilter/FilterSearch.js
var React394 = __toESM(require_react());
var FilterSearch = (props) => {
  const {
    value,
    filterSearch,
    tablePrefixCls,
    locale: locale2,
    onChange
  } = props;
  if (!filterSearch) {
    return null;
  }
  return React394.createElement("div", {
    className: `${tablePrefixCls}-filter-dropdown-search`
  }, React394.createElement(Input_default, {
    prefix: React394.createElement(SearchOutlined_default, null),
    placeholder: locale2.filterSearchPlaceholder,
    onChange,
    value,
    // for skip min-width of input
    htmlSize: 1,
    className: `${tablePrefixCls}-filter-dropdown-search-input`
  }));
};
var FilterSearch_default = FilterSearch;

// node_modules/antd/es/table/hooks/useFilter/FilterWrapper.js
var React395 = __toESM(require_react());
var onKeyDown = (event) => {
  const {
    keyCode
  } = event;
  if (keyCode === KeyCode_default.ENTER) {
    event.stopPropagation();
  }
};
var FilterDropdownMenuWrapper = React395.forwardRef((props, ref) => React395.createElement("div", {
  className: props.className,
  onClick: (e3) => e3.stopPropagation(),
  onKeyDown,
  ref
}, props.children));
if (true) {
  FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
}
var FilterWrapper_default = FilterDropdownMenuWrapper;

// node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
function flattenKeys(filters) {
  let keys = [];
  (filters || []).forEach(({
    value,
    children
  }) => {
    keys.push(value);
    if (children) {
      keys = [].concat(_toConsumableArray(keys), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys;
}
function hasSubMenu(filters) {
  return filters.some(({
    children
  }) => children);
}
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text?.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems({
  filters,
  prefixCls,
  filteredKeys,
  filterMultiple,
  searchValue,
  filterSearch
}) {
  return filters.map((filter2, index2) => {
    const key = String(filter2.value);
    if (filter2.children) {
      return {
        key: key || index2,
        label: filter2.text,
        popupClassName: `${prefixCls}-dropdown-submenu`,
        children: renderFilterItems({
          filters: filter2.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    }
    const Component6 = filterMultiple ? checkbox_default : radio_default2;
    const item = {
      key: filter2.value !== void 0 ? key : index2,
      label: React396.createElement(React396.Fragment, null, React396.createElement(Component6, {
        checked: filteredKeys.includes(key)
      }), React396.createElement("span", null, filter2.text))
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter2) ? item : null;
      }
      return searchValueMatched(searchValue, filter2.text) ? item : null;
    }
    return item;
  });
}
function wrapStringListType(keys) {
  return keys || [];
}
var FilterDropdown = (props) => {
  const {
    tablePrefixCls,
    prefixCls,
    column,
    dropdownPrefixCls,
    columnKey,
    filterOnClose,
    filterMultiple,
    filterMode = "menu",
    filterSearch = false,
    filterState,
    triggerFilter,
    locale: locale2,
    children,
    getPopupContainer,
    rootClassName
  } = props;
  const {
    filterResetToDefaultFilteredValue,
    defaultFilteredValue,
    filterDropdownProps = {},
    // Deprecated
    filterDropdownOpen,
    onFilterDropdownOpenChange
  } = column;
  const [visible, setVisible] = React396.useState(false);
  const filtered = !!(filterState && (filterState.filteredKeys?.length || filterState.forceFiltered));
  const triggerVisible = (newVisible) => {
    setVisible(newVisible);
    filterDropdownProps.onOpenChange?.(newVisible);
    onFilterDropdownOpenChange?.(newVisible);
  };
  if (true) {
    const warning2 = devUseWarning("Table");
    const deprecatedList = [["filterDropdownOpen", "filterDropdownProps.open"], ["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"]];
    deprecatedList.forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in column), deprecatedName, newName);
    });
    warning2.deprecated(!("filterCheckall" in locale2), "filterCheckall", "locale.filterCheckAll");
  }
  const mergedVisible = filterDropdownProps.open ?? filterDropdownOpen ?? // deprecated
  visible;
  const propFilteredKeys = filterState?.filteredKeys;
  const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(wrapStringListType(propFilteredKeys));
  const onSelectKeys = ({
    selectedKeys
  }) => {
    setFilteredKeysSync(selectedKeys);
  };
  const onCheck = (keys, {
    node,
    checked
  }) => {
    if (!filterMultiple) {
      onSelectKeys({
        selectedKeys: checked && node.key ? [node.key] : []
      });
    } else {
      onSelectKeys({
        selectedKeys: keys
      });
    }
  };
  React396.useEffect(() => {
    if (!visible) {
      return;
    }
    onSelectKeys({
      selectedKeys: wrapStringListType(propFilteredKeys)
    });
  }, [propFilteredKeys]);
  const [openKeys, setOpenKeys] = React396.useState([]);
  const onOpenChange = (keys) => {
    setOpenKeys(keys);
  };
  const [searchValue, setSearchValue] = React396.useState("");
  const onSearch = (e3) => {
    const {
      value
    } = e3.target;
    setSearchValue(value);
  };
  React396.useEffect(() => {
    if (!visible) {
      setSearchValue("");
    }
  }, [visible]);
  const internalTriggerFilter = (keys) => {
    const mergedKeys = keys?.length ? keys : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (isEqual_default(mergedKeys, filterState?.filteredKeys, true)) {
      return null;
    }
    triggerFilter({
      column,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  };
  const onConfirm = () => {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  };
  const onReset = ({
    confirm: confirm2,
    closeDropdown
  } = {
    confirm: false,
    closeDropdown: false
  }) => {
    if (confirm2) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue("");
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
    } else {
      setFilteredKeysSync([]);
    }
  };
  const doFilter = ({
    closeDropdown
  } = {
    closeDropdown: true
  }) => {
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  };
  const onVisibleChange = (newVisible, info) => {
    if (info.source === "trigger") {
      if (newVisible && propFilteredKeys !== void 0) {
        setFilteredKeysSync(wrapStringListType(propFilteredKeys));
      }
      triggerVisible(newVisible);
      if (!newVisible && !column.filterDropdown && filterOnClose) {
        onConfirm();
      }
    }
  };
  const dropdownMenuClass = clsx({
    [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column.filters || [])
  });
  const onCheckAll = (e3) => {
    if (e3.target.checked) {
      const allFilterKeys = flattenKeys(column?.filters).map((key) => String(key));
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  };
  const getTreeData2 = ({
    filters
  }) => (filters || []).map((filter2, index2) => {
    const key = String(filter2.value);
    const item = {
      title: filter2.text,
      key: filter2.value !== void 0 ? key : String(index2)
    };
    if (filter2.children) {
      item.children = getTreeData2({
        filters: filter2.children
      });
    }
    return item;
  });
  const getFilterData2 = (node) => ({
    ...node,
    text: node.title,
    value: node.key,
    children: node.children?.map((item) => getFilterData2(item)) || []
  });
  let dropdownContent;
  const {
    direction,
    renderEmpty
  } = React396.useContext(ConfigContext);
  if (typeof column.filterDropdown === "function") {
    dropdownContent = column.filterDropdown({
      prefixCls: `${dropdownPrefixCls}-custom`,
      setSelectedKeys: (selectedKeys) => onSelectKeys({
        selectedKeys
      }),
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column.filters,
      visible: mergedVisible,
      close: () => {
        triggerVisible(false);
      }
    });
  } else if (column.filterDropdown) {
    dropdownContent = column.filterDropdown;
  } else {
    const selectedKeys = getFilteredKeysSync() || [];
    const getFilterComponent = () => {
      const empty2 = renderEmpty?.("Table.filter") ?? React396.createElement(empty_default, {
        image: empty_default.PRESENTED_IMAGE_SIMPLE,
        description: locale2.filterEmptyText,
        styles: {
          image: {
            height: 24
          }
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      });
      if ((column.filters || []).length === 0) {
        return empty2;
      }
      if (filterMode === "tree") {
        return React396.createElement(React396.Fragment, null, React396.createElement(FilterSearch_default, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale2
        }), React396.createElement("div", {
          className: `${tablePrefixCls}-filter-dropdown-tree`
        }, filterMultiple ? React396.createElement(checkbox_default, {
          checked: selectedKeys.length === flattenKeys(column.filters).length,
          indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column.filters).length,
          className: `${tablePrefixCls}-filter-dropdown-checkall`,
          onChange: onCheckAll
        }, locale2?.filterCheckall ?? locale2?.filterCheckAll) : null, React396.createElement(tree_default, {
          checkable: true,
          selectable: false,
          blockNode: true,
          multiple: filterMultiple,
          checkStrictly: !filterMultiple,
          className: `${dropdownPrefixCls}-menu`,
          onCheck,
          checkedKeys: selectedKeys,
          selectedKeys,
          showIcon: false,
          treeData: getTreeData2({
            filters: column.filters
          }),
          autoExpandParent: true,
          defaultExpandAll: true,
          filterTreeNode: searchValue.trim() ? (node) => {
            if (typeof filterSearch === "function") {
              return filterSearch(searchValue, getFilterData2(node));
            }
            return searchValueMatched(searchValue, node.title);
          } : void 0
        })));
      }
      const items = renderFilterItems({
        filters: column.filters || [],
        filterSearch,
        prefixCls,
        filteredKeys: getFilteredKeysSync(),
        filterMultiple,
        searchValue
      });
      const isEmpty = items.every((item) => item === null);
      return React396.createElement(React396.Fragment, null, React396.createElement(FilterSearch_default, {
        filterSearch,
        value: searchValue,
        onChange: onSearch,
        tablePrefixCls,
        locale: locale2
      }), isEmpty ? empty2 : React396.createElement(menu_default2, {
        selectable: true,
        multiple: filterMultiple,
        prefixCls: `${dropdownPrefixCls}-menu`,
        className: dropdownMenuClass,
        onSelect: onSelectKeys,
        onDeselect: onSelectKeys,
        selectedKeys,
        getPopupContainer,
        openKeys,
        onOpenChange,
        items
      }));
    };
    const getResetDisabled = () => {
      if (filterResetToDefaultFilteredValue) {
        return isEqual_default((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
      }
      return selectedKeys.length === 0;
    };
    dropdownContent = React396.createElement(React396.Fragment, null, getFilterComponent(), React396.createElement("div", {
      className: `${prefixCls}-dropdown-btns`
    }, React396.createElement(Button_default, {
      type: "link",
      size: "small",
      disabled: getResetDisabled(),
      onClick: () => onReset()
    }, locale2.filterReset), React396.createElement(Button_default, {
      type: "primary",
      size: "small",
      onClick: onConfirm
    }, locale2.filterConfirm)));
  }
  if (column.filterDropdown) {
    dropdownContent = React396.createElement(OverrideProvider, {
      selectable: void 0
    }, dropdownContent);
  }
  dropdownContent = React396.createElement(FilterWrapper_default, {
    className: `${prefixCls}-dropdown`
  }, dropdownContent);
  const getDropdownTrigger = () => {
    let filterIcon;
    if (typeof column.filterIcon === "function") {
      filterIcon = column.filterIcon(filtered);
    } else if (column.filterIcon) {
      filterIcon = column.filterIcon;
    } else {
      filterIcon = React396.createElement(FilterFilled_default, null);
    }
    return React396.createElement("span", {
      role: "button",
      tabIndex: -1,
      className: clsx(`${prefixCls}-trigger`, {
        active: filtered
      }),
      onClick: (e3) => {
        e3.stopPropagation();
      }
    }, filterIcon);
  };
  const mergedDropdownProps = extendsObject_default({
    trigger: ["click"],
    placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
    children: getDropdownTrigger(),
    getPopupContainer
  }, {
    ...filterDropdownProps,
    rootClassName: clsx(rootClassName, filterDropdownProps.rootClassName),
    open: mergedVisible,
    onOpenChange: onVisibleChange,
    popupRender: () => {
      if (typeof filterDropdownProps?.dropdownRender === "function") {
        return filterDropdownProps.dropdownRender(dropdownContent);
      }
      return dropdownContent;
    }
  });
  return React396.createElement("div", {
    className: `${prefixCls}-column`
  }, React396.createElement("span", {
    className: `${tablePrefixCls}-column-title`
  }, children), React396.createElement(dropdown_default2, {
    ...mergedDropdownProps
  }));
};
var FilterDropdown_default = FilterDropdown;

// node_modules/antd/es/table/hooks/useFilter/index.js
var collectFilterStates = (columns, init, pos) => {
  let filterStates = [];
  (columns || []).forEach((column, index2) => {
    const columnPos = getColumnPos(index2, pos);
    const filterDropdownIsDefined = column.filterDropdown !== void 0;
    if (column.filters || filterDropdownIsDefined || "onFilter" in column) {
      if ("filteredValue" in column) {
        let filteredValues = column.filteredValue;
        if (!filterDropdownIsDefined) {
          filteredValues = filteredValues?.map(String) ?? filteredValues;
        }
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column.filtered
        });
      } else {
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: init && column.defaultFilteredValue ? column.defaultFilteredValue : void 0,
          forceFiltered: column.filtered
        });
      }
    }
    if ("children" in column) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column.children, init, columnPos)));
    }
  });
  return filterStates;
};
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos, rootClassName) {
  return columns.map((column, index2) => {
    const columnPos = getColumnPos(index2, pos);
    const {
      filterOnClose = true,
      filterMultiple = true,
      filterMode,
      filterSearch
    } = column;
    let newColumn = column;
    if (newColumn.filters || newColumn.filterDropdown) {
      const columnKey = getColumnKey(newColumn, columnPos);
      const filterState = filterStates.find(({
        key
      }) => columnKey === key);
      newColumn = {
        ...newColumn,
        title: (renderProps) => React397.createElement(FilterDropdown_default, {
          tablePrefixCls: prefixCls,
          prefixCls: `${prefixCls}-filter`,
          dropdownPrefixCls,
          column: newColumn,
          columnKey,
          filterState,
          filterOnClose,
          filterMultiple,
          filterMode,
          filterSearch,
          triggerFilter,
          locale: locale2,
          getPopupContainer,
          rootClassName
        }, renderColumnTitle(column.title, renderProps))
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos, rootClassName)
      };
    }
    return newColumn;
  });
}
var generateFilterInfo = (filterStates) => {
  const currentFilters = {};
  filterStates.forEach(({
    key,
    filteredKeys,
    column
  }) => {
    const keyAsString = key;
    const {
      filters,
      filterDropdown
    } = column;
    if (filterDropdown) {
      currentFilters[keyAsString] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      const keys = flattenKeys(filters);
      currentFilters[keyAsString] = keys.filter((originKey) => filteredKeys.includes(String(originKey)));
    } else {
      currentFilters[keyAsString] = null;
    }
  });
  return currentFilters;
};
var getFilterData = (data, filterStates, childrenColumnName) => {
  const filterDatas = filterStates.reduce((currentData, filterState) => {
    const {
      column: {
        onFilter,
        filters
      },
      filteredKeys
    } = filterState;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.map((record) => ({
        ...record
      })).filter((record) => filteredKeys.some((key) => {
        const keys = flattenKeys(filters);
        const keyIndex2 = keys.findIndex((k) => String(k) === String(key));
        const realKey = keyIndex2 !== -1 ? keys[keyIndex2] : key;
        if (record[childrenColumnName]) {
          record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName);
        }
        return onFilter(realKey, record);
      }));
    }
    return currentData;
  }, data);
  return filterDatas;
};
var getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column) => {
  if ("children" in column) {
    return [column].concat(_toConsumableArray(getMergedColumns(column.children || [])));
  }
  return [column];
});
var useFilter = (props) => {
  const {
    prefixCls,
    dropdownPrefixCls,
    mergedColumns: rawMergedColumns,
    onFilterChange,
    getPopupContainer,
    locale: tableLocale,
    rootClassName
  } = props;
  const warning2 = devUseWarning("Table");
  const mergedColumns = React397.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
  const [filterStates, setFilterStates] = React397.useState(() => collectFilterStates(mergedColumns, true));
  const mergedFilterStates = React397.useMemo(() => {
    const collectedStates = collectFilterStates(mergedColumns, false);
    if (collectedStates.length === 0) {
      return collectedStates;
    }
    let filteredKeysIsAllNotControlled = true;
    let filteredKeysIsAllControlled = true;
    collectedStates.forEach(({
      filteredKeys
    }) => {
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      } else {
        filteredKeysIsAllControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      const keyList = (mergedColumns || []).map((column, index2) => getColumnKey(column, getColumnPos(index2)));
      return filterStates.filter(({
        key
      }) => keyList.includes(key)).map((item) => {
        const col = mergedColumns[keyList.indexOf(item.key)];
        return {
          ...item,
          column: {
            ...item.column,
            ...col
          },
          forceFiltered: col.filtered
        };
      });
    }
    true ? warning2(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`.") : void 0;
    return collectedStates;
  }, [mergedColumns, filterStates]);
  const filters = React397.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
  const triggerFilter = (filterState) => {
    const newFilterStates = mergedFilterStates.filter(({
      key
    }) => key !== filterState.key);
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
  return [transformColumns, mergedFilterStates, filters];
};
var useFilter_default = useFilter;

// node_modules/antd/es/table/hooks/useLazyKVMap.js
var React398 = __toESM(require_react());
var useLazyKVMap = (data, childrenColumnName, getRowKey) => {
  const mapCacheRef = React398.useRef({});
  function getRecordByKey(key) {
    if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig = function(records) {
        records.forEach((record, index2) => {
          const rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record);
          if (record && typeof record === "object" && childrenColumnName in record) {
            dig(record[childrenColumnName] || []);
          }
        });
      };
      const kvMap = /* @__PURE__ */ new Map();
      dig(data);
      mapCacheRef.current = {
        data,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return mapCacheRef.current.kvMap?.get(key);
  }
  return [getRecordByKey];
};
var useLazyKVMap_default = useLazyKVMap;

// node_modules/antd/es/table/hooks/usePagination.js
var import_react125 = __toESM(require_react());
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
  const param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  Object.keys(paginationObj).forEach((pageProp) => {
    const value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
function usePagination(total, onChange, pagination) {
  const {
    total: paginationTotal = 0,
    ...paginationObj
  } = pagination && typeof pagination === "object" ? pagination : {};
  const [innerPagination, setInnerPagination] = (0, import_react125.useState)(() => ({
    current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
    pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
  }));
  const mergedPagination = extendsObject_default(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  });
  const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    mergedPagination.current = maxPage || 1;
  }
  const refreshPagination = (current, pageSize) => {
    setInnerPagination({
      current: current ?? 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  };
  const onInternalChange = (current, pageSize) => {
    if (pagination) {
      pagination.onChange?.(current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange(current, pageSize || mergedPagination?.pageSize);
  };
  if (pagination === false) {
    return [{}, () => {
    }];
  }
  return [{
    ...mergedPagination,
    onChange: onInternalChange
  }, refreshPagination];
}
var usePagination_default = usePagination;

// node_modules/antd/es/table/hooks/useSorter.js
var React399 = __toESM(require_react());
var ASCEND = "ascend";
var DESCEND = "descend";
var getMultiplePriority = (column) => {
  if (typeof column.sorter === "object" && typeof column.sorter.multiple === "number") {
    return column.sorter.multiple;
  }
  return false;
};
var getSortFunction = (sorter) => {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && typeof sorter === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
};
var nextSortDirection = (sortDirections, current) => {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
};
var collectSortStates = (columns, init, pos) => {
  let sortStates = [];
  const pushState = (column, columnPos) => {
    sortStates.push({
      column,
      key: getColumnKey(column, columnPos),
      multiplePriority: getMultiplePriority(column),
      sortOrder: column.sortOrder
    });
  };
  (columns || []).forEach((column, index2) => {
    const columnPos = getColumnPos(index2, pos);
    if (column.children) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column.children, init, columnPos)));
    } else if (column.sorter) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      } else if (init && column.defaultSortOrder) {
        sortStates.push({
          column,
          key: getColumnKey(column, columnPos),
          multiplePriority: getMultiplePriority(column),
          sortOrder: column.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
};
var injectSorter = (prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos, a11yLocale) => {
  const finalColumns = (columns || []).map((column, index2) => {
    const columnPos = getColumnPos(index2, pos);
    let newColumn = column;
    if (newColumn.sorter) {
      const sortDirections = newColumn.sortDirections || defaultSortDirections;
      const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      const columnKey = getColumnKey(newColumn, columnPos);
      const sorterState = sorterStates.find(({
        key
      }) => key === columnKey);
      const sortOrder = sorterState ? sorterState.sortOrder : null;
      const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
      let sorter;
      if (column.sortIcon) {
        sorter = column.sortIcon({
          sortOrder
        });
      } else {
        const upNode = sortDirections.includes(ASCEND) && React399.createElement(CaretUpOutlined_default, {
          className: clsx(`${prefixCls}-column-sorter-up`, {
            active: sortOrder === ASCEND
          })
        });
        const downNode = sortDirections.includes(DESCEND) && React399.createElement(CaretDownOutlined_default, {
          className: clsx(`${prefixCls}-column-sorter-down`, {
            active: sortOrder === DESCEND
          })
        });
        sorter = React399.createElement("span", {
          className: clsx(`${prefixCls}-column-sorter`, {
            [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
          })
        }, React399.createElement("span", {
          className: `${prefixCls}-column-sorter-inner`,
          "aria-hidden": "true"
        }, upNode, downNode));
      }
      const {
        cancelSort,
        triggerAsc,
        triggerDesc
      } = tableLocale || {};
      let sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      const tooltipProps = typeof showSorterTooltip === "object" ? {
        title: sortTip,
        ...showSorterTooltip
      } : {
        title: sortTip
      };
      newColumn = {
        ...newColumn,
        className: clsx(newColumn.className, {
          [`${prefixCls}-column-sort`]: sortOrder
        }),
        title: (renderProps) => {
          const columnSortersClass = `${prefixCls}-column-sorters`;
          const renderColumnTitleWrapper = React399.createElement("span", {
            className: `${prefixCls}-column-title`
          }, renderColumnTitle(column.title, renderProps));
          const renderSortTitle = React399.createElement("div", {
            className: columnSortersClass
          }, renderColumnTitleWrapper, sorter);
          if (showSorterTooltip) {
            if (typeof showSorterTooltip !== "boolean" && showSorterTooltip?.target === "sorter-icon") {
              return React399.createElement("div", {
                className: clsx(columnSortersClass, `${columnSortersClass}-tooltip-target-sorter`)
              }, renderColumnTitleWrapper, React399.createElement(tooltip_default, {
                ...tooltipProps
              }, sorter));
            }
            return React399.createElement(tooltip_default, {
              ...tooltipProps
            }, renderSortTitle);
          }
          return renderSortTitle;
        },
        onHeaderCell: (col) => {
          const cell = column.onHeaderCell?.(col) || {};
          const originOnClick = cell.onClick;
          const originOKeyDown = cell.onKeyDown;
          cell.onClick = (event) => {
            triggerSorter({
              column,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column)
            });
            originOnClick?.(event);
          };
          cell.onKeyDown = (event) => {
            if (event.keyCode === KeyCode_default.ENTER) {
              triggerSorter({
                column,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column)
              });
              originOKeyDown?.(event);
            }
          };
          const renderTitle = safeColumnTitle(column.title, {});
          const displayTitle = renderTitle?.toString();
          if (sortOrder) {
            cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
          }
          cell["aria-description"] = a11yLocale?.sortable;
          cell["aria-label"] = displayTitle || "";
          cell.className = clsx(cell.className, `${prefixCls}-column-has-sorters`);
          cell.tabIndex = 0;
          if (column.ellipsis) {
            cell.title = (renderTitle ?? "").toString();
          }
          return cell;
        }
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos, a11yLocale)
      };
    }
    return newColumn;
  });
  return finalColumns;
};
var stateToInfo = (sorterState) => {
  const {
    column,
    sortOrder
  } = sorterState;
  return {
    column,
    order: sortOrder,
    field: column.dataIndex,
    columnKey: column.key
  };
};
var generateSorterInfo = (sorterStates) => {
  const activeSorters = sorterStates.filter(({
    sortOrder
  }) => sortOrder).map(stateToInfo);
  if (activeSorters.length === 0 && sorterStates.length) {
    const lastIndex = sorterStates.length - 1;
    return {
      ...stateToInfo(sorterStates[lastIndex]),
      column: void 0,
      order: void 0,
      field: void 0,
      columnKey: void 0
    };
  }
  if (activeSorters.length <= 1) {
    return activeSorters[0] || {};
  }
  return activeSorters;
};
var getSortData = (data, sortStates, childrenColumnName) => {
  const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
  const cloneData = data.slice();
  const runningSorters = innerSorterStates.filter(({
    column: {
      sorter
    },
    sortOrder
  }) => getSortFunction(sorter) && sortOrder);
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort((record1, record2) => {
    for (let i = 0; i < runningSorters.length; i += 1) {
      const sorterState = runningSorters[i];
      const {
        column: {
          sorter
        },
        sortOrder
      } = sorterState;
      const compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        const compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map((record) => {
    const subRecords = record[childrenColumnName];
    if (subRecords) {
      return {
        ...record,
        [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
      };
    }
    return record;
  });
};
var useFilterSorter = (props) => {
  const {
    prefixCls,
    mergedColumns,
    sortDirections,
    tableLocale,
    showSorterTooltip,
    onSorterChange,
    globalLocale
  } = props;
  const [sortStates, setSortStates] = React399.useState(() => collectSortStates(mergedColumns, true));
  const getColumnKeys = (columns, pos) => {
    const newKeys = [];
    columns.forEach((item, index2) => {
      const columnPos = getColumnPos(index2, pos);
      newKeys.push(getColumnKey(item, columnPos));
      if (Array.isArray(item.children)) {
        const childKeys = getColumnKeys(item.children, columnPos);
        newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
      }
    });
    return newKeys;
  };
  const mergedSorterStates = React399.useMemo(() => {
    let validate = true;
    const collectedStates = collectSortStates(mergedColumns, false);
    if (!collectedStates.length) {
      const mergedColumnsKeys = getColumnKeys(mergedColumns);
      return sortStates.filter(({
        key
      }) => mergedColumnsKeys.includes(key));
    }
    const validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push({
          ...state,
          sortOrder: null
        });
      }
    }
    let multipleMode = null;
    collectedStates.forEach((state) => {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  const columnTitleSorterProps = React399.useMemo(() => {
    const sortColumns = mergedSorterStates.map(({
      column,
      sortOrder
    }) => ({
      column,
      order: sortOrder
    }));
    return {
      sortColumns,
      // Legacy
      sortColumn: sortColumns[0]?.column,
      sortOrder: sortColumns[0]?.order
    };
  }, [mergedSorterStates]);
  const triggerSorter = (sortState) => {
    let newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(({
        key
      }) => key !== sortState.key)), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  };
  const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip, void 0, globalLocale);
  const getSorters = () => generateSorterInfo(mergedSorterStates);
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
};
var useSorter_default = useFilterSorter;

// node_modules/antd/es/table/hooks/useTitleColumns.js
var React400 = __toESM(require_react());
var fillTitle = (columns, columnTitleProps) => {
  const finalColumns = columns.map((column) => {
    const cloneColumn = {
      ...column
    };
    cloneColumn.title = renderColumnTitle(column.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
  return finalColumns;
};
var useTitleColumns = (columnTitleProps) => {
  const filledColumns = React400.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps]);
  return [filledColumns];
};
var useTitleColumns_default = useTitleColumns;

// node_modules/antd/es/table/RcTable/index.js
var RcTable = genTable((prev, next) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev;
  const {
    _renderTimes: nextRenderTimes
  } = next;
  return prevRenderTimes !== nextRenderTimes;
});
var RcTable_default = RcTable;

// node_modules/antd/es/table/RcTable/VirtualTable.js
var RcVirtualTable = genVirtualTable((prev, next) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev;
  const {
    _renderTimes: nextRenderTimes
  } = next;
  return prevRenderTimes !== nextRenderTimes;
});
var VirtualTable_default2 = RcVirtualTable;

// node_modules/antd/es/table/style/bordered.js
var genBorderedStyle4 = (token) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    tableBorderColor,
    tableHeaderBg,
    tablePaddingVertical,
    tablePaddingHorizontal,
    calc
  } = token;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
    [`&${componentCls}-${size}`]: {
      [`> ${componentCls}-container`]: {
        [`> ${componentCls}-content, > ${componentCls}-body`]: {
          [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
            [`> ${componentCls}-expanded-row-fixed`]: {
              margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
            }
          }
        }
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}${componentCls}-bordered`]: {
        // ============================ Title =============================
        [`> ${componentCls}-title`]: {
          border: tableBorder,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${componentCls}-container`]: {
          borderInlineStart: tableBorder,
          borderTop: tableBorder,
          [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              [`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                borderInlineEnd: tableBorder
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: tableBorder
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                [`> ${componentCls}-cell-fix-right-first::after`]: {
                  borderInlineEnd: tableBorder
                }
              },
              // ========================== Expandable ==========================
              [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: lineWidth,
                    bottom: 0,
                    borderInlineEnd: tableBorder,
                    content: '""'
                  }
                }
              }
            }
          }
        },
        // ============================ Scroll ============================
        [`&${componentCls}-scroll-horizontal`]: {
          [`> ${componentCls}-container > ${componentCls}-body`]: {
            "> table > tbody": {
              [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                "> th, > td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        },
        // ============================ Size ============================
        ...getSizeBorderStyle("middle", token.tablePaddingVerticalMiddle, token.tablePaddingHorizontalMiddle),
        ...getSizeBorderStyle("small", token.tablePaddingVerticalSmall, token.tablePaddingHorizontalSmall),
        // ============================ Footer ============================
        [`> ${componentCls}-footer`]: {
          border: tableBorder,
          borderTop: 0
        }
      },
      // ============================ Nested ============================
      [`${componentCls}-cell`]: {
        [`${componentCls}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}`
        }
      },
      [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
        borderInlineEnd: tableBorder
      }
    }
  };
};
var bordered_default2 = genBorderedStyle4;

// node_modules/antd/es/table/style/ellipsis.js
var genEllipsisStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-cell-ellipsis`]: {
        ...textEllipsis,
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${componentCls}-cell-fix-start-shadow,
          &${componentCls}-cell-fix-end-shadow
        `]: {
          overflow: "visible",
          [`${componentCls}-cell-content`]: {
            ...textEllipsis,
            display: "block"
          }
        },
        [`${componentCls}-column-title`]: {
          ...textEllipsis,
          wordBreak: "keep-all"
        }
      }
    }
  };
};
var ellipsis_default = genEllipsisStyle;

// node_modules/antd/es/table/style/empty.js
var genEmptyStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
        textAlign: "center",
        color: token.colorTextDisabled,
        [`
          &:hover > th,
          &:hover > td,
        `]: {
          background: token.colorBgContainer
        }
      }
    }
  };
};
var empty_default2 = genEmptyStyle;

// node_modules/antd/es/table/style/expand.js
var genExpandStyle = (token) => {
  const {
    componentCls,
    antCls,
    motionDurationSlow,
    lineWidth,
    paddingXS,
    lineType,
    tableBorderColor,
    tableExpandIconBg,
    tableExpandColumnWidth,
    borderRadius,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandedRowBg,
    paddingXXS,
    expandIconMarginTop,
    expandIconSize,
    expandIconHalfInner,
    expandIconScale,
    calc
  } = token;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-expand-icon-col`]: {
        width: tableExpandColumnWidth
      },
      [`${componentCls}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${componentCls}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${componentCls}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${componentCls}-row-expand-icon`]: {
        ...operationUnit(token),
        position: "relative",
        float: "left",
        width: expandIconSize,
        height: expandIconSize,
        color: "inherit",
        lineHeight: unit(expandIconSize),
        background: tableExpandIconBg,
        border: tableBorder,
        borderRadius,
        transform: `scale(${expandIconScale})`,
        "&:focus, &:hover, &:active": {
          borderColor: "currentcolor"
        },
        "&::before, &::after": {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${motionDurationSlow} ease-out`,
          content: '""'
        },
        "&::before": {
          top: expandIconHalfInner,
          insetInlineEnd: expandIconLineOffset,
          insetInlineStart: expandIconLineOffset,
          height: lineWidth
        },
        "&::after": {
          top: expandIconLineOffset,
          bottom: expandIconLineOffset,
          insetInlineStart: expandIconHalfInner,
          width: lineWidth,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      },
      [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
        marginTop: expandIconMarginTop,
        marginInlineEnd: paddingXS
      },
      [`tr${componentCls}-expanded-row`]: {
        "&, &:hover": {
          "> th, > td": {
            background: tableExpandedRowBg
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${antCls}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "100%"
          }
        }
      },
      // With fixed
      [`${componentCls}-expanded-row-fixed`]: {
        position: "relative",
        margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      }
    }
  };
};
var expand_default = genExpandStyle;

// node_modules/antd/es/table/style/filter.js
var genFilterStyle = (token) => {
  const {
    componentCls,
    antCls,
    iconCls,
    tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth,
    paddingXXS,
    paddingXS,
    colorText,
    lineWidth,
    lineType,
    tableBorderColor,
    headerIconColor,
    fontSizeSM,
    tablePaddingHorizontal,
    borderRadius,
    motionDurationSlow,
    colorIcon,
    colorPrimary,
    tableHeaderFilterActiveBg,
    colorTextDisabled,
    tableFilterDropdownBg,
    tableFilterDropdownHeight,
    controlItemBgHover,
    controlItemBgActive,
    boxShadowSecondary,
    filterDropdownMenuBg,
    calc
  } = token;
  const dropdownPrefixCls = `${antCls}-dropdown`;
  const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
  const treePrefixCls = `${antCls}-tree`;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${componentCls}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: calc(paddingXXS).mul(-1).equal(),
          marginInline: `${unit(paddingXXS)} ${unit(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
          padding: `0 ${unit(paddingXXS)}`,
          color: headerIconColor,
          fontSize: fontSizeSM,
          borderRadius,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIcon,
            background: tableHeaderFilterActiveBg
          },
          "&.active": {
            color: colorPrimary
          }
        }
      }
    },
    {
      // Dropdown
      [`${antCls}-dropdown`]: {
        [tableFilterDropdownPrefixCls]: {
          ...resetComponent(token),
          minWidth: tableFilterDropdownWidth,
          backgroundColor: tableFilterDropdownBg,
          borderRadius,
          boxShadow: boxShadowSecondary,
          overflow: "hidden",
          // Reset menu
          [`${dropdownPrefixCls}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: tableFilterDropdownHeight,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            borderRadius: "unset",
            backgroundColor: filterDropdownMenuBg,
            "&:empty::after": {
              display: "block",
              padding: `${unit(paddingXS)} 0`,
              color: colorTextDisabled,
              fontSize: fontSizeSM,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${tableFilterDropdownPrefixCls}-tree`]: {
            paddingBlock: `${unit(paddingXS)} 0`,
            paddingInline: paddingXS,
            [treePrefixCls]: {
              padding: 0
            },
            [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
              backgroundColor: controlItemBgHover
            },
            [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: controlItemBgActive
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-search`]: {
            padding: paddingXS,
            borderBottom: tableBorder,
            "&-input": {
              input: {
                minWidth: tableFilterDropdownSearchWidth
              },
              [iconCls]: {
                color: colorTextDisabled
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-checkall`]: {
            width: "100%",
            marginBottom: paddingXXS,
            marginInlineStart: paddingXXS
          },
          // Operation
          [`${tableFilterDropdownPrefixCls}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
            overflow: "hidden",
            borderTop: tableBorder
          }
        }
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
        // Checkbox
        [`${antCls}-checkbox-wrapper + span`]: {
          paddingInlineStart: paddingXS,
          color: colorText
        },
        "> ul": {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
};
var filter_default = genFilterStyle;

// node_modules/antd/es/table/style/fixed.js
function getShadowStyle({
  colorSplit: shadowColor
}) {
  const leftShadowStyle = {
    boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
  };
  const rightShadowStyle = {
    boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
  };
  return [leftShadowStyle, rightShadowStyle];
}
var genFixedStyle = (token) => {
  const {
    componentCls,
    lineWidth,
    motionDurationSlow,
    zIndexTableFixed: zIndexTableFixed2,
    tableBg,
    calc
  } = token;
  const cellCls = `${componentCls}-cell`;
  const fixCellCls = `${cellCls}-fix`;
  const sharedShadowStyle = {
    position: "absolute",
    top: 0,
    bottom: calc(lineWidth).mul(-1).equal(),
    width: 30,
    transition: `box-shadow ${motionDurationSlow}`,
    content: '""',
    pointerEvents: "none"
  };
  const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token);
  return {
    [`${componentCls}-wrapper`]: {
      // ====================== Cell ======================
      [`${cellCls}${fixCellCls}`]: {
        position: "sticky"
      },
      [fixCellCls]: {
        zIndex: `calc(var(--z-offset-reverse) + ${zIndexTableFixed2})`,
        background: tableBg,
        "&:after": sharedShadowStyle,
        // Position
        "&-start:after": {
          insetInlineStart: "100%"
        },
        "&-end:after": {
          insetInlineEnd: "100%"
        },
        // visible
        "&-start-shadow-show:after": leftShadowStyle,
        "&-end-shadow-show:after": rightShadowStyle
      },
      // =================== Container ====================
      [`${componentCls}-container`]: {
        position: "relative",
        "&:before, &:after": {
          ...sharedShadowStyle,
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`
        },
        "&:before": {
          insetInlineStart: 0
        },
        "&:after": {
          insetInlineEnd: 0
        }
      },
      [`${componentCls}-has-fix-start ${componentCls}-container:before`]: {
        display: "none"
      },
      [`${componentCls}-has-fix-end ${componentCls}-container:after`]: {
        display: "none"
      },
      [`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: leftShadowStyle,
      [`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: rightShadowStyle
    }
  };
};
var fixed_default = genFixedStyle;

// node_modules/antd/es/table/style/pagination.js
var genPaginationStyle2 = (token) => {
  const {
    componentCls,
    antCls,
    margin
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${componentCls}-pagination${antCls}-pagination`]: {
        margin: `${unit(margin)} 0`
      },
      [`${componentCls}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: token.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-start": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-end": {
          justifyContent: "flex-end"
        }
      }
    }
  };
};
var pagination_default2 = genPaginationStyle2;

// node_modules/antd/es/table/style/radius.js
var genRadiusStyle = (token) => {
  const {
    componentCls,
    tableRadius
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [componentCls]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${componentCls}-title, ${componentCls}-header`]: {
          borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`
        },
        [`${componentCls}-title + ${componentCls}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          // https://github.com/ant-design/ant-design/issues/41975
          [`${componentCls}-header, table`]: {
            borderRadius: 0
          },
          "table > thead > tr:first-child": {
            "th:first-child, th:last-child, td:first-child, td:last-child": {
              borderRadius: 0
            }
          }
        },
        "&-container": {
          borderStartStartRadius: tableRadius,
          borderStartEndRadius: tableRadius,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: tableRadius
            },
            "> *:last-child": {
              borderStartEndRadius: tableRadius
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}`
        }
      }
    }
  };
};
var radius_default = genRadiusStyle;

// node_modules/antd/es/table/style/rtl.js
var genStyle = (token) => {
  const {
    componentCls
  } = token;
  const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token);
  return {
    [`${componentCls}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${componentCls}-row-expand-icon`]: {
        float: "right",
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      },
      // ====================== Cell ======================
      [`${componentCls}-cell-fix`]: {
        "&-start-shadow-show:after": rightShadowStyle,
        "&-end-shadow-show:after": leftShadowStyle
      },
      // =================== Container ====================
      [`${componentCls}-container`]: {
        [`${componentCls}-row-indent`]: {
          float: "right"
        }
      },
      [`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: rightShadowStyle,
      [`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: leftShadowStyle
    }
  };
};
var rtl_default3 = genStyle;

// node_modules/antd/es/table/style/selection.js
var genSelectionStyle = (token) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSizeIcon,
    padding,
    paddingXS,
    headerIconColor,
    headerIconHoverColor,
    tableSelectionColumnWidth,
    tableSelectedRowBg,
    tableSelectedRowHoverBg,
    tableRowHoverBg,
    tablePaddingHorizontal,
    calc
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Selections ==========================
      [`${componentCls}-selection-col`]: {
        width: tableSelectionColumnWidth,
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
        }
      },
      [`${componentCls}-bordered ${componentCls}-selection-col`]: {
        width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
        }
      },
      [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
        paddingInlineEnd: token.paddingXS,
        paddingInlineStart: token.paddingXS,
        textAlign: "center",
        [`${antCls}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
        zIndex: calc(token.zIndexTableFixed).add(1).equal({
          unit: false
        })
      },
      [`table tr th${componentCls}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${componentCls}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${componentCls}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${token.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
        [iconCls]: {
          color: headerIconColor,
          fontSize: fontSizeIcon,
          verticalAlign: "baseline",
          "&:hover": {
            color: headerIconHoverColor
          }
        }
      },
      // ============================= Rows =============================
      [`${componentCls}-tbody`]: {
        [`${componentCls}-row`]: {
          [`&${componentCls}-row-selected`]: {
            [`> ${componentCls}-cell`]: {
              background: tableSelectedRowBg,
              "&-row-hover": {
                background: tableSelectedRowHoverBg
              }
            }
          },
          [`> ${componentCls}-cell-row-hover`]: {
            background: tableRowHoverBg
          }
        }
      }
    }
  };
};
var selection_default = genSelectionStyle;

// node_modules/antd/es/table/style/size.js
var genSizeStyle2 = (token) => {
  const {
    componentCls,
    tableExpandColumnWidth,
    calc
  } = token;
  const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
    [`${componentCls}${componentCls}-${size}`]: {
      fontSize,
      [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}`
      },
      [`${componentCls}-filter-trigger`]: {
        marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal())
      },
      [`${componentCls}-expanded-row-fixed`]: {
        margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
      },
      [`${componentCls}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${componentCls}-wrapper:only-child ${componentCls}`]: {
          marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
          marginInline: `${unit(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${componentCls}-selection-extra`]: {
        paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal())
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: {
      ...getSizeStyle("middle", token.tablePaddingVerticalMiddle, token.tablePaddingHorizontalMiddle, token.tableFontSizeMiddle),
      ...getSizeStyle("small", token.tablePaddingVerticalSmall, token.tablePaddingHorizontalSmall, token.tableFontSizeSmall)
    }
  };
};
var size_default = genSizeStyle2;

// node_modules/antd/es/table/style/sorter.js
var genSorterStyle = (token) => {
  const {
    componentCls,
    marginXXS,
    fontSizeIcon,
    headerIconColor,
    headerIconHoverColor
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        // why left 0s? Avoid column header move with transition when left is changed
        // https://github.com/ant-design/ant-design/issues/50588
        transition: `all ${token.motionDurationSlow}, left 0s`,
        "&:hover": {
          background: token.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: token.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
          background: token.tableFixedHeaderSortActiveBg
        }
      },
      [`${componentCls}-thead th${componentCls}-column-sort`]: {
        background: token.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${componentCls}-column-sort`]: {
        background: token.tableBodySortBg
      },
      [`${componentCls}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${componentCls}-column-sorters-tooltip-target-sorter`]: {
        "&::after": {
          content: "none"
        }
      },
      [`${componentCls}-column-sorter`]: {
        marginInlineStart: marginXXS,
        color: headerIconColor,
        fontSize: 0,
        transition: `color ${token.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: fontSizeIcon,
          "&.active": {
            color: token.colorPrimary
          }
        },
        [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
        color: headerIconHoverColor
      }
    }
  };
};
var sorter_default = genSorterStyle;

// node_modules/antd/es/table/style/sticky.js
var genStickyStyle = (token) => {
  const {
    componentCls,
    opacityLoading,
    tableScrollThumbBg,
    tableScrollThumbBgHover,
    tableScrollThumbSize,
    tableScrollBg,
    stickyScrollBarBorderRadius,
    lineWidth,
    lineType,
    tableBorderColor,
    zIndexTableFixed: zIndexTableFixed2
  } = token;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`,
          background: token.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${unit(tableScrollThumbSize)} !important`,
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`,
          display: "flex",
          alignItems: "center",
          background: tableScrollBg,
          borderTop: tableBorder,
          opacity: opacityLoading,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: tableScrollThumbSize,
            backgroundColor: tableScrollThumbBg,
            borderRadius: stickyScrollBarBorderRadius,
            transition: `all ${token.motionDurationSlow}, transform 0s`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: tableScrollThumbBgHover
            }
          }
        }
      }
    }
  };
};
var sticky_default = genStickyStyle;

// node_modules/antd/es/table/style/summary.js
var genSummaryStyle = (token) => {
  const {
    componentCls,
    lineWidth,
    tableBorderColor,
    calc
  } = token;
  const tableBorder = `${unit(lineWidth)} ${token.lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-summary`]: {
        position: "relative",
        zIndex: token.zIndexTableFixed,
        background: token.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: tableBorder
          }
        }
      },
      [`div${componentCls}-summary`]: {
        boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
      }
    }
  };
};
var summary_default = genSummaryStyle;

// node_modules/antd/es/table/style/virtual.js
var genVirtualStyle = (token) => {
  const {
    componentCls,
    motionDurationMid,
    lineWidth,
    lineType,
    tableBorderColor,
    calc
  } = token;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const rowCellCls = `${componentCls}-expanded-row-cell`;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Row ==========================
      [`${componentCls}-tbody-virtual`]: {
        [`${componentCls}-tbody-virtual-holder-inner`]: {
          [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
            display: "flex",
            boxSizing: "border-box",
            width: "100%"
          }
        },
        [`${componentCls}-cell`]: {
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid}`
        },
        [`${componentCls}-expanded-row`]: {
          [`${rowCellCls}${rowCellCls}-fixed`]: {
            position: "sticky",
            insetInlineStart: 0,
            overflow: "hidden",
            width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
            borderInlineEnd: "none"
          }
        }
      },
      // ======================== Border =========================
      [`${componentCls}-bordered`]: {
        [`${componentCls}-tbody-virtual`]: {
          "&:after": {
            content: '""',
            insetInline: 0,
            bottom: 0,
            borderBottom: tableBorder,
            position: "absolute"
          },
          [`${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            [`&${componentCls}-cell-fix-right-first:before`]: {
              content: '""',
              position: "absolute",
              insetBlock: 0,
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              borderInlineStart: tableBorder
            }
          }
        },
        // Empty placeholder
        [`&${componentCls}-virtual`]: {
          [`${componentCls}-placeholder ${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            borderBottom: tableBorder
          }
        }
      }
    }
  };
};
var virtual_default = genVirtualStyle;

// node_modules/antd/es/table/style/index.js
var genTableStyle = (token) => {
  const {
    componentCls,
    fontWeightStrong,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandColumnWidth,
    lineWidth,
    lineType,
    tableBorderColor,
    tableFontSize,
    tableBg,
    tableRadius,
    tableHeaderTextColor,
    motionDurationMid,
    tableHeaderBg,
    tableHeaderCellSplitColor,
    tableFooterTextColor,
    tableFooterBg,
    calc
  } = token;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      clear: "both",
      maxWidth: "100%",
      // fix https://github.com/ant-design/ant-design/issues/46177
      ["--rc-virtual-list-scrollbar-bg"]: token.tableScrollBg,
      ...clearFix(),
      [componentCls]: {
        ...resetComponent(token),
        fontSize: tableFontSize,
        background: tableBg,
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        // https://github.com/ant-design/ant-design/issues/47486
        scrollbarColor: `${token.tableScrollThumbBg} ${token.tableScrollBg}`
      },
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell ==============================
      [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${componentCls}-title`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      },
      // ============================ Header ============================
      [`${componentCls}-thead`]: {
        [`
          > tr > th,
          > tr > td
        `]: {
          position: "relative",
          color: tableHeaderTextColor,
          fontWeight: fontWeightStrong,
          textAlign: "start",
          background: tableHeaderBg,
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: tableHeaderCellSplitColor,
            transform: "translateY(-50%)",
            transition: `background-color ${motionDurationMid}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      [`${componentCls}-tbody`]: {
        "> tr": {
          "> th, > td": {
            transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
            borderBottom: tableBorder,
            // ========================= Nest Table ===========================
            [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
              [componentCls]: {
                marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
                marginInline: `${unit(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                [`${componentCls}-tbody > tr:last-child > td`]: {
                  borderBottomWidth: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          "> th": {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`
          },
          // measure cell styles
          [`& > ${componentCls}-measure-cell`]: {
            paddingBlock: `0 !important`,
            borderBlock: `0 !important`,
            [`${componentCls}-measure-cell-content`]: {
              height: 0,
              overflow: "hidden",
              pointerEvents: "none"
            }
          }
        }
      },
      // ============================ Footer ============================
      [`${componentCls}-footer`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        color: tableFooterTextColor,
        background: tableFooterBg
      }
    }
  };
};
var prepareComponentToken44 = (token) => {
  const {
    colorFillAlter,
    colorBgContainer,
    colorTextHeading,
    colorFillSecondary,
    colorFillContent,
    controlItemBgActive,
    controlItemBgActiveHover,
    padding,
    paddingSM,
    paddingXS,
    colorBorderSecondary,
    borderRadiusLG,
    controlHeight,
    colorTextPlaceholder,
    fontSize,
    fontSizeSM,
    lineHeight,
    lineWidth,
    colorIcon,
    colorIconHover,
    opacityLoading,
    controlInteractiveSize
  } = token;
  const colorFillSecondarySolid = new FastColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
  const colorFillContentSolid = new FastColor(colorFillContent).onBackground(colorBgContainer).toHexString();
  const colorFillAlterSolid = new FastColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
  const baseColorAction = new FastColor(colorIcon);
  const baseColorActionHover = new FastColor(colorIconHover);
  const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
  const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
  return {
    headerBg: colorFillAlterSolid,
    headerColor: colorTextHeading,
    headerSortActiveBg: colorFillSecondarySolid,
    headerSortHoverBg: colorFillContentSolid,
    bodySortBg: colorFillAlterSolid,
    rowHoverBg: colorFillAlterSolid,
    rowSelectedBg: controlItemBgActive,
    rowSelectedHoverBg: controlItemBgActiveHover,
    rowExpandedBg: colorFillAlter,
    cellPaddingBlock: padding,
    cellPaddingInline: padding,
    cellPaddingBlockMD: paddingSM,
    cellPaddingInlineMD: paddingXS,
    cellPaddingBlockSM: paddingXS,
    cellPaddingInlineSM: paddingXS,
    borderColor: colorBorderSecondary,
    headerBorderRadius: borderRadiusLG,
    footerBg: colorFillAlterSolid,
    footerColor: colorTextHeading,
    cellFontSize: fontSize,
    cellFontSizeMD: fontSize,
    cellFontSizeSM: fontSize,
    headerSplitColor: colorBorderSecondary,
    fixedHeaderSortActiveBg: colorFillSecondarySolid,
    headerFilterHoverBg: colorFillContent,
    filterDropdownMenuBg: colorBgContainer,
    filterDropdownBg: colorBgContainer,
    expandIconBg: colorBgContainer,
    selectionColumnWidth: controlHeight,
    stickyScrollBarBg: colorTextPlaceholder,
    stickyScrollBarBorderRadius: 100,
    expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
    headerIconColor: baseColorAction.clone().setA(baseColorAction.a * opacityLoading).toRgbString(),
    headerIconHoverColor: baseColorActionHover.clone().setA(baseColorActionHover.a * opacityLoading).toRgbString(),
    expandIconHalfInner,
    expandIconSize,
    expandIconScale: controlInteractiveSize / expandIconSize
  };
};
var zIndexTableFixed = 2;
var style_default50 = genStyleHooks("Table", (token) => {
  const {
    colorTextHeading,
    colorSplit,
    colorBgContainer,
    controlInteractiveSize: checkboxSize,
    headerBg,
    headerColor,
    headerSortActiveBg,
    headerSortHoverBg,
    bodySortBg,
    rowHoverBg,
    rowSelectedBg,
    rowSelectedHoverBg,
    rowExpandedBg,
    cellPaddingBlock,
    cellPaddingInline,
    cellPaddingBlockMD,
    cellPaddingInlineMD,
    cellPaddingBlockSM,
    cellPaddingInlineSM,
    borderColor,
    footerBg,
    footerColor,
    headerBorderRadius,
    cellFontSize,
    cellFontSizeMD,
    cellFontSizeSM,
    headerSplitColor,
    fixedHeaderSortActiveBg,
    headerFilterHoverBg,
    filterDropdownBg,
    expandIconBg,
    selectionColumnWidth,
    stickyScrollBarBg,
    calc
  } = token;
  const tableToken = merge(token, {
    tableFontSize: cellFontSize,
    tableBg: colorBgContainer,
    tableRadius: headerBorderRadius,
    tablePaddingVertical: cellPaddingBlock,
    tablePaddingHorizontal: cellPaddingInline,
    tablePaddingVerticalMiddle: cellPaddingBlockMD,
    tablePaddingHorizontalMiddle: cellPaddingInlineMD,
    tablePaddingVerticalSmall: cellPaddingBlockSM,
    tablePaddingHorizontalSmall: cellPaddingInlineSM,
    tableBorderColor: borderColor,
    tableHeaderTextColor: headerColor,
    tableHeaderBg: headerBg,
    tableFooterTextColor: footerColor,
    tableFooterBg: footerBg,
    tableHeaderCellSplitColor: headerSplitColor,
    tableHeaderSortBg: headerSortActiveBg,
    tableHeaderSortHoverBg: headerSortHoverBg,
    tableBodySortBg: bodySortBg,
    tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
    tableHeaderFilterActiveBg: headerFilterHoverBg,
    tableFilterDropdownBg: filterDropdownBg,
    tableRowHoverBg: rowHoverBg,
    tableSelectedRowBg: rowSelectedBg,
    tableSelectedRowHoverBg: rowSelectedHoverBg,
    zIndexTableFixed,
    tableFontSizeMiddle: cellFontSizeMD,
    tableFontSizeSmall: cellFontSizeSM,
    tableSelectionColumnWidth: selectionColumnWidth,
    tableExpandIconBg: expandIconBg,
    tableExpandColumnWidth: calc(checkboxSize).add(calc(token.padding).mul(2)).equal(),
    tableExpandedRowBg: rowExpandedBg,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    // Mac scroll bar size
    tableScrollThumbBg: stickyScrollBarBg,
    tableScrollThumbBgHover: colorTextHeading,
    tableScrollBg: colorSplit
  });
  return [genTableStyle(tableToken), pagination_default2(tableToken), summary_default(tableToken), sorter_default(tableToken), filter_default(tableToken), bordered_default2(tableToken), radius_default(tableToken), expand_default(tableToken), summary_default(tableToken), empty_default2(tableToken), selection_default(tableToken), fixed_default(tableToken), sticky_default(tableToken), ellipsis_default(tableToken), size_default(tableToken), rtl_default3(tableToken), virtual_default(tableToken)];
}, prepareComponentToken44, {
  resetFont: false,
  unitless: {
    expandIconScale: true
  }
});

// node_modules/antd/es/table/InternalTable.js
var EMPTY_LIST5 = [];
var InternalTable = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    classNames,
    styles,
    size: customizeSize,
    bordered,
    dropdownPrefixCls: customizeDropdownPrefixCls,
    dataSource,
    pagination,
    rowSelection,
    rowKey: customizeRowKey,
    rowClassName,
    columns,
    children,
    childrenColumnName: legacyChildrenColumnName,
    onChange,
    getPopupContainer,
    loading,
    expandIcon,
    expandable,
    expandedRowRender,
    expandIconColumnIndex,
    indentSize,
    scroll,
    sortDirections,
    locale: locale2,
    showSorterTooltip = {
      target: "full-header"
    },
    virtual
  } = props;
  const warning2 = devUseWarning("Table");
  const baseColumns = React401.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
  const needResponsive = React401.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
  const screens = useBreakpoint_default(needResponsive);
  const mergedColumns = React401.useMemo(() => {
    const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
    return baseColumns.filter((c) => !c.responsive || c.responsive.some((r2) => matched.has(r2)));
  }, [baseColumns, screens]);
  const tableProps = omit(props, ["className", "style", "columns"]);
  const {
    locale: contextLocale = en_US_default4,
    table
  } = React401.useContext(ConfigContext);
  const {
    getPrefixCls,
    direction,
    renderEmpty,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("table");
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    bordered
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    pagination: {
      _default: "root"
    },
    header: {
      _default: "wrapper"
    },
    body: {
      _default: "wrapper"
    }
  });
  const tableLocale = {
    ...contextLocale.Table,
    ...locale2
  };
  const [globalLocale] = useLocale_default("global", en_US_default4.global);
  const rawData = dataSource || EMPTY_LIST5;
  const prefixCls = getPrefixCls("table", customizePrefixCls);
  const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
  const [, token] = useToken();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default50(prefixCls, rootCls);
  const mergedExpandable = {
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex,
    ...expandable,
    expandIcon: expandable?.expandIcon ?? table?.expandable?.expandIcon
  };
  const {
    childrenColumnName = "children"
  } = mergedExpandable;
  const expandType = React401.useMemo(() => {
    if (rawData.some((item) => item?.[childrenColumnName])) {
      return "nest";
    }
    if (expandedRowRender || expandable?.expandedRowRender) {
      return "row";
    }
    return null;
  }, [childrenColumnName, rawData]);
  const internalRefs = {
    body: React401.useRef(null)
  };
  const getContainerWidth = useContainerWidth(prefixCls);
  const rootRef = React401.useRef(null);
  const tblRef = React401.useRef(null);
  useProxyImperativeHandle(ref, () => ({
    ...tblRef.current,
    nativeElement: rootRef.current
  }));
  const rowKey = customizeRowKey || table?.rowKey || "key";
  if (true) {
    true ? warning2(!(typeof rowKey === "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.") : void 0;
  }
  const getRowKey = React401.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => record?.[rowKey];
  }, [rowKey]);
  const [getRecordByKey] = useLazyKVMap_default(rawData, childrenColumnName, getRowKey);
  const changeEventInfo = {};
  const triggerOnChange = (info, action, reset = false) => {
    const changeInfo = {
      ...changeEventInfo,
      ...info
    };
    if (reset) {
      changeEventInfo.resetPagination?.();
      if (changeInfo.pagination?.current) {
        changeInfo.pagination.current = 1;
      }
      if (pagination) {
        pagination.onChange?.(1, changeInfo.pagination?.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo(0, {
        getContainer: () => internalRefs.body.current
      });
    }
    onChange?.(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
      action
    });
  };
  const onSorterChange = (sorter, sorterStates) => {
    triggerOnChange({
      sorter,
      sorterStates
    }, "sort", false);
  };
  const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useSorter_default({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip,
    globalLocale
  });
  const sortedData = React401.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [childrenColumnName, rawData, sortStates]);
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  const onFilterChange = (filters2, filterStates2) => {
    triggerOnChange({
      filters: filters2,
      filterStates: filterStates2
    }, "filter", true);
  };
  const [transformFilterColumns, filterStates, filters] = useFilter_default({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    rootClassName: clsx(rootClassName, rootCls)
  });
  const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
  changeEventInfo.filters = filters;
  changeEventInfo.filterStates = filterStates;
  const columnTitleProps = React401.useMemo(() => {
    const mergedFilters = {};
    Object.keys(filters).forEach((filterKey) => {
      if (filters[filterKey] !== null) {
        mergedFilters[filterKey] = filters[filterKey];
      }
    });
    return {
      ...sorterTitleProps,
      filters: mergedFilters
    };
  }, [sorterTitleProps, filters]);
  const [transformTitleColumns] = useTitleColumns_default(columnTitleProps);
  const onPaginationChange = (current, pageSize) => {
    triggerOnChange({
      pagination: {
        ...changeEventInfo.pagination,
        current,
        pageSize
      }
    }, "paginate");
  };
  const [mergedPagination, resetPagination] = usePagination_default(mergedData.length, onPaginationChange, pagination);
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
  changeEventInfo.resetPagination = resetPagination;
  const pageData = React401.useMemo(() => {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    const {
      current = 1,
      total,
      pageSize = DEFAULT_PAGE_SIZE
    } = mergedPagination;
    true ? warning2(current > 0, "usage", "`current` should be positive number.") : void 0;
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        true ? warning2(false, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.") : void 0;
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination?.current, mergedPagination?.pageSize, mergedPagination?.total]);
  const [transformSelectionColumns, selectedKeySet] = useSelection_default({
    prefixCls,
    data: mergedData,
    pageData,
    getRowKey,
    getRecordByKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer: getPopupContainer || getContextPopupContainer
  }, rowSelection);
  const internalRowClassName = (record, index2, indent) => {
    const resolvedRowClassName = typeof rowClassName === "function" ? rowClassName(record, index2, indent) : rowClassName;
    return clsx({
      [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index2))
    }, resolvedRowClassName);
  };
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
  if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  if (typeof mergedExpandable.indentSize !== "number") {
    mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
  }
  const transformColumns = React401.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  let topPaginationNode;
  let bottomPaginationNode;
  if (pagination !== false && mergedPagination?.total) {
    let paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    }
    const renderPagination = (placement2 = "end") => React401.createElement(pagination_default, {
      ...mergedPagination,
      classNames: mergedClassNames.pagination,
      styles: mergedStyles.pagination,
      className: clsx(`${prefixCls}-pagination ${prefixCls}-pagination-${placement2}`, mergedPagination.className),
      size: paginationSize
    });
    const {
      placement,
      position: position2
    } = mergedPagination;
    const mergedPlacement = placement ?? position2;
    const normalizePlacement = (pos) => {
      const lowerPos = pos.toLowerCase();
      if (lowerPos.includes("center")) {
        return "center";
      }
      return lowerPos.includes("left") || lowerPos.includes("start") ? "start" : "end";
    };
    if (Array.isArray(mergedPlacement)) {
      const [topPos, bottomPos] = ["top", "bottom"].map((dir) => mergedPlacement.find((p) => p.includes(dir)));
      const isDisable = mergedPlacement.every((p) => `${p}` === "none");
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination();
      }
      if (topPos) {
        topPaginationNode = renderPagination(normalizePlacement(topPos));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(normalizePlacement(bottomPos));
      }
    } else {
      bottomPaginationNode = renderPagination();
    }
    if (true) {
      warning2.deprecated(!position2, "pagination.position", "pagination.placement");
    }
  }
  const spinProps = React401.useMemo(() => {
    if (typeof loading === "boolean") {
      return {
        spinning: loading
      };
    } else if (typeof loading === "object" && loading !== null) {
      return {
        spinning: true,
        ...loading
      };
    } else {
      return void 0;
    }
  }, [loading]);
  const wrappercls = clsx(cssVarCls, rootCls, `${prefixCls}-wrapper`, contextClassName, {
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style
  };
  const mergedEmptyNode = React401.useMemo(() => {
    if (spinProps?.spinning && rawData === EMPTY_LIST5) {
      return null;
    }
    if (typeof locale2?.emptyText !== "undefined") {
      return locale2.emptyText;
    }
    return renderEmpty?.("Table") || React401.createElement(defaultRenderEmpty_default, {
      componentName: "Table"
    });
  }, [spinProps?.spinning, rawData, locale2?.emptyText, renderEmpty]);
  const TableComponent = virtual ? VirtualTable_default2 : RcTable_default;
  const virtualProps = {};
  const listItemHeight = React401.useMemo(() => {
    const {
      fontSize,
      lineHeight,
      lineWidth,
      padding,
      paddingXS,
      paddingSM
    } = token;
    const fontHeight = Math.floor(fontSize * lineHeight);
    switch (mergedSize) {
      case "middle":
        return paddingSM * 2 + fontHeight + lineWidth;
      case "small":
        return paddingXS * 2 + fontHeight + lineWidth;
      default:
        return padding * 2 + fontHeight + lineWidth;
    }
  }, [token, mergedSize]);
  if (virtual) {
    virtualProps.listItemHeight = listItemHeight;
  }
  return React401.createElement("div", {
    ref: rootRef,
    className: wrappercls,
    style: mergedStyle
  }, React401.createElement(spin_default, {
    spinning: false,
    ...spinProps
  }, topPaginationNode, React401.createElement(TableComponent, {
    ...virtualProps,
    ...tableProps,
    classNames: mergedClassNames,
    styles: mergedStyles,
    ref: tblRef,
    columns: mergedColumns,
    direction,
    expandable: mergedExpandable,
    prefixCls,
    className: clsx({
      [`${prefixCls}-middle`]: mergedSize === "middle",
      [`${prefixCls}-small`]: mergedSize === "small",
      [`${prefixCls}-bordered`]: bordered,
      [`${prefixCls}-empty`]: rawData.length === 0
    }, cssVarCls, rootCls, hashId),
    data: pageData,
    rowKey: getRowKey,
    rowClassName: internalRowClassName,
    emptyText: mergedEmptyNode,
    // Internal
    internalHooks: INTERNAL_HOOKS,
    internalRefs,
    transformColumns,
    getContainerWidth,
    measureRowRender: (measureRow) => React401.createElement(config_provider_default, {
      getPopupContainer: (node) => node
    }, measureRow)
  }), bottomPaginationNode));
};
var InternalTable_default = React401.forwardRef(InternalTable);

// node_modules/antd/es/table/Table.js
var Table2 = (props, ref) => {
  const renderTimesRef = React402.useRef(0);
  renderTimesRef.current += 1;
  return React402.createElement(InternalTable_default, {
    ...props,
    ref,
    _renderTimes: renderTimesRef.current
  });
};
var ForwardTable = React402.forwardRef(Table2);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column_default2;
ForwardTable.ColumnGroup = ColumnGroup_default2;
ForwardTable.Summary = FooterComponents;
if (true) {
  ForwardTable.displayName = "Table";
}
var Table_default2 = ForwardTable;

// node_modules/antd/es/table/index.js
var table_default = Table_default2;

// node_modules/antd/es/tag/index.js
var React406 = __toESM(require_react());

// node_modules/antd/es/tag/CheckableTag.js
var React403 = __toESM(require_react());

// node_modules/antd/es/tag/style/index.js
var genBaseStyle12 = (token) => {
  const {
    paddingXXS,
    lineWidth,
    tagPaddingHorizontal,
    componentCls,
    calc
  } = token;
  const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
  const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
  return {
    // Result
    [componentCls]: {
      ...resetComponent(token),
      display: "inline-block",
      height: "auto",
      paddingInline,
      fontSize: token.tagFontSize,
      lineHeight: token.tagLineHeight,
      whiteSpace: "nowrap",
      backgroundColor: token.defaultBg,
      border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
      borderRadius: token.borderRadiusSM,
      opacity: 1,
      transition: `all ${token.motionDurationMid}`,
      textAlign: "start",
      position: "relative",
      // RTL
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: token.defaultColor
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: iconMarginInline,
        fontSize: token.tagIconSize,
        color: token.colorIcon,
        cursor: "pointer",
        transition: `all ${token.motionDurationMid}`,
        "&:hover": {
          color: token.colorTextHeading
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${componentCls}-checkable-checked):hover`]: {
          color: token.colorPrimary,
          backgroundColor: token.colorFillSecondary
        },
        "&:active, &-checked": {
          color: token.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: token.colorPrimary,
          "&:hover": {
            backgroundColor: token.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: token.colorPrimaryActive
        },
        "&-disabled": {
          cursor: "not-allowed",
          [`&:not(${componentCls}-checkable-checked)`]: {
            color: token.colorTextDisabled,
            "&:hover": {
              backgroundColor: "transparent"
            }
          },
          [`&${componentCls}-checkable-checked`]: {
            color: token.colorTextDisabled,
            backgroundColor: token.colorBgContainerDisabled
          },
          "&:hover, &:active": {
            backgroundColor: token.colorBgContainerDisabled,
            color: token.colorTextDisabled
          },
          [`&:not(${componentCls}-checkable-checked):hover`]: {
            color: token.colorTextDisabled
          }
        },
        "&-group": {
          display: "flex",
          flexWrap: "wrap",
          gap: token.paddingXS
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${token.iconCls} + span, > span + ${token.iconCls}`]: {
        marginInlineStart: paddingInline
      }
    },
    [`&${token.componentCls}-solid`]: {
      borderColor: "transparent",
      color: token.colorTextLightSolid,
      backgroundColor: token.colorBgSolid,
      [`&${componentCls}-default`]: {
        color: token.solidTextColor
      }
    },
    [`${componentCls}-filled`]: {
      borderColor: "transparent",
      backgroundColor: token.tagBorderlessBg
    },
    [`&${componentCls}-disabled`]: {
      color: token.colorTextDisabled,
      cursor: "not-allowed",
      backgroundColor: token.colorBgContainerDisabled,
      a: {
        cursor: "not-allowed",
        pointerEvents: "none",
        color: token.colorTextDisabled,
        "&:hover": {
          color: token.colorTextDisabled
        }
      },
      "a&": {
        "&:hover, &:active": {
          color: token.colorTextDisabled
        }
      },
      [`&${componentCls}-outlined`]: {
        borderColor: token.colorBorderDisabled
      },
      [`&${componentCls}-solid, &${componentCls}-filled`]: {
        color: token.colorTextDisabled,
        [`${componentCls}-close-icon`]: {
          color: token.colorTextDisabled
        }
      },
      [`${componentCls}-close-icon`]: {
        cursor: "not-allowed",
        color: token.colorTextDisabled,
        "&:hover": {
          color: token.colorTextDisabled
        }
      }
    }
  };
};
var prepareToken6 = (token) => {
  const {
    lineWidth,
    fontSizeIcon,
    calc
  } = token;
  const tagFontSize = token.fontSizeSM;
  const tagToken = merge(token, {
    tagFontSize,
    tagLineHeight: unit(calc(token.lineHeightSM).mul(tagFontSize).equal()),
    tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
    // Tag icon is much smaller
    tagPaddingHorizontal: 8,
    // Fixed padding.
    tagBorderlessBg: token.defaultBg
  });
  return tagToken;
};
var prepareComponentToken45 = (token) => {
  const solidTextColor = isBright(new AggregationColor(token.colorBgSolid), "#fff") ? "#000" : "#fff";
  return {
    defaultBg: new FastColor(token.colorFillQuaternary).onBackground(token.colorBgContainer).toHexString(),
    defaultColor: token.colorText,
    solidTextColor
  };
};
var style_default51 = genStyleHooks("Tag", (token) => {
  const tagToken = prepareToken6(token);
  return genBaseStyle12(tagToken);
}, prepareComponentToken45);

// node_modules/antd/es/tag/CheckableTag.js
var CheckableTag = React403.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    style,
    className,
    checked,
    children,
    icon,
    onChange,
    onClick,
    disabled: customDisabled,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    tag
  } = React403.useContext(ConfigContext);
  const disabled = React403.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const handleClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    onChange?.(!checked);
    onClick?.(e3);
  };
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [hashId, cssVarCls] = style_default51(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-checkable`, {
    [`${prefixCls}-checkable-checked`]: checked,
    [`${prefixCls}-checkable-disabled`]: mergedDisabled
  }, tag?.className, className, hashId, cssVarCls);
  return React403.createElement("span", {
    ...restProps,
    ref,
    style: {
      ...style,
      ...tag?.style
    },
    className: cls,
    onClick: handleClick
  }, icon, React403.createElement("span", null, children));
});
var CheckableTag_default = CheckableTag;

// node_modules/antd/es/tag/CheckableTagGroup.js
var import_react126 = __toESM(require_react());
function CheckableTagGroup(props, ref) {
  const {
    id,
    prefixCls: customizePrefixCls,
    rootClassName,
    className,
    style,
    classNames,
    styles,
    disabled,
    options,
    value,
    defaultValue,
    onChange,
    multiple,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tag");
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-checkable-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default51(prefixCls, rootCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const parsedOptions = (0, import_react126.useMemo)(() => (options || []).map((option) => {
    if (option && typeof option === "object") {
      return option;
    }
    return {
      value: option,
      label: option
    };
  }), [options]);
  const [mergedValue, setMergedValue] = useControlledState(defaultValue, value);
  const handleChange = (checked, option) => {
    let newValue = null;
    if (multiple) {
      const valueList = mergedValue || [];
      newValue = checked ? [].concat(_toConsumableArray(valueList), [option.value]) : valueList.filter((item) => item !== option.value);
    } else {
      newValue = checked ? option.value : null;
    }
    setMergedValue(newValue);
    onChange?.(newValue);
  };
  const divRef = import_react126.default.useRef(null);
  (0, import_react126.useImperativeHandle)(ref, () => ({
    nativeElement: divRef.current
  }));
  const ariaProps = pickAttrs(restProps, {
    aria: true,
    data: true
  });
  return import_react126.default.createElement("div", {
    ...ariaProps,
    className: clsx(groupPrefixCls, contextClassName, rootClassName, {
      [`${groupPrefixCls}-disabled`]: disabled,
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    }, hashId, cssVarCls, className, mergedClassNames.root),
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style
    },
    id,
    ref: divRef
  }, parsedOptions.map((option) => import_react126.default.createElement(CheckableTag_default, {
    key: option.value,
    className: clsx(`${groupPrefixCls}-item`, mergedClassNames.item),
    style: mergedStyles.item,
    checked: multiple ? (mergedValue || []).includes(option.value) : mergedValue === option.value,
    onChange: (checked) => handleChange(checked, option),
    disabled
  }, option.label)));
}
var ForwardCheckableTagGroup = import_react126.default.forwardRef(CheckableTagGroup);
if (true) {
  ForwardCheckableTagGroup.displayName = "CheckableTagGroup";
}
var CheckableTagGroup_default = ForwardCheckableTagGroup;

// node_modules/antd/es/tag/hooks/useColor.js
var React405 = __toESM(require_react());
function useColor(props, contextVariant) {
  const {
    color,
    variant,
    bordered
  } = props;
  return React405.useMemo(() => {
    const isInverseColor = color?.endsWith("-inverse");
    let nextVariant;
    if (variant) {
      nextVariant = variant;
    } else if (isInverseColor) {
      nextVariant = "solid";
    } else if (bordered === false) {
      nextVariant = "filled";
    } else {
      nextVariant = contextVariant || "filled";
    }
    const nextColor = isInverseColor ? color?.replace("-inverse", "") : color;
    const nextIsPreset = isPresetColor(color);
    const nextIsStatus = isPresetStatusColor(color);
    const tagStyle = {};
    if (!nextIsPreset && !nextIsStatus && nextColor) {
      if (nextVariant === "solid") {
        tagStyle.backgroundColor = color;
      } else {
        const hsl = new FastColor(nextColor).toHsl();
        hsl.l = 0.95;
        tagStyle.backgroundColor = new FastColor(hsl).toHexString();
        tagStyle.color = color;
        if (nextVariant === "outlined") {
          tagStyle.borderColor = color;
        }
      }
    }
    return [nextVariant, nextColor, nextIsPreset, nextIsStatus, tagStyle];
  }, [color, variant, bordered, contextVariant]);
}

// node_modules/antd/es/tag/style/presetCmp.js
var genPresetStyle = (token) => genPresetColor(token, (colorKey, {
  textColor,
  lightBorderColor,
  lightColor,
  darkColor
}) => ({
  [`${token.componentCls}${token.componentCls}-${colorKey}:not(${token.componentCls}-disabled)`]: {
    [`&${token.componentCls}-outlined`]: {
      backgroundColor: lightColor,
      borderColor: lightBorderColor,
      color: textColor
    },
    [`&${token.componentCls}-solid`]: {
      backgroundColor: darkColor,
      borderColor: darkColor,
      color: token.colorTextLightSolid
    },
    [`&${token.componentCls}-filled`]: {
      backgroundColor: lightColor,
      color: textColor
    }
  }
}));
var presetCmp_default = genSubStyleComponent(["Tag", "preset"], (token) => {
  const tagToken = prepareToken6(token);
  return genPresetStyle(tagToken);
}, prepareComponentToken45);

// node_modules/antd/es/_util/capitalize.js
function capitalize(str) {
  if (typeof str !== "string") {
    return str;
  }
  const ret = str.charAt(0).toUpperCase() + str.slice(1);
  return ret;
}

// node_modules/antd/es/tag/style/statusCmp.js
var genTagStatusStyle = (token, status, cssVariableType) => {
  const capitalizedCssVariableType = capitalize(cssVariableType);
  return {
    [`${token.componentCls}${token.componentCls}-${status}:not(${token.componentCls}-disabled)`]: {
      [`&${token.componentCls}-outlined`]: {
        backgroundColor: token[`color${capitalizedCssVariableType}Bg`],
        borderColor: token[`color${capitalizedCssVariableType}Border`],
        color: token[`color${cssVariableType}`]
      },
      [`&${token.componentCls}-solid`]: {
        backgroundColor: token[`color${cssVariableType}`],
        borderColor: token[`color${cssVariableType}`]
      },
      [`&${token.componentCls}-filled`]: {
        backgroundColor: token[`color${capitalizedCssVariableType}Bg`],
        color: token[`color${cssVariableType}`]
      }
    }
  };
};
var statusCmp_default = genSubStyleComponent(["Tag", "status"], (token) => {
  const tagToken = prepareToken6(token);
  return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
}, prepareComponentToken45);

// node_modules/antd/es/tag/index.js
var InternalTag = React406.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    children,
    icon,
    color,
    variant: _variant,
    onClose,
    bordered,
    disabled: customDisabled,
    href,
    target,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    variant: contextVariant,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tag");
  if (true) {
    const warning2 = devUseWarning("Tag");
    warning2.deprecated(bordered !== false, "bordered={false}", 'variant="filled"');
    warning2.deprecated(!color?.endsWith("-inverse"), 'color="xxx-inverse"', 'variant="solid"');
  }
  const [mergedVariant, mergedColor, isPreset, isStatus, customTagStyle] = useColor(props, contextVariant);
  const isInternalColor = isPreset || isStatus;
  const disabled = React406.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    tag: tagContext
  } = React406.useContext(ConfigContext);
  const [visible, setVisible] = React406.useState(true);
  const domProps = omit(restProps, ["closeIcon", "closable"]);
  const mergedProps = {
    ...props,
    color: mergedColor,
    variant: mergedVariant,
    disabled: mergedDisabled,
    href,
    target,
    icon
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const tagStyle = React406.useMemo(() => {
    let nextTagStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style
    };
    if (!mergedDisabled) {
      nextTagStyle = {
        ...customTagStyle,
        ...nextTagStyle
      };
    }
    return nextTagStyle;
  }, [mergedStyles.root, contextStyle, style, customTagStyle, mergedDisabled]);
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [hashId, cssVarCls] = style_default51(prefixCls);
  const tagClassName = clsx(prefixCls, contextClassName, mergedClassNames.root, `${prefixCls}-${mergedVariant}`, {
    [`${prefixCls}-${mergedColor}`]: isInternalColor,
    [`${prefixCls}-hidden`]: !visible,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-disabled`]: mergedDisabled
  }, className, rootClassName, hashId, cssVarCls);
  const handleCloseClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    e3.stopPropagation();
    onClose?.(e3);
    if (e3.defaultPrevented) {
      return;
    }
    setVisible(false);
  };
  const [, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(tagContext), {
    closable: false,
    closeIconRender: (iconNode2) => {
      const replacement = React406.createElement("span", {
        className: `${prefixCls}-close-icon`,
        onClick: handleCloseClick
      }, iconNode2);
      return replaceElement(iconNode2, replacement, (originProps) => ({
        onClick: (e3) => {
          originProps?.onClick?.(e3);
          handleCloseClick(e3);
        },
        className: clsx(originProps?.className, `${prefixCls}-close-icon`)
      }));
    }
  });
  const isNeedWave = typeof restProps.onClick === "function" || children && children.type === "a";
  const iconNode = cloneElement(icon, {
    className: clsx(React406.isValidElement(icon) ? icon.props?.className : "", mergedClassNames.icon),
    style: mergedStyles.icon
  });
  const child = iconNode ? React406.createElement(React406.Fragment, null, iconNode, children && React406.createElement("span", {
    className: mergedClassNames.content,
    style: mergedStyles.content
  }, children)) : children;
  const TagWrapper = href ? "a" : "span";
  const tagNode = React406.createElement(TagWrapper, {
    ...domProps,
    // @ts-expect-error
    ref,
    className: tagClassName,
    style: tagStyle,
    href: mergedDisabled ? void 0 : href,
    target,
    onClick: mergedDisabled ? void 0 : domProps.onClick,
    ...href && mergedDisabled ? {
      "aria-disabled": true
    } : {}
  }, child, mergedCloseIcon, isPreset && React406.createElement(presetCmp_default, {
    key: "preset",
    prefixCls
  }), isStatus && React406.createElement(statusCmp_default, {
    key: "status",
    prefixCls
  }));
  return isNeedWave ? React406.createElement(wave_default, {
    component: "Tag"
  }, tagNode) : tagNode;
});
var Tag = InternalTag;
if (true) {
  Tag.displayName = "Tag";
}
Tag.CheckableTag = CheckableTag_default;
Tag.CheckableTagGroup = CheckableTagGroup_default;
var tag_default = Tag;

// node_modules/antd/es/theme/getDesignToken.js
var getDesignToken = (config) => {
  const theme = config?.algorithm ? createTheme(config.algorithm) : theme_default;
  const mergedToken = {
    ...seed_default,
    ...config?.token
  };
  return getComputedToken(mergedToken, {
    override: config?.token
  }, theme, formatToken);
};
var getDesignToken_default = getDesignToken;

// node_modules/antd/es/theme/themes/compact/genCompactSizeMapToken.js
function genSizeMapToken(token) {
  const {
    sizeUnit,
    sizeStep
  } = token;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}

// node_modules/antd/es/theme/themes/compact/index.js
var derivative2 = (token, mapToken) => {
  const mergedMapToken = mapToken ?? derivative(token);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return {
    ...mergedMapToken,
    ...genSizeMapToken(mapToken ?? token),
    // font
    ...genFontMapToken_default(fontSize),
    // controlHeight
    controlHeight,
    ...genControlHeight_default({
      ...mergedMapToken,
      controlHeight
    })
  };
};
var compact_default2 = derivative2;

// node_modules/antd/es/theme/themes/dark/colorAlgorithm.js
var getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
var getSolidColor = (baseColor, brightness) => {
  const instance = new FastColor(baseColor);
  return instance.lighten(brightness).toHexString();
};

// node_modules/antd/es/theme/themes/dark/colors.js
var generateColorPalettes = (baseColor) => {
  const colors = generate(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
  };
};
var generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
    colorBgSolid: getAlphaColor(colorTextBase, 0.95),
    colorBgSolidHover: getAlphaColor(colorTextBase, 1),
    colorBgSolidActive: getAlphaColor(colorTextBase, 0.9),
    colorBgElevated: getSolidColor(colorBgBase, 12),
    colorBgContainer: getSolidColor(colorBgBase, 8),
    colorBgLayout: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getSolidColor(colorBgBase, 26),
    colorBgBlur: getAlphaColor(colorTextBase, 0.04),
    colorBorder: getSolidColor(colorBgBase, 26),
    colorBorderDisabled: getSolidColor(colorBgBase, 26),
    colorBorderSecondary: getSolidColor(colorBgBase, 19)
  };
};

// node_modules/antd/es/theme/themes/dark/index.js
var derivative3 = (token, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate(token[colorKey], {
      theme: "dark"
    });
    return Array.from({
      length: 10
    }, () => 1).reduce((prev, _, i) => {
      prev[`${colorKey}-${i + 1}`] = colors[i];
      prev[`${colorKey}${i + 1}`] = colors[i];
      return prev;
    }, {});
  }).reduce((prev, cur) => {
    prev = {
      ...prev,
      ...cur
    };
    return prev;
  }, {});
  const mergedMapToken = mapToken ?? derivative(token);
  const colorMapToken = genColorMapToken(token, {
    generateColorPalettes,
    generateNeutralColorPalettes
  });
  return {
    ...mergedMapToken,
    // Dark tokens
    ...colorPalettes,
    // Colors
    ...colorMapToken,
    // Customize selected item background color
    // https://github.com/ant-design/ant-design/issues/30524#issuecomment-871961867
    colorPrimaryBg: colorMapToken.colorPrimaryBorder,
    colorPrimaryBgHover: colorMapToken.colorPrimaryBorderHover
  };
};
var dark_default = derivative3;

// node_modules/antd/es/theme/index.js
function useToken2() {
  const [theme, token, hashId, cssVar] = useToken();
  return {
    theme,
    token,
    hashId,
    cssVar
  };
}
var theme_default3 = {
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  useToken: useToken2,
  defaultAlgorithm: derivative,
  darkAlgorithm: dark_default,
  compactAlgorithm: compact_default2,
  getDesignToken: getDesignToken_default,
  /**
   * @private Private variable
   * @warring  Do not use in production. 
   */
  defaultConfig,
  /**
   * @private Private variable
   * @warring  Do not use in production. 
   */
  _internalContext: DesignTokenContext
};

// node_modules/antd/es/time-picker/index.js
var React407 = __toESM(require_react());
var {
  TimePicker: InternalTimePicker,
  RangePicker: InternalRangePicker
} = date_picker_default;
var RangePicker2 = React407.forwardRef((props, ref) => React407.createElement(InternalRangePicker, {
  ...props,
  picker: "time",
  mode: void 0,
  ref
}));
var TimePicker = React407.forwardRef((props, ref) => {
  const {
    addon,
    renderExtraFooter,
    variant,
    bordered,
    classNames,
    styles,
    popupClassName,
    popupStyle,
    ...restProps
  } = props;
  if (true) {
    const warning2 = devUseWarning("TimePicker");
    warning2.deprecated(!addon, "addon", "renderExtraFooter");
  }
  const [mergedVariant] = useVariants_default("timePicker", variant, bordered);
  const internalRenderExtraFooter = React407.useMemo(() => {
    if (renderExtraFooter) {
      return renderExtraFooter;
    }
    if (addon) {
      return addon;
    }
    return void 0;
  }, [addon, renderExtraFooter]);
  const mergedProps = {
    ...props,
    variant: mergedVariant
  };
  const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default("timePicker", classNames, styles, popupClassName, popupStyle, mergedProps);
  return React407.createElement(InternalTimePicker, {
    ...restProps,
    mode: void 0,
    ref,
    renderExtraFooter: internalRenderExtraFooter,
    variant: mergedVariant,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
});
if (true) {
  TimePicker.displayName = "TimePicker";
}
var PurePanel12 = PurePanel_default(TimePicker, "popupAlign", void 0, "picker");
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel12;
TimePicker.RangePicker = RangePicker2;
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel12;
var time_picker_default = TimePicker;

// node_modules/antd/es/timeline/Timeline.js
var React409 = __toESM(require_react());

// node_modules/antd/es/timeline/style/horizontal.js
var genHorizontalStyle3 = (token) => {
  const {
    componentCls,
    fontHeight
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-horizontal`]: {
      "--steps-title-vertical-row-gap": token.paddingXS,
      "--timeline-content-height": `${unit(fontHeight)}`,
      // =============================================================
      // ==                          Share                          ==
      // =============================================================
      alignItems: "stretch",
      // =============================================================
      // ==                        Alternate                        ==
      // =============================================================
      [`&${componentCls}-layout-alternate`]: {
        [itemCls]: {
          [`${itemCls}-wrapper`]: {
            "--timeline-alternate-content-offset": `calc(var(--timeline-content-height) + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`,
            height: `calc(var(--timeline-content-height) * 2 + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`
          },
          // Icon
          [`${itemCls}-icon`]: {
            position: "absolute"
          },
          // Icon & Rail
          [`${itemCls}-icon, ${itemCls}-rail`]: {
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%)",
            margin: 0
          },
          // Title & Content
          [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
            whiteSpace: "nowrap",
            maxWidth: "unset"
          },
          // Title
          [`${itemCls}-title`]: {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%)"
          },
          // Content
          [`${itemCls}-content`]: {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%)"
          },
          // Placement
          "&-placement-start": {
            [`${itemCls}-title`]: {
              bottom: "var(--timeline-alternate-content-offset)"
            },
            [`${itemCls}-content`]: {
              top: "var(--timeline-alternate-content-offset)"
            }
          },
          "&-placement-end": {
            [`${itemCls}-title`]: {
              top: "var(--timeline-alternate-content-offset)"
            },
            [`${itemCls}-content`]: {
              bottom: "var(--timeline-alternate-content-offset)"
            }
          }
        }
      },
      // =============================================================
      // ==                        Same Side                        ==
      // =============================================================
      [`&:not(${componentCls}-layout-alternate)`]: {
        [`${itemCls}-placement-end`]: {
          display: "flex",
          alignItems: "flex-end",
          [`${itemCls}-wrapper`]: {
            flex: "auto",
            flexDirection: "column-reverse"
          },
          [`${itemCls}-rail`]: {
            top: "auto",
            bottom: "var(--steps-horizontal-rail-margin)",
            transform: "translateY(50%)"
          }
        }
      }
    }
  };
};
var horizontal_default3 = genHorizontalStyle3;

// node_modules/antd/es/timeline/style/index.js
var genTimelineStyle = (token) => {
  const {
    componentCls,
    tailColor
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: [
      // ==============================================================
      // ==                           Item                           ==
      // ==============================================================
      {
        ...resetComponent(token),
        [itemCls]: {
          "--steps-title-horizontal-title-height": token.fontHeight,
          "--steps-vertical-rail-margin": "0px",
          "--steps-title-horizontal-rail-gap": "0px",
          // Root Level: Record Steps icon size and support fallback
          "--steps-icon-dot-size-origin": "var(--steps-icon-size-active)",
          "--steps-icon-dot-size-custom": token.dotSize,
          // Item Level: Record Steps icon color and support fallback
          "--steps-item-icon-dot-bg-color-origin": "var(--steps-item-icon-dot-bg-color)",
          "--steps-item-icon-dot-bg-color-custom": token.dotBg,
          "--steps-icon-size": "var(--steps-icon-dot-size-custom, var(--steps-icon-dot-size-origin))",
          // Icon
          [`${itemCls}-icon`]: {
            "--steps-dot-icon-border-width": token.dotBorderWidth,
            "--steps-dot-icon-size": "var(--steps-icon-size)",
            "--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-bg-color-custom, var(--steps-item-icon-dot-bg-color-origin))"
          },
          // Title
          [`${itemCls}-title`]: {
            fontSize: token.fontSize,
            lineHeight: token.lineHeight
          },
          // Content
          [`${itemCls}-content`]: {
            color: token.colorText
          },
          // Rail
          [`${itemCls}-rail`]: {
            "--steps-item-solid-line-color": tailColor,
            "--steps-rail-size": token.tailWidth
          }
        }
      },
      // ==============================================================
      // ==                          Status                          ==
      // ==============================================================
      {
        [itemCls]: {
          "--steps-item-process-rail-line-style": "dotted"
        },
        [`${itemCls}${itemCls}${itemCls}-color`]: {
          "&-blue": {
            "--steps-item-icon-dot-color": token.colorPrimary
          },
          "&-red": {
            "--steps-item-icon-dot-color": token.colorError
          },
          "&-green": {
            "--steps-item-icon-dot-color": token.colorSuccess
          },
          "&-gray": {
            "--steps-item-icon-dot-color": token.colorTextDisabled
          }
        }
      }
    ]
  };
};
var genVerticalStyle3 = (token) => {
  const {
    calc,
    componentCls,
    itemPaddingBottom
  } = token;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}:not(${componentCls}-horizontal)`]: {
      "--timeline-head-span": "12",
      "--timeline-head-span-ptg": "calc(var(--timeline-head-span) / 24 * 100%)",
      // =============================================================
      // ==                        Alternate                        ==
      // =============================================================
      [`&${componentCls}-layout-alternate`]: {
        [itemCls]: {
          "--timeline-alternate-gap": calc(token.margin).mul(2).add("var(--steps-dot-icon-size)").equal(),
          minHeight: "auto",
          paddingBottom: itemPaddingBottom,
          // Icon & Rail
          [`${itemCls}-icon, ${itemCls}-rail`]: {
            position: "absolute",
            insetInlineStart: "var(--timeline-head-span-ptg)"
          },
          // Icon
          [`${itemCls}-icon`]: {
            marginInlineStart: `calc(var(--steps-icon-size) / -2)`
          },
          // Section
          [`${itemCls}-section`]: {
            display: "flex",
            flexWrap: "nowrap",
            gap: "var(--timeline-alternate-gap)"
          },
          // >>> Header
          [`${itemCls}-header`]: {
            textAlign: "end",
            flexDirection: "column",
            alignItems: "stretch",
            flex: "1 1 calc(var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
          },
          // >>> Content
          [`${itemCls}-content`]: {
            textAlign: "start",
            flex: "1 1 calc(100% - var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
          },
          // Placement
          "&-placement-end": {
            [`${itemCls}-header`]: {
              textAlign: "start",
              order: 1
            },
            [`${itemCls}-content`]: {
              textAlign: "end"
            },
            [`${itemCls}-icon, ${itemCls}-rail`]: {
              insetInlineStart: "calc(100% - var(--timeline-head-span-ptg))"
            }
          }
        }
      },
      // =============================================================
      // ==                        Same Side                        ==
      // =============================================================
      [`&:not(${componentCls}-layout-alternate)`]: {
        [`${itemCls}-placement-end`]: {
          textAlign: "end",
          [`${itemCls}-icon`]: {
            order: 1
          },
          [`${itemCls}-rail`]: {
            insetInlineStart: "auto",
            insetInlineEnd: "calc(var(--steps-icon-size) / 2)",
            marginInlineEnd: `calc(var(--steps-rail-size) / -2)`
          }
        }
      }
    }
  };
};
var prepareComponentToken46 = (token) => ({
  tailColor: token.colorSplit,
  tailWidth: token.lineWidthBold,
  dotBorderWidth: token.lineWidthBold,
  dotBg: void 0,
  dotSize: void 0,
  itemPaddingBottom: token.padding * 1.25
});
var style_default52 = genStyleHooks("Timeline", (token) => {
  const timeLineToken = merge(token, {
    itemHeadSize: 10,
    customHeadPaddingVertical: token.paddingXXS,
    paddingInlineEnd: 2
  });
  return [genTimelineStyle(timeLineToken), genVerticalStyle3(timeLineToken), horizontal_default3(timeLineToken)];
}, prepareComponentToken46);

// node_modules/antd/es/timeline/useItems.js
var React408 = __toESM(require_react());
function useItems4(prefixCls, mode, items, children, pending, pendingDot) {
  const itemCls = `${prefixCls}-item`;
  const parseItems2 = React408.useMemo(() => {
    return Array.isArray(items) ? items : toArray(children).map((ele) => ({
      ...ele.props
    }));
  }, [items, children]);
  return React408.useMemo(() => {
    const mergedItems = parseItems2.map((item, index2) => {
      const {
        label,
        children: children2,
        title,
        content,
        color,
        className,
        style,
        icon,
        dot,
        placement,
        position: position2,
        loading,
        ...restProps
      } = item;
      let mergedStyle = style;
      let mergedClassName = className;
      if (color) {
        if (["blue", "red", "green", "gray"].includes(color)) {
          mergedClassName = clsx(className, `${itemCls}-color-${color}`);
        } else {
          mergedStyle = {
            "--steps-item-icon-dot-color": color,
            ...style
          };
        }
      }
      const mergedPlacement = placement ?? position2 ?? (mode === "alternate" ? index2 % 2 === 0 ? "start" : "end" : mode);
      mergedClassName = clsx(mergedClassName, `${itemCls}-placement-${mergedPlacement}`);
      let mergedIcon = icon ?? dot;
      if (!mergedIcon && loading) {
        mergedIcon = React408.createElement(LoadingOutlined_default, null);
      }
      return {
        ...restProps,
        title: title ?? label,
        content: content ?? children2,
        style: mergedStyle,
        className: mergedClassName,
        icon: mergedIcon,
        status: loading ? "process" : "finish"
      };
    });
    if (pending) {
      mergedItems.push({
        icon: pendingDot ?? React408.createElement(LoadingOutlined_default, null),
        content: pending,
        status: "process"
      });
    }
    return mergedItems;
  }, [parseItems2, pending, pendingDot, itemCls, mode]);
}

// node_modules/antd/es/timeline/Timeline.js
var stepInternalContext = {
  rootComponent: "ol",
  itemComponent: "li"
};
var Timeline = (props) => {
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("timeline");
  const {
    prefixCls: customizePrefixCls,
    // Style
    className,
    style,
    classNames,
    styles,
    // Design
    variant = "outlined",
    mode,
    orientation = "vertical",
    titleSpan,
    // Data
    items,
    children,
    reverse,
    // Legacy Pending
    pending,
    pendingDot,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("timeline", customizePrefixCls);
  const [hashId, cssVarCls] = style_default52(prefixCls);
  const stepsClassNames = React409.useMemo(() => ({
    item: `${prefixCls}-item`,
    itemTitle: `${prefixCls}-item-title`,
    itemIcon: `${prefixCls}-item-icon`,
    itemContent: `${prefixCls}-item-content`,
    itemRail: `${prefixCls}-item-rail`,
    itemWrapper: `${prefixCls}-item-wrapper`,
    itemSection: `${prefixCls}-item-section`,
    itemHeader: `${prefixCls}-item-header`
  }), [prefixCls]);
  const mergedMode = React409.useMemo(() => {
    if (mode === "left") {
      return "start";
    }
    if (mode === "right") {
      return "end";
    }
    const modeList = ["alternate", "start", "end"];
    return modeList.includes(mode) ? mode : "start";
  }, [mode]);
  const rawItems = useItems4(prefixCls, mergedMode, items, children, pending, pendingDot);
  const mergedItems = React409.useMemo(() => reverse ? _toConsumableArray(rawItems).reverse() : rawItems, [reverse, rawItems]);
  const mergedProps = {
    ...props,
    variant,
    mode: mergedMode,
    orientation,
    items: mergedItems
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([stepsClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const stepContext = React409.useMemo(() => ({
    railFollowPrevStatus: reverse
  }), [reverse]);
  const layoutAlternate = React409.useMemo(() => mergedMode === "alternate" || orientation === "vertical" && mergedItems.some((item) => item.title), [mergedItems, mergedMode, orientation]);
  if (true) {
    const warning2 = devUseWarning("Timeline");
    warning2.deprecated(!children, "Timeline.Item", "items");
    const pendingWarning = "You can create a `item` as pending node directly.";
    warning2.deprecated(!pending, "pending", "items", pendingWarning);
    warning2.deprecated(!pendingDot, "pendingDot", "items", pendingWarning);
    warning2.deprecated(mode !== "left" && mode !== "right", "mode=left|right", "mode=start|end");
    const warnItems = items || [];
    [["label", "title"], ["children", "content"], ["dot", "icon"], ["position", "placement"]].forEach(([oldProp, newProp]) => {
      warning2.deprecated(warnItems.every((item) => !item[oldProp]), `items.${oldProp}`, `items.${newProp}`);
    });
  }
  const stepStyle = {
    ...contextStyle,
    ...style
  };
  if (titleSpan && mergedMode !== "alternate") {
    if (typeof titleSpan === "number") {
      stepStyle["--timeline-head-span"] = titleSpan;
    } else {
      stepStyle["--timeline-head-span-ptg"] = titleSpan;
    }
  }
  return React409.createElement(InternalContext.Provider, {
    value: stepInternalContext
  }, React409.createElement(UnstableContext2.Provider, {
    value: stepContext
  }, React409.createElement(steps_default, {
    ...restProps,
    // Style
    className: clsx(prefixCls, contextClassName, className, hashId, cssVarCls, {
      [`${prefixCls}-${orientation}`]: orientation === "horizontal",
      [`${prefixCls}-layout-alternate`]: layoutAlternate,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }),
    style: stepStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    // Design
    variant,
    orientation,
    // Layout
    type: "dot",
    items: mergedItems,
    current: mergedItems.length - 1
  })));
};
Timeline.Item = () => {
};
if (true) {
  Timeline.displayName = "Timeline";
}
var Timeline_default = Timeline;

// node_modules/antd/es/timeline/index.js
var timeline_default = Timeline_default;

// node_modules/antd/es/tour/index.js
var import_react131 = __toESM(require_react());

// node_modules/@rc-component/tour/es/Tour.js
var React415 = __toESM(require_react());
var import_react129 = __toESM(require_react());

// node_modules/@rc-component/tour/es/hooks/useClosable.js
var React410 = __toESM(require_react());
function isConfigObj(closable) {
  return closable !== null && typeof closable === "object";
}
function getClosableConfig(closable, closeIcon, preset) {
  if (closable === false || closeIcon === false && (!isConfigObj(closable) || !closable.closeIcon)) {
    return null;
  }
  const mergedCloseIcon = typeof closeIcon !== "boolean" ? closeIcon : void 0;
  if (isConfigObj(closable)) {
    return {
      ...closable,
      closeIcon: closable.closeIcon ?? mergedCloseIcon
    };
  }
  return preset || closable || closeIcon ? {
    closeIcon: mergedCloseIcon
  } : "empty";
}
function useClosable2(stepClosable, stepCloseIcon, closable, closeIcon) {
  return React410.useMemo(() => {
    const stepClosableConfig = getClosableConfig(stepClosable, stepCloseIcon, false);
    const rootClosableConfig = getClosableConfig(closable, closeIcon, true);
    if (stepClosableConfig !== "empty") {
      return stepClosableConfig;
    }
    return rootClosableConfig;
  }, [closable, closeIcon, stepClosable, stepCloseIcon]);
}

// node_modules/@rc-component/tour/es/hooks/useTarget.js
var import_react127 = __toESM(require_react());

// node_modules/@rc-component/tour/es/util.js
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const {
    top,
    right,
    bottom,
    left
  } = element.getBoundingClientRect();
  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
function getPlacement(targetElement, placement, stepPlacement) {
  return stepPlacement ?? placement ?? (targetElement === null ? "center" : "bottom");
}

// node_modules/@rc-component/tour/es/hooks/useTarget.js
function isValidNumber(val) {
  return typeof val === "number" && !Number.isNaN(val);
}
function useTarget(target, open3, gap, scrollIntoViewOptions, inlineMode, placeholderRef) {
  const [targetElement, setTargetElement] = (0, import_react127.useState)(void 0);
  useLayoutEffect_default(() => {
    const nextElement = typeof target === "function" ? target() : target;
    setTargetElement(nextElement || null);
  });
  const [posInfo, setPosInfo] = (0, import_react127.useState)(null);
  const updatePos = useEvent_default(() => {
    if (targetElement) {
      if (!inlineMode && !isInViewPort(targetElement) && open3) {
        targetElement.scrollIntoView(scrollIntoViewOptions);
      }
      const {
        left,
        top,
        width,
        height
      } = targetElement.getBoundingClientRect();
      const nextPosInfo = {
        left,
        top,
        width,
        height,
        radius: 0
      };
      if (inlineMode) {
        const parentRect = placeholderRef.current?.parentElement?.getBoundingClientRect();
        if (parentRect) {
          nextPosInfo.left -= parentRect.left;
          nextPosInfo.top -= parentRect.top;
        }
      }
      setPosInfo((origin) => {
        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {
          return nextPosInfo;
        }
        return origin;
      });
    } else {
      setPosInfo(null);
    }
  });
  const getGapOffset = (index2) => (Array.isArray(gap?.offset) ? gap?.offset[index2] : gap?.offset) ?? 6;
  useLayoutEffect_default(() => {
    updatePos();
    window.addEventListener("resize", updatePos);
    window.addEventListener("scroll", updatePos);
    return () => {
      window.removeEventListener("resize", updatePos);
      window.removeEventListener("scroll", updatePos);
    };
  }, [targetElement, open3, updatePos]);
  const mergedPosInfo = (0, import_react127.useMemo)(() => {
    if (!posInfo) {
      return posInfo;
    }
    const gapOffsetX = getGapOffset(0);
    const gapOffsetY = getGapOffset(1);
    const gapRadius = isValidNumber(gap?.radius) ? gap?.radius : 2;
    return {
      left: posInfo.left - gapOffsetX,
      top: posInfo.top - gapOffsetY,
      width: posInfo.width + gapOffsetX * 2,
      height: posInfo.height + gapOffsetY * 2,
      radius: gapRadius
    };
  }, [posInfo, gap]);
  return [mergedPosInfo, targetElement];
}

// node_modules/@rc-component/tour/es/Mask.js
var import_react128 = __toESM(require_react());
function _extends73() {
  _extends73 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends73.apply(this, arguments);
}
var COVER_PROPS = {
  fill: "transparent",
  pointerEvents: "auto"
};
var Mask2 = (props) => {
  const {
    prefixCls,
    rootClassName,
    pos,
    showMask,
    style = {},
    fill = "rgba(0,0,0,0.5)",
    open: open3,
    animated,
    zIndex,
    disabledInteraction,
    styles,
    classNames: tourClassNames,
    getPopupContainer
  } = props;
  const id = useId_default();
  const maskId = `${prefixCls}-mask-${id}`;
  const mergedAnimated = typeof animated === "object" ? animated?.placeholder : animated;
  const isSafari = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const maskRectSize = isSafari ? {
    width: "100%",
    height: "100%"
  } : {
    width: "100vw",
    height: "100vh"
  };
  const inlineMode = getPopupContainer === false;
  return import_react128.default.createElement(es_default2, {
    open: open3,
    autoLock: !inlineMode,
    getContainer: getPopupContainer
  }, import_react128.default.createElement("div", {
    className: clsx(`${prefixCls}-mask`, rootClassName, tourClassNames?.mask),
    style: {
      position: inlineMode ? "absolute" : "fixed",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      zIndex,
      pointerEvents: pos && !disabledInteraction ? "none" : "auto",
      ...style,
      ...styles?.mask
    }
  }, showMask ? import_react128.default.createElement("svg", {
    style: {
      width: "100%",
      height: "100%"
    }
  }, import_react128.default.createElement("defs", null, import_react128.default.createElement("mask", {
    id: maskId
  }, import_react128.default.createElement("rect", _extends73({
    x: "0",
    y: "0"
  }, maskRectSize, {
    fill: "white"
  })), pos && import_react128.default.createElement("rect", {
    x: pos.left,
    y: pos.top,
    rx: pos.radius,
    width: pos.width,
    height: pos.height,
    fill: "black",
    className: mergedAnimated ? `${prefixCls}-placeholder-animated` : ""
  }))), import_react128.default.createElement("rect", {
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    fill,
    mask: `url(#${maskId})`
  }), pos && import_react128.default.createElement(import_react128.default.Fragment, null, import_react128.default.createElement("rect", _extends73({}, COVER_PROPS, {
    x: "0",
    y: "0",
    width: "100%",
    height: Math.max(pos.top, 0)
  })), import_react128.default.createElement("rect", _extends73({}, COVER_PROPS, {
    x: "0",
    y: "0",
    width: Math.max(pos.left, 0),
    height: "100%"
  })), import_react128.default.createElement("rect", _extends73({}, COVER_PROPS, {
    x: "0",
    y: pos.top + pos.height,
    width: "100%",
    height: `calc(100% - ${pos.top + pos.height}px)`
  })), import_react128.default.createElement("rect", _extends73({}, COVER_PROPS, {
    x: pos.left + pos.width,
    y: "0",
    width: `calc(100% - ${pos.left + pos.width}px)`,
    height: "100%"
  })))) : null));
};
var Mask_default2 = Mask2;

// node_modules/@rc-component/tour/es/placements.js
var targetOffset2 = [0, 0];
var basePlacements = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function getPlacements2(arrowPointAtCenter = false) {
  const placements4 = {};
  Object.keys(basePlacements).forEach((key) => {
    placements4[key] = {
      ...basePlacements[key],
      autoArrow: arrowPointAtCenter,
      targetOffset: targetOffset2
    };
  });
  return placements4;
}
var placements3 = getPlacements2();

// node_modules/@rc-component/tour/es/TourStep/index.js
var React413 = __toESM(require_react());

// node_modules/@rc-component/tour/es/TourStep/DefaultPanel.js
var React412 = __toESM(require_react());
function _extends74() {
  _extends74 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends74.apply(this, arguments);
}
function DefaultPanel(props) {
  const {
    prefixCls,
    current,
    total,
    title,
    description,
    onClose,
    onPrev,
    onNext,
    onFinish,
    className,
    closable,
    classNames: tourClassNames,
    styles
  } = props;
  const ariaProps = pickAttrs(closable || {}, true);
  const closeIcon = closable?.closeIcon ?? React412.createElement("span", {
    className: `${prefixCls}-close-x`
  }, "");
  const mergedClosable = !!closable;
  return React412.createElement("div", {
    className: clsx(`${prefixCls}-panel`, className)
  }, React412.createElement("div", {
    className: clsx(`${prefixCls}-section`, tourClassNames?.section),
    style: styles?.section
  }, mergedClosable && React412.createElement("button", _extends74({
    type: "button",
    onClick: onClose,
    "aria-label": "Close"
  }, ariaProps, {
    className: `${prefixCls}-close`
  }), closeIcon), React412.createElement("div", {
    className: clsx(`${prefixCls}-header`, tourClassNames?.header),
    style: styles?.header
  }, React412.createElement("div", {
    className: clsx(`${prefixCls}-title`, tourClassNames?.title),
    style: styles?.title
  }, title)), React412.createElement("div", {
    className: clsx(`${prefixCls}-description`, tourClassNames?.description),
    style: styles?.description
  }, description), React412.createElement("div", {
    className: clsx(`${prefixCls}-footer`, tourClassNames?.footer),
    style: styles?.footer
  }, React412.createElement("div", {
    className: `${prefixCls}-sliders`
  }, total > 1 ? [...Array.from({
    length: total
  }).keys()].map((item, index2) => {
    return React412.createElement("span", {
      key: item,
      className: index2 === current ? "active" : ""
    });
  }) : null), React412.createElement("div", {
    className: clsx(`${prefixCls}-actions`, tourClassNames?.actions),
    style: styles?.actions
  }, current !== 0 ? React412.createElement("button", {
    className: `${prefixCls}-prev-btn`,
    onClick: onPrev
  }, "Prev") : null, current === total - 1 ? React412.createElement("button", {
    className: `${prefixCls}-finish-btn`,
    onClick: onFinish
  }, "Finish") : React412.createElement("button", {
    className: `${prefixCls}-next-btn`,
    onClick: onNext
  }, "Next")))));
}

// node_modules/@rc-component/tour/es/TourStep/index.js
var TourStep = (props) => {
  const {
    current,
    renderPanel
  } = props;
  return React413.createElement(React413.Fragment, null, typeof renderPanel === "function" ? renderPanel(props, current) : React413.createElement(DefaultPanel, props));
};
var TourStep_default = TourStep;

// node_modules/@rc-component/tour/es/Placeholder.js
var React414 = __toESM(require_react());
var Placeholder = React414.forwardRef((props, ref) => {
  const {
    open: open3,
    autoLock,
    getContainer,
    domRef,
    className,
    style,
    fallbackDOM
  } = props;
  React414.useImperativeHandle(ref, () => domRef.current || fallbackDOM());
  return React414.createElement(es_default2, {
    open: open3,
    autoLock,
    getContainer
  }, React414.createElement("div", {
    ref: domRef,
    className,
    style
  }));
});
if (true) {
  Placeholder.displayName = "Placeholder";
}
var Placeholder_default = Placeholder;

// node_modules/@rc-component/tour/es/Tour.js
function _extends75() {
  _extends75 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends75.apply(this, arguments);
}
var CENTER_PLACEHOLDER = {
  left: "50%",
  top: "50%",
  width: 1,
  height: 1
};
var defaultScrollIntoViewOptions = {
  block: "center",
  inline: "center"
};
var Tour = (props) => {
  const {
    prefixCls = "rc-tour",
    steps = [],
    defaultCurrent,
    current,
    onChange,
    onClose,
    onFinish,
    open: open3,
    defaultOpen,
    mask = true,
    arrow = true,
    rootClassName,
    placement,
    renderPanel,
    gap,
    animated,
    scrollIntoViewOptions = defaultScrollIntoViewOptions,
    zIndex = 1001,
    closeIcon,
    closable,
    builtinPlacements,
    disabledInteraction,
    styles,
    classNames: tourClassNames,
    className,
    style,
    getPopupContainer,
    ...restProps
  } = props;
  const triggerRef = React415.useRef();
  const [mergedCurrent, setMergedCurrent] = useControlledState(defaultCurrent || 0, current);
  const [internalOpen, setMergedOpen] = useControlledState(defaultOpen, open3);
  const mergedOpen = mergedCurrent < 0 || mergedCurrent >= steps.length ? false : internalOpen ?? true;
  const [hasOpened, setHasOpened] = React415.useState(mergedOpen);
  const openRef = React415.useRef(mergedOpen);
  useLayoutEffect_default(() => {
    if (mergedOpen) {
      if (!openRef.current) {
        setMergedCurrent(0);
      }
      setHasOpened(true);
    }
    openRef.current = mergedOpen;
  }, [mergedOpen]);
  const {
    target,
    placement: stepPlacement,
    style: stepStyle,
    arrow: stepArrow,
    className: stepClassName,
    mask: stepMask,
    scrollIntoViewOptions: stepScrollIntoViewOptions = defaultScrollIntoViewOptions,
    closeIcon: stepCloseIcon,
    closable: stepClosable
  } = steps[mergedCurrent] || {};
  const mergedClosable = useClosable2(stepClosable, stepCloseIcon, closable, closeIcon);
  const mergedMask = mergedOpen && (stepMask ?? mask);
  const mergedScrollIntoViewOptions = stepScrollIntoViewOptions ?? scrollIntoViewOptions;
  const placeholderRef = React415.useRef(null);
  const inlineMode = getPopupContainer === false;
  const [posInfo, targetElement] = useTarget(target, open3, gap, mergedScrollIntoViewOptions, inlineMode, placeholderRef);
  const mergedPlacement = getPlacement(targetElement, placement, stepPlacement);
  const mergedArrow = targetElement ? typeof stepArrow === "undefined" ? arrow : stepArrow : false;
  const arrowPointAtCenter = typeof mergedArrow === "object" ? mergedArrow.pointAtCenter : false;
  useLayoutEffect_default(() => {
    triggerRef.current?.forceAlign();
  }, [arrowPointAtCenter, mergedCurrent]);
  const onInternalChange = (nextCurrent) => {
    setMergedCurrent(nextCurrent);
    onChange?.(nextCurrent);
  };
  const mergedBuiltinPlacements = (0, import_react129.useMemo)(() => {
    if (builtinPlacements) {
      return typeof builtinPlacements === "function" ? builtinPlacements({
        arrowPointAtCenter
      }) : builtinPlacements;
    }
    return getPlacements2(arrowPointAtCenter);
  }, [builtinPlacements, arrowPointAtCenter]);
  if (targetElement === void 0 || !hasOpened) {
    return null;
  }
  const handleClose = () => {
    setMergedOpen(false);
    onClose?.(mergedCurrent);
  };
  const getPopupElement = () => React415.createElement(TourStep_default, _extends75({
    styles,
    classNames: tourClassNames,
    arrow: mergedArrow,
    key: "content",
    prefixCls,
    total: steps.length,
    renderPanel,
    onPrev: () => {
      onInternalChange(mergedCurrent - 1);
    },
    onNext: () => {
      onInternalChange(mergedCurrent + 1);
    },
    onClose: handleClose,
    current: mergedCurrent,
    onFinish: () => {
      handleClose();
      onFinish?.();
    }
  }, steps[mergedCurrent], {
    closable: mergedClosable
  }));
  const mergedShowMask = typeof mergedMask === "boolean" ? mergedMask : !!mergedMask;
  const mergedMaskStyle = typeof mergedMask === "boolean" ? void 0 : mergedMask;
  const fallbackDOM = () => {
    return targetElement || document.body;
  };
  return React415.createElement(React415.Fragment, null, React415.createElement(Mask_default2, {
    getPopupContainer,
    styles,
    classNames: tourClassNames,
    zIndex,
    prefixCls,
    pos: posInfo,
    showMask: mergedShowMask,
    style: mergedMaskStyle?.style,
    fill: mergedMaskStyle?.color,
    open: mergedOpen,
    animated,
    rootClassName,
    disabledInteraction
  }), React415.createElement(es_default5, _extends75({}, restProps, {
    // `rc-portal` def bug not support `false` but does support and in used.
    getPopupContainer,
    builtinPlacements: mergedBuiltinPlacements,
    ref: triggerRef,
    popupStyle: stepStyle,
    popupPlacement: mergedPlacement,
    popupVisible: mergedOpen,
    popupClassName: clsx(rootClassName, stepClassName),
    prefixCls,
    popup: getPopupElement,
    forceRender: false,
    autoDestroy: true,
    zIndex,
    arrow: !!mergedArrow
  }), React415.createElement(Placeholder_default, {
    open: mergedOpen,
    autoLock: !inlineMode,
    getContainer: getPopupContainer,
    domRef: placeholderRef,
    fallbackDOM,
    className: clsx(className, rootClassName, `${prefixCls}-target-placeholder`),
    style: {
      ...posInfo || CENTER_PLACEHOLDER,
      position: inlineMode ? "absolute" : "fixed",
      pointerEvents: "none",
      ...style
    }
  })));
};
var Tour_default = Tour;

// node_modules/@rc-component/tour/es/index.js
var es_default24 = Tour_default;

// node_modules/antd/es/tour/panelRender.js
var import_react130 = __toESM(require_react());
var TourPanel = (props) => {
  const {
    stepProps,
    current,
    type,
    indicatorsRender,
    actionsRender
  } = props;
  const {
    prefixCls,
    total = 1,
    title,
    onClose,
    onPrev,
    onNext,
    onFinish,
    cover,
    description,
    nextButtonProps,
    prevButtonProps,
    type: stepType,
    closable,
    classNames = {},
    styles = {}
  } = stepProps;
  const mergedType = stepType ?? type;
  const ariaProps = pickAttrs(closable ?? {}, true);
  const [contextLocaleGlobal] = useLocale_default("global", en_US_default4.global);
  const [contextLocaleTour] = useLocale_default("Tour", en_US_default4.Tour);
  const mergedCloseIcon = import_react130.default.createElement("button", {
    type: "button",
    onClick: onClose,
    className: `${prefixCls}-close`,
    "aria-label": contextLocaleGlobal?.close,
    ...ariaProps
  }, closable?.closeIcon || import_react130.default.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  }));
  const isLastStep = current === total - 1;
  const prevBtnClick = () => {
    onPrev?.();
    prevButtonProps?.onClick?.();
  };
  const nextBtnClick = () => {
    if (isLastStep) {
      onFinish?.();
    } else {
      onNext?.();
    }
    nextButtonProps?.onClick?.();
  };
  const headerNode = isNonNullable_default(title) ? import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-header`, classNames.header),
    style: styles.header
  }, import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames.title),
    style: styles.title
  }, title)) : null;
  const descriptionNode = isNonNullable_default(description) ? import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-description`, classNames.description),
    style: styles.description
  }, description) : null;
  const coverNode = isNonNullable_default(cover) ? import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-cover`, classNames.cover),
    style: styles.cover
  }, cover) : null;
  let mergedIndicatorNode;
  if (indicatorsRender) {
    mergedIndicatorNode = indicatorsRender(current, total);
  } else {
    mergedIndicatorNode = _toConsumableArray(Array.from({
      length: total
    }).keys()).map((stepItem, index2) => import_react130.default.createElement("span", {
      key: stepItem,
      className: clsx(index2 === current && `${prefixCls}-indicator-active`, `${prefixCls}-indicator`, classNames.indicator),
      style: styles.indicator
    }));
  }
  const mainBtnType = mergedType === "primary" ? "default" : "primary";
  const secondaryBtnProps = {
    type: "default",
    ghost: mergedType === "primary"
  };
  const defaultActionsNode = import_react130.default.createElement(import_react130.default.Fragment, null, current !== 0 ? import_react130.default.createElement(Button_default, {
    size: "small",
    ...secondaryBtnProps,
    ...prevButtonProps,
    onClick: prevBtnClick,
    className: clsx(`${prefixCls}-prev-btn`, prevButtonProps?.className)
  }, prevButtonProps?.children ?? contextLocaleTour?.Previous) : null, import_react130.default.createElement(Button_default, {
    size: "small",
    type: mainBtnType,
    ...nextButtonProps,
    onClick: nextBtnClick,
    className: clsx(`${prefixCls}-next-btn`, nextButtonProps?.className)
  }, nextButtonProps?.children ?? (isLastStep ? contextLocaleTour?.Finish : contextLocaleTour?.Next)));
  return import_react130.default.createElement("div", {
    className: `${prefixCls}-panel`
  }, import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-section`, classNames.section),
    style: styles.section
  }, closable && mergedCloseIcon, coverNode, headerNode, descriptionNode, import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, total > 1 && import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-indicators`, classNames.indicators),
    style: styles.indicators
  }, mergedIndicatorNode), import_react130.default.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames.actions),
    style: styles.actions
  }, actionsRender ? actionsRender(defaultActionsNode, {
    current,
    total
  }) : defaultActionsNode))));
};
var panelRender_default = TourPanel;

// node_modules/antd/es/tour/PurePanel.js
var React417 = __toESM(require_react());

// node_modules/antd/es/tour/style/index.js
var genBaseStyle13 = (token) => {
  const {
    componentCls,
    padding,
    paddingXS,
    borderRadius,
    borderRadiusXS,
    colorPrimary,
    colorFill,
    indicatorHeight,
    indicatorWidth,
    boxShadowTertiary,
    zIndexPopup,
    colorBgElevated,
    fontWeightStrong,
    marginXS,
    colorTextLightSolid,
    tourBorderRadius,
    colorWhite,
    primaryNextBtnHoverBg,
    closeBtnSize,
    motionDurationSlow,
    antCls,
    primaryPrevBtnBg
  } = token;
  return [
    {
      [componentCls]: {
        ...resetComponent(token),
        position: "absolute",
        zIndex: zIndexPopup,
        maxWidth: "fit-content",
        visibility: "visible",
        width: 520,
        "--antd-arrow-background-color": colorBgElevated,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${componentCls}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${componentCls}-panel`]: {
          position: "relative"
        },
        [`${componentCls}-section`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: tourBorderRadius,
          boxShadow: boxShadowTertiary,
          position: "relative",
          backgroundColor: colorBgElevated,
          border: "none",
          backgroundClip: "padding-box",
          [`${componentCls}-close`]: {
            position: "absolute",
            top: padding,
            insetInlineEnd: padding,
            color: token.colorIcon,
            background: "none",
            border: "none",
            width: closeBtnSize,
            height: closeBtnSize,
            borderRadius: token.borderRadiusSM,
            transition: `background-color ${token.motionDurationMid}, color ${token.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            "&:hover": {
              color: token.colorIconHover,
              backgroundColor: token.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token.colorBgTextActive
            },
            ...genFocusStyle(token)
          },
          [`${componentCls}-cover`]: {
            textAlign: "center",
            padding: `${unit(token.calc(padding).add(closeBtnSize).add(paddingXS).equal())} ${unit(padding)} 0`,
            img: {
              width: "100%"
            }
          },
          [`${componentCls}-header`]: {
            padding: `${unit(padding)} ${unit(padding)} ${unit(paddingXS)}`,
            width: `calc(100% - ${unit(closeBtnSize)})`,
            wordBreak: "break-word",
            [`${componentCls}-title`]: {
              fontWeight: fontWeightStrong
            }
          },
          [`${componentCls}-description`]: {
            padding: `0 ${unit(padding)}`,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            padding: `${unit(paddingXS)} ${unit(padding)} ${unit(padding)}`,
            textAlign: "end",
            borderRadius: `0 0 ${unit(borderRadiusXS)} ${unit(borderRadiusXS)}`,
            display: "flex",
            [`${componentCls}-indicators`]: {
              display: "inline-block",
              [`${componentCls}-indicator`]: {
                width: indicatorWidth,
                height: indicatorHeight,
                display: "inline-block",
                borderRadius: "50%",
                background: colorFill,
                "&:not(:last-child)": {
                  marginInlineEnd: indicatorHeight
                },
                "&-active": {
                  background: colorPrimary
                }
              }
            },
            [`${componentCls}-actions`]: {
              marginInlineStart: "auto",
              [`${antCls}-btn`]: {
                marginInlineStart: marginXS
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${componentCls}-primary, &${componentCls}-primary`]: {
          "--antd-arrow-background-color": colorPrimary,
          [`${componentCls}-section`]: {
            color: colorTextLightSolid,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: colorPrimary,
            borderRadius,
            boxShadow: boxShadowTertiary,
            [`${componentCls}-close`]: {
              color: colorTextLightSolid
            },
            [`${componentCls}-indicators`]: {
              [`${componentCls}-indicator`]: {
                background: primaryPrevBtnBg,
                "&-active": {
                  background: colorTextLightSolid
                }
              }
            },
            [`${componentCls}-prev-btn`]: {
              color: colorTextLightSolid,
              borderColor: primaryPrevBtnBg,
              backgroundColor: colorPrimary,
              "&:hover": {
                backgroundColor: primaryPrevBtnBg,
                borderColor: "transparent"
              }
            },
            [`${componentCls}-next-btn`]: {
              color: colorPrimary,
              borderColor: "transparent",
              background: colorWhite,
              "&:hover": {
                background: primaryNextBtnHoverBg
              }
            }
          }
        }
      },
      // ============================= mask ===========================
      [`${componentCls}-mask`]: {
        [`${componentCls}-placeholder-animated`]: {
          transition: `all ${motionDurationSlow}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
        [`${componentCls}-section`]: {
          borderRadius: token.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
        }
      }
    },
    // ============================= Arrow ===========================
    getArrowStyle(token, "var(--antd-arrow-background-color)")
  ];
};
var prepareComponentToken47 = (token) => ({
  zIndexPopup: token.zIndexPopupBase + 70,
  closeBtnSize: token.fontSize * token.lineHeight,
  primaryPrevBtnBg: new FastColor(token.colorTextLightSolid).setA(0.15).toRgbString(),
  primaryNextBtnHoverBg: new FastColor(token.colorBgTextHover).onBackground(token.colorWhite).toRgbString(),
  ...getArrowOffsetToken({
    contentRadius: token.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token)
});
var style_default53 = genStyleHooks("Tour", (token) => {
  const {
    borderRadiusLG
  } = token;
  const TourToken = merge(token, {
    indicatorWidth: 6,
    indicatorHeight: 6,
    tourBorderRadius: borderRadiusLG
  });
  return genBaseStyle13(TourToken);
}, prepareComponentToken47);

// node_modules/antd/es/tour/PurePanel.js
var PurePanel13 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    current = 0,
    total = 6,
    className,
    style,
    type,
    closable,
    closeIcon,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React417.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [hashId, cssVarCls] = style_default53(prefixCls);
  const [mergedClosable, mergedCloseIcon] = useClosable({
    closable,
    closeIcon
  }, null, {
    closable: true,
    closeIconRender: (icon) => React417.isValidElement(icon) ? cloneElement(icon, {
      className: clsx(icon.props?.className, `${prefixCls}-close-icon`)
    }) : icon
  });
  return React417.createElement(RawPurePanel, {
    prefixCls,
    hashId,
    className: clsx(className, `${prefixCls}-pure`, type && `${prefixCls}-${type}`, cssVarCls),
    style
  }, React417.createElement(panelRender_default, {
    stepProps: {
      ...restProps,
      prefixCls,
      total,
      closable: mergedClosable ? {
        closeIcon: mergedCloseIcon
      } : void 0
    },
    current,
    type
  }));
};
var PurePanel_default8 = withPureRenderTheme(PurePanel13);

// node_modules/antd/es/tour/index.js
var Tour2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    type,
    rootClassName,
    indicatorsRender,
    actionsRender,
    steps,
    closeIcon,
    classNames,
    styles,
    className,
    style,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    closeIcon: contextCloseIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tour");
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [hashId, cssVarCls] = style_default53(prefixCls);
  const [, token] = useToken();
  const mergedSteps = import_react131.default.useMemo(() => steps?.map((step) => ({
    ...step,
    className: clsx(step.className, {
      [`${prefixCls}-primary`]: (step.type ?? type) === "primary"
    })
  })), [prefixCls, steps, type]);
  const mergedProps = {
    ...props,
    steps: mergedSteps
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const builtinPlacements = (config) => getPlacements({
    arrowPointAtCenter: config?.arrowPointAtCenter ?? true,
    autoAdjustOverflow: true,
    offset: token.marginXXS,
    arrowWidth: token.sizePopupArrow,
    borderRadius: token.borderRadius
  });
  const mergedRootClassName = clsx({
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, cssVarCls, rootClassName, contextClassName, mergedClassNames.root, className);
  const semanticStyles = {
    ...mergedStyles,
    mask: {
      ...mergedStyles.root,
      ...mergedStyles.mask,
      ...contextStyle,
      ...style
    }
  };
  const mergedRenderPanel = (stepProps, stepCurrent) => import_react131.default.createElement(panelRender_default, {
    styles: semanticStyles,
    classNames: mergedClassNames,
    type,
    stepProps,
    current: stepCurrent,
    indicatorsRender,
    actionsRender
  });
  const [zIndex, contextZIndex] = useZIndex("Tour", restProps.zIndex);
  return import_react131.default.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, import_react131.default.createElement(es_default24, {
    ...restProps,
    styles: semanticStyles,
    classNames: mergedClassNames,
    closeIcon: closeIcon ?? contextCloseIcon,
    zIndex,
    rootClassName: mergedRootClassName,
    prefixCls,
    animated: true,
    renderPanel: mergedRenderPanel,
    builtinPlacements,
    steps: mergedSteps
  }));
};
if (true) {
  Tour2.displayName = "Tour";
}
Tour2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default8;
var tour_default = Tour2;

// node_modules/antd/es/transfer/index.js
var import_react134 = __toESM(require_react());

// node_modules/antd/es/_util/transKeys.js
var groupKeysMap = (keys) => {
  const map = /* @__PURE__ */ new Map();
  keys.forEach((key, index2) => {
    map.set(key, index2);
  });
  return map;
};
var groupDisabledKeysMap = (dataSource) => {
  const map = /* @__PURE__ */ new Map();
  dataSource.forEach(({
    disabled,
    key
  }, index2) => {
    if (disabled) {
      map.set(key, index2);
    }
  });
  return map;
};

// node_modules/antd/es/transfer/Actions.js
var import_react132 = __toESM(require_react());
function getArrowIcon(type, direction) {
  const isRight = type === "right";
  if (direction !== "rtl") {
    return isRight ? import_react132.default.createElement(RightOutlined_default, null) : import_react132.default.createElement(LeftOutlined_default, null);
  }
  return isRight ? import_react132.default.createElement(LeftOutlined_default, null) : import_react132.default.createElement(RightOutlined_default, null);
}
var Action = ({
  type,
  actions,
  moveToLeft,
  moveToRight,
  leftActive,
  rightActive,
  direction,
  disabled
}) => {
  const isRight = type === "right";
  const button = isRight ? actions[0] : actions[1];
  const moveHandler = isRight ? moveToRight : moveToLeft;
  const active = isRight ? rightActive : leftActive;
  const icon = getArrowIcon(type, direction);
  if (import_react132.default.isValidElement(button)) {
    const element = button;
    const onClick = (event) => {
      element?.props?.onClick?.(event);
      moveHandler?.(event);
    };
    return import_react132.default.cloneElement(element, {
      disabled: disabled || !active,
      onClick
    });
  }
  return import_react132.default.createElement(Button_default, {
    type: "primary",
    size: "small",
    disabled: disabled || !active,
    onClick: (event) => moveHandler?.(event),
    icon
  }, button);
};
var Actions = (props) => {
  const {
    className,
    style,
    oneWay,
    actions,
    ...restProps
  } = props;
  return import_react132.default.createElement("div", {
    className,
    style
  }, import_react132.default.createElement(Action, {
    type: "right",
    actions,
    ...restProps
  }), !oneWay && import_react132.default.createElement(Action, {
    type: "left",
    actions,
    ...restProps
  }), actions.slice(oneWay ? 1 : 2));
};
if (true) {
  Actions.displayName = "Actions";
}
var Actions_default = Actions;

// node_modules/antd/es/transfer/hooks/useData.js
var React420 = __toESM(require_react());
var useData = (dataSource, rowKey, targetKeys) => {
  const mergedDataSource = React420.useMemo(() => (dataSource || []).map((record) => {
    if (rowKey) {
      return {
        ...record,
        key: rowKey(record)
      };
    }
    return record;
  }), [dataSource, rowKey]);
  const [leftDataSource, rightDataSource] = React420.useMemo(() => {
    const leftData = [];
    const rightData = Array.from({
      length: targetKeys?.length ?? 0
    });
    const targetKeysMap = groupKeysMap(targetKeys || []);
    mergedDataSource.forEach((record) => {
      if (targetKeysMap.has(record.key)) {
        const idx = targetKeysMap.get(record.key);
        rightData[idx] = record;
      } else {
        leftData.push(record);
      }
    });
    return [leftData, rightData];
  }, [mergedDataSource, targetKeys]);
  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];
};
var useData_default = useData;

// node_modules/antd/es/transfer/hooks/useSelection.js
var React421 = __toESM(require_react());
var EMPTY_KEYS = [];
function filterKeys(keys, dataKeys) {
  const filteredKeys = keys.filter((key) => dataKeys.has(key));
  return keys.length === filteredKeys.length ? keys : filteredKeys;
}
function flattenKeys2(keys) {
  return Array.from(keys).join(";");
}
function useSelection2(leftDataSource, rightDataSource, selectedKeys) {
  const [leftKeys, rightKeys] = React421.useMemo(() => [new Set(leftDataSource.map((src) => src?.key)), new Set(rightDataSource.map((src) => src?.key))], [leftDataSource, rightDataSource]);
  const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(EMPTY_KEYS, selectedKeys);
  const sourceSelectedKeys = React421.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]);
  const targetSelectedKeys = React421.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
  React421.useEffect(() => {
    setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
  }, [flattenKeys2(leftKeys), flattenKeys2(rightKeys)]);
  const setSourceSelectedKeys = useEvent_default((nextSrcKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
  });
  const setTargetSelectedKeys = useEvent_default((nextTargetKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
  });
  return [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Updater
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ];
}
var useSelection_default2 = useSelection2;

// node_modules/antd/es/transfer/search.js
var React422 = __toESM(require_react());
var Search2 = (props) => {
  const {
    placeholder = "",
    value,
    prefixCls,
    disabled,
    onChange,
    handleClear
  } = props;
  const handleChange = React422.useCallback((e3) => {
    onChange?.(e3);
    if (e3.target.value === "") {
      handleClear?.();
    }
  }, [onChange]);
  return React422.createElement(Input_default, {
    placeholder,
    className: prefixCls,
    value,
    onChange: handleChange,
    disabled,
    allowClear: true,
    prefix: React422.createElement(SearchOutlined_default, null)
  });
};
if (true) {
  Search2.displayName = "Search";
}
var search_default2 = Search2;

// node_modules/antd/es/transfer/Section.js
var import_react133 = __toESM(require_react());

// node_modules/antd/es/transfer/ListBody.js
var React424 = __toESM(require_react());

// node_modules/antd/es/transfer/ListItem.js
var React423 = __toESM(require_react());
var ListItem = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    renderedText,
    renderedEl,
    item,
    checked,
    disabled,
    onClick,
    onRemove,
    showRemove
  } = props;
  const classes = clsx(`${prefixCls}-content-item`, classNames.item, {
    [`${prefixCls}-content-item-disabled`]: disabled || item.disabled,
    [`${prefixCls}-content-item-checked`]: checked && !item.disabled
  });
  let title;
  if (typeof renderedText === "string" || typeof renderedText === "number") {
    title = String(renderedText);
  }
  const [contextLocale] = useLocale_default("Transfer", en_US_default4.Transfer);
  const liProps = {
    className: classes,
    style: styles.item,
    title
  };
  const labelNode = React423.createElement("span", {
    className: clsx(`${prefixCls}-content-item-text`, classNames.itemContent),
    style: styles.itemContent
  }, renderedEl);
  if (showRemove) {
    return React423.createElement("li", {
      ...liProps
    }, labelNode, React423.createElement("button", {
      type: "button",
      disabled: disabled || item.disabled,
      className: `${prefixCls}-content-item-remove`,
      "aria-label": contextLocale?.remove,
      onClick: () => onRemove?.(item)
    }, React423.createElement(DeleteOutlined_default, null)));
  }
  liProps.onClick = disabled || item.disabled ? void 0 : (event) => onClick(item, event);
  return React423.createElement("li", {
    ...liProps
  }, React423.createElement(checkbox_default, {
    className: clsx(`${prefixCls}-checkbox`, classNames.itemIcon),
    style: styles.itemIcon,
    checked,
    disabled: disabled || item.disabled
  }), labelNode);
};
var ListItem_default = React423.memo(ListItem);

// node_modules/antd/es/transfer/ListBody.js
var OmitProps = ["handleFilter", "handleClear", "checkedKeys"];
var parsePagination = (pagination) => {
  const defaultPagination = {
    simple: true,
    showSizeChanger: false,
    showLessItems: false
  };
  return {
    ...defaultPagination,
    ...pagination
  };
};
var TransferListBody = (props, ref) => {
  const {
    prefixCls,
    classNames,
    styles,
    filteredRenderItems,
    selectedKeys,
    disabled: globalDisabled,
    showRemove,
    pagination,
    onScroll,
    onItemSelect,
    onItemRemove
  } = props;
  const [current, setCurrent] = React424.useState(1);
  const mergedPagination = React424.useMemo(() => {
    if (!pagination) {
      return null;
    }
    const convertPagination = typeof pagination === "object" ? pagination : {};
    return parsePagination(convertPagination);
  }, [pagination]);
  const [pageSize, setPageSize] = useControlledState(10, mergedPagination?.pageSize);
  React424.useEffect(() => {
    if (mergedPagination) {
      const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
      setCurrent(Math.min(current, maxPageCount));
    }
  }, [filteredRenderItems, mergedPagination, pageSize]);
  const onInternalClick = (item, e3) => {
    onItemSelect(item.key, !selectedKeys.includes(item.key), e3);
  };
  const onRemove = (item) => {
    onItemRemove?.([item.key]);
  };
  const onPageChange = (cur) => {
    setCurrent(cur);
  };
  const onSizeChange = (cur, size) => {
    setCurrent(cur);
    setPageSize(size);
  };
  const memoizedItems = React424.useMemo(() => {
    const displayItems = mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
    return displayItems;
  }, [current, filteredRenderItems, mergedPagination, pageSize]);
  React424.useImperativeHandle(ref, () => ({
    items: memoizedItems
  }));
  const paginationNode = mergedPagination ? React424.createElement(pagination_default, {
    size: "small",
    disabled: globalDisabled,
    simple: mergedPagination.simple,
    pageSize,
    showLessItems: mergedPagination.showLessItems,
    showSizeChanger: mergedPagination.showSizeChanger,
    className: `${prefixCls}-pagination`,
    total: filteredRenderItems.length,
    current,
    onChange: onPageChange,
    onShowSizeChange: onSizeChange
  }) : null;
  return React424.createElement(React424.Fragment, null, React424.createElement("ul", {
    className: clsx(`${prefixCls}-content`, classNames.list, {
      [`${prefixCls}-content-show-remove`]: showRemove
    }),
    style: styles.list,
    onScroll
  }, (memoizedItems || []).map(({
    renderedEl,
    renderedText,
    item
  }) => React424.createElement(ListItem_default, {
    key: item.key,
    prefixCls,
    classNames,
    styles,
    item,
    renderedText,
    renderedEl,
    showRemove,
    onClick: onInternalClick,
    onRemove,
    checked: selectedKeys.includes(item.key),
    disabled: globalDisabled || item.disabled
  }))), paginationNode);
};
if (true) {
  TransferListBody.displayName = "TransferListBody";
}
var ListBody_default = React424.forwardRef(TransferListBody);

// node_modules/antd/es/transfer/Section.js
var defaultRender2 = () => null;
function isRenderResultPlainObject(result) {
  return !!(result && !import_react133.default.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
function getEnabledItemKeys(items) {
  return items.filter((data) => !data.disabled).map((data) => data.key);
}
var isValidIcon = (icon) => icon !== void 0;
var getShowSearchOption = (showSearch) => {
  if (showSearch && typeof showSearch === "object") {
    return {
      ...showSearch,
      defaultValue: showSearch.defaultValue || ""
    };
  }
  return {
    defaultValue: "",
    placeholder: ""
  };
};
var TransferSection = (props) => {
  const {
    prefixCls,
    style,
    classNames,
    styles,
    dataSource = [],
    titleText = "",
    checkedKeys,
    disabled,
    showSearch = false,
    searchPlaceholder,
    notFoundContent,
    selectAll,
    deselectAll,
    selectCurrent,
    selectInvert,
    removeAll,
    removeCurrent,
    showSelectAll = true,
    showRemove,
    pagination,
    direction,
    itemsUnit,
    itemUnit,
    selectAllLabel,
    selectionsIcon,
    footer,
    renderList,
    onItemSelectAll,
    onItemRemove,
    handleFilter,
    handleClear,
    filterOption: filterOption2,
    render: render2 = defaultRender2
  } = props;
  const sectionPrefixCls = `${prefixCls}-section`;
  const listPrefixCls = `${prefixCls}-list`;
  const searchOptions = getShowSearchOption(showSearch);
  const [filterValue, setFilterValue] = (0, import_react133.useState)(searchOptions.defaultValue);
  const listBodyRef = (0, import_react133.useRef)({});
  const internalHandleFilter = (e3) => {
    setFilterValue(e3.target.value);
    handleFilter(e3);
  };
  const internalHandleClear = () => {
    setFilterValue("");
    handleClear();
  };
  const matchFilter = (text, item) => {
    if (typeof filterOption2 === "function") {
      return filterOption2(filterValue, item, direction);
    }
    return text.includes(filterValue);
  };
  const customRenderListBody = (listProps) => {
    let bodyContent = renderList ? renderList({
      ...listProps,
      onItemSelect: (key, check) => listProps.onItemSelect(key, check)
    }) : null;
    const customize = !!bodyContent;
    if (!customize) {
      bodyContent = import_react133.default.createElement(ListBody_default, {
        ref: listBodyRef,
        ...listProps,
        prefixCls: listPrefixCls
      });
    }
    return {
      customize,
      bodyContent
    };
  };
  const renderItem2 = (item) => {
    const renderResult = render2(item);
    const isRenderResultPlain = isRenderResultPlainObject(renderResult);
    return {
      item,
      renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
      renderedText: isRenderResultPlain ? renderResult.value : renderResult
    };
  };
  const notFoundContentEle = (0, import_react133.useMemo)(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]);
  const [filteredItems, filteredRenderItems] = (0, import_react133.useMemo)(() => {
    const filterItems = [];
    const filterRenderItems = [];
    dataSource.forEach((item) => {
      const renderedItem = renderItem2(item);
      if (filterValue && !matchFilter(renderedItem.renderedText, item)) {
        return;
      }
      filterItems.push(item);
      filterRenderItems.push(renderedItem);
    });
    return [filterItems, filterRenderItems];
  }, [dataSource, filterValue]);
  const checkedActiveItems = (0, import_react133.useMemo)(() => {
    return filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled);
  }, [checkedKeys, filteredItems]);
  const checkStatus = (0, import_react133.useMemo)(() => {
    if (checkedActiveItems.length === 0) {
      return "none";
    }
    const checkedKeysMap = groupKeysMap(checkedKeys);
    if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) {
      return "all";
    }
    return "part";
  }, [checkedActiveItems.length, checkedKeys, filteredItems]);
  const renderListBody = () => {
    const search = showSearch ? import_react133.default.createElement("div", {
      className: `${listPrefixCls}-body-search-wrapper`
    }, import_react133.default.createElement(search_default2, {
      prefixCls: `${listPrefixCls}-search`,
      onChange: internalHandleFilter,
      handleClear: internalHandleClear,
      placeholder: searchOptions.placeholder || searchPlaceholder,
      value: filterValue,
      disabled
    })) : null;
    const {
      customize,
      bodyContent
    } = customRenderListBody({
      ...omit(props, OmitProps),
      filteredItems,
      filteredRenderItems,
      selectedKeys: checkedKeys,
      classNames,
      styles
    });
    let bodyNode;
    if (customize) {
      bodyNode = import_react133.default.createElement("div", {
        className: `${listPrefixCls}-body-customize-wrapper`
      }, bodyContent);
    } else {
      bodyNode = filteredItems.length ? bodyContent : import_react133.default.createElement("div", {
        className: `${listPrefixCls}-body-not-found`
      }, notFoundContentEle);
    }
    return import_react133.default.createElement("div", {
      className: clsx(`${listPrefixCls}-body`, {
        [`${listPrefixCls}-body-with-search`]: showSearch
      }, classNames.body),
      style: styles.body
    }, search, bodyNode);
  };
  const checkBox = import_react133.default.createElement(checkbox_default, {
    disabled: dataSource.filter((d) => !d.disabled).length === 0 || disabled,
    checked: checkStatus === "all",
    indeterminate: checkStatus === "part",
    className: `${listPrefixCls}-checkbox`,
    onChange: () => {
      onItemSelectAll?.(filteredItems.filter((item) => !item.disabled).map(({
        key
      }) => key), checkStatus !== "all");
    }
  });
  const getSelectAllLabel = (selectedCount, totalCount) => {
    if (selectAllLabel) {
      return typeof selectAllLabel === "function" ? selectAllLabel({
        selectedCount,
        totalCount
      }) : selectAllLabel;
    }
    const unit2 = totalCount > 1 ? itemsUnit : itemUnit;
    return import_react133.default.createElement(import_react133.default.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit2);
  };
  const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, {
    direction
  }));
  const listFooter = footerDom ? import_react133.default.createElement("div", {
    className: clsx(`${listPrefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, footerDom) : null;
  const checkAllCheckbox = !showRemove && !pagination && checkBox;
  let items;
  if (showRemove) {
    items = [
      /* Remove Current Page */
      pagination ? {
        key: "removeCurrent",
        label: removeCurrent,
        onClick() {
          const pageKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
          onItemRemove?.(pageKeys);
        }
      } : null,
      /* Remove All */
      {
        key: "removeAll",
        label: removeAll,
        onClick() {
          onItemRemove?.(getEnabledItemKeys(filteredItems));
        }
      }
    ].filter(Boolean);
  } else {
    items = [{
      key: "selectAll",
      label: checkStatus === "all" ? deselectAll : selectAll,
      onClick() {
        const keys = getEnabledItemKeys(filteredItems);
        onItemSelectAll?.(keys, keys.length !== checkedKeys.length);
      }
    }, pagination ? {
      key: "selectCurrent",
      label: selectCurrent,
      onClick() {
        const pageItems = listBodyRef.current?.items || [];
        onItemSelectAll?.(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
      }
    } : null, {
      key: "selectInvert",
      label: selectInvert,
      onClick() {
        const availablePageItemKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
        const checkedKeySet = new Set(checkedKeys);
        const newCheckedKeysSet = new Set(checkedKeySet);
        availablePageItemKeys.forEach((key) => {
          if (checkedKeySet.has(key)) {
            newCheckedKeysSet.delete(key);
          } else {
            newCheckedKeysSet.add(key);
          }
        });
        onItemSelectAll?.(Array.from(newCheckedKeysSet), "replace");
      }
    }];
  }
  const dropdown = import_react133.default.createElement(dropdown_default2, {
    className: `${listPrefixCls}-header-dropdown`,
    menu: {
      items
    },
    disabled
  }, isValidIcon(selectionsIcon) ? selectionsIcon : import_react133.default.createElement(DownOutlined_default, null));
  return import_react133.default.createElement("div", {
    className: clsx(sectionPrefixCls, classNames.section, {
      [`${sectionPrefixCls}-with-pagination`]: !!pagination,
      [`${sectionPrefixCls}-with-footer`]: !!footerDom
    }),
    style: {
      ...style,
      ...styles.section
    }
  }, import_react133.default.createElement("div", {
    className: clsx(`${listPrefixCls}-header`, classNames.header),
    style: styles.header
  }, showSelectAll ? import_react133.default.createElement(import_react133.default.Fragment, null, checkAllCheckbox, dropdown) : null, import_react133.default.createElement("span", {
    className: `${listPrefixCls}-header-selected`
  }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), import_react133.default.createElement("span", {
    className: clsx(`${listPrefixCls}-header-title`, classNames.title),
    style: styles.title
  }, titleText)), renderListBody(), listFooter);
};
if (true) {
  TransferSection.displayName = "TransferSection";
}
var Section_default = TransferSection;

// node_modules/antd/es/transfer/style/index.js
var genTransferCustomizeStyle = (token) => {
  const {
    antCls,
    componentCls,
    listHeight,
    controlHeightLG
  } = token;
  const tableCls = `${antCls}-table`;
  const inputCls = `${antCls}-input`;
  return {
    [`${componentCls}-customize-list`]: {
      [`${componentCls}-section`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: listHeight,
        minWidth: 0
      },
      // =================== Hook Components ===================
      [`${tableCls}-wrapper`]: {
        [`${tableCls}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${tableCls}-selection-column`]: {
            width: controlHeightLG,
            minWidth: controlHeightLG
          }
        },
        [`${tableCls}-pagination${tableCls}-pagination`]: {
          margin: 0,
          padding: token.paddingXS
        }
      },
      [`${inputCls}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
};
var genTransferStatusColor = (token, color) => {
  const {
    componentCls,
    colorBorder
  } = token;
  return {
    [`${componentCls}-section`]: {
      borderColor: color,
      [`${componentCls}-list-search:not([disabled])`]: {
        borderColor: colorBorder
      }
    }
  };
};
var genTransferStatusStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-status-error`]: {
      ...genTransferStatusColor(token, token.colorError)
    },
    [`${componentCls}-status-warning`]: {
      ...genTransferStatusColor(token, token.colorWarning)
    }
  };
};
var genTransferListStyle = (token) => {
  const {
    componentCls,
    colorBorder,
    colorSplit,
    lineWidth,
    itemHeight,
    headerHeight,
    transferHeaderVerticalPadding,
    itemPaddingBlock,
    controlItemBgActive,
    colorTextDisabled,
    colorTextSecondary,
    listHeight,
    listWidth,
    listWidthLG,
    fontSizeIcon,
    marginXS,
    paddingSM,
    lineType,
    antCls,
    iconCls,
    motionDurationSlow,
    controlItemBgHover,
    borderRadiusLG,
    colorBgContainer,
    colorText,
    controlItemBgActiveHover
  } = token;
  const contentBorderRadius = unit(token.calc(borderRadiusLG).sub(lineWidth).equal());
  return {
    display: "flex",
    flexDirection: "column",
    width: listWidth,
    height: listHeight,
    border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
    borderRadius: token.borderRadiusLG,
    "&-with-pagination": {
      width: listWidthLG,
      height: "auto"
    },
    [`${componentCls}-list`]: {
      "&-search": {
        [`${iconCls}-search`]: {
          color: colorTextDisabled
        }
      },
      "&-header": {
        display: "flex",
        flex: "none",
        alignItems: "center",
        height: headerHeight,
        // border-top is on the transfer dom. We should minus 1px for this
        padding: `${unit(token.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit(paddingSM)} ${unit(transferHeaderVerticalPadding)}`,
        color: colorText,
        background: colorBgContainer,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        borderRadius: `${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0 0`,
        "> *:not(:last-child)": {
          marginInlineEnd: 4
          // This is magic and fixed number, DO NOT use token since it may change.
        },
        "> *": {
          flex: "none"
        },
        "&-title": {
          ...textEllipsis,
          flex: "0 1 auto",
          textAlign: "end",
          marginInlineStart: "auto"
        },
        "&-dropdown": {
          ...resetIcon(),
          fontSize: fontSizeIcon,
          transform: "translateY(10%)",
          cursor: "pointer",
          "&[disabled]": {
            cursor: "not-allowed"
          }
        }
      },
      "&-body": {
        display: "flex",
        flex: "auto",
        flexDirection: "column",
        fontSize: token.fontSize,
        // https://blog.csdn.net/qq449245884/article/details/107373672/
        minHeight: 0,
        "&-search-wrapper": {
          position: "relative",
          flex: "none",
          padding: paddingSM
        }
      },
      "&-content": {
        flex: "auto",
        margin: 0,
        padding: 0,
        overflow: "auto",
        listStyle: "none",
        borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
        "&-item": {
          display: "flex",
          alignItems: "center",
          minHeight: itemHeight,
          padding: `${unit(itemPaddingBlock)} ${unit(paddingSM)}`,
          transition: `all ${motionDurationSlow}`,
          "> *:not(:last-child)": {
            marginInlineEnd: marginXS
          },
          "> *": {
            flex: "none"
          },
          "&-text": {
            ...textEllipsis,
            flex: "auto"
          },
          "&-remove": {
            ...operationUnit(token),
            color: colorBorder,
            "&:hover, &:focus": {
              color: colorTextSecondary
            }
          },
          [`&:not(${componentCls}-list-content-item-disabled)`]: {
            "&:hover": {
              backgroundColor: controlItemBgHover,
              cursor: "pointer"
            },
            [`&${componentCls}-list-content-item-checked:hover`]: {
              backgroundColor: controlItemBgActiveHover
            }
          },
          "&-checked": {
            backgroundColor: controlItemBgActive
          },
          "&-disabled": {
            color: colorTextDisabled,
            cursor: "not-allowed"
          }
        },
        // Do not change hover style when `oneWay` mode
        [`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
          background: "transparent",
          cursor: "default"
        }
      },
      "&-pagination": {
        padding: token.paddingXS,
        textAlign: "end",
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        [`${antCls}-pagination-options`]: {
          paddingInlineEnd: token.paddingXS
        }
      },
      "&-body-not-found": {
        flex: "none",
        width: "100%",
        margin: "auto 0",
        color: colorTextDisabled,
        textAlign: "center"
      },
      "&-footer": {
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
      },
      // fix: https://github.com/ant-design/ant-design/issues/44489
      "&-checkbox": {
        lineHeight: 1
      }
    }
  };
};
var genTransferStyle = (token) => {
  const {
    antCls,
    iconCls,
    componentCls,
    marginXS,
    marginXXS,
    fontSizeIcon,
    colorBgContainerDisabled
  } = token;
  return {
    [componentCls]: {
      ...resetComponent(token),
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${componentCls}-disabled`]: {
        [`${componentCls}-section`]: {
          background: colorBgContainerDisabled
        }
      },
      [`${componentCls}-section`]: genTransferListStyle(token),
      [`${componentCls}-actions`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${unit(marginXS)}`,
        verticalAlign: "middle",
        gap: marginXXS,
        [`${antCls}-btn ${iconCls}`]: {
          fontSize: fontSizeIcon
        }
      }
    }
  };
};
var genTransferRTLStyle = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var prepareComponentToken48 = (token) => {
  const {
    fontSize,
    lineHeight,
    controlHeight,
    controlHeightLG,
    lineWidth
  } = token;
  const fontHeight = Math.round(fontSize * lineHeight);
  return {
    listWidth: 180,
    listHeight: 200,
    listWidthLG: 250,
    headerHeight: controlHeightLG,
    itemHeight: controlHeight,
    itemPaddingBlock: (controlHeight - fontHeight) / 2,
    transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
  };
};
var style_default54 = genStyleHooks("Transfer", (token) => {
  const transferToken = merge(token);
  return [genTransferStyle(transferToken), genTransferCustomizeStyle(transferToken), genTransferStatusStyle(transferToken), genTransferRTLStyle(transferToken)];
}, prepareComponentToken48);

// node_modules/antd/es/transfer/index.js
var Transfer = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    styles,
    style,
    listStyle,
    operationStyle,
    operations,
    actions,
    dataSource,
    targetKeys = [],
    selectedKeys,
    selectAllLabels = [],
    locale: locale2 = {},
    titles,
    disabled,
    showSearch = false,
    showSelectAll,
    oneWay,
    pagination,
    status: customStatus,
    selectionsIcon,
    filterOption: filterOption2,
    render: render2,
    footer,
    children,
    rowKey,
    onScroll,
    onChange,
    onSearch,
    onSelectChange
  } = props;
  const {
    getPrefixCls,
    renderEmpty,
    direction: dir,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    selectionsIcon: contextSelectionsIcon
  } = useComponentConfig("transfer");
  const contextDisabled = (0, import_react134.useContext)(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const mergedProps = {
    ...props,
    disabled: mergedDisabled
  };
  const prefixCls = getPrefixCls("transfer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default54(prefixCls);
  const mergedActions = actions || operations || [];
  const [mergedDataSource, leftDataSource, rightDataSource] = useData_default(dataSource, rowKey, targetKeys);
  const [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Setters
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ] = useSelection_default2(leftDataSource, rightDataSource, selectedKeys);
  const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  const setStateKeys = (0, import_react134.useCallback)((direction, keys) => {
    if (direction === "left") {
      const nextKeys = typeof keys === "function" ? keys(sourceSelectedKeys || []) : keys;
      setSourceSelectedKeys(nextKeys);
    } else {
      const nextKeys = typeof keys === "function" ? keys(targetSelectedKeys || []) : keys;
      setTargetSelectedKeys(nextKeys);
    }
  }, [sourceSelectedKeys, targetSelectedKeys]);
  const setPrevSelectedIndex = (direction, value) => {
    const isLeftDirection = direction === "left";
    const updatePrevSelectedIndex = isLeftDirection ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex;
    updatePrevSelectedIndex(value);
  };
  const handleSelectChange = (0, import_react134.useCallback)((direction, holder) => {
    if (direction === "left") {
      onSelectChange?.(holder, targetSelectedKeys);
    } else {
      onSelectChange?.(sourceSelectedKeys, holder);
    }
  }, [sourceSelectedKeys, targetSelectedKeys]);
  const getTitles = (transferLocale) => titles ?? transferLocale.titles ?? [];
  const handleLeftScroll = (e3) => {
    onScroll?.("left", e3);
  };
  const handleRightScroll = (e3) => {
    onScroll?.("right", e3);
  };
  const moveTo = (direction) => {
    const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
    const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
    const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
    const newMoveKeysMap = groupKeysMap(newMoveKeys);
    const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
    const oppositeDirection = direction === "right" ? "left" : "right";
    setStateKeys(oppositeDirection, []);
    handleSelectChange(oppositeDirection, []);
    onChange?.(newTargetKeys, direction, newMoveKeys);
  };
  const moveToLeft = () => {
    moveTo("left");
    setPrevSelectedIndex("left", null);
  };
  const moveToRight = () => {
    moveTo("right");
    setPrevSelectedIndex("right", null);
  };
  const onItemSelectAll = (direction, keys, checkAll) => {
    setStateKeys(direction, (prevKeys) => {
      let mergedCheckedKeys = [];
      if (checkAll === "replace") {
        mergedCheckedKeys = keys;
      } else if (checkAll) {
        mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys))));
      } else {
        const selectedKeysMap = groupKeysMap(keys);
        mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
      }
      handleSelectChange(direction, mergedCheckedKeys);
      return mergedCheckedKeys;
    });
    setPrevSelectedIndex(direction, null);
  };
  const onLeftItemSelectAll = (keys, checkAll) => {
    onItemSelectAll("left", keys, checkAll);
  };
  const onRightItemSelectAll = (keys, checkAll) => {
    onItemSelectAll("right", keys, checkAll);
  };
  const leftFilter = (e3) => onSearch?.("left", e3.target.value);
  const rightFilter = (e3) => onSearch?.("right", e3.target.value);
  const handleLeftClear = () => onSearch?.("left", "");
  const handleRightClear = () => onSearch?.("right", "");
  const handleSingleSelect = (direction, holder, selectedKey, checked, currentSelectedIndex) => {
    const isSelected = holder.has(selectedKey);
    if (isSelected) {
      holder.delete(selectedKey);
      setPrevSelectedIndex(direction, null);
    }
    if (checked) {
      holder.add(selectedKey);
      setPrevSelectedIndex(direction, currentSelectedIndex);
    }
  };
  const handleMultipleSelect = (direction, data, holder, currentSelectedIndex) => {
    const isLeftDirection = direction === "left";
    const multipleSelect = isLeftDirection ? leftMultipleSelect : rightMultipleSelect;
    multipleSelect(currentSelectedIndex, data, holder);
  };
  const onItemSelect = (direction, selectedKey, checked, multiple) => {
    const isLeftDirection = direction === "left";
    const holder = _toConsumableArray(isLeftDirection ? sourceSelectedKeys : targetSelectedKeys);
    const holderSet = new Set(holder);
    const data = _toConsumableArray(isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !item?.disabled);
    const currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
    if (multiple && holder.length > 0) {
      handleMultipleSelect(direction, data, holderSet, currentSelectedIndex);
    } else {
      handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
    }
    const holderArr = Array.from(holderSet);
    handleSelectChange(direction, holderArr);
    if (!props.selectedKeys) {
      setStateKeys(direction, holderArr);
    }
  };
  const onLeftItemSelect = (selectedKey, checked, e3) => {
    onItemSelect("left", selectedKey, checked, e3?.shiftKey);
  };
  const onRightItemSelect = (selectedKey, checked, e3) => {
    onItemSelect("right", selectedKey, checked, e3?.shiftKey);
  };
  const onRightItemRemove = (keys) => {
    setStateKeys("right", []);
    onChange?.(targetKeys.filter((key) => !keys.includes(key)), "left", _toConsumableArray(keys));
  };
  const handleListStyle = (direction) => {
    if (typeof listStyle === "function") {
      return listStyle({
        direction
      });
    }
    return listStyle || {};
  };
  const formItemContext = (0, import_react134.useContext)(FormItemInputContext);
  const {
    hasFeedback,
    status
  } = formItemContext;
  const getLocale = (transferLocale) => ({
    ...transferLocale,
    notFoundContent: renderEmpty?.("Transfer") || import_react134.default.createElement(defaultRenderEmpty_default, {
      componentName: "Transfer"
    }),
    ...locale2
  });
  const mergedStatus = getMergedStatus(status, customStatus);
  const mergedPagination = !children && pagination;
  const leftActive = rightDataSource.filter((d) => targetSelectedKeys.includes(d.key) && !d.disabled).length > 0;
  const rightActive = leftDataSource.filter((d) => sourceSelectedKeys.includes(d.key) && !d.disabled).length > 0;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const cls = clsx(prefixCls, {
    [`${prefixCls}-disabled`]: mergedDisabled,
    [`${prefixCls}-customize-list`]: !!children,
    [`${prefixCls}-rtl`]: dir === "rtl"
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const [contextLocale] = useLocale_default("Transfer", en_US_default4.Transfer);
  const listLocale = getLocale(contextLocale);
  const [leftTitle, rightTitle] = getTitles(listLocale);
  const mergedSelectionsIcon = selectionsIcon ?? contextSelectionsIcon;
  if (true) {
    const warning2 = devUseWarning("Transfer");
    true ? warning2(!pagination || !children, "usage", "`pagination` not support customize render list.") : void 0;
    [["listStyle", "styles.section"], ["operationStyle", "styles.actions"], ["operations", "actions"]].forEach(([deprecatedName, newName]) => {
      warning2.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return import_react134.default.createElement("div", {
    className: cls,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style
    }
  }, import_react134.default.createElement(Section_default, {
    prefixCls,
    style: handleListStyle("left"),
    classNames: mergedClassNames,
    styles: mergedStyles,
    titleText: leftTitle,
    dataSource: leftDataSource,
    filterOption: filterOption2,
    checkedKeys: sourceSelectedKeys,
    handleFilter: leftFilter,
    handleClear: handleLeftClear,
    onItemSelect: onLeftItemSelect,
    onItemSelectAll: onLeftItemSelectAll,
    render: render2,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleLeftScroll,
    disabled: mergedDisabled,
    direction: dir === "rtl" ? "right" : "left",
    showSelectAll,
    selectAllLabel: selectAllLabels[0],
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon,
    ...listLocale
  }), import_react134.default.createElement(Actions_default, {
    className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
    rightActive,
    moveToRight,
    leftActive,
    actions: mergedActions,
    moveToLeft,
    style: {
      ...operationStyle,
      ...mergedStyles.actions
    },
    disabled: mergedDisabled,
    direction: dir,
    oneWay
  }), import_react134.default.createElement(Section_default, {
    prefixCls,
    style: handleListStyle("right"),
    classNames: mergedClassNames,
    styles: mergedStyles,
    titleText: rightTitle,
    dataSource: rightDataSource,
    filterOption: filterOption2,
    checkedKeys: targetSelectedKeys,
    handleFilter: rightFilter,
    handleClear: handleRightClear,
    onItemSelect: onRightItemSelect,
    onItemSelectAll: onRightItemSelectAll,
    onItemRemove: onRightItemRemove,
    render: render2,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleRightScroll,
    disabled: mergedDisabled,
    direction: dir === "rtl" ? "left" : "right",
    showSelectAll,
    selectAllLabel: selectAllLabels[1],
    showRemove: oneWay,
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon,
    ...listLocale
  }));
};
if (true) {
  Transfer.displayName = "Transfer";
}
Transfer.List = Section_default;
Transfer.Search = search_default2;
Transfer.Operation = Actions_default;
var transfer_default = Transfer;

// node_modules/antd/es/tree-select/index.js
var React439 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeSelect.js
var React438 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/hooks/useCache.js
var React427 = __toESM(require_react());
var useCache_default = ((values) => {
  const cacheRef = React427.useRef({
    valueLabels: /* @__PURE__ */ new Map()
  });
  return React427.useMemo(() => {
    const {
      valueLabels
    } = cacheRef.current;
    const valueLabelsCache = /* @__PURE__ */ new Map();
    const filledValues = values.map((item) => {
      const {
        value,
        label
      } = item;
      const mergedLabel = label ?? valueLabels.get(value);
      valueLabelsCache.set(value, mergedLabel);
      return {
        ...item,
        label: mergedLabel
      };
    });
    cacheRef.current.valueLabels = valueLabelsCache;
    return [filledValues];
  }, [values]);
});

// node_modules/@rc-component/tree-select/es/hooks/useCheckedKeys.js
var React428 = __toESM(require_react());
var useCheckedKeys = (rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities) => {
  return React428.useMemo(() => {
    const extractValues = (values) => values.map(({
      value
    }) => value);
    const checkedKeys = extractValues(rawLabeledValues);
    const halfCheckedKeys = extractValues(rawHalfCheckedValues);
    const missingValues = checkedKeys.filter((key) => !keyEntities[key]);
    let finalCheckedKeys = checkedKeys;
    let finalHalfCheckedKeys = halfCheckedKeys;
    if (treeConduction) {
      const conductResult = conductCheck(checkedKeys, true, keyEntities);
      finalCheckedKeys = conductResult.checkedKeys;
      finalHalfCheckedKeys = conductResult.halfCheckedKeys;
    }
    return [Array.from(/* @__PURE__ */ new Set([...missingValues, ...finalCheckedKeys])), finalHalfCheckedKeys];
  }, [rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities]);
};
var useCheckedKeys_default = useCheckedKeys;

// node_modules/@rc-component/tree-select/es/hooks/useDataEntities.js
var React429 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/utils/valueUtil.js
var toArray6 = (value) => Array.isArray(value) ? value : value !== void 0 ? [value] : [];
var fillFieldNames3 = (fieldNames) => {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  return {
    _title: label ? [label] : ["title", "label"],
    value: value || "value",
    key: value || "value",
    children: children || "children"
  };
};
var isCheckDisabled2 = (node) => !node || node.disabled || node.disableCheckbox || node.checkable === false;
var getAllKeys = (treeData, fieldNames) => {
  const keys = [];
  const dig = (list) => {
    list.forEach((item) => {
      const children = item[fieldNames.children];
      if (children) {
        keys.push(item[fieldNames.value]);
        dig(children);
      }
    });
  };
  dig(treeData);
  return keys;
};
var isNil = (val) => val === null || val === void 0;

// node_modules/@rc-component/tree-select/es/hooks/useDataEntities.js
var useDataEntities_default = ((treeData, fieldNames) => React429.useMemo(() => {
  const collection = convertDataToEntities(treeData, {
    fieldNames,
    initWrapper: (wrapper) => ({
      ...wrapper,
      valueEntities: /* @__PURE__ */ new Map()
    }),
    processEntity: (entity, wrapper) => {
      const val = entity.node[fieldNames.value];
      if (true) {
        const key = entity.node.key;
        warning_default(!isNil(val), "TreeNode `value` is invalidate: undefined");
        warning_default(!wrapper.valueEntities.has(val), `Same \`value\` exist in the tree: ${val}`);
        warning_default(!key || String(key) === String(val), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${key}, value: ${val}.`);
      }
      wrapper.valueEntities.set(val, entity);
    }
  });
  return collection;
}, [treeData, fieldNames]));

// node_modules/@rc-component/tree-select/es/hooks/useFilterTreeData.js
var React431 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/utils/legacyUtil.js
var React430 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeNode.js
var TreeNode2 = () => null;
var TreeNode_default2 = TreeNode2;

// node_modules/@rc-component/tree-select/es/utils/legacyUtil.js
function convertChildrenToData(nodes) {
  return toArray(nodes).map((node) => {
    if (!React430.isValidElement(node) || !node.type) {
      return null;
    }
    const {
      key,
      props: {
        children,
        value,
        ...restProps
      }
    } = node;
    const data = {
      key,
      value,
      ...restProps
    };
    const childData = convertChildrenToData(children);
    if (childData.length) {
      data.children = childData;
    }
    return data;
  }).filter((data) => data);
}
function fillLegacyProps(dataNode) {
  if (!dataNode) {
    return dataNode;
  }
  const cloneNode = {
    ...dataNode
  };
  if (!("props" in cloneNode)) {
    Object.defineProperty(cloneNode, "props", {
      get() {
        warning_default(false, "New `rc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access.");
        return cloneNode;
      }
    });
  }
  return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
  let triggerNode = null;
  let nodeList = null;
  function generateMap() {
    function dig(list, level = "0", parentIncluded = false) {
      return list.map((option, index2) => {
        const pos = `${level}-${index2}`;
        const value = option[fieldNames.value];
        const included = checkedValues.includes(value);
        const children = dig(option[fieldNames.children] || [], pos, included);
        const node = React430.createElement(TreeNode_default2, option, children.map((child) => child.node));
        if (triggerValue === value) {
          triggerNode = node;
        }
        if (included) {
          const checkedNode = {
            pos,
            node,
            children
          };
          if (!parentIncluded) {
            nodeList.push(checkedNode);
          }
          return checkedNode;
        }
        return null;
      }).filter((node) => node);
    }
    if (!nodeList) {
      nodeList = [];
      dig(treeData);
      nodeList.sort(({
        node: {
          props: {
            value: val1
          }
        }
      }, {
        node: {
          props: {
            value: val2
          }
        }
      }) => {
        const index1 = checkedValues.indexOf(val1);
        const index2 = checkedValues.indexOf(val2);
        return index1 - index2;
      });
    }
  }
  Object.defineProperty(extra, "triggerNode", {
    get() {
      warning_default(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
      generateMap();
      return triggerNode;
    }
  });
  Object.defineProperty(extra, "allCheckedNodes", {
    get() {
      warning_default(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
      generateMap();
      if (showPosition) {
        return nodeList;
      }
      return nodeList.map(({
        node
      }) => node);
    }
  });
}

// node_modules/@rc-component/tree-select/es/hooks/useFilterTreeData.js
var useFilterTreeData = (treeData, searchValue, options) => {
  const {
    fieldNames,
    treeNodeFilterProp,
    filterTreeNode
  } = options;
  const {
    children: fieldChildren
  } = fieldNames;
  return React431.useMemo(() => {
    if (!searchValue || filterTreeNode === false) {
      return treeData;
    }
    const filterOptionFunc = typeof filterTreeNode === "function" ? filterTreeNode : (_, dataNode) => String(dataNode[treeNodeFilterProp]).toUpperCase().includes(searchValue.toUpperCase());
    const filterTreeNodes = (nodes, keepAll = false) => nodes.reduce((filtered, node) => {
      const children = node[fieldChildren];
      const isMatch = keepAll || filterOptionFunc(searchValue, fillLegacyProps(node));
      const filteredChildren = filterTreeNodes(children || [], isMatch);
      if (isMatch || filteredChildren.length) {
        filtered.push({
          ...node,
          isLeaf: void 0,
          [fieldChildren]: filteredChildren
        });
      }
      return filtered;
    }, []);
    return filterTreeNodes(treeData);
  }, [treeData, searchValue, fieldChildren, treeNodeFilterProp, filterTreeNode]);
};
var useFilterTreeData_default = useFilterTreeData;

// node_modules/@rc-component/tree-select/es/hooks/useRefFunc.js
var React432 = __toESM(require_react());
function useRefFunc(callback) {
  const funcRef = React432.useRef();
  funcRef.current = callback;
  const cacheFn = React432.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}

// node_modules/@rc-component/tree-select/es/hooks/useTreeData.js
var React433 = __toESM(require_react());
function buildTreeStructure(nodes, config) {
  const {
    id,
    pId,
    rootPId
  } = config;
  const nodeMap = /* @__PURE__ */ new Map();
  const rootNodes = [];
  nodes.forEach((node) => {
    const nodeKey = node[id];
    const clonedNode = {
      ...node,
      key: node.key || nodeKey
    };
    nodeMap.set(nodeKey, clonedNode);
  });
  nodeMap.forEach((node) => {
    const parentKey = node[pId];
    const parent = nodeMap.get(parentKey);
    if (parent) {
      parent.children = parent.children || [];
      parent.children.push(node);
    } else if (parentKey === rootPId || rootPId === null) {
      rootNodes.push(node);
    }
  });
  return rootNodes;
}
function useTreeData(treeData, children, simpleMode) {
  return React433.useMemo(() => {
    if (treeData) {
      if (simpleMode) {
        const config = {
          id: "id",
          pId: "pId",
          rootPId: null,
          ...typeof simpleMode === "object" ? simpleMode : {}
        };
        return buildTreeStructure(treeData, config);
      }
      return treeData;
    }
    return convertChildrenToData(children);
  }, [children, simpleMode, treeData]);
}

// node_modules/@rc-component/tree-select/es/LegacyContext.js
var React434 = __toESM(require_react());
var LegacySelectContext = React434.createContext(null);
var LegacyContext_default = LegacySelectContext;

// node_modules/@rc-component/tree-select/es/OptionList.js
var React436 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeSelectContext.js
var React435 = __toESM(require_react());
var TreeSelectContext = React435.createContext(null);
var TreeSelectContext_default = TreeSelectContext;

// node_modules/@rc-component/tree-select/es/OptionList.js
function _extends76() {
  _extends76 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends76.apply(this, arguments);
}
var HIDDEN_STYLE3 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var OptionList = (_, ref) => {
  const {
    prefixCls,
    multiple,
    searchValue,
    toggleOpen,
    open: open3,
    notFoundContent
  } = useBaseProps();
  const {
    virtual,
    listHeight,
    listItemHeight,
    listItemScrollOffset,
    treeData,
    fieldNames,
    onSelect,
    popupMatchSelectWidth,
    treeExpandAction,
    treeTitleRender,
    onPopupScroll,
    leftMaxCount,
    leafCountOnly,
    valueEntities,
    classNames: treeClassNames,
    styles
  } = React436.useContext(TreeSelectContext_default);
  const {
    checkable,
    checkedKeys,
    halfCheckedKeys,
    treeExpandedKeys,
    treeDefaultExpandAll,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeLine,
    treeNodeFilterProp,
    loadData,
    treeLoadedKeys,
    treeMotion,
    onTreeLoad,
    keyEntities
  } = React436.useContext(LegacyContext_default);
  const treeRef = React436.useRef();
  const memoTreeData = useMemo(
    () => treeData,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [open3, treeData],
    (prev, next) => next[0] && prev[1] !== next[1]
  );
  const mergedCheckedKeys = React436.useMemo(() => {
    if (!checkable) {
      return null;
    }
    return {
      checked: checkedKeys,
      halfChecked: halfCheckedKeys
    };
  }, [checkable, checkedKeys, halfCheckedKeys]);
  React436.useEffect(() => {
    if (open3 && !multiple && checkedKeys.length) {
      treeRef.current?.scrollTo({
        key: checkedKeys[0]
      });
    }
  }, [open3]);
  const onListMouseDown = (event) => {
    event.preventDefault();
  };
  const onInternalSelect = (__, info) => {
    const {
      node
    } = info;
    if (checkable && isCheckDisabled2(node)) {
      return;
    }
    onSelect(node.key, {
      selected: !checkedKeys.includes(node.key)
    });
    if (!multiple) {
      toggleOpen(false);
    }
  };
  const [expandedKeys, setExpandedKeys] = React436.useState(treeDefaultExpandedKeys);
  const [searchExpandedKeys, setSearchExpandedKeys] = React436.useState(null);
  const mergedExpandedKeys = React436.useMemo(() => {
    if (treeExpandedKeys) {
      return [...treeExpandedKeys];
    }
    return searchValue ? searchExpandedKeys : expandedKeys;
  }, [expandedKeys, searchExpandedKeys, treeExpandedKeys, searchValue]);
  const onInternalExpand = (keys) => {
    setExpandedKeys(keys);
    setSearchExpandedKeys(keys);
    if (onTreeExpand) {
      onTreeExpand(keys);
    }
  };
  const lowerSearchValue = String(searchValue).toLowerCase();
  const filterTreeNode = (treeNode) => {
    if (!lowerSearchValue) {
      return false;
    }
    return String(treeNode[treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue);
  };
  React436.useEffect(() => {
    if (searchValue) {
      setSearchExpandedKeys(getAllKeys(treeData, fieldNames));
    }
  }, [searchValue]);
  const [disabledCache, setDisabledCache] = React436.useState(() => /* @__PURE__ */ new Map());
  React436.useEffect(() => {
    if (leftMaxCount) {
      setDisabledCache(/* @__PURE__ */ new Map());
    }
  }, [leftMaxCount]);
  function getDisabledWithCache(node) {
    const value = node[fieldNames.value];
    if (!disabledCache.has(value)) {
      const entity = valueEntities.get(value);
      const isLeaf2 = (entity.children || []).length === 0;
      if (!isLeaf2) {
        const checkableChildren = entity.children.filter((childTreeNode) => !childTreeNode.node.disabled && !childTreeNode.node.disableCheckbox && !checkedKeys.includes(childTreeNode.node[fieldNames.value]));
        const checkableChildrenCount = checkableChildren.length;
        disabledCache.set(value, checkableChildrenCount > leftMaxCount);
      } else {
        disabledCache.set(value, false);
      }
    }
    return disabledCache.get(value);
  }
  const nodeDisabled = useEvent_default((node) => {
    const nodeValue = node[fieldNames.value];
    if (checkedKeys.includes(nodeValue)) {
      return false;
    }
    if (leftMaxCount === null) {
      return false;
    }
    if (leftMaxCount <= 0) {
      return true;
    }
    if (leafCountOnly && leftMaxCount) {
      return getDisabledWithCache(node);
    }
    return false;
  });
  const getFirstMatchingNode = (nodes) => {
    for (const node of nodes) {
      if (node.disabled || node.selectable === false) {
        continue;
      }
      if (searchValue) {
        if (filterTreeNode(node)) {
          return node;
        }
      } else {
        return node;
      }
      if (node[fieldNames.children]) {
        const matchInChildren = getFirstMatchingNode(node[fieldNames.children]);
        if (matchInChildren) {
          return matchInChildren;
        }
      }
    }
    return null;
  };
  const [activeKey, setActiveKey] = React436.useState(null);
  const activeEntity = keyEntities[activeKey];
  React436.useEffect(() => {
    if (!open3) {
      return;
    }
    let nextActiveKey = null;
    const getFirstNode = () => {
      const firstNode = getFirstMatchingNode(memoTreeData);
      return firstNode ? firstNode[fieldNames.value] : null;
    };
    if (!multiple && checkedKeys.length && !searchValue) {
      nextActiveKey = checkedKeys[0];
    } else {
      nextActiveKey = getFirstNode();
    }
    setActiveKey(nextActiveKey);
  }, [open3, searchValue]);
  React436.useImperativeHandle(ref, () => ({
    scrollTo: treeRef.current?.scrollTo,
    onKeyDown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        // >>> Arrow keys
        case KeyCode_default.UP:
        case KeyCode_default.DOWN:
        case KeyCode_default.LEFT:
        case KeyCode_default.RIGHT:
          treeRef.current?.onKeyDown(event);
          break;
        // >>> Select item
        case KeyCode_default.ENTER: {
          if (activeEntity) {
            const isNodeDisabled = nodeDisabled(activeEntity.node);
            const {
              selectable,
              value,
              disabled
            } = activeEntity?.node || {};
            if (selectable !== false && !disabled && !isNodeDisabled) {
              onInternalSelect(null, {
                node: {
                  key: activeKey
                },
                selected: !checkedKeys.includes(value)
              });
            }
          }
          break;
        }
        // >>> Close
        case KeyCode_default.ESC: {
          toggleOpen(false);
        }
      }
    },
    onKeyUp: () => {
    }
  }));
  const hasLoadDataFn = useMemo(
    () => searchValue ? false : true,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchValue, treeExpandedKeys || expandedKeys],
    ([preSearchValue], [nextSearchValue, nextExcludeSearchExpandedKeys]) => preSearchValue !== nextSearchValue && !!(nextSearchValue || nextExcludeSearchExpandedKeys)
  );
  const syncLoadData = hasLoadDataFn ? loadData : null;
  if (memoTreeData.length === 0) {
    return React436.createElement("div", {
      role: "listbox",
      className: `${prefixCls}-empty`,
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  const treeProps = {
    fieldNames
  };
  if (treeLoadedKeys) {
    treeProps.loadedKeys = treeLoadedKeys;
  }
  if (mergedExpandedKeys) {
    treeProps.expandedKeys = mergedExpandedKeys;
  }
  return React436.createElement("div", {
    onMouseDown: onListMouseDown
  }, activeEntity && open3 && React436.createElement("span", {
    style: HIDDEN_STYLE3,
    "aria-live": "assertive"
  }, activeEntity.node.value), React436.createElement(UnstableContext3.Provider, {
    value: {
      nodeDisabled
    }
  }, React436.createElement(es_default23, _extends76({
    classNames: treeClassNames?.popup,
    styles: styles?.popup,
    ref: treeRef,
    focusable: false,
    prefixCls: `${prefixCls}-tree`,
    treeData: memoTreeData,
    height: listHeight,
    itemHeight: listItemHeight,
    itemScrollOffset: listItemScrollOffset,
    virtual: virtual !== false && popupMatchSelectWidth !== false,
    multiple,
    icon: treeIcon,
    showIcon: showTreeIcon,
    switcherIcon,
    showLine: treeLine,
    loadData: syncLoadData,
    motion: treeMotion,
    activeKey,
    checkable,
    checkStrictly: true,
    checkedKeys: mergedCheckedKeys,
    selectedKeys: !checkable ? checkedKeys : [],
    defaultExpandAll: treeDefaultExpandAll,
    titleRender: treeTitleRender
  }, treeProps, {
    // Proxy event out
    onActiveChange: setActiveKey,
    onSelect: onInternalSelect,
    onCheck: onInternalSelect,
    onExpand: onInternalExpand,
    onLoad: onTreeLoad,
    filterTreeNode,
    expandAction: treeExpandAction,
    onScroll: onPopupScroll
  }))));
};
var RefOptionList2 = React436.forwardRef(OptionList);
if (true) {
  RefOptionList2.displayName = "OptionList";
}
var OptionList_default2 = RefOptionList2;

// node_modules/@rc-component/tree-select/es/utils/strategyUtil.js
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT3 = "SHOW_PARENT";
var SHOW_CHILD3 = "SHOW_CHILD";
function formatStrategyValues2(values, strategy, keyEntities, fieldNames) {
  const valueSet = new Set(values);
  if (strategy === SHOW_CHILD3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      return !entity || !entity.children || !entity.children.some(({
        node
      }) => valueSet.has(node[fieldNames.value])) || !entity.children.every(({
        node
      }) => isCheckDisabled2(node) || valueSet.has(node[fieldNames.value]));
    });
  }
  if (strategy === SHOW_PARENT3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      const parent = entity ? entity.parent : null;
      return !parent || isCheckDisabled2(parent.node) || !valueSet.has(parent.key);
    });
  }
  return values;
}

// node_modules/@rc-component/tree-select/es/utils/warningPropsUtil.js
function warningProps(props) {
  const {
    searchPlaceholder,
    treeCheckStrictly,
    treeCheckable,
    labelInValue,
    value,
    multiple,
    showCheckedStrategy,
    maxCount
  } = props;
  warning_default(!searchPlaceholder, "`searchPlaceholder` has been removed.");
  if (treeCheckStrictly && labelInValue === false) {
    warning_default(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
  }
  if (labelInValue || treeCheckStrictly) {
    warning_default(toArray6(value).every((val) => val && typeof val === "object" && "value" in val), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead.");
  }
  if (treeCheckStrictly || multiple || treeCheckable) {
    warning_default(!value || Array.isArray(value), "`value` should be an array when `TreeSelect` is checkable or multiple.");
  } else {
    warning_default(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
  }
  if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) {
    warning_default(false, "`maxCount` not work with `showCheckedStrategy=SHOW_ALL` (when `treeCheckStrictly=false`) or `showCheckedStrategy=SHOW_PARENT`.");
  }
}
var warningPropsUtil_default = warningProps;

// node_modules/@rc-component/tree-select/es/hooks/useSearchConfig.js
var React437 = __toESM(require_react());
function useSearchConfig2(showSearch, props) {
  const {
    searchValue,
    inputValue,
    onSearch,
    autoClearSearchValue,
    filterTreeNode,
    treeNodeFilterProp
  } = props;
  return React437.useMemo(() => {
    const isObject = typeof showSearch === "object";
    const searchConfig = {
      searchValue: searchValue ?? inputValue,
      onSearch,
      autoClearSearchValue,
      filterTreeNode,
      treeNodeFilterProp,
      ...isObject ? showSearch : {}
    };
    return [isObject ? true : showSearch, searchConfig];
  }, [showSearch, searchValue, inputValue, onSearch, autoClearSearchValue, filterTreeNode, treeNodeFilterProp]);
}

// node_modules/@rc-component/tree-select/es/TreeSelect.js
function _extends77() {
  _extends77 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends77.apply(this, arguments);
}
function isRawValue(value) {
  return !value || typeof value !== "object";
}
var TreeSelect = React438.forwardRef((props, ref) => {
  const {
    id,
    prefixCls = "rc-tree-select",
    // Value
    value,
    defaultValue,
    onChange,
    onSelect,
    onDeselect,
    // Search
    showSearch,
    searchValue: legacySearchValue,
    inputValue: legacyinputValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterTreeNode: legacyFilterTreeNode,
    treeNodeFilterProp: legacytreeNodeFilterProp,
    // Selector
    showCheckedStrategy,
    treeNodeLabelProp,
    //  Mode
    multiple,
    treeCheckable,
    treeCheckStrictly,
    labelInValue,
    maxCount,
    // FieldNames
    fieldNames,
    // Data
    treeDataSimpleMode,
    treeData,
    children,
    loadData,
    treeLoadedKeys,
    onTreeLoad,
    // Expanded
    treeDefaultExpandAll,
    treeExpandedKeys,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeExpandAction,
    // Options
    virtual,
    listHeight = 200,
    listItemHeight = 20,
    listItemScrollOffset = 0,
    onPopupVisibleChange,
    popupMatchSelectWidth = true,
    // Tree
    treeLine,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeMotion,
    treeTitleRender,
    onPopupScroll,
    classNames: treeSelectClassNames,
    styles,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const treeConduction = treeCheckable && !treeCheckStrictly;
  const mergedCheckable = treeCheckable || treeCheckStrictly;
  const mergedLabelInValue = treeCheckStrictly || labelInValue;
  const mergedMultiple = mergedCheckable || multiple;
  const searchProps = {
    searchValue: legacySearchValue,
    inputValue: legacyinputValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterTreeNode: legacyFilterTreeNode,
    treeNodeFilterProp: legacytreeNodeFilterProp
  };
  const [mergedShowSearch, searchConfig] = useSearchConfig2(showSearch, searchProps);
  const {
    searchValue,
    onSearch,
    autoClearSearchValue = true,
    filterTreeNode,
    treeNodeFilterProp = "value"
  } = searchConfig;
  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
  const mergedShowCheckedStrategy = React438.useMemo(() => {
    if (!treeCheckable) {
      return SHOW_ALL;
    }
    return showCheckedStrategy || SHOW_CHILD3;
  }, [showCheckedStrategy, treeCheckable]);
  if (true) {
    warningPropsUtil_default(props);
  }
  const mergedFieldNames = React438.useMemo(
    () => fillFieldNames3(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const onInternalSearch = (searchText) => {
    setSearchValue(searchText);
    onSearch?.(searchText);
  };
  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);
  const {
    keyEntities,
    valueEntities
  } = useDataEntities_default(mergedTreeData, mergedFieldNames);
  const splitRawValues = React438.useCallback((newRawValues) => {
    const missingRawValues = [];
    const existRawValues = [];
    newRawValues.forEach((val) => {
      if (valueEntities.has(val)) {
        existRawValues.push(val);
      } else {
        missingRawValues.push(val);
      }
    });
    return {
      missingRawValues,
      existRawValues
    };
  }, [valueEntities]);
  const filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
    fieldNames: mergedFieldNames,
    treeNodeFilterProp,
    filterTreeNode
  });
  const getLabel = React438.useCallback((item) => {
    if (item) {
      if (treeNodeLabelProp) {
        return item[treeNodeLabelProp];
      }
      const {
        _title: titleList
      } = mergedFieldNames;
      for (let i = 0; i < titleList.length; i += 1) {
        const title = item[titleList[i]];
        if (title !== void 0) {
          return title;
        }
      }
    }
  }, [mergedFieldNames, treeNodeLabelProp]);
  const toLabeledValues = React438.useCallback((draftValues) => {
    const values = toArray6(draftValues);
    return values.map((val) => {
      if (isRawValue(val)) {
        return {
          value: val
        };
      }
      return val;
    });
  }, []);
  const convert2LabelValues = React438.useCallback((draftValues) => {
    const values = toLabeledValues(draftValues);
    return values.map((item) => {
      let {
        label: rawLabel
      } = item;
      const {
        value: rawValue,
        halfChecked: rawHalfChecked
      } = item;
      let rawDisabled;
      const entity = valueEntities.get(rawValue);
      if (entity) {
        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);
        rawDisabled = entity.node.disabled;
      } else if (rawLabel === void 0) {
        const labelInValueItem = toLabeledValues(internalValue).find((labeledItem) => labeledItem.value === rawValue);
        rawLabel = labelInValueItem.label;
      }
      return {
        label: rawLabel,
        value: rawValue,
        halfChecked: rawHalfChecked,
        disabled: rawDisabled
      };
    });
  }, [valueEntities, getLabel, toLabeledValues, internalValue]);
  const rawMixedLabeledValues = React438.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);
  const [rawLabeledValues, rawHalfLabeledValues] = React438.useMemo(() => {
    const fullCheckValues = [];
    const halfCheckValues = [];
    rawMixedLabeledValues.forEach((item) => {
      if (item.halfChecked) {
        halfCheckValues.push(item);
      } else {
        fullCheckValues.push(item);
      }
    });
    return [fullCheckValues, halfCheckValues];
  }, [rawMixedLabeledValues]);
  const rawValues = React438.useMemo(() => rawLabeledValues.map((item) => item.value), [rawLabeledValues]);
  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys_default(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);
  const displayValues = React438.useMemo(() => {
    const displayKeys = formatStrategyValues2(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
    const values = displayKeys.map((key) => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key);
    const labeledValues = values.map((val) => {
      const targetItem = rawLabeledValues.find((item) => item.value === val);
      const label = labelInValue ? targetItem?.label : treeTitleRender?.(targetItem);
      return {
        value: val,
        label
      };
    });
    const rawDisplayValues = convert2LabelValues(labeledValues);
    const firstVal = rawDisplayValues[0];
    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {
      return [];
    }
    return rawDisplayValues.map((item) => ({
      ...item,
      label: item.label ?? item.value
    }));
  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);
  const [cachedDisplayValues] = useCache_default(displayValues);
  const mergedMaxCount = React438.useMemo(() => {
    if (mergedMultiple && (mergedShowCheckedStrategy === "SHOW_CHILD" || treeCheckStrictly || !treeCheckable)) {
      return maxCount;
    }
    return null;
  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);
  const triggerChange = useRefFunc((newRawValues, extra, source) => {
    const formattedKeyList = formatStrategyValues2(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {
      return;
    }
    const labeledValues = convert2LabelValues(newRawValues);
    setInternalValue(labeledValues);
    if (autoClearSearchValue) {
      setSearchValue("");
    }
    if (onChange) {
      let eventValues = newRawValues;
      if (treeConduction) {
        eventValues = formattedKeyList.map((key) => {
          const entity = valueEntities.get(key);
          return entity ? entity.node[mergedFieldNames.value] : key;
        });
      }
      const {
        triggerValue,
        selected
      } = extra || {
        triggerValue: void 0,
        selected: void 0
      };
      let returnRawValues = eventValues;
      if (treeCheckStrictly) {
        const halfValues = rawHalfLabeledValues.filter((item) => !eventValues.includes(item.value));
        returnRawValues = [...returnRawValues, ...halfValues];
      }
      const returnLabeledValues = convert2LabelValues(returnRawValues);
      const additionalInfo = {
        // [Legacy] Always return as array contains label & value
        preValue: rawLabeledValues,
        triggerValue
      };
      let showPosition = true;
      if (treeCheckStrictly || source === "selection" && !selected) {
        showPosition = false;
      }
      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);
      if (mergedCheckable) {
        additionalInfo.checked = selected;
      } else {
        additionalInfo.selected = selected;
      }
      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map((item) => item.value);
      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map((item) => item.label), additionalInfo);
    }
  });
  const onOptionSelect = React438.useCallback((selectedKey, {
    selected,
    source
  }) => {
    const entity = keyEntities[selectedKey];
    const node = entity?.node;
    const selectedValue = node?.[mergedFieldNames.value] ?? selectedKey;
    if (!mergedMultiple) {
      triggerChange([selectedValue], {
        selected: true,
        triggerValue: selectedValue
      }, "option");
    } else {
      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter((v) => v !== selectedValue);
      if (treeConduction) {
        const {
          missingRawValues,
          existRawValues
        } = splitRawValues(newRawValues);
        const keyList = existRawValues.map((val) => valueEntities.get(val).key);
        let checkedKeys;
        if (selected) {
          ({
            checkedKeys
          } = conductCheck(keyList, true, keyEntities));
        } else {
          ({
            checkedKeys
          } = conductCheck(keyList, {
            checked: false,
            halfCheckedKeys: rawHalfCheckedValues
          }, keyEntities));
        }
        newRawValues = [...missingRawValues, ...checkedKeys.map((key) => keyEntities[key].node[mergedFieldNames.value])];
      }
      triggerChange(newRawValues, {
        selected,
        triggerValue: selectedValue
      }, source || "option");
    }
    if (selected || !mergedMultiple) {
      onSelect?.(selectedValue, fillLegacyProps(node));
    } else {
      onDeselect?.(selectedValue, fillLegacyProps(node));
    }
  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);
  const onInternalPopupVisibleChange = React438.useCallback((open3) => {
    if (onPopupVisibleChange) {
      onPopupVisibleChange(open3);
    }
  }, [onPopupVisibleChange]);
  const onDisplayValuesChange = useRefFunc((newValues, info) => {
    const newRawValues = newValues.map((item) => item.value);
    if (info.type === "clear") {
      triggerChange(newRawValues, {}, "selection");
      return;
    }
    if (info.values.length) {
      onOptionSelect(info.values[0].value, {
        selected: false,
        source: "selection"
      });
    }
  });
  const treeSelectContext = React438.useMemo(() => {
    return {
      virtual,
      popupMatchSelectWidth,
      listHeight,
      listItemHeight,
      listItemScrollOffset,
      treeData: filteredTreeData,
      fieldNames: mergedFieldNames,
      onSelect: onOptionSelect,
      treeExpandAction,
      treeTitleRender,
      onPopupScroll,
      leftMaxCount: maxCount === void 0 ? null : maxCount - cachedDisplayValues.length,
      leafCountOnly: mergedShowCheckedStrategy === "SHOW_CHILD" && !treeCheckStrictly && !!treeCheckable,
      valueEntities,
      classNames: treeSelectClassNames,
      styles
    };
  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);
  const legacyContext = React438.useMemo(() => ({
    checkable: mergedCheckable,
    loadData,
    treeLoadedKeys,
    onTreeLoad,
    checkedKeys: rawCheckedValues,
    halfCheckedKeys: rawHalfCheckedValues,
    treeDefaultExpandAll,
    treeExpandedKeys,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeIcon,
    treeMotion,
    showTreeIcon,
    switcherIcon,
    treeLine,
    treeNodeFilterProp,
    keyEntities
  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);
  return React438.createElement(TreeSelectContext_default.Provider, {
    value: treeSelectContext
  }, React438.createElement(LegacyContext_default.Provider, {
    value: legacyContext
  }, React438.createElement(BaseSelect_default, _extends77({
    ref
  }, restProps, {
    classNames: treeSelectClassNames,
    styles,
    id: mergedId,
    prefixCls,
    mode: mergedMultiple ? "multiple" : void 0,
    displayValues: cachedDisplayValues,
    onDisplayValuesChange,
    autoClearSearchValue,
    showSearch: mergedShowSearch,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    OptionList: OptionList_default2,
    emptyOptions: !mergedTreeData.length,
    onPopupVisibleChange: onInternalPopupVisibleChange,
    popupMatchSelectWidth
  }))));
});
if (true) {
  TreeSelect.displayName = "TreeSelect";
}
var GenericTreeSelect = TreeSelect;
GenericTreeSelect.TreeNode = TreeNode_default2;
GenericTreeSelect.SHOW_ALL = SHOW_ALL;
GenericTreeSelect.SHOW_PARENT = SHOW_PARENT3;
GenericTreeSelect.SHOW_CHILD = SHOW_CHILD3;
var TreeSelect_default = GenericTreeSelect;

// node_modules/@rc-component/tree-select/es/index.js
var es_default25 = TreeSelect_default;

// node_modules/antd/es/tree-select/style/index.js
var genBaseStyle14 = (token) => {
  const {
    componentCls,
    treePrefixCls,
    colorBgElevated
  } = token;
  const treeCls = `.${treePrefixCls}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${componentCls}-dropdown`]: [
        {
          padding: `${unit(token.paddingXS)} ${unit(token.calc(token.paddingXS).div(2).equal())}`
        },
        // ====================== Tree ======================
        genTreeStyle(treePrefixCls, merge(token, {
          colorBgContainer: colorBgElevated
        }), false),
        {
          [treeCls]: {
            borderRadius: 0,
            [`${treeCls}-list-holder-inner`]: {
              alignItems: "stretch",
              [`${treeCls}-treenode`]: {
                [`${treeCls}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        getStyle(`${treePrefixCls}-checkbox`, token),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${treeCls}-switcher${treeCls}-switcher_close`]: {
              [`${treeCls}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function useTreeSelectStyle(prefixCls, treePrefixCls, rootCls) {
  return genStyleHooks("TreeSelect", (token) => {
    const treeSelectToken = merge(token, {
      treePrefixCls
    });
    return genBaseStyle14(treeSelectToken);
  }, initComponentToken2, {
    resetFont: false
  })(prefixCls, rootCls);
}

// node_modules/antd/es/tree-select/index.js
var InternalTreeSelect = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    bordered = true,
    style,
    className,
    rootClassName,
    treeCheckable,
    multiple,
    listHeight = 256,
    listItemHeight: customListItemHeight,
    placement,
    notFoundContent,
    switcherIcon: customSwitcherIcon,
    treeLine,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    treeIcon = false,
    transitionName,
    choiceTransitionName = "",
    status: customStatus,
    treeExpandAction,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    allowClear,
    variant: customVariant,
    dropdownStyle: _dropdownStyle,
    dropdownRender,
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    tagRender,
    maxCount,
    showCheckedStrategy,
    treeCheckStrictly,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    direction,
    styles: contextStyles,
    classNames: contextClassNames,
    switcherIcon
  } = useComponentConfig("treeSelect");
  const {
    renderEmpty,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow
  } = React439.useContext(ConfigContext);
  const [, token] = useToken();
  const listItemHeight = customListItemHeight ?? token?.controlHeightSM + token?.paddingXXS;
  if (true) {
    const warning2 = devUseWarning("TreeSelect");
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning2.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning2(multiple !== false || !treeCheckable, "usage", "`multiple` will always be `true` when `treeCheckable` is true") : void 0;
    true ? warning2(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
  }
  const rootPrefixCls = getPrefixCls();
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const treePrefixCls = getPrefixCls("select-tree", customizePrefixCls);
  const treeSelectPrefixCls = getPrefixCls("tree-select", customizePrefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const rootCls = useCSSVarCls_default(prefixCls);
  const treeSelectRootCls = useCSSVarCls_default(treeSelectPrefixCls);
  const [hashId, cssVarCls] = style_default(prefixCls, rootCls);
  useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls, treeSelectRootCls);
  const [variant, enableVariantCls] = useVariants_default("treeSelect", customVariant, bordered);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React439.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React439.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled,
    status: mergedStatus,
    variant
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${treeSelectPrefixCls}-dropdown`, {
    [`${treeSelectPrefixCls}-dropdown-rtl`]: direction === "rtl"
  }, rootClassName, mergedClassNames.root, mergedClassNames.popup?.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  const isMultiple = !!(treeCheckable || multiple);
  const mergedMaxCount = React439.useMemo(() => {
    if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) {
      return void 0;
    }
    return maxCount;
  }, [maxCount, showCheckedStrategy, treeCheckStrictly]);
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const {
    suffixIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...restProps,
    multiple: isMultiple,
    showSuffixIcon,
    hasFeedback,
    feedbackIcon,
    prefixCls,
    componentName: "TreeSelect"
  });
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else {
    mergedNotFound = renderEmpty?.("Select") || React439.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }
  const selectProps = omit(restProps, ["suffixIcon", "removeIcon", "clearIcon", "itemIcon", "switcherIcon", "style"]);
  const memoizedPlacement = React439.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  const mergedClassName = clsx(!customizePrefixCls && treeSelectPrefixCls, {
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${variant}`]: enableVariantCls,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, mergedClassNames?.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
  const mergedSwitcherIcon = customSwitcherIcon ?? switcherIcon;
  const renderSwitcherIcon = (nodeProps) => React439.createElement(iconUtil_default, {
    prefixCls: treePrefixCls,
    switcherIcon: mergedSwitcherIcon,
    treeNodeProps: nodeProps,
    showLine: treeLine
  });
  const [zIndex] = useZIndex("SelectLike", mergedStyles.popup?.root?.zIndex);
  return React439.createElement(es_default25, {
    classNames: mergedClassNames,
    styles: mergedStyles,
    virtual,
    disabled: mergedDisabled,
    ...selectProps,
    popupMatchSelectWidth: mergedPopupMatchSelectWidth,
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    ref,
    prefixCls,
    className: mergedClassName,
    style: {
      ...mergedStyles?.root,
      ...style
    },
    listHeight,
    listItemHeight,
    treeCheckable: treeCheckable ? React439.createElement("span", {
      className: `${prefixCls}-tree-checkbox-inner`
    }) : treeCheckable,
    treeLine: !!treeLine,
    suffixIcon,
    multiple: isMultiple,
    placement: memoizedPlacement,
    removeIcon,
    allowClear: mergedAllowClear,
    switcherIcon: renderSwitcherIcon,
    showTreeIcon: treeIcon,
    notFoundContent: mergedNotFound,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    treeMotion: null,
    popupClassName: mergedPopupClassName,
    popupStyle: {
      ...mergedStyles.root,
      ...mergedStyles.popup?.root,
      zIndex
    },
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange,
    choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
    transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
    treeExpandAction,
    tagRender: isMultiple ? tagRender : void 0,
    maxCount: mergedMaxCount,
    showCheckedStrategy,
    treeCheckStrictly
  });
};
var TreeSelectRef = React439.forwardRef(InternalTreeSelect);
var TreeSelect2 = TreeSelectRef;
var PurePanel14 = PurePanel_default(TreeSelect2, "popupAlign", (props) => omit(props, ["visible"]));
TreeSelect2.TreeNode = TreeNode_default2;
TreeSelect2.SHOW_ALL = SHOW_ALL;
TreeSelect2.SHOW_PARENT = SHOW_PARENT3;
TreeSelect2.SHOW_CHILD = SHOW_CHILD3;
TreeSelect2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel14;
if (true) {
  TreeSelect2.displayName = "TreeSelect";
}
var tree_select_default = TreeSelect2;

// node_modules/antd/es/typography/Link.js
var React448 = __toESM(require_react());

// node_modules/antd/es/typography/Base/index.js
var React447 = __toESM(require_react());

// node_modules/antd/es/typography/Editable.js
var React440 = __toESM(require_react());

// node_modules/antd/es/typography/style/mixins.js
var getTitleStyle = (fontSize, lineHeight, color, token) => {
  const {
    titleMarginBottom,
    fontWeightStrong
  } = token;
  return {
    marginBottom: titleMarginBottom,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
};
var getTitleStyles = (token) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token[`fontSizeHeading${headingLevel}`], token[`lineHeightHeading${headingLevel}`], token.colorTextHeading, token);
  });
  return styles;
};
var getLinkStyles = (token) => {
  const {
    componentCls
  } = token;
  return {
    "a&, a": {
      ...operationUnit(token),
      userSelect: "text",
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    }
  };
};
var getResetStyles = (token) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: token.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: token.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: token.fontWeightStrong
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: token.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
});
var getEditableStyles = (token) => {
  const {
    componentCls,
    paddingSM
  } = token;
  const inputShift = paddingSM;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: token.calc(token.paddingSM).mul(-1).equal(),
        insetBlockStart: token.calc(inputShift).div(-2).add(1).equal(),
        marginBottom: token.calc(inputShift).div(2).sub(2).equal()
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token.calc(token.marginXS).add(2).equal(),
        insetBlockEnd: token.marginXS,
        color: token.colorIcon,
        // default style
        fontWeight: "normal",
        fontSize: token.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
};
var getCopyableStyles = (token) => ({
  [`${token.componentCls}-copy-success`]: {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token.colorSuccess
    }
  },
  [`${token.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
});
var getEllipsisStyles = () => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-ellipsis-single-line": {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
});

// node_modules/antd/es/typography/style/index.js
var genTypographyStyle = (token) => {
  const {
    componentCls,
    titleMarginTop
  } = token;
  return {
    [componentCls]: {
      color: token.colorText,
      wordBreak: "break-word",
      lineHeight: token.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token.colorSuccessText
      },
      [`&${componentCls}-warning`]: {
        color: token.colorWarningText
      },
      [`&${componentCls}-danger`]: {
        color: token.colorErrorText,
        "a&:active, a&:focus": {
          color: token.colorErrorTextActive
        },
        "a&:hover": {
          color: token.colorErrorTextHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      },
      ...getTitleStyles(token),
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: titleMarginTop
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: titleMarginTop
        }
      },
      ...getResetStyles(token),
      ...getLinkStyles(token),
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: {
        ...operationUnit(token),
        marginInlineStart: token.marginXXS
      },
      ...getEditableStyles(token),
      ...getCopyableStyles(token),
      ...getEllipsisStyles(),
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken49 = () => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
});
var style_default55 = genStyleHooks("Typography", genTypographyStyle, prepareComponentToken49);

// node_modules/antd/es/typography/Editable.js
var Editable = (props) => {
  const {
    prefixCls,
    "aria-label": ariaLabel,
    className,
    style,
    direction,
    maxLength,
    autoSize = true,
    value,
    onSave,
    onCancel,
    onEnd,
    component,
    enterIcon = React440.createElement(EnterOutlined_default, null)
  } = props;
  const ref = React440.useRef(null);
  const inComposition = React440.useRef(false);
  const lastKeyCode = React440.useRef(null);
  const [current, setCurrent] = React440.useState(value);
  React440.useEffect(() => {
    setCurrent(value);
  }, [value]);
  React440.useEffect(() => {
    if (ref.current?.resizableTextArea) {
      const {
        textArea
      } = ref.current.resizableTextArea;
      textArea.focus();
      const {
        length
      } = textArea.value;
      textArea.setSelectionRange(length, length);
    }
  }, []);
  const onChange = ({
    target
  }) => {
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  };
  const onCompositionStart = () => {
    inComposition.current = true;
  };
  const onCompositionEnd = () => {
    inComposition.current = false;
  };
  const onKeyDown2 = ({
    keyCode
  }) => {
    if (inComposition.current) {
      return;
    }
    lastKeyCode.current = keyCode;
  };
  const confirmChange = () => {
    onSave(current.trim());
  };
  const onKeyUp = ({
    keyCode,
    ctrlKey,
    altKey,
    metaKey,
    shiftKey
  }) => {
    if (lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey) {
      return;
    }
    if (keyCode === KeyCode_default.ENTER) {
      confirmChange();
      onEnd?.();
    } else if (keyCode === KeyCode_default.ESC) {
      onCancel();
    }
  };
  const onBlur = () => {
    confirmChange();
  };
  const [hashId, cssVarCls] = style_default55(prefixCls);
  const textAreaClassName = clsx(prefixCls, `${prefixCls}-edit-content`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${component}`]: !!component
  }, className, hashId, cssVarCls);
  return React440.createElement("div", {
    className: textAreaClassName,
    style
  }, React440.createElement(TextArea_default2, {
    ref,
    maxLength,
    value: current,
    onChange,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBlur,
    "aria-label": ariaLabel,
    rows: 1,
    autoSize
  }), enterIcon !== null ? cloneElement(enterIcon, {
    className: `${prefixCls}-edit-content-confirm`
  }) : null);
};
var Editable_default = Editable;

// node_modules/antd/es/typography/hooks/useCopyClick.js
var React441 = __toESM(require_react());

// node_modules/antd/es/_util/copy.js
var execCopy = (text, isHtmlFormat) => {
  let copySuccess = false;
  const onCopy = (event) => {
    event.stopPropagation();
    event.preventDefault();
    event.clipboardData?.clearData();
    event.clipboardData?.setData("text/plain", text);
    if (isHtmlFormat) {
      event.clipboardData?.setData("text/html", text);
    }
    copySuccess = true;
  };
  try {
    document.addEventListener("copy", onCopy, {
      capture: true
    });
    document.execCommand("copy");
    return copySuccess;
  } catch {
    return false;
  } finally {
    document.removeEventListener("copy", onCopy, {
      capture: true
    });
  }
};
var asyncCopy = async (text, isHtmlFormat) => {
  try {
    if (isHtmlFormat) {
      await navigator.clipboard.write([new ClipboardItem({
        "text/html": new Blob([text], {
          type: "text/html"
        }),
        "text/plain": new Blob([text], {
          type: "text/plain"
        })
      })]);
    } else {
      await navigator.clipboard.writeText(text);
    }
    return true;
  } catch {
    return false;
  }
};
async function copy(text, config) {
  if (typeof text !== "string") {
    true ? warning_default2(false, "The clipboard content must be of string type", "") : void 0;
    return false;
  }
  const isHtmlFormat = config?.format === "text/html";
  if (await asyncCopy(text, isHtmlFormat)) {
    return true;
  }
  if (execCopy(text, isHtmlFormat)) {
    return true;
  }
  return false;
}
var copy_default = copy;

// node_modules/antd/es/typography/hooks/useCopyClick.js
var useCopyClick = ({
  copyConfig,
  children
}) => {
  const [copied, setCopied] = React441.useState(false);
  const [copyLoading, setCopyLoading] = React441.useState(false);
  const copyIdRef = React441.useRef(null);
  const cleanCopyId = () => {
    if (copyIdRef.current) {
      clearTimeout(copyIdRef.current);
    }
  };
  const copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  React441.useEffect(() => cleanCopyId, []);
  const onClick = useEvent_default(async (e3) => {
    e3?.preventDefault();
    e3?.stopPropagation();
    setCopyLoading(true);
    try {
      const text = typeof copyConfig.text === "function" ? await copyConfig.text() : copyConfig.text;
      await copy_default(text || toList_default(children, true).join("") || "", copyOptions);
      setCopyLoading(false);
      setCopied(true);
      cleanCopyId();
      copyIdRef.current = setTimeout(() => {
        setCopied(false);
      }, 3e3);
      copyConfig.onCopy?.(e3);
    } catch (error) {
      setCopyLoading(false);
      throw error;
    }
  });
  return {
    copied,
    copyLoading,
    onClick
  };
};
var useCopyClick_default = useCopyClick;

// node_modules/antd/es/typography/hooks/useMergedConfig.js
var React442 = __toESM(require_react());
function useMergedConfig(propConfig, templateConfig) {
  return React442.useMemo(() => {
    const support = !!propConfig;
    return [support, {
      ...templateConfig,
      ...support && typeof propConfig === "object" ? propConfig : null
    }];
  }, [propConfig]);
}

// node_modules/antd/es/typography/hooks/usePrevious.js
var import_react135 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = (0, import_react135.useRef)(void 0);
  (0, import_react135.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};
var usePrevious_default = usePrevious;

// node_modules/antd/es/typography/hooks/useTooltipProps.js
var import_react136 = __toESM(require_react());
var useTooltipProps = (tooltip, editConfigText, children) => (0, import_react136.useMemo)(() => {
  if (tooltip === true) {
    return {
      title: editConfigText ?? children
    };
  }
  if ((0, import_react136.isValidElement)(tooltip)) {
    return {
      title: tooltip
    };
  }
  if (typeof tooltip === "object") {
    return {
      title: editConfigText ?? children,
      ...tooltip
    };
  }
  return {
    title: tooltip
  };
}, [tooltip, editConfigText, children]);
var useTooltipProps_default = useTooltipProps;

// node_modules/antd/es/typography/Typography.js
var React443 = __toESM(require_react());
var Typography = React443.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    component: Component6 = "article",
    className,
    rootClassName,
    children,
    direction: typographyDirection,
    style,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction: contextDirection,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("typography");
  const direction = typographyDirection ?? contextDirection;
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const [hashId, cssVarCls] = style_default55(prefixCls);
  const componentClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls);
  const mergedStyle = {
    ...contextStyle,
    ...style
  };
  return (
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    React443.createElement(Component6, {
      className: componentClassName,
      style: mergedStyle,
      ref,
      ...restProps
    }, children)
  );
});
if (true) {
  Typography.displayName = "Typography";
}
var Typography_default = Typography;

// node_modules/antd/es/typography/Base/CopyBtn.js
var React444 = __toESM(require_react());

// node_modules/antd/es/typography/Base/util.js
function toList2(val) {
  if (val === false) {
    return [false, false];
  }
  return Array.isArray(val) ? val : [val];
}
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === void 0) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
function isEleEllipsis(ele) {
  const childDiv = document.createElement("em");
  ele.appendChild(childDiv);
  if (true) {
    childDiv.className = "ant-typography-css-ellipsis-content-measure";
  }
  const rect = ele.getBoundingClientRect();
  const childRect = childDiv.getBoundingClientRect();
  ele.removeChild(childDiv);
  return (
    // Horizontal out of range
    rect.left > childRect.left || childRect.right > rect.right || // Vertical out of range
    rect.top > childRect.top || childRect.bottom > rect.bottom
  );
}
var isValidText = (val) => ["string", "number"].includes(typeof val);

// node_modules/antd/es/typography/Base/CopyBtn.js
var CopyBtn = ({
  prefixCls,
  copied,
  locale: locale2,
  iconOnly,
  tooltips,
  icon,
  tabIndex,
  onCopy,
  loading: btnLoading
}) => {
  const tooltipNodes = toList2(tooltips);
  const iconNodes = toList2(icon);
  const {
    copied: copiedText,
    copy: copyText
  } = locale2 ?? {};
  const systemStr = copied ? copiedText : copyText;
  const copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr);
  const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
  return React444.createElement(tooltip_default, {
    title: copyTitle
  }, React444.createElement("button", {
    type: "button",
    className: clsx(`${prefixCls}-copy`, {
      [`${prefixCls}-copy-success`]: copied,
      [`${prefixCls}-copy-icon-only`]: iconOnly
    }),
    onClick: onCopy,
    "aria-label": ariaLabel,
    tabIndex
  }, copied ? getNode(iconNodes[1], React444.createElement(CheckOutlined_default, null), true) : getNode(iconNodes[0], btnLoading ? React444.createElement(LoadingOutlined_default, null) : React444.createElement(CopyOutlined_default, null), true)));
};
var CopyBtn_default = CopyBtn;

// node_modules/antd/es/typography/Base/Ellipsis.js
var React445 = __toESM(require_react());
var MeasureText = React445.forwardRef(({
  style,
  children
}, ref) => {
  const spanRef = React445.useRef(null);
  React445.useImperativeHandle(ref, () => ({
    isExceed: () => {
      const span = spanRef.current;
      return span.scrollHeight > span.clientHeight;
    },
    getHeight: () => spanRef.current.clientHeight
  }));
  return React445.createElement("span", {
    "aria-hidden": true,
    ref: spanRef,
    style: {
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)",
      ...style
    }
  }, children);
});
var getNodesLen = (nodeList) => nodeList.reduce((totalLen, node) => totalLen + (isValidText(node) ? String(node).length : 1), 0);
function sliceNodes(nodeList, len) {
  let currLen = 0;
  const currentNodeList = [];
  for (let i = 0; i < nodeList.length; i += 1) {
    if (currLen === len) {
      return currentNodeList;
    }
    const node = nodeList[i];
    const canCut = isValidText(node);
    const nodeLen = canCut ? String(node).length : 1;
    const nextLen = currLen + nodeLen;
    if (nextLen > len) {
      const restLen = len - currLen;
      currentNodeList.push(String(node).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node);
    currLen = nextLen;
  }
  return nodeList;
}
var STATUS_MEASURE_NONE = 0;
var STATUS_MEASURE_PREPARE = 1;
var STATUS_MEASURE_START = 2;
var STATUS_MEASURE_NEED_ELLIPSIS = 3;
var STATUS_MEASURE_NO_NEED_ELLIPSIS = 4;
var lineClipStyle = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
  const {
    enableMeasure,
    width,
    text,
    children,
    rows,
    expanded,
    miscDeps,
    onEllipsis
  } = props;
  const nodeList = React445.useMemo(() => toArray(text), [text]);
  const nodeLen = React445.useMemo(() => getNodesLen(nodeList), [text]);
  const fullContent = React445.useMemo(() => children(nodeList, false), [text]);
  const [ellipsisCutIndex, setEllipsisCutIndex] = React445.useState(null);
  const cutMidRef = React445.useRef(null);
  const measureWhiteSpaceRef = React445.useRef(null);
  const needEllipsisRef = React445.useRef(null);
  const descRowsEllipsisRef = React445.useRef(null);
  const symbolRowEllipsisRef = React445.useRef(null);
  const [canEllipsis, setCanEllipsis] = React445.useState(false);
  const [needEllipsis, setNeedEllipsis] = React445.useState(STATUS_MEASURE_NONE);
  const [ellipsisHeight, setEllipsisHeight] = React445.useState(0);
  const [parentWhiteSpace, setParentWhiteSpace] = React445.useState(null);
  useLayoutEffect_default(() => {
    if (enableMeasure && width && nodeLen) {
      setNeedEllipsis(STATUS_MEASURE_PREPARE);
    } else {
      setNeedEllipsis(STATUS_MEASURE_NONE);
    }
  }, [width, text, rows, enableMeasure, nodeList]);
  useLayoutEffect_default(() => {
    if (needEllipsis === STATUS_MEASURE_PREPARE) {
      setNeedEllipsis(STATUS_MEASURE_START);
      const nextWhiteSpace = measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace;
      setParentWhiteSpace(nextWhiteSpace);
    } else if (needEllipsis === STATUS_MEASURE_START) {
      const isOverflow = !!needEllipsisRef.current?.isExceed();
      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
      setCanEllipsis(isOverflow);
      const baseRowsEllipsisHeight = needEllipsisRef.current?.getHeight() || 0;
      const descRowsEllipsisHeight = rows === 1 ? 0 : descRowsEllipsisRef.current?.getHeight() || 0;
      const symbolRowEllipsisHeight = symbolRowEllipsisRef.current?.getHeight() || 0;
      const maxRowsHeight = Math.max(
        baseRowsEllipsisHeight,
        // height of rows with ellipsis
        descRowsEllipsisHeight + symbolRowEllipsisHeight
      );
      setEllipsisHeight(maxRowsHeight + 1);
      onEllipsis(isOverflow);
    }
  }, [needEllipsis]);
  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
  useLayoutEffect_default(() => {
    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
    if (minIndex !== maxIndex) {
      const midHeight = cutMidRef.current?.getHeight() || 0;
      const isOverflow = midHeight > ellipsisHeight;
      let targetMidIndex = cutMidIndex;
      if (maxIndex - minIndex === 1) {
        targetMidIndex = isOverflow ? minIndex : maxIndex;
      }
      setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
    }
  }, [ellipsisCutIndex, cutMidIndex]);
  const finalContent = React445.useMemo(() => {
    if (!enableMeasure) {
      return children(nodeList, false);
    }
    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
      const content = children(nodeList, false);
      if ([STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis)) {
        return content;
      }
      return React445.createElement("span", {
        style: {
          ...lineClipStyle,
          WebkitLineClamp: rows
        }
      }, content);
    }
    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));
  const measureStyle = {
    width,
    margin: 0,
    padding: 0,
    whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
  };
  return React445.createElement(React445.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && React445.createElement(React445.Fragment, null, React445.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: rows
    },
    ref: needEllipsisRef
  }, fullContent), React445.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: rows - 1
    },
    ref: descRowsEllipsisRef
  }, fullContent), React445.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: 1
    },
    ref: symbolRowEllipsisRef
  }, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && React445.createElement(MeasureText, {
    style: {
      ...measureStyle,
      top: 400
    },
    ref: cutMidRef
  }, children(sliceNodes(nodeList, cutMidIndex), true)), needEllipsis === STATUS_MEASURE_PREPARE && React445.createElement("span", {
    style: {
      whiteSpace: "inherit"
    },
    ref: measureWhiteSpaceRef
  }));
}

// node_modules/antd/es/typography/Base/EllipsisTooltip.js
var React446 = __toESM(require_react());
var EllipsisTooltip = ({
  enableEllipsis,
  isEllipsis,
  children,
  tooltipProps
}) => {
  if (!tooltipProps?.title || !enableEllipsis) {
    return children;
  }
  return React446.createElement(tooltip_default, {
    open: isEllipsis ? void 0 : false,
    ...tooltipProps
  }, children);
};
if (true) {
  EllipsisTooltip.displayName = "EllipsisTooltip";
}
var EllipsisTooltip_default = EllipsisTooltip;

// node_modules/antd/es/typography/Base/index.js
function wrapperDecorations({
  mark,
  code,
  underline,
  delete: del,
  strong,
  keyboard,
  italic
}, content) {
  let currentContent = content;
  function wrap(tag, needed) {
    if (!needed) {
      return;
    }
    currentContent = React447.createElement(tag, {}, currentContent);
  }
  wrap("strong", strong);
  wrap("u", underline);
  wrap("del", del);
  wrap("code", code);
  wrap("mark", mark);
  wrap("kbd", keyboard);
  wrap("i", italic);
  return currentContent;
}
var ELLIPSIS_STR = "...";
var DECORATION_PROPS = ["delete", "mark", "code", "underline", "strong", "keyboard", "italic"];
var Base = React447.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style,
    type,
    disabled,
    children,
    ellipsis,
    editable,
    copyable,
    component,
    title,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = React447.useContext(ConfigContext);
  const [textLocale] = useLocale_default("Text");
  const typographyRef = React447.useRef(null);
  const editIconRef = React447.useRef(null);
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const textProps = omit(restProps, DECORATION_PROPS);
  const [enableEdit, editConfig] = useMergedConfig(editable);
  const [editing, setEditing] = useControlledState(false, editConfig.editing);
  const {
    triggerType = ["icon"]
  } = editConfig;
  const triggerEdit = (edit) => {
    if (edit) {
      editConfig.onStart?.();
    }
    setEditing(edit);
  };
  const prevEditing = usePrevious_default(editing);
  useLayoutEffect_default(() => {
    if (!editing && prevEditing) {
      editIconRef.current?.focus();
    }
  }, [editing]);
  const onEditClick = (e3) => {
    e3?.preventDefault();
    triggerEdit(true);
  };
  const onEditChange = (value) => {
    editConfig.onChange?.(value);
    triggerEdit(false);
  };
  const onEditCancel = () => {
    editConfig.onCancel?.();
    triggerEdit(false);
  };
  const [enableCopy, copyConfig] = useMergedConfig(copyable);
  const {
    copied,
    copyLoading,
    onClick: onCopyClick
  } = useCopyClick_default({
    copyConfig,
    children
  });
  const [isLineClampSupport, setIsLineClampSupport] = React447.useState(false);
  const [isTextOverflowSupport, setIsTextOverflowSupport] = React447.useState(false);
  const [isJsEllipsis, setIsJsEllipsis] = React447.useState(false);
  const [isNativeEllipsis, setIsNativeEllipsis] = React447.useState(false);
  const [isNativeVisible, setIsNativeVisible] = React447.useState(true);
  const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
    expandable: false,
    symbol: (isExpanded) => isExpanded ? textLocale?.collapse : textLocale?.expand
  });
  const [expanded, setExpanded] = useControlledState(ellipsisConfig.defaultExpanded || false, ellipsisConfig.expanded);
  const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
  const {
    rows = 1
  } = ellipsisConfig;
  const needMeasureEllipsis = React447.useMemo(() => (
    // Disable ellipsis
    mergedEnableEllipsis && // Provide suffix
    (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    ellipsisConfig.expandable || enableEdit || enableCopy)
  ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect_default(() => {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
      setIsTextOverflowSupport(isStyleSupport("textOverflow"));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  const [cssEllipsis, setCssEllipsis] = React447.useState(mergedEnableEllipsis);
  const canUseCssEllipsis = React447.useMemo(() => {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  useLayoutEffect_default(() => {
    setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
  }, [canUseCssEllipsis, mergedEnableEllipsis]);
  const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  const onExpandClick = (e3, info) => {
    setExpanded(info.expanded);
    ellipsisConfig.onExpand?.(e3, info);
  };
  const [ellipsisWidth, setEllipsisWidth] = React447.useState(0);
  const onResize = ({
    offsetWidth
  }) => {
    setEllipsisWidth(offsetWidth);
  };
  const onJsEllipsis = (jsEllipsis) => {
    setIsJsEllipsis(jsEllipsis);
    if (isJsEllipsis !== jsEllipsis) {
      ellipsisConfig.onEllipsis?.(jsEllipsis);
    }
  };
  React447.useEffect(() => {
    const textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      const currentEllipsis = isEleEllipsis(textEle);
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible, ellipsisWidth]);
  React447.useEffect(() => {
    const textEle = typographyRef.current;
    if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
      return;
    }
    const observer = new IntersectionObserver(() => {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    observer.observe(textEle);
    return () => {
      observer.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  const tooltipProps = useTooltipProps_default(ellipsisConfig.tooltip, editConfig.text, children);
  const topAriaLabel = React447.useMemo(() => {
    if (!enableEllipsis || cssEllipsis) {
      return void 0;
    }
    return [editConfig.text, children, title, tooltipProps.title].find(isValidText);
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  if (editing) {
    return React447.createElement(Editable_default, {
      value: editConfig.text ?? (typeof children === "string" ? children : ""),
      onSave: onEditChange,
      onCancel: onEditCancel,
      onEnd: editConfig.onEnd,
      prefixCls,
      className,
      style,
      direction,
      component,
      maxLength: editConfig.maxLength,
      autoSize: editConfig.autoSize,
      enterIcon: editConfig.enterIcon
    });
  }
  const renderExpand = () => {
    const {
      expandable,
      symbol
    } = ellipsisConfig;
    return expandable ? React447.createElement("button", {
      type: "button",
      key: "expand",
      className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
      onClick: (e3) => onExpandClick(e3, {
        expanded: !expanded
      }),
      "aria-label": expanded ? textLocale.collapse : textLocale?.expand
    }, typeof symbol === "function" ? symbol(expanded) : symbol) : null;
  };
  const renderEdit = () => {
    if (!enableEdit) {
      return;
    }
    const {
      icon,
      tooltip,
      tabIndex
    } = editConfig;
    const editTitle = toArray(tooltip)[0] || textLocale?.edit;
    const ariaLabel = typeof editTitle === "string" ? editTitle : "";
    return triggerType.includes("icon") ? React447.createElement(tooltip_default, {
      key: "edit",
      title: tooltip === false ? "" : editTitle
    }, React447.createElement("button", {
      type: "button",
      ref: editIconRef,
      className: `${prefixCls}-edit`,
      onClick: onEditClick,
      "aria-label": ariaLabel,
      tabIndex
    }, icon || React447.createElement(EditOutlined_default, {
      role: "button"
    }))) : null;
  };
  const renderCopy = () => {
    if (!enableCopy) {
      return null;
    }
    return React447.createElement(CopyBtn_default, {
      key: "copy",
      ...copyConfig,
      prefixCls,
      copied,
      locale: textLocale,
      onCopy: onCopyClick,
      loading: copyLoading,
      iconOnly: !isNonNullable_default(children)
    });
  };
  const renderOperations = (canEllipsis) => [canEllipsis && renderExpand(), renderEdit(), renderCopy()];
  const renderEllipsis = (canEllipsis) => [canEllipsis && !expanded && React447.createElement("span", {
    "aria-hidden": true,
    key: "ellipsis"
  }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(canEllipsis)];
  return React447.createElement(es_default3, {
    onResize,
    disabled: !mergedEnableEllipsis
  }, (resizeRef) => React447.createElement(EllipsisTooltip_default, {
    tooltipProps,
    enableEllipsis: mergedEnableEllipsis,
    isEllipsis: isMergedEllipsis
  }, React447.createElement(Typography_default, {
    className: clsx({
      [`${prefixCls}-${type}`]: type,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-ellipsis`]: enableEllipsis,
      [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
      [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
    }, className),
    prefixCls: customizePrefixCls,
    style: {
      ...style,
      WebkitLineClamp: cssLineClamp ? rows : void 0
    },
    component,
    ref: composeRef(resizeRef, typographyRef, ref),
    direction,
    onClick: triggerType.includes("text") ? onEditClick : void 0,
    "aria-label": topAriaLabel?.toString(),
    title,
    ...textProps
  }, React447.createElement(EllipsisMeasure, {
    enableMeasure: mergedEnableEllipsis && !cssEllipsis,
    text: children,
    rows,
    width: ellipsisWidth,
    onEllipsis: onJsEllipsis,
    expanded,
    miscDeps: [copied, expanded, copyLoading, enableEdit, enableCopy, textLocale].concat(_toConsumableArray(DECORATION_PROPS.map((key) => props[key])))
  }, (node, canEllipsis) => wrapperDecorations(props, React447.createElement(React447.Fragment, null, node.length > 0 && canEllipsis && !expanded && topAriaLabel ? React447.createElement("span", {
    key: "show-content",
    "aria-hidden": true
  }, node) : node, renderEllipsis(canEllipsis)))))));
});
var Base_default = Base;

// node_modules/antd/es/typography/Link.js
var Link = React448.forwardRef((props, ref) => {
  const {
    ellipsis,
    rel,
    children,
    // @ts-expect-error: https://github.com/ant-design/ant-design/issues/26622
    navigate: _navigate,
    ...restProps
  } = props;
  if (true) {
    const warning2 = devUseWarning("Typography.Link");
    true ? warning2(typeof ellipsis !== "object", "usage", "`ellipsis` only supports boolean value.") : void 0;
  }
  const mergedProps = {
    ...restProps,
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  };
  return React448.createElement(Base_default, {
    ...mergedProps,
    ref,
    ellipsis: !!ellipsis,
    component: "a"
  }, children);
});
var Link_default = Link;

// node_modules/antd/es/typography/Paragraph.js
var React449 = __toESM(require_react());
var Paragraph2 = React449.forwardRef((props, ref) => {
  const {
    children,
    ...restProps
  } = props;
  return React449.createElement(Base_default, {
    ref,
    ...restProps,
    component: "div"
  }, children);
});
var Paragraph_default2 = Paragraph2;

// node_modules/antd/es/typography/Text.js
var React450 = __toESM(require_react());
var Text = (props, ref) => {
  const {
    ellipsis,
    children,
    ...restProps
  } = props;
  const mergedEllipsis = React450.useMemo(() => {
    if (ellipsis && typeof ellipsis === "object") {
      return omit(ellipsis, ["expandable", "rows"]);
    }
    return ellipsis;
  }, [ellipsis]);
  if (true) {
    const warning2 = devUseWarning("Typography.Text");
    true ? warning2(typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "usage", "`ellipsis` do not support `expandable` or `rows` props.") : void 0;
  }
  return React450.createElement(Base_default, {
    ref,
    ...restProps,
    ellipsis: mergedEllipsis,
    component: "span"
  }, children);
};
var Text_default = React450.forwardRef(Text);

// node_modules/antd/es/typography/Title.js
var React451 = __toESM(require_react());
var TITLE_ELE_LIST = [1, 2, 3, 4, 5];
var Title2 = React451.forwardRef((props, ref) => {
  const {
    level = 1,
    children,
    ...restProps
  } = props;
  if (true) {
    const warning2 = devUseWarning("Typography.Title");
    true ? warning2(TITLE_ELE_LIST.includes(level), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.") : void 0;
  }
  const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : `h1`;
  return React451.createElement(Base_default, {
    ref,
    ...restProps,
    component
  }, children);
});
var Title_default2 = Title2;

// node_modules/antd/es/typography/index.js
var Typography2 = Typography_default;
Typography2.Text = Text_default;
Typography2.Link = Link_default;
Typography2.Title = Title_default2;
Typography2.Paragraph = Paragraph_default2;
var typography_default = Typography2;

// node_modules/antd/es/upload/Dragger.js
var React457 = __toESM(require_react());

// node_modules/antd/es/upload/Upload.js
var React456 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());

// node_modules/@rc-component/upload/es/Upload.js
var import_react138 = __toESM(require_react());

// node_modules/@rc-component/upload/es/AjaxUploader.js
var import_react137 = __toESM(require_react());

// node_modules/@rc-component/upload/es/attr-accept.js
var attr_accept_default = ((file, acceptedFiles) => {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name || "";
    const mimeType = file.type || "";
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type) => {
      const validType = type.trim();
      if (/^\*(\/\*)?$/.test(type)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        const lowerFileName = fileName.toLowerCase();
        const lowerType = validType.toLowerCase();
        let affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some((affix) => lowerFileName.endsWith(affix));
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        warning_default(false, `Upload takes an invalidate 'accept' type '${validType}'.Skip for check.`);
        return true;
      }
      return false;
    });
  }
  return true;
});

// node_modules/@rc-component/upload/es/request.js
function getError(option, xhr) {
  const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e3) {
    return text;
  }
}
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e3) {
      if (e3.total > 0) {
        e3.percent = e3.loaded / e3.total * 100;
      }
      option.onProgress(e3);
    };
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach((key) => {
      const value = option.data[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key}[]`, item);
        });
        return;
      }
      formData.append(key, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = function error(e3) {
    option.onError(e3);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h) => {
    if (headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}

// node_modules/@rc-component/upload/es/traverseFileTree.js
var traverseFileTree = async (files, isAccepted) => {
  const flattenFileList = [];
  const progressFileList = [];
  files.forEach((file) => progressFileList.push(file.webkitGetAsEntry()));
  async function readDirectory(directory) {
    const dirReader = directory.createReader();
    const entries = [];
    while (true) {
      const results = await new Promise((resolve) => {
        dirReader.readEntries(resolve, () => resolve([]));
      });
      const n2 = results.length;
      if (!n2) {
        break;
      }
      for (let i = 0; i < n2; i++) {
        entries.push(results[i]);
      }
    }
    return entries;
  }
  async function readFile(item) {
    return new Promise((reslove) => {
      item.file((file) => {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          reslove(file);
        } else {
          reslove(null);
        }
      });
    });
  }
  const _traverseFileTree = async (item, path2) => {
    if (!item) {
      return;
    }
    item.path = path2 || "";
    if (item.isFile) {
      const file = await readFile(item);
      if (file) {
        flattenFileList.push(file);
      }
    } else if (item.isDirectory) {
      const entries = await readDirectory(item);
      progressFileList.push(...entries);
    }
  };
  let wipIndex = 0;
  while (wipIndex < progressFileList.length) {
    await _traverseFileTree(progressFileList[wipIndex]);
    wipIndex++;
  }
  return flattenFileList;
};
var traverseFileTree_default = traverseFileTree;

// node_modules/@rc-component/upload/es/uid.js
var now = +/* @__PURE__ */ new Date();
var index = 0;
function uid2() {
  return `rc-upload-${now}-${++index}`;
}

// node_modules/@rc-component/upload/es/AjaxUploader.js
function _extends78() {
  _extends78 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends78.apply(this, arguments);
}
var AjaxUploader = class extends import_react137.Component {
  state = {
    uid: uid2()
  };
  reqs = {};
  fileInput;
  _isMounted;
  filterFile = (file, force = false) => {
    const {
      accept,
      directory
    } = this.props;
    let filterFn;
    let acceptFormat;
    if (typeof accept === "string") {
      acceptFormat = accept;
    } else {
      const {
        filter: filter2,
        format: format2
      } = accept || {};
      acceptFormat = format2;
      if (filter2 === "native") {
        filterFn = () => true;
      } else {
        filterFn = filter2;
      }
    }
    const mergedFilter = filterFn || (directory || force ? (currentFile) => attr_accept_default(currentFile, acceptFormat) : () => true);
    return mergedFilter(file);
  };
  onChange = (e3) => {
    const {
      files
    } = e3.target;
    const acceptedFiles = [...files].filter((file) => this.filterFile(file));
    this.uploadFiles(acceptedFiles);
    this.reset();
  };
  onClick = (event) => {
    const el = this.fileInput;
    if (!el) {
      return;
    }
    const target = event.target;
    const {
      onClick
    } = this.props;
    if (target && target.tagName === "BUTTON") {
      const parent = el.parentNode;
      parent.focus();
      target.blur();
    }
    el.click();
    if (onClick) {
      onClick(event);
    }
  };
  onKeyDown = (e3) => {
    if (e3.key === "Enter") {
      this.onClick(e3);
    }
  };
  onDataTransferFiles = async (dataTransfer, existFileCallback) => {
    const {
      multiple,
      directory
    } = this.props;
    const items = [...dataTransfer.items || []];
    let files = [...dataTransfer.files || []];
    if (files.length > 0 || items.some((item) => item.kind === "file")) {
      existFileCallback?.();
    }
    if (directory) {
      files = await traverseFileTree_default(Array.prototype.slice.call(items), this.filterFile);
      this.uploadFiles(files);
    } else {
      let acceptFiles = [...files].filter((file) => this.filterFile(file, true));
      if (multiple === false) {
        acceptFiles = files.slice(0, 1);
      }
      this.uploadFiles(acceptFiles);
    }
  };
  onFilePaste = async (e3) => {
    const {
      pastable
    } = this.props;
    if (!pastable) {
      return;
    }
    if (e3.type === "paste") {
      const clipboardData = e3.clipboardData;
      return this.onDataTransferFiles(clipboardData, () => {
        e3.preventDefault();
      });
    }
  };
  onFileDragOver = (e3) => {
    e3.preventDefault();
  };
  onFileDrop = async (e3) => {
    e3.preventDefault();
    if (e3.type === "drop") {
      const dataTransfer = e3.dataTransfer;
      return this.onDataTransferFiles(dataTransfer);
    }
  };
  componentDidMount() {
    this._isMounted = true;
    const {
      pastable
    } = this.props;
    if (pastable) {
      document.addEventListener("paste", this.onFilePaste);
    }
  }
  componentWillUnmount() {
    this._isMounted = false;
    this.abort();
    document.removeEventListener("paste", this.onFilePaste);
  }
  componentDidUpdate(prevProps) {
    const {
      pastable
    } = this.props;
    if (pastable && !prevProps.pastable) {
      document.addEventListener("paste", this.onFilePaste);
    } else if (!pastable && prevProps.pastable) {
      document.removeEventListener("paste", this.onFilePaste);
    }
  }
  uploadFiles = (files) => {
    const originFiles = [...files];
    const postFiles = originFiles.map((file) => {
      file.uid = uid2();
      return this.processFile(file, originFiles);
    });
    Promise.all(postFiles).then((fileList) => {
      const {
        onBatchStart
      } = this.props;
      onBatchStart?.(fileList.map(({
        origin,
        parsedFile
      }) => ({
        file: origin,
        parsedFile
      })));
      fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
        this.post(file);
      });
    });
  };
  /**
   * Process file before upload. When all the file is ready, we start upload.
   */
  processFile = async (file, fileList) => {
    const {
      beforeUpload
    } = this.props;
    let transformedFile = file;
    if (beforeUpload) {
      try {
        transformedFile = await beforeUpload(file, fileList);
      } catch (e3) {
        transformedFile = false;
      }
      if (transformedFile === false) {
        return {
          origin: file,
          parsedFile: null,
          action: null,
          data: null
        };
      }
    }
    const {
      action
    } = this.props;
    let mergedAction;
    if (typeof action === "function") {
      mergedAction = await action(file);
    } else {
      mergedAction = action;
    }
    const {
      data
    } = this.props;
    let mergedData;
    if (typeof data === "function") {
      mergedData = await data(file);
    } else {
      mergedData = data;
    }
    const parsedData = (
      // string type is from legacy `transformFile`.
      // Not sure if this will work since no related test case works with it
      (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file
    );
    let parsedFile;
    if (parsedData instanceof File) {
      parsedFile = parsedData;
    } else {
      parsedFile = new File([parsedData], file.name, {
        type: file.type
      });
    }
    const mergedParsedFile = parsedFile;
    mergedParsedFile.uid = file.uid;
    return {
      origin: file,
      data: mergedData,
      parsedFile: mergedParsedFile,
      action: mergedAction
    };
  };
  post({
    data,
    origin,
    action,
    parsedFile
  }) {
    if (!this._isMounted) {
      return;
    }
    const {
      onStart,
      customRequest,
      name,
      headers,
      withCredentials,
      method
    } = this.props;
    const {
      uid: uid3
    } = origin;
    const request = customRequest || upload;
    const requestOption = {
      action,
      filename: name,
      data,
      file: parsedFile,
      headers,
      withCredentials,
      method: method || "post",
      onProgress: (e3) => {
        const {
          onProgress
        } = this.props;
        onProgress?.(e3, parsedFile);
      },
      onSuccess: (ret, xhr) => {
        const {
          onSuccess
        } = this.props;
        onSuccess?.(ret, parsedFile, xhr);
        delete this.reqs[uid3];
      },
      onError: (err, ret) => {
        const {
          onError
        } = this.props;
        onError?.(err, ret, parsedFile);
        delete this.reqs[uid3];
      }
    };
    onStart(origin);
    this.reqs[uid3] = request(requestOption, {
      defaultRequest: upload
    });
  }
  reset() {
    this.setState({
      uid: uid2()
    });
  }
  abort(file) {
    const {
      reqs
    } = this;
    if (file) {
      const uid3 = file.uid ? file.uid : file;
      if (reqs[uid3] && reqs[uid3].abort) {
        reqs[uid3].abort();
      }
      delete reqs[uid3];
    } else {
      Object.keys(reqs).forEach((uid3) => {
        if (reqs[uid3] && reqs[uid3].abort) {
          reqs[uid3].abort();
        }
        delete reqs[uid3];
      });
    }
  }
  saveFileInput = (node) => {
    this.fileInput = node;
  };
  render() {
    const {
      component: Tag2,
      prefixCls,
      className,
      classNames = {},
      disabled,
      id,
      name,
      style,
      styles = {},
      multiple,
      accept,
      capture,
      children,
      directory,
      openFileDialogOnClick,
      onMouseEnter,
      onMouseLeave,
      hasControlInside,
      ...otherProps
    } = this.props;
    const acceptFormat = typeof accept === "string" ? accept : accept?.format;
    const cls = clsx(prefixCls, {
      [`${prefixCls}-disabled`]: disabled,
      [className]: className
    });
    const dirProps = directory ? {
      directory: "directory",
      webkitdirectory: "webkitdirectory"
    } : {};
    const events = disabled ? {} : {
      onClick: openFileDialogOnClick ? this.onClick : () => {
      },
      onKeyDown: openFileDialogOnClick ? this.onKeyDown : () => {
      },
      onMouseEnter,
      onMouseLeave,
      onDrop: this.onFileDrop,
      onDragOver: this.onFileDragOver,
      tabIndex: hasControlInside ? void 0 : "0"
    };
    return import_react137.default.createElement(Tag2, _extends78({}, events, {
      className: cls,
      role: hasControlInside ? void 0 : "button",
      style
    }), import_react137.default.createElement("input", _extends78({}, pickAttrs(otherProps, {
      aria: true,
      data: true
    }), {
      id,
      name,
      disabled,
      type: "file",
      ref: this.saveFileInput,
      onClick: (e3) => e3.stopPropagation(),
      key: this.state.uid,
      style: {
        display: "none",
        ...styles.input
      },
      className: classNames.input,
      accept: acceptFormat
    }, dirProps, {
      multiple,
      onChange: this.onChange
    }, capture != null ? {
      capture
    } : {})), children);
  }
};
var AjaxUploader_default = AjaxUploader;

// node_modules/@rc-component/upload/es/Upload.js
function _extends79() {
  _extends79 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends79.apply(this, arguments);
}
function empty() {
}
var Upload = class extends import_react138.Component {
  static defaultProps = {
    component: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true,
    hasControlInside: false
  };
  uploader;
  abort(file) {
    this.uploader.abort(file);
  }
  saveUploader = (node) => {
    this.uploader = node;
  };
  render() {
    return import_react138.default.createElement(AjaxUploader_default, _extends79({}, this.props, {
      ref: this.saveUploader
    }));
  }
};
var Upload_default = Upload;

// node_modules/@rc-component/upload/es/index.js
var es_default26 = Upload_default;

// node_modules/antd/es/upload/style/dragger.js
var genDraggerStyle = (token) => {
  const {
    componentCls,
    iconCls
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token.colorFillAlter,
        border: `${unit(token.lineWidth)} dashed ${token.colorBorder}`,
        borderRadius: token.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token.motionDurationSlow}`,
        [componentCls]: {
          padding: token.padding
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none",
          borderRadius: token.borderRadiusLG,
          "&:focus-visible": {
            outline: `${unit(token.lineWidthFocus)} solid ${token.colorPrimaryBorder}`
          }
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
          borderColor: token.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token.margin,
          [iconCls]: {
            color: token.colorPrimary,
            fontSize: token.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${unit(token.marginXXS)}`,
          color: token.colorTextHeading,
          fontSize: token.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token.colorTextDescription,
          fontSize: token.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token.colorTextDisabled
          }
        }
      }
    }
  };
};
var dragger_default = genDraggerStyle;

// node_modules/antd/es/upload/style/list.js
var genListStyle = (token) => {
  const {
    componentCls,
    iconCls,
    fontSize,
    lineHeight,
    calc
  } = token;
  const itemCls = `${componentCls}-list-item`;
  const actionsCls = `${itemCls}-actions`;
  const actionCls = `${itemCls}-action`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: {
        ...clearFix(),
        lineHeight: token.lineHeight,
        [itemCls]: {
          position: "relative",
          height: calc(token.lineHeight).mul(fontSize).equal(),
          marginTop: token.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token.motionDurationSlow}`,
          borderRadius: token.borderRadiusSM,
          "&:hover": {
            backgroundColor: token.controlItemBgHover
          },
          [`${itemCls}-name`]: {
            ...textEllipsis,
            padding: `0 ${unit(token.paddingXS)}`,
            lineHeight,
            flex: "auto",
            transition: `all ${token.motionDurationSlow}`
          },
          [actionsCls]: {
            whiteSpace: "nowrap",
            [actionCls]: {
              opacity: 0
            },
            [iconCls]: {
              color: token.actionsColor,
              transition: `all ${token.motionDurationSlow}`
            },
            [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token.colorIcon,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: token.calc(token.uploadProgressOffset).mul(-1).equal(),
            width: "100%",
            paddingInlineStart: calc(fontSize).add(token.paddingXS).equal(),
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1
        },
        [`${itemCls}-error`]: {
          color: token.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token.motionDurationSlow}, height ${token.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      }
    }
  };
};
var list_default2 = genListStyle;

// node_modules/antd/es/upload/style/motion.js
var genMotionStyle3 = (token) => {
  const {
    componentCls
  } = token;
  const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", {
    from: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token.calc(token.marginXS).div(-2).equal()
    }
  });
  const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", {
    to: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token.calc(token.marginXS).div(-2).equal()
    }
  });
  const inlineCls = `${componentCls}-animate-inline`;
  return [{
    [`${componentCls}-wrapper`]: {
      [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
        animationDuration: token.motionDurationSlow,
        animationTimingFunction: token.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${inlineCls}-appear, ${inlineCls}-enter`]: {
        animationName: uploadAnimateInlineIn
      },
      [`${inlineCls}-leave`]: {
        animationName: uploadAnimateInlineOut
      }
    }
  }, {
    [`${componentCls}-wrapper`]: initFadeMotion(token)
  }, uploadAnimateInlineIn, uploadAnimateInlineOut];
};
var motion_default4 = genMotionStyle3;

// node_modules/antd/es/upload/style/picture.js
var genPictureStyle = (token) => {
  const {
    componentCls,
    iconCls,
    uploadThumbnailSize,
    uploadProgressOffset,
    calc
  } = token;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 
      [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
        [itemCls]: {
          position: "relative",
          height: calc(uploadThumbnailSize).add(calc(token.lineWidth).mul(2)).add(calc(token.paddingXS).mul(2)).equal(),
          padding: token.paddingXS,
          border: `${unit(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderRadius: token.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: {
            ...textEllipsis,
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: unit(calc(uploadThumbnailSize).add(token.paddingSM).equal()),
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token.fontSizeHeading2,
              color: token.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          },
          [`${itemCls}-progress`]: {
            bottom: calc(token.fontSize).mul(token.lineHeight).div(2).add(uploadProgressOffset).equal(),
            width: `calc(100% - ${unit(calc(token.paddingSM).mul(2).equal())})`,
            marginTop: 0,
            paddingInlineStart: calc(uploadThumbnailSize).add(token.paddingXS).equal()
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='${blue[0]}']`]: {
              fill: token.colorErrorBg
            },
            [`svg path[fill='${blue.primary}']`]: {
              fill: token.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      },
      [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
        [`&, &::before, ${itemCls}-thumbnail`]: {
          borderRadius: "50%"
        }
      }
    }
  };
};
var genPictureCardStyle = (token) => {
  const {
    componentCls,
    iconCls,
    fontSizeLG,
    colorTextLightSolid,
    calc
  } = token;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  const uploadPictureCardSize = token.uploadPicCardSize;
  return {
    [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: {
      ...clearFix(),
      display: "block",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token.colorFillAlter,
        border: `${unit(token.lineWidth)} dashed ${token.colorBorder}`,
        borderRadius: token.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
        display: "flex",
        flexWrap: "wrap",
        "@supports not (gap: 1px)": {
          "& > *": {
            marginBlockEnd: token.marginXS,
            marginInlineEnd: token.marginXS
          }
        },
        "@supports (gap: 1px)": {
          gap: token.marginXS
        },
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        "&::before": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${unit(calc(token.paddingXS).mul(2).equal())})`,
            height: `calc(100% - ${unit(calc(token.paddingXS).mul(2).equal())})`,
            backgroundColor: token.colorBgMask,
            opacity: 0,
            transition: `all ${token.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token.motionDurationSlow}`,
          [`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${unit(token.marginXXS)}`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token.motionDurationSlow}`,
            color: colorTextLightSolid,
            "&:hover": {
              color: colorTextLightSolid
            },
            svg: {
              verticalAlign: "baseline"
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token.margin,
          display: "block",
          width: `calc(100% - ${unit(calc(token.paddingXS).mul(2).equal())})`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token.marginXL,
          width: `calc(100% - ${unit(calc(token.paddingXS).mul(2).equal())})`,
          paddingInlineStart: 0
        }
      }
    },
    [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
      [`${componentCls}${componentCls}-select`]: {
        borderRadius: "50%"
      }
    }
  };
};

// node_modules/antd/es/upload/style/rtl.js
var genRtlStyle2 = (token) => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var rtl_default4 = genRtlStyle2;

// node_modules/antd/es/upload/style/index.js
var genBaseStyle15 = (token) => {
  const {
    componentCls,
    colorTextDisabled
  } = token;
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token),
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-hidden`]: {
        display: "none"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  };
};
var prepareComponentToken50 = (token) => ({
  actionsColor: token.colorIcon,
  pictureCardSize: token.controlHeightLG * 2.55
});
var style_default56 = genStyleHooks("Upload", (token) => {
  const {
    fontSizeHeading3,
    marginXS,
    lineWidth,
    pictureCardSize,
    calc
  } = token;
  const uploadToken = merge(token, {
    uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
    uploadProgressOffset: calc(calc(marginXS).div(2)).add(lineWidth).equal(),
    uploadPicCardSize: pictureCardSize
  });
  return [genBaseStyle15(uploadToken), dragger_default(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), list_default2(uploadToken), motion_default4(uploadToken), rtl_default4(uploadToken), collapse_default(uploadToken)];
}, prepareComponentToken50);

// node_modules/antd/es/upload/UploadList/index.js
var React455 = __toESM(require_react());

// node_modules/antd/es/upload/utils.js
function file2Obj(file) {
  return {
    ...file,
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  };
}
function updateFileList(file, fileList) {
  const nextFileList = _toConsumableArray(fileList);
  const fileIndex = nextFileList.findIndex(({
    uid: uid3
  }) => uid3 === file.uid);
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
var extname = (url = "") => {
  const temp = url.split("/");
  const filename = temp[temp.length - 1];
  const filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = (type) => type.indexOf("image/") === 0;
var isImageUrl = (file) => {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  const url = file.thumbUrl || file.url || "";
  const extension = extname(url);
  if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
      const {
        width,
        height
      } = img;
      let drawWidth = MEASURE_SIZE;
      let drawHeight = MEASURE_SIZE;
      let offsetX = 0;
      let offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      window.URL.revokeObjectURL(img.src);
      resolve(dataURL);
    };
    img.crossOrigin = "anonymous";
    if (file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result && typeof reader.result === "string") {
          img.src = reader.result;
        }
      };
      reader.readAsDataURL(file);
    } else if (file.type.startsWith("image/gif")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result) {
          resolve(reader.result);
        }
      };
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}

// node_modules/antd/es/upload/UploadList/ListItem.js
var React454 = __toESM(require_react());
var ListItem2 = React454.forwardRef(({
  prefixCls,
  className,
  style,
  classNames: itemClassNames,
  styles,
  locale: locale2,
  listType,
  file,
  items,
  progress: progressProps,
  iconRender,
  actionIconRender,
  itemRender,
  isImgUrl,
  showPreviewIcon,
  showRemoveIcon,
  showDownloadIcon,
  previewIcon: customPreviewIcon,
  removeIcon: customRemoveIcon,
  downloadIcon: customDownloadIcon,
  extra: customExtra,
  onPreview,
  onDownload,
  onClose
}, ref) => {
  const {
    status
  } = file;
  const [mergedStatus, setMergedStatus] = React454.useState(status);
  React454.useEffect(() => {
    if (status !== "removed") {
      setMergedStatus(status);
    }
  }, [status]);
  const [showProgress, setShowProgress] = React454.useState(false);
  React454.useEffect(() => {
    const timer = setTimeout(() => {
      setShowProgress(true);
    }, 300);
    return () => {
      clearTimeout(timer);
    };
  }, []);
  const iconNode = iconRender(file);
  let icon = React454.createElement("div", {
    className: `${prefixCls}-icon`
  }, iconNode);
  if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
    if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
      const uploadingClassName = clsx(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
      });
      icon = React454.createElement("div", {
        className: uploadingClassName
      }, iconNode);
    } else {
      const thumbnail = isImgUrl?.(file) ? React454.createElement("img", {
        src: file.thumbUrl || file.url,
        alt: file.name,
        className: `${prefixCls}-list-item-image`,
        crossOrigin: file.crossOrigin
      }) : iconNode;
      const aClassName = clsx(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
      });
      icon = React454.createElement("a", {
        className: aClassName,
        onClick: (e3) => onPreview(file, e3),
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      }, thumbnail);
    }
  }
  const listItemClassName = clsx(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`, itemClassNames?.item);
  const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
  const removeIcon = (typeof showRemoveIcon === "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender(
    (typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || React454.createElement(DeleteOutlined_default, null),
    () => onClose(file),
    prefixCls,
    locale2.removeFile,
    // acceptUploadDisabled is true, only remove icon will follow Upload disabled prop
    // https://github.com/ant-design/ant-design/issues/46171
    true
  ) : null;
  const downloadIcon = (typeof showDownloadIcon === "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || React454.createElement(DownloadOutlined_default, null), () => onDownload(file), prefixCls, locale2.downloadFile) : null;
  const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && React454.createElement("span", {
    key: "download-delete",
    className: clsx(`${prefixCls}-list-item-actions`, {
      picture: listType === "picture"
    })
  }, downloadIcon, removeIcon);
  const extraContent = typeof customExtra === "function" ? customExtra(file) : customExtra;
  const extra = extraContent && React454.createElement("span", {
    className: `${prefixCls}-list-item-extra`
  }, extraContent);
  const listItemNameClass = clsx(`${prefixCls}-list-item-name`);
  const fileName = file.url ? React454.createElement("a", {
    key: "view",
    target: "_blank",
    rel: "noopener noreferrer",
    className: listItemNameClass,
    title: file.name,
    ...linkProps,
    href: file.url,
    onClick: (e3) => onPreview(file, e3)
  }, file.name, extra) : React454.createElement("span", {
    key: "view",
    className: listItemNameClass,
    onClick: (e3) => onPreview(file, e3),
    title: file.name
  }, file.name, extra);
  const previewIcon = (typeof showPreviewIcon === "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? React454.createElement("a", {
    href: file.url || file.thumbUrl,
    target: "_blank",
    rel: "noopener noreferrer",
    onClick: (e3) => onPreview(file, e3),
    title: locale2.previewFile
  }, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || React454.createElement(EyeOutlined_default, null)) : null;
  const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && React454.createElement("span", {
    className: `${prefixCls}-list-item-actions`
  }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
  const {
    getPrefixCls
  } = React454.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const dom = React454.createElement("div", {
    className: listItemClassName,
    style: styles?.item
  }, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && React454.createElement(es_default4, {
    motionName: `${rootPrefixCls}-fade`,
    visible: mergedStatus === "uploading",
    motionDeadline: 2e3
  }, ({
    className: motionClassName
  }) => {
    const loadingProgress = "percent" in file ? React454.createElement(progress_default2, {
      type: "line",
      percent: file.percent,
      "aria-label": file["aria-label"],
      "aria-labelledby": file["aria-labelledby"],
      ...progressProps
    }) : null;
    return React454.createElement("div", {
      className: clsx(`${prefixCls}-list-item-progress`, motionClassName)
    }, loadingProgress);
  }));
  const message2 = file.response && typeof file.response === "string" ? file.response : file.error?.statusText || file.error?.message || locale2.uploadError;
  const item = mergedStatus === "error" ? React454.createElement(tooltip_default, {
    title: message2,
    getPopupContainer: (node) => node.parentNode
  }, dom) : dom;
  return React454.createElement("div", {
    className: clsx(`${prefixCls}-list-item-container`, className),
    style,
    ref
  }, itemRender ? itemRender(item, file, items, {
    download: onDownload.bind(null, file),
    preview: onPreview.bind(null, file),
    remove: onClose.bind(null, file)
  }) : item);
});
var ListItem_default2 = ListItem2;

// node_modules/antd/es/upload/UploadList/index.js
var InternalUploadList = (props, ref) => {
  const {
    listType = "text",
    previewFile = previewImage,
    onPreview,
    onDownload,
    onRemove,
    locale: locale2,
    iconRender,
    isImageUrl: isImgUrl = isImageUrl,
    prefixCls: customizePrefixCls,
    items = [],
    showPreviewIcon = true,
    showRemoveIcon = true,
    showDownloadIcon = false,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra,
    progress = {
      size: [-1, 2],
      showInfo: false
    },
    appendAction,
    appendActionVisible = true,
    itemRender,
    disabled,
    classNames: uploadListClassNames,
    styles
  } = props;
  const [, forceUpdate] = useForceUpdate();
  const [motionAppear, setMotionAppear] = React455.useState(false);
  const isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
  React455.useEffect(() => {
    if (!listType.startsWith("picture")) {
      return;
    }
    (items || []).forEach((file) => {
      if (!(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
        return;
      }
      file.thumbUrl = "";
      previewFile?.(file.originFileObj).then((previewDataUrl) => {
        file.thumbUrl = previewDataUrl || "";
        forceUpdate();
      });
    });
  }, [listType, items, previewFile]);
  React455.useEffect(() => {
    setMotionAppear(true);
  }, []);
  const onInternalPreview = (file, e3) => {
    if (!onPreview) {
      return;
    }
    e3?.preventDefault();
    return onPreview(file);
  };
  const onInternalDownload = (file) => {
    if (typeof onDownload === "function") {
      onDownload(file);
    } else if (file.url) {
      window.open(file.url);
    }
  };
  const onInternalClose = (file) => {
    onRemove?.(file);
  };
  const internalIconRender = (file) => {
    if (iconRender) {
      return iconRender(file, listType);
    }
    const isLoading = file.status === "uploading";
    if (listType.startsWith("picture")) {
      const loadingIcon = listType === "picture" ? React455.createElement(LoadingOutlined_default, null) : locale2.uploading;
      const fileIcon = isImgUrl?.(file) ? React455.createElement(PictureTwoTone_default, null) : React455.createElement(FileTwoTone_default, null);
      return isLoading ? loadingIcon : fileIcon;
    }
    return isLoading ? React455.createElement(LoadingOutlined_default, null) : React455.createElement(PaperClipOutlined_default, null);
  };
  const actionIconRender = (customIcon, callback, prefixCls2, title, acceptUploadDisabled) => {
    const btnProps = {
      type: "text",
      size: "small",
      title,
      onClick: (e3) => {
        callback();
        if (React455.isValidElement(customIcon)) {
          customIcon.props.onClick?.(e3);
        }
      },
      className: `${prefixCls2}-list-item-action`,
      disabled: acceptUploadDisabled ? disabled : false
    };
    return React455.isValidElement(customIcon) ? React455.createElement(Button_default, {
      ...btnProps,
      icon: cloneElement(customIcon, {
        ...customIcon.props,
        onClick: () => {
        }
      })
    }) : React455.createElement(Button_default, {
      ...btnProps
    }, React455.createElement("span", null, customIcon));
  };
  React455.useImperativeHandle(ref, () => ({
    handlePreview: onInternalPreview,
    handleDownload: onInternalDownload
  }));
  const {
    getPrefixCls
  } = React455.useContext(ConfigContext);
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const listClassNames = clsx(`${prefixCls}-list`, `${prefixCls}-list-${listType}`, uploadListClassNames?.list);
  const listItemMotion = React455.useMemo(() => omit(motion_default(rootPrefixCls), ["onAppearEnd", "onEnterEnd", "onLeaveEnd"]), [rootPrefixCls]);
  const motionConfig = {
    ...isPictureCardOrCirle ? {} : listItemMotion,
    motionDeadline: 2e3,
    motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
    keys: _toConsumableArray(items.map((file) => ({
      key: file.uid,
      file
    }))),
    motionAppear
  };
  return React455.createElement("div", {
    className: listClassNames,
    style: styles?.list
  }, React455.createElement(CSSMotionList_default, {
    ...motionConfig,
    component: false
  }, ({
    key,
    file,
    className: motionClassName,
    style: motionStyle
  }) => React455.createElement(ListItem_default2, {
    key,
    locale: locale2,
    prefixCls,
    className: motionClassName,
    style: motionStyle,
    classNames: uploadListClassNames,
    styles,
    file,
    items,
    progress,
    listType,
    isImgUrl,
    showPreviewIcon,
    showRemoveIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra,
    iconRender: internalIconRender,
    actionIconRender,
    itemRender,
    onPreview: onInternalPreview,
    onDownload: onInternalDownload,
    onClose: onInternalClose
  })), appendAction && React455.createElement(es_default4, {
    ...motionConfig,
    visible: appendActionVisible,
    forceRender: true
  }, ({
    className: motionClassName,
    style: motionStyle
  }) => cloneElement(appendAction, (oriProps) => ({
    className: clsx(oriProps.className, motionClassName),
    style: {
      ...motionStyle,
      // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
      pointerEvents: motionClassName ? "none" : void 0,
      ...oriProps.style
    }
  }))));
};
var UploadList = React455.forwardRef(InternalUploadList);
if (true) {
  UploadList.displayName = "UploadList";
}
var UploadList_default = UploadList;

// node_modules/antd/es/upload/Upload.js
var LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var InternalUpload = (props, ref) => {
  const config = useComponentConfig("upload");
  const {
    fileList,
    defaultFileList,
    onRemove,
    showUploadList = true,
    listType = "text",
    onPreview,
    onDownload,
    onChange,
    onDrop,
    previewFile,
    disabled: customDisabled,
    locale: propLocale,
    iconRender,
    isImageUrl: isImageUrl2,
    progress,
    prefixCls: customizePrefixCls,
    className,
    type = "select",
    children,
    style,
    itemRender,
    maxCount,
    data = {},
    multiple = false,
    hasControlInside = true,
    action = "",
    accept = "",
    supportServerRender = true,
    rootClassName,
    styles,
    classNames
  } = props;
  const disabled = React456.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const customRequest = props.customRequest || config.customRequest;
  const [internalFileList, setMergedFileList] = useControlledState(defaultFileList, fileList);
  const mergedFileList = internalFileList || [];
  const [dragState, setDragState] = React456.useState("drop");
  const upload2 = React456.useRef(null);
  const wrapRef = React456.useRef(null);
  if (true) {
    const warning2 = devUseWarning("Upload");
    true ? warning2("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?") : void 0;
  }
  React456.useMemo(() => {
    const timestamp = Date.now();
    (fileList || []).forEach((file, index2) => {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = `__AUTO__${timestamp}_${index2}__`;
      }
    });
  }, [fileList]);
  const onInternalChange = (file, changedFileList, event) => {
    let cloneList = _toConsumableArray(changedFileList);
    let exceedMaxCount = false;
    if (maxCount === 1) {
      cloneList = cloneList.slice(-1);
    } else if (maxCount) {
      exceedMaxCount = cloneList.length > maxCount;
      cloneList = cloneList.slice(0, maxCount);
    }
    (0, import_react_dom4.flushSync)(() => {
      setMergedFileList(cloneList);
    });
    const changeInfo = {
      file,
      fileList: cloneList
    };
    if (event) {
      changeInfo.event = event;
    }
    if (!exceedMaxCount || file.status === "removed" || // We should ignore event if current file is exceed `maxCount`
    cloneList.some((f) => f.uid === file.uid)) {
      (0, import_react_dom4.flushSync)(() => {
        onChange?.(changeInfo);
      });
    }
  };
  const mergedBeforeUpload = async (file, fileListArgs) => {
    const {
      beforeUpload
    } = props;
    let parsedFile = file;
    if (beforeUpload) {
      const result = await beforeUpload(file, fileListArgs);
      if (result === false) {
        return false;
      }
      delete file[LIST_IGNORE];
      if (result === LIST_IGNORE) {
        Object.defineProperty(file, LIST_IGNORE, {
          value: true,
          configurable: true
        });
        return false;
      }
      if (typeof result === "object" && result) {
        parsedFile = result;
      }
    }
    return parsedFile;
  };
  const onBatchStart = (batchFileInfoList) => {
    const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
    if (!filteredFileInfoList.length) {
      return;
    }
    const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
    let newFileList = _toConsumableArray(mergedFileList);
    objectFileList.forEach((fileObj) => {
      newFileList = updateFileList(fileObj, newFileList);
    });
    objectFileList.forEach((fileObj, index2) => {
      let triggerFileObj = fileObj;
      if (!filteredFileInfoList[index2].parsedFile) {
        const {
          originFileObj
        } = fileObj;
        let clone;
        try {
          clone = new File([originFileObj], originFileObj.name, {
            type: originFileObj.type
          });
        } catch {
          clone = new Blob([originFileObj], {
            type: originFileObj.type
          });
          clone.name = originFileObj.name;
          clone.lastModifiedDate = /* @__PURE__ */ new Date();
          clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
        }
        clone.uid = fileObj.uid;
        triggerFileObj = clone;
      } else {
        fileObj.status = "uploading";
      }
      onInternalChange(triggerFileObj, newFileList);
    });
  };
  const onSuccess = (response, file, xhr) => {
    try {
      if (typeof response === "string") {
        response = JSON.parse(response);
      }
    } catch {
    }
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "done";
    targetItem.percent = 100;
    targetItem.response = response;
    targetItem.xhr = xhr;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  const onProgress = (e3, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "uploading";
    targetItem.percent = e3.percent;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList, e3);
  };
  const onError = (error, response, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.error = error;
    targetItem.response = response;
    targetItem.status = "error";
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  const handleRemove = (file) => {
    let currentFile;
    Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
      if (ret === false) {
        return;
      }
      const removedFileList = removeFileItem(file, mergedFileList);
      if (removedFileList) {
        currentFile = {
          ...file,
          status: "removed"
        };
        mergedFileList?.forEach((item) => {
          const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
          if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
            item.status = "removed";
          }
        });
        upload2.current?.abort(currentFile);
        onInternalChange(currentFile, removedFileList);
      }
    });
  };
  const onFileDrop = (e3) => {
    setDragState(e3.type);
    if (e3.type === "drop") {
      onDrop?.(e3);
    }
  };
  React456.useImperativeHandle(ref, () => ({
    onBatchStart,
    onSuccess,
    onProgress,
    onError,
    fileList: mergedFileList,
    upload: upload2.current,
    nativeElement: wrapRef.current
  }));
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("upload");
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const mergedProps = {
    ...props,
    listType,
    showUploadList,
    type,
    multiple,
    hasControlInside,
    supportServerRender,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rcUploadProps = {
    onBatchStart,
    onError,
    onProgress,
    onSuccess,
    ...props,
    customRequest,
    data,
    multiple,
    action,
    accept,
    supportServerRender,
    prefixCls,
    disabled: mergedDisabled,
    beforeUpload: mergedBeforeUpload,
    onChange: void 0,
    hasControlInside
  };
  delete rcUploadProps.className;
  delete rcUploadProps.style;
  if (!children || mergedDisabled) {
    delete rcUploadProps.id;
  }
  const wrapperCls = `${prefixCls}-wrapper`;
  const [hashId, cssVarCls] = style_default56(prefixCls, wrapperCls);
  const [contextLocale] = useLocale_default("Upload", en_US_default4.Upload);
  const {
    showRemoveIcon,
    showPreviewIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra
  } = typeof showUploadList === "boolean" ? {} : showUploadList;
  const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : showRemoveIcon;
  const renderUploadList = (button, buttonVisible) => {
    if (!showUploadList) {
      return button;
    }
    return React456.createElement(UploadList_default, {
      classNames: mergedClassNames,
      styles: mergedStyles,
      prefixCls,
      listType,
      items: mergedFileList,
      previewFile,
      onPreview,
      onDownload,
      onRemove: handleRemove,
      showRemoveIcon: realShowRemoveIcon,
      showPreviewIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      iconRender,
      extra,
      locale: {
        ...contextLocale,
        ...propLocale
      },
      isImageUrl: isImageUrl2,
      progress,
      appendAction: button,
      appendActionVisible: buttonVisible,
      itemRender,
      disabled: mergedDisabled
    });
  };
  const mergedRootCls = clsx(wrapperCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
    [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
  });
  const mergedRootStyle = {
    ...mergedStyles.root
  };
  const mergedStyle = {
    ...contextStyle,
    ...style
  };
  if (type === "drag") {
    const dragCls = clsx(hashId, prefixCls, `${prefixCls}-drag`, {
      [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
      [`${prefixCls}-drag-hover`]: dragState === "dragover",
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    return React456.createElement("span", {
      className: mergedRootCls,
      ref: wrapRef,
      style: mergedRootStyle
    }, React456.createElement("div", {
      className: dragCls,
      style: mergedStyle,
      onDrop: onFileDrop,
      onDragOver: onFileDrop,
      onDragLeave: onFileDrop
    }, React456.createElement(es_default26, {
      ...rcUploadProps,
      ref: upload2,
      className: `${prefixCls}-btn`
    }, React456.createElement("div", {
      className: `${prefixCls}-drag-container`
    }, children))), renderUploadList());
  }
  const uploadBtnCls = clsx(prefixCls, `${prefixCls}-select`, {
    [`${prefixCls}-disabled`]: mergedDisabled,
    [`${prefixCls}-hidden`]: !children
  });
  const uploadButton = React456.createElement("div", {
    className: uploadBtnCls,
    style: mergedStyle
  }, React456.createElement(es_default26, {
    ...rcUploadProps,
    ref: upload2
  }));
  if (listType === "picture-card" || listType === "picture-circle") {
    return React456.createElement("span", {
      className: mergedRootCls,
      ref: wrapRef,
      style: mergedRootStyle
    }, renderUploadList(uploadButton, !!children));
  }
  return React456.createElement("span", {
    className: mergedRootCls,
    ref: wrapRef,
    style: mergedRootStyle
  }, uploadButton, renderUploadList());
};
var Upload2 = React456.forwardRef(InternalUpload);
if (true) {
  Upload2.displayName = "Upload";
}
var Upload_default2 = Upload2;

// node_modules/antd/es/upload/Dragger.js
var Dragger = React457.forwardRef((props, ref) => {
  const {
    style,
    height,
    hasControlInside = false,
    children,
    ...restProps
  } = props;
  const mergedStyle = {
    ...style,
    height
  };
  return React457.createElement(Upload_default2, {
    ref,
    hasControlInside,
    ...restProps,
    style: mergedStyle,
    type: "drag"
  }, children);
});
if (true) {
  Dragger.displayName = "Dragger";
}
var Dragger_default = Dragger;

// node_modules/antd/es/upload/index.js
var Upload3 = Upload_default2;
Upload3.Dragger = Dragger_default;
Upload3.LIST_IGNORE = LIST_IGNORE;
var upload_default = Upload3;

// node_modules/antd/es/watermark/index.js
var import_react143 = __toESM(require_react());

// node_modules/@rc-component/mutate-observer/es/MutateObserver.js
var import_react140 = __toESM(require_react());

// node_modules/@rc-component/mutate-observer/es/useMutateObserver.js
var import_react139 = __toESM(require_react());
var defaultOptions = {
  subtree: true,
  childList: true,
  attributeFilter: ["style", "class"]
};
var useMutateObserver = (nodeOrList, callback, options = defaultOptions) => {
  import_react139.default.useEffect(() => {
    if (!canUseDom() || !nodeOrList) {
      return;
    }
    let instance;
    const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
    if ("MutationObserver" in window) {
      instance = new MutationObserver(callback);
      nodeList.forEach((element) => {
        instance.observe(element, options);
      });
    }
    return () => {
      instance?.takeRecords();
      instance?.disconnect();
    };
  }, [options, nodeOrList]);
};
var useMutateObserver_default = useMutateObserver;

// node_modules/antd/es/watermark/useClips.js
var import_react141 = __toESM(require_react());
var FontGap = 3;
var prepareCanvas = (width, height, ratio = 1) => {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const realWidth = width * ratio;
  const realHeight = height * ratio;
  canvas.setAttribute("width", `${realWidth}px`);
  canvas.setAttribute("height", `${realHeight}px`);
  ctx.save();
  return [ctx, canvas, realWidth, realHeight];
};
var getRotatePos = (x, y, angle) => {
  const targetX = x * Math.cos(angle) - y * Math.sin(angle);
  const targetY = x * Math.sin(angle) + y * Math.cos(angle);
  return [targetX, targetY];
};
var useClips = () => {
  const getClips = (content, rotate, ratio, width, height, font, gapX, gapY) => {
    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
    if (content instanceof HTMLImageElement) {
      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
    } else {
      const {
        color,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        textAlign
      } = font;
      const mergedFontSize = Number(fontSize) * ratio;
      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
      ctx.fillStyle = color;
      ctx.textAlign = textAlign;
      ctx.textBaseline = "top";
      const contents = toList_default(content);
      contents?.forEach((item, index2) => {
        ctx.fillText(item ?? "", contentWidth / 2, index2 * (mergedFontSize + FontGap * ratio));
      });
    }
    const angle = Math.PI / 180 * Number(rotate);
    const maxSize = Math.max(width, height);
    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
    rCtx.translate(realMaxSize / 2, realMaxSize / 2);
    rCtx.rotate(angle);
    if (contentWidth > 0 && contentHeight > 0) {
      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
    }
    let left = 0;
    let right = 0;
    let top = 0;
    let bottom = 0;
    const halfWidth = contentWidth / 2;
    const halfHeight = contentHeight / 2;
    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];
    points.forEach(([x, y]) => {
      const [targetX, targetY] = getRotatePos(x, y, angle);
      left = Math.min(left, targetX);
      right = Math.max(right, targetX);
      top = Math.min(top, targetY);
      bottom = Math.max(bottom, targetY);
    });
    const cutLeft = left + realMaxSize / 2;
    const cutTop = top + realMaxSize / 2;
    const cutWidth = right - left;
    const cutHeight = bottom - top;
    const realGapX = gapX * ratio;
    const realGapY = gapY * ratio;
    const filledWidth = (cutWidth + realGapX) * 2;
    const filledHeight = cutHeight + realGapY;
    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
    const drawImg = (targetX = 0, targetY = 0) => {
      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
    };
    drawImg();
    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
  };
  return import_react141.default.useCallback(getClips, []);
};
var useClips_default = useClips;

// node_modules/antd/es/watermark/useRafDebounce.js
var import_react142 = __toESM(require_react());
function useRafDebounce(callback) {
  const executeRef = import_react142.default.useRef(false);
  const rafRef = import_react142.default.useRef(null);
  const wrapperCallback = useEvent_default(callback);
  return () => {
    if (executeRef.current) {
      return;
    }
    executeRef.current = true;
    wrapperCallback();
    rafRef.current = raf_default(() => {
      executeRef.current = false;
    });
  };
}

// node_modules/antd/es/watermark/useSingletonCache.js
var React462 = __toESM(require_react());
function useSingletonCache() {
  const cacheRef = React462.useRef([null, null]);
  const getCache = (cacheKeys, callback) => {
    const filteredKeys = cacheKeys.map((item) => item instanceof HTMLElement || Number.isNaN(item) ? "" : item);
    if (!isEqual_default(cacheRef.current[0], filteredKeys)) {
      cacheRef.current = [filteredKeys, callback()];
    }
    return cacheRef.current[1];
  };
  return getCache;
}

// node_modules/antd/es/watermark/useWatermark.js
var React463 = __toESM(require_react());

// node_modules/antd/es/watermark/utils.js
function toLowercaseSeparator(key) {
  return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function getStyleStr(style) {
  return Object.keys(style).map((key) => `${toLowercaseSeparator(key)}: ${style[key]};`).join(" ");
}
function getPixelRatio() {
  return window.devicePixelRatio || 1;
}
var reRendering = (mutation, isWatermarkEle) => {
  let flag = false;
  if (mutation.removedNodes.length) {
    flag = Array.from(mutation.removedNodes).some((node) => isWatermarkEle(node));
  }
  if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) {
    flag = true;
  }
  return flag;
};

// node_modules/antd/es/watermark/useWatermark.js
var emphasizedStyle = {
  visibility: "visible !important"
};
function useWatermark(markStyle, onRemove) {
  const watermarkMap = React463.useRef(/* @__PURE__ */ new Map());
  const onRemoveEvent = useEvent_default(onRemove);
  const appendWatermark = (base64Url, markWidth, container) => {
    if (container) {
      const exist = watermarkMap.current.get(container);
      if (!exist) {
        const newWatermarkEle = document.createElement("div");
        watermarkMap.current.set(container, newWatermarkEle);
      }
      const watermarkEle = watermarkMap.current.get(container);
      watermarkEle.setAttribute("style", getStyleStr({
        ...markStyle,
        backgroundImage: `url('${base64Url}')`,
        backgroundSize: `${Math.floor(markWidth)}px`,
        ...emphasizedStyle
      }));
      watermarkEle.removeAttribute("class");
      watermarkEle.removeAttribute("hidden");
      if (watermarkEle.parentElement !== container) {
        if (exist && onRemove) {
          onRemoveEvent();
        }
        container.append(watermarkEle);
      }
    }
    return watermarkMap.current.get(container);
  };
  const removeWatermark = (container) => {
    const watermarkEle = watermarkMap.current.get(container);
    if (watermarkEle && container) {
      container.removeChild(watermarkEle);
    }
    watermarkMap.current.delete(container);
  };
  const isWatermarkEle = (ele) => Array.from(watermarkMap.current.values()).includes(ele);
  return [appendWatermark, removeWatermark, isWatermarkEle];
}

// node_modules/antd/es/watermark/index.js
function getSizeDiff(prev, next) {
  return prev.size === next.size ? prev : next;
}
var DEFAULT_GAP_X = 100;
var DEFAULT_GAP_Y = 100;
var fixedStyle = {
  position: "relative",
  overflow: "hidden"
};
var Watermark = (props) => {
  const {
    /**
     * The antd content layer zIndex is basically below 10
     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335
     */
    zIndex = 9,
    rotate = -22,
    width,
    height,
    image,
    content,
    font = {},
    style,
    className,
    rootClassName,
    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],
    offset: offset3,
    children,
    inherit = true,
    onRemove
  } = props;
  const {
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("watermark");
  const mergedStyle = {
    ...fixedStyle,
    ...contextStyle,
    ...style
  };
  const [, token] = useToken();
  const {
    color = token.colorFill,
    fontSize = token.fontSizeLG,
    fontWeight = "normal",
    fontStyle = "normal",
    fontFamily = "sans-serif",
    textAlign = "center"
  } = font;
  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
  const gapXCenter = gapX / 2;
  const gapYCenter = gapY / 2;
  const offsetLeft = offset3?.[0] ?? gapXCenter;
  const offsetTop = offset3?.[1] ?? gapYCenter;
  const markStyle = import_react143.default.useMemo(() => {
    const mergedMarkStyle = {
      zIndex,
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      backgroundRepeat: "repeat"
    };
    let positionLeft = offsetLeft - gapXCenter;
    let positionTop = offsetTop - gapYCenter;
    if (positionLeft > 0) {
      mergedMarkStyle.left = `${positionLeft}px`;
      mergedMarkStyle.width = `calc(100% - ${positionLeft}px)`;
      positionLeft = 0;
    }
    if (positionTop > 0) {
      mergedMarkStyle.top = `${positionTop}px`;
      mergedMarkStyle.height = `calc(100% - ${positionTop}px)`;
      positionTop = 0;
    }
    mergedMarkStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
    return mergedMarkStyle;
  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);
  const [container, setContainer] = import_react143.default.useState();
  const [subElements, setSubElements] = import_react143.default.useState(() => /* @__PURE__ */ new Set());
  const targetElements = import_react143.default.useMemo(() => {
    const list = container ? [container] : [];
    return [].concat(list, _toConsumableArray(Array.from(subElements)));
  }, [container, subElements]);
  const getMarkSize = (ctx) => {
    let defaultWidth = 120;
    let defaultHeight = 64;
    if (!image && ctx.measureText) {
      ctx.font = `${Number(fontSize)}px ${fontFamily}`;
      const contents = toList_default(content);
      const sizes2 = contents.map((item) => {
        const metrics = ctx.measureText(item);
        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
      });
      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes2.map((size) => size[0]))));
      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes2.map((size) => size[1])))) * contents.length + (contents.length - 1) * FontGap;
    }
    return [width ?? defaultWidth, height ?? defaultHeight];
  };
  const getClips = useClips_default();
  const getClipsCache = useSingletonCache();
  const [watermarkInfo, setWatermarkInfo] = import_react143.default.useState(null);
  const renderWatermark = () => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const ratio = getPixelRatio();
      const [markWidth, markHeight] = getMarkSize(ctx);
      const drawCanvas = (drawContent) => {
        const params = [drawContent || "", rotate, ratio, markWidth, markHeight, {
          color,
          fontSize,
          fontStyle,
          fontWeight,
          fontFamily,
          textAlign
        }, gapX, gapY];
        const [nextClips, clipWidth] = getClipsCache(params, () => getClips.apply(void 0, params));
        setWatermarkInfo([nextClips, clipWidth]);
      };
      if (image) {
        const img = new Image();
        img.onload = () => {
          drawCanvas(img);
        };
        img.onerror = () => {
          drawCanvas(content);
        };
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.src = image;
      } else {
        drawCanvas(content);
      }
    }
  };
  const syncWatermark = useRafDebounce(renderWatermark);
  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle, onRemove);
  (0, import_react143.useEffect)(() => {
    if (watermarkInfo) {
      targetElements.forEach((holder) => {
        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
      });
    }
  }, [watermarkInfo, targetElements]);
  const onMutate = useEvent_default((mutations) => {
    mutations.forEach((mutation) => {
      if (reRendering(mutation, isWatermarkEle)) {
        syncWatermark();
      } else if (mutation.target === container && mutation.attributeName === "style") {
        const keyStyles = Object.keys(fixedStyle);
        for (let i = 0; i < keyStyles.length; i += 1) {
          const key = keyStyles[i];
          const oriValue = mergedStyle[key];
          const currentValue = container.style[key];
          if (oriValue && oriValue !== currentValue) {
            container.style[key] = oriValue;
          }
        }
      }
    });
  });
  useMutateObserver_default(targetElements, onMutate);
  (0, import_react143.useEffect)(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);
  const watermarkContext = import_react143.default.useMemo(() => ({
    add: (ele) => {
      setSubElements((prev) => {
        const clone = new Set(prev);
        clone.add(ele);
        return getSizeDiff(prev, clone);
      });
    },
    remove: (ele) => {
      removeWatermark(ele);
      setSubElements((prev) => {
        const clone = new Set(prev);
        clone.delete(ele);
        return getSizeDiff(prev, clone);
      });
    }
  }), []);
  const childNode = inherit ? import_react143.default.createElement(context_default2.Provider, {
    value: watermarkContext
  }, children) : children;
  return import_react143.default.createElement("div", {
    ref: setContainer,
    className: clsx(className, contextClassName, rootClassName),
    style: mergedStyle
  }, childNode);
};
if (true) {
  Watermark.displayName = "Watermark";
}
var watermark_default = Watermark;

// node_modules/antd/es/index.js
var unstableSetRender = () => {
  true ? warning_default2(false, "compatible", "antd v6 support React 19 already, it's no need to call the compatible function or just remove `@ant-design/v5-patch-for-react-19`") : void 0;
};
if (true) {
  const majorVersion = getReactMajorVersion();
  true ? warning_default2(majorVersion >= 18, "version", `antd v6 no longer supports React versions below 18. Please upgrade to React 18 or higher.`) : void 0;
}
export {
  affix_default as Affix,
  alert_default as Alert,
  anchor_default as Anchor,
  app_default as App,
  auto_complete_default as AutoComplete,
  avatar_default as Avatar,
  back_top_default as BackTop,
  badge_default as Badge,
  breadcrumb_default as Breadcrumb,
  button_default as Button,
  calendar_default as Calendar,
  card_default as Card,
  carousel_default as Carousel,
  cascader_default as Cascader,
  checkbox_default as Checkbox,
  col_default2 as Col,
  collapse_default2 as Collapse,
  color_picker_default as ColorPicker,
  config_provider_default as ConfigProvider,
  date_picker_default as DatePicker,
  descriptions_default as Descriptions,
  divider_default as Divider,
  drawer_default as Drawer,
  dropdown_default2 as Dropdown,
  empty_default as Empty,
  flex_default as Flex,
  float_button_default as FloatButton,
  form_default as Form,
  grid_default as Grid,
  image_default as Image,
  input_default as Input,
  input_number_default as InputNumber,
  layout_default2 as Layout,
  list_default as List,
  masonry_default as Masonry,
  mentions_default as Mentions,
  menu_default2 as Menu,
  modal_default as Modal,
  pagination_default as Pagination,
  popconfirm_default as Popconfirm,
  popover_default as Popover,
  progress_default2 as Progress,
  qr_code_default as QRCode,
  radio_default2 as Radio,
  rate_default as Rate,
  result_default as Result,
  row_default2 as Row,
  segmented_default as Segmented,
  select_default as Select,
  skeleton_default as Skeleton,
  slider_default as Slider,
  space_default as Space,
  spin_default as Spin,
  splitter_default as Splitter,
  statistic_default as Statistic,
  steps_default as Steps,
  switch_default as Switch,
  table_default as Table,
  tabs_default as Tabs,
  tag_default as Tag,
  time_picker_default as TimePicker,
  timeline_default as Timeline,
  tooltip_default as Tooltip,
  tour_default as Tour,
  transfer_default as Transfer,
  tree_default as Tree,
  tree_select_default as TreeSelect,
  typography_default as Typography,
  upload_default as Upload,
  watermark_default as Watermark,
  message_default as message,
  notification_default as notification,
  theme_default3 as theme,
  unstableSetRender,
  version_default as version
};
//# sourceMappingURL=antd.js.map
